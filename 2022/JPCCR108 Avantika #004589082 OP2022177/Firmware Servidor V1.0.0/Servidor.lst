CCS PCH C Compiler, Version 5.015, 5967               27-jul.-22 09:30

               Filename:   D:\Laboratorio\Camara Climatica\2022\JPCCR108 Avantika #0045890XX OP2022177\Firmware Servidor V1.0.0\Servidor.lst

               ROM used:   32890 bytes (33%)
                           Largest free fragment is 32768
               RAM used:   809 (24%) at main() level
                           997 (30%) worst case
               Stack used: 16 locations (14 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   7F2E
*
00008:  NOP   
0000A:  NOP   
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FFB,15
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   00BA
00068:  BTFSS  F9D.5
0006A:  GOTO   0074
0006E:  BTFSC  F9E.5
00070:  GOTO   19BC
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FFB
000AE:  MOVF   04,W
000B0:  MOVFF  06,FE0
000B4:  MOVFF  05,FD8
000B8:  RETFIE 0
.................... //Falta crear menu de ajuste de variables y de norma CFR21 
....................  
.................... #include <18F4685.h> 
.................... //////////// Standard Header file for the PIC18F4685 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4685 
*
000DA:  DATA 3C,48
000DC:  DATA 54,4D
000DE:  DATA 4C,3E
000E0:  DATA 3C,42
000E2:  DATA 4F,44
000E4:  DATA 59,3E
000E6:  DATA 3C,48
000E8:  DATA 31,3E
000EA:  DATA 34,30
000EC:  DATA 34,20
000EE:  DATA 45,72
000F0:  DATA 72,6F
000F2:  DATA 72,3C
000F4:  DATA 2F,48
000F6:  DATA 31,3E
000F8:  DATA 3C,48
000FA:  DATA 52,3E
000FC:  DATA 3C,50
000FE:  DATA 3E,46
00100:  DATA 69,6C
00102:  DATA 65,20
00104:  DATA 4E,6F
00106:  DATA 74,20
00108:  DATA 66,6F
0010A:  DATA 75,6E
0010C:  DATA 64,2E
0010E:  DATA 3C,2F
00110:  DATA 42,4F
00112:  DATA 44,59
00114:  DATA 3E,3C
00116:  DATA 2F,48
00118:  DATA 54,4D
0011A:  DATA 4C,3E
0011C:  DATA 00,00
0011E:  DATA 3C,48
00120:  DATA 54,4D
00122:  DATA 4C,3E
00124:  DATA 3C,42
00126:  DATA 4F,44
00128:  DATA 59,3E
0012A:  DATA 3C,48
0012C:  DATA 31,3E
0012E:  DATA 35,30
00130:  DATA 30,20
00132:  DATA 45,72
00134:  DATA 72,6F
00136:  DATA 72,3C
00138:  DATA 2F,48
0013A:  DATA 31,3E
0013C:  DATA 3C,48
0013E:  DATA 52,3E
00140:  DATA 3C,50
00142:  DATA 3E,49
00144:  DATA 6E,74
00146:  DATA 65,72
00148:  DATA 6E,61
0014A:  DATA 6C,20
0014C:  DATA 53,65
0014E:  DATA 72,76
00150:  DATA 65,72
00152:  DATA 20,45
00154:  DATA 72,72
00156:  DATA 6F,72
00158:  DATA 3C,2F
0015A:  DATA 42,4F
0015C:  DATA 44,59
0015E:  DATA 3E,3C
00160:  DATA 2F,48
00162:  DATA 54,4D
00164:  DATA 4C,3E
00166:  DATA 00,00
00168:  DATA 48,54
0016A:  DATA 54,50
0016C:  DATA 2F,31
0016E:  DATA 2E,30
00170:  DATA 20,25
00172:  DATA 4C,55
00174:  DATA 20,00
00176:  DATA 4E,6F
00178:  DATA 74,20
0017A:  DATA 66,6F
0017C:  DATA 75,6E
0017E:  DATA 64,00
00180:  DATA 53,65
00182:  DATA 72,76
00184:  DATA 65,72
00186:  DATA 20,45
00188:  DATA 72,72
0018A:  DATA 6F,72
0018C:  DATA 00,00
0018E:  DATA 0D,0A
00190:  DATA 43,6F
00192:  DATA 6E,74
00194:  DATA 65,6E
00196:  DATA 74,2D
00198:  DATA 54,79
0019A:  DATA 70,65
0019C:  DATA 3A,20
0019E:  DATA 00,00
001A0:  DATA 74,65
001A2:  DATA 78,74
001A4:  DATA 2F,68
001A6:  DATA 74,6D
001A8:  DATA 6C,00
001AA:  DATA 0D,0A
001AC:  DATA 0D,0A
001AE:  DATA 00,00
001B0:  DATA 20,0A
001B2:  DATA 20,20
001B4:  DATA 20,3C
001B6:  DATA 68,74
001B8:  DATA 6D,6C
001BA:  DATA 3E,20
001BC:  DATA 0A,3C
001BE:  DATA 68,65
001C0:  DATA 61,64
001C2:  DATA 3E,20
001C4:  DATA 0A,3C
001C6:  DATA 6D,65
001C8:  DATA 74,61
001CA:  DATA 20,68
001CC:  DATA 74,74
001CE:  DATA 70,2D
001D0:  DATA 65,71
001D2:  DATA 75,69
001D4:  DATA 76,3D
001D6:  DATA 22,72
001D8:  DATA 65,66
001DA:  DATA 72,65
001DC:  DATA 73,68
001DE:  DATA 22,63
001E0:  DATA 6F,6E
001E2:  DATA 74,65
001E4:  DATA 6E,74
001E6:  DATA 3D,22
001E8:  DATA 32,30
001EA:  DATA 3B,75
001EC:  DATA 72,6C
001EE:  DATA 3D,22
001F0:  DATA 3E,20
001F2:  DATA 0A,3C
001F4:  DATA 74,69
001F6:  DATA 74,6C
001F8:  DATA 65,3E
001FA:  DATA 4A,50
001FC:  DATA 49,6E
001FE:  DATA 67,6C
00200:  DATA 6F,62
00202:  DATA 61,6C
00204:  DATA 20,44
00206:  DATA 61,74
00208:  DATA 6F,73
0020A:  DATA 20,45
0020C:  DATA 74,68
0020E:  DATA 65,72
00210:  DATA 6E,65
00212:  DATA 74,3C
00214:  DATA 2F,74
00216:  DATA 69,74
00218:  DATA 6C,65
0021A:  DATA 3E,20
0021C:  DATA 0A,3C
0021E:  DATA 2F,68
00220:  DATA 65,61
00222:  DATA 64,3E
00224:  DATA 20,0A
00226:  DATA 20,0A
00228:  DATA 3C,62
0022A:  DATA 6F,64
0022C:  DATA 79,20
0022E:  DATA 73,74
00230:  DATA 79,6C
00232:  DATA 65,3D
00234:  DATA 22,62
00236:  DATA 61,63
00238:  DATA 6B,67
0023A:  DATA 72,6F
0023C:  DATA 75,6E
0023E:  DATA 64,3A
00240:  DATA 23,66
00242:  DATA 66,66
00244:  DATA 66,66
00246:  DATA 66,22
00248:  DATA 3E,20
0024A:  DATA 20,0A
0024C:  DATA 20,0A
0024E:  DATA 3C,64
00250:  DATA 69,76
00252:  DATA 20,73
00254:  DATA 74,79
00256:  DATA 6C,65
00258:  DATA 3D,22
0025A:  DATA 62,61
0025C:  DATA 63,6B
0025E:  DATA 67,72
00260:  DATA 6F,75
00262:  DATA 6E,64
00264:  DATA 3A,23
00266:  DATA 34,33
00268:  DATA 38,33
0026A:  DATA 64,33
0026C:  DATA 22,20
0026E:  DATA 61,6C
00270:  DATA 69,67
00272:  DATA 6E,3D
00274:  DATA 22,63
00276:  DATA 65,6E
00278:  DATA 74,65
0027A:  DATA 72,22
0027C:  DATA 3E,20
0027E:  DATA 0A,20
00280:  DATA 0A,20
00282:  DATA 20,20
00284:  DATA 3C,69
00286:  DATA 6D,67
00288:  DATA 20,73
0028A:  DATA 72,63
0028C:  DATA 3D,22
0028E:  DATA 68,74
00290:  DATA 74,70
00292:  DATA 73,3A
00294:  DATA 2F,2F
00296:  DATA 6A,70
00298:  DATA 69,6E
0029A:  DATA 67,6C
0029C:  DATA 6F,62
0029E:  DATA 61,6C
002A0:  DATA 2E,63
002A2:  DATA 6F,6D
002A4:  DATA 2F,69
002A6:  DATA 6D,61
002A8:  DATA 67,65
002AA:  DATA 73,2F
002AC:  DATA 61,6E
002AE:  DATA 64,6F
002B0:  DATA 5F,73
002B2:  DATA 69,73
002B4:  DATA 74,65
002B6:  DATA 6D,61
002B8:  DATA 2F,4C
002BA:  DATA 6F,67
002BC:  DATA 6F,2D
002BE:  DATA 4A,50
002C0:  DATA 5F,32
002C2:  DATA 30,31
002C4:  DATA 39,2D
002C6:  DATA 30,35
002C8:  DATA 2E,70
002CA:  DATA 6E,67
002CC:  DATA 22,20
002CE:  DATA 61,6C
002D0:  DATA 74,3D
002D2:  DATA 22,4C
002D4:  DATA 6F,67
002D6:  DATA 6F,20
002D8:  DATA 4A,50
002DA:  DATA 49,6E
002DC:  DATA 67,6C
002DE:  DATA 6F,62
002E0:  DATA 61,6C
002E2:  DATA 22,20
002E4:  DATA 61,6C
002E6:  DATA 69,67
002E8:  DATA 6E,3D
002EA:  DATA 22,63
002EC:  DATA 65,6E
002EE:  DATA 74,65
002F0:  DATA 72,22
002F2:  DATA 20,77
002F4:  DATA 69,64
002F6:  DATA 74,68
002F8:  DATA 3D,22
002FA:  DATA 35,36
002FC:  DATA 37,22
002FE:  DATA 20,68
00300:  DATA 65,69
00302:  DATA 67,68
00304:  DATA 74,3D
00306:  DATA 22,31
00308:  DATA 38,39
0030A:  DATA 22,3E
0030C:  DATA 20,0A
0030E:  DATA 3C,2F
00310:  DATA 64,69
00312:  DATA 76,3E
00314:  DATA 20,0A
00316:  DATA 20,0A
00318:  DATA 3C,68
0031A:  DATA 72,20
0031C:  DATA 73,69
0031E:  DATA 7A,65
00320:  DATA 3D,22
00322:  DATA 38,70
00324:  DATA 78,22
00326:  DATA 20,63
00328:  DATA 6F,6C
0032A:  DATA 6F,72
0032C:  DATA 3D,22
0032E:  DATA 23,34
00330:  DATA 33,38
00332:  DATA 33,64
00334:  DATA 33,22
00336:  DATA 3E,20
00338:  DATA 0A,20
0033A:  DATA 0A,3C
0033C:  DATA 64,69
0033E:  DATA 76,20
00340:  DATA 73,74
00342:  DATA 79,6C
00344:  DATA 65,3D
00346:  DATA 22,62
00348:  DATA 61,63
0034A:  DATA 6B,67
0034C:  DATA 72,6F
0034E:  DATA 75,6E
00350:  DATA 64,3A
00352:  DATA 23,45
00354:  DATA 31,46
00356:  DATA 36,46
00358:  DATA 46,22
0035A:  DATA 20,61
0035C:  DATA 6C,69
0035E:  DATA 67,6E
00360:  DATA 3D,22
00362:  DATA 63,65
00364:  DATA 6E,74
00366:  DATA 65,72
00368:  DATA 22,3E
0036A:  DATA 20,0A
0036C:  DATA 20,0A
0036E:  DATA 20,20
00370:  DATA 20,3C
00372:  DATA 68,32
00374:  DATA 20,61
00376:  DATA 6C,69
00378:  DATA 67,6E
0037A:  DATA 3D,22
0037C:  DATA 63,65
0037E:  DATA 6E,74
00380:  DATA 65,72
00382:  DATA 22,3E
00384:  DATA 20,56
00386:  DATA 69,73
00388:  DATA 75,61
0038A:  DATA 6C,69
0038C:  DATA 7A,61
0038E:  DATA 63,69
00390:  DATA F3,6E
00392:  DATA 20,64
00394:  DATA 65,20
00396:  DATA 64,61
00398:  DATA 74,6F
0039A:  DATA 73,3C
0039C:  DATA 2F,68
0039E:  DATA 32,3E
003A0:  DATA 20,0A
003A2:  DATA 20,20
003A4:  DATA 20,3C
003A6:  DATA 54,41
003A8:  DATA 42,4C
003AA:  DATA 45,20
003AC:  DATA 42,4F
003AE:  DATA 52,44
003B0:  DATA 45,52
003B2:  DATA 3D,30
003B4:  DATA 3E,20
003B6:  DATA 0A,20
003B8:  DATA 20,20
003BA:  DATA 20,20
003BC:  DATA 20,3C
003BE:  DATA 54,52
003C0:  DATA 3E,20
003C2:  DATA 0A,20
003C4:  DATA 20,20
003C6:  DATA 20,3C
003C8:  DATA 54,44
003CA:  DATA 3E,20
003CC:  DATA 3C,69
003CE:  DATA 6D,67
003D0:  DATA 20,73
003D2:  DATA 72,63
003D4:  DATA 3D,22
003D6:  DATA 68,74
003D8:  DATA 74,70
003DA:  DATA 73,3A
003DC:  DATA 2F,2F
003DE:  DATA 77,37
003E0:  DATA 2E,70
003E2:  DATA 6E,67
003E4:  DATA 77,69
003E6:  DATA 6E,67
003E8:  DATA 2E,63
003EA:  DATA 6F,6D
003EC:  DATA 2F,70
003EE:  DATA 6E,67
003F0:  DATA 73,2F
003F2:  DATA 32,2F
003F4:  DATA 32,33
003F6:  DATA 37,2F
003F8:  DATA 70,6E
003FA:  DATA 67,2D
003FC:  DATA 74,72
003FE:  DATA 61,6E
00400:  DATA 73,70
00402:  DATA 61,72
00404:  DATA 65,6E
00406:  DATA 74,2D
00408:  DATA 63,6F
0040A:  DATA 6D,70
0040C:  DATA 75,74
0040E:  DATA 65,72
00410:  DATA 2D,69
00412:  DATA 63,6F
00414:  DATA 6E,73
00416:  DATA 2D,74
00418:  DATA 68,65
0041A:  DATA 72,6D
0041C:  DATA 6F,6D
0041E:  DATA 65,74
00420:  DATA 65,72
00422:  DATA 2D,74
00424:  DATA 65,6D
00426:  DATA 70,65
00428:  DATA 72,61
0042A:  DATA 74,75
0042C:  DATA 72,65
0042E:  DATA 2D,62
00430:  DATA 75,73
00432:  DATA 69,6E
00434:  DATA 65,73
00436:  DATA 73,2D
00438:  DATA 63,65
0043A:  DATA 6C,73
0043C:  DATA 69,75
0043E:  DATA 73,2D
00440:  DATA 74,68
00442:  DATA 65,6D
00444:  DATA 6F,6D
00446:  DATA 65,74
00448:  DATA 65,72
0044A:  DATA 2D,6D
0044C:  DATA 65,61
0044E:  DATA 73,75
00450:  DATA 72,65
00452:  DATA 6D,65
00454:  DATA 6E,74
00456:  DATA 2D,62
00458:  DATA 75,73
0045A:  DATA 69,6E
0045C:  DATA 65,73
0045E:  DATA 73,2D
00460:  DATA 74,65
00462:  DATA 6D,70
00464:  DATA 65,72
00466:  DATA 61,74
00468:  DATA 75,72
0046A:  DATA 65,2D
0046C:  DATA 6D,65
0046E:  DATA 61,73
00470:  DATA 75,72
00472:  DATA 65,6D
00474:  DATA 65,6E
00476:  DATA 74,2E
00478:  DATA 70,6E
0047A:  DATA 67,22
0047C:  DATA 20,61
0047E:  DATA 6C,74
00480:  DATA 3D,22
00482:  DATA 54,65
00484:  DATA 6D,70
00486:  DATA 65,72
00488:  DATA 61,74
0048A:  DATA 75,72
0048C:  DATA 61,22
0048E:  DATA 20,61
00490:  DATA 6C,69
00492:  DATA 67,6E
00494:  DATA 3D,22
00496:  DATA 63,65
00498:  DATA 6E,74
0049A:  DATA 65,72
0049C:  DATA 22,20
0049E:  DATA 77,69
004A0:  DATA 64,74
004A2:  DATA 68,3D
004A4:  DATA 22,39
004A6:  DATA 32,22
004A8:  DATA 20,68
004AA:  DATA 65,69
004AC:  DATA 67,68
004AE:  DATA 74,3D
004B0:  DATA 22,35
004B2:  DATA 31,22
004B4:  DATA 3E,20
004B6:  DATA 3C,2F
004B8:  DATA 54,44
004BA:  DATA 3E,20
004BC:  DATA 0A,20
004BE:  DATA 20,20
004C0:  DATA 20,20
004C2:  DATA 20,20
004C4:  DATA 20,20
004C6:  DATA 3C,54
004C8:  DATA 48,3E
004CA:  DATA 54,65
004CC:  DATA 6D,70
004CE:  DATA 65,72
004D0:  DATA 61,74
004D2:  DATA 75,72
004D4:  DATA 61,3A
004D6:  DATA 3C,2F
004D8:  DATA 54,48
004DA:  DATA 3E,20
004DC:  DATA 0A,20
004DE:  DATA 20,20
004E0:  DATA 20,20
004E2:  DATA 20,20
004E4:  DATA 20,20
004E6:  DATA 3C,54
004E8:  DATA 44,20
004EA:  DATA 69,64
004EC:  DATA 3D,22
004EE:  DATA 64,79
004F0:  DATA 6E,30
004F2:  DATA 22,3E
004F4:  DATA 25,30
004F6:  DATA 3C,2F
004F8:  DATA 54,44
004FA:  DATA 3E,20
004FC:  DATA 20,20
004FE:  DATA 20,20
00500:  DATA 20,20
00502:  DATA 20,20
00504:  DATA 20,0A
00506:  DATA 20,20
00508:  DATA 20,20
0050A:  DATA 20,20
0050C:  DATA 3C,2F
0050E:  DATA 54,52
00510:  DATA 3E,20
00512:  DATA 0A,20
00514:  DATA 20,20
00516:  DATA 20,20
00518:  DATA 20,3C
0051A:  DATA 54,52
0051C:  DATA 3E,20
0051E:  DATA 0A,20
00520:  DATA 20,20
00522:  DATA 20,3C
00524:  DATA 54,44
00526:  DATA 3E,20
00528:  DATA 3C,69
0052A:  DATA 6D,67
0052C:  DATA 20,73
0052E:  DATA 72,63
00530:  DATA 3D,22
00532:  DATA 68,74
00534:  DATA 74,70
00536:  DATA 73,3A
00538:  DATA 2F,2F
0053A:  DATA 77,37
0053C:  DATA 2E,70
0053E:  DATA 6E,67
00540:  DATA 77,69
00542:  DATA 6E,67
00544:  DATA 2E,63
00546:  DATA 6F,6D
00548:  DATA 2F,70
0054A:  DATA 6E,67
0054C:  DATA 73,2F
0054E:  DATA 32,2F
00550:  DATA 32,33
00552:  DATA 37,2F
00554:  DATA 70,6E
00556:  DATA 67,2D
00558:  DATA 74,72
0055A:  DATA 61,6E
0055C:  DATA 73,70
0055E:  DATA 61,72
00560:  DATA 65,6E
00562:  DATA 74,2D
00564:  DATA 63,6F
00566:  DATA 6D,70
00568:  DATA 75,74
0056A:  DATA 65,72
0056C:  DATA 2D,69
0056E:  DATA 63,6F
00570:  DATA 6E,73
00572:  DATA 2D,74
00574:  DATA 68,65
00576:  DATA 72,6D
00578:  DATA 6F,6D
0057A:  DATA 65,74
0057C:  DATA 65,72
0057E:  DATA 2D,74
00580:  DATA 65,6D
00582:  DATA 70,65
00584:  DATA 72,61
00586:  DATA 74,75
00588:  DATA 72,65
0058A:  DATA 2D,62
0058C:  DATA 75,73
0058E:  DATA 69,6E
00590:  DATA 65,73
00592:  DATA 73,2D
00594:  DATA 63,65
00596:  DATA 6C,73
00598:  DATA 69,75
0059A:  DATA 73,2D
0059C:  DATA 74,68
0059E:  DATA 65,6D
005A0:  DATA 6F,6D
005A2:  DATA 65,74
005A4:  DATA 65,72
005A6:  DATA 2D,6D
005A8:  DATA 65,61
005AA:  DATA 73,75
005AC:  DATA 72,65
005AE:  DATA 6D,65
005B0:  DATA 6E,74
005B2:  DATA 2D,62
005B4:  DATA 75,73
005B6:  DATA 69,6E
005B8:  DATA 65,73
005BA:  DATA 73,2D
005BC:  DATA 74,65
005BE:  DATA 6D,70
005C0:  DATA 65,72
005C2:  DATA 61,74
005C4:  DATA 75,72
005C6:  DATA 65,2D
005C8:  DATA 6D,65
005CA:  DATA 61,73
005CC:  DATA 75,72
005CE:  DATA 65,6D
005D0:  DATA 65,6E
005D2:  DATA 74,2E
005D4:  DATA 70,6E
005D6:  DATA 67,22
005D8:  DATA 20,61
005DA:  DATA 6C,74
005DC:  DATA 3D,22
005DE:  DATA 54,65
005E0:  DATA 6D,70
005E2:  DATA 65,72
005E4:  DATA 61,74
005E6:  DATA 75,72
005E8:  DATA 61,22
005EA:  DATA 20,61
005EC:  DATA 6C,69
005EE:  DATA 67,6E
005F0:  DATA 3D,22
005F2:  DATA 63,65
005F4:  DATA 6E,74
005F6:  DATA 65,72
005F8:  DATA 22,20
005FA:  DATA 77,69
005FC:  DATA 64,74
005FE:  DATA 68,3D
00600:  DATA 22,39
00602:  DATA 32,22
00604:  DATA 20,68
00606:  DATA 65,69
00608:  DATA 67,68
0060A:  DATA 74,3D
0060C:  DATA 22,35
0060E:  DATA 31,22
00610:  DATA 3E,20
00612:  DATA 3C,2F
00614:  DATA 54,44
00616:  DATA 3E,20
00618:  DATA 0A,20
0061A:  DATA 20,20
0061C:  DATA 20,20
0061E:  DATA 20,20
00620:  DATA 20,20
00622:  DATA 3C,54
00624:  DATA 48,3E
00626:  DATA 54,65
00628:  DATA 6D,70
0062A:  DATA 65,72
0062C:  DATA 61,74
0062E:  DATA 75,72
00630:  DATA 61,32
00632:  DATA 3A,3C
00634:  DATA 2F,54
00636:  DATA 48,3E
00638:  DATA 20,0A
0063A:  DATA 20,20
0063C:  DATA 20,20
0063E:  DATA 20,20
00640:  DATA 20,20
00642:  DATA 20,3C
00644:  DATA 54,44
00646:  DATA 20,69
00648:  DATA 64,3D
0064A:  DATA 22,64
0064C:  DATA 79,6E
0064E:  DATA 31,22
00650:  DATA 3E,25
00652:  DATA 31,3C
00654:  DATA 2F,54
00656:  DATA 44,3E
00658:  DATA 20,20
0065A:  DATA 20,20
0065C:  DATA 20,20
0065E:  DATA 20,20
00660:  DATA 20,20
00662:  DATA 0A,20
00664:  DATA 20,20
00666:  DATA 20,20
00668:  DATA 20,3C
0066A:  DATA 2F,54
0066C:  DATA 52,3E
0066E:  DATA 20,0A
00670:  DATA 20,20
00672:  DATA 20,20
00674:  DATA 20,20
00676:  DATA 3C,54
00678:  DATA 52,3E
0067A:  DATA 20,20
0067C:  DATA 0A,20
0067E:  DATA 20,20
00680:  DATA 20,3C
00682:  DATA 54,44
00684:  DATA 3E,20
00686:  DATA 3C,69
00688:  DATA 6D,67
0068A:  DATA 20,73
0068C:  DATA 72,63
0068E:  DATA 3D,22
00690:  DATA 68,74
00692:  DATA 74,70
00694:  DATA 73,3A
00696:  DATA 2F,2F
00698:  DATA 77,37
0069A:  DATA 2E,70
0069C:  DATA 6E,67
0069E:  DATA 77,69
006A0:  DATA 6E,67
006A2:  DATA 2E,63
006A4:  DATA 6F,6D
006A6:  DATA 2F,70
006A8:  DATA 6E,67
006AA:  DATA 73,2F
006AC:  DATA 37,36
006AE:  DATA 32,2F
006B0:  DATA 33,35
006B2:  DATA 31,2F
006B4:  DATA 70,6E
006B6:  DATA 67,2D
006B8:  DATA 74,72
006BA:  DATA 61,6E
006BC:  DATA 73,70
006BE:  DATA 61,72
006C0:  DATA 65,6E
006C2:  DATA 74,2D
006C4:  DATA 68,75
006C6:  DATA 6D,69
006C8:  DATA 64,69
006CA:  DATA 74,79
006CC:  DATA 2D,63
006CE:  DATA 6F,6D
006D0:  DATA 70,75
006D2:  DATA 74,65
006D4:  DATA 72,2D
006D6:  DATA 69,63
006D8:  DATA 6F,6E
006DA:  DATA 73,2D
006DC:  DATA 63,6C
006DE:  DATA 69,6D
006E0:  DATA 61,74
006E2:  DATA 65,2D
006E4:  DATA 6D,6F
006E6:  DATA 69,73
006E8:  DATA 74,75
006EA:  DATA 72,65
006EC:  DATA 2D,68
006EE:  DATA 75,6D
006F0:  DATA 69,64
006F2:  DATA 2D,61
006F4:  DATA 6E,67
006F6:  DATA 6C,65
006F8:  DATA 2D,63
006FA:  DATA 6C,6F
006FC:  DATA 75,64
006FE:  DATA 2D,6D
00700:  DATA 65,74
00702:  DATA 65,6F
00704:  DATA 72,6F
00706:  DATA 6C,6F
00708:  DATA 67,79
0070A:  DATA 2E,70
0070C:  DATA 6E,67
0070E:  DATA 22,20
00710:  DATA 61,6C
00712:  DATA 74,3D
00714:  DATA 22,48
00716:  DATA 75,6D
00718:  DATA 65,64
0071A:  DATA 61,64
0071C:  DATA 22,20
0071E:  DATA 61,6C
00720:  DATA 69,67
00722:  DATA 6E,3D
00724:  DATA 22,63
00726:  DATA 65,6E
00728:  DATA 74,65
0072A:  DATA 72,22
0072C:  DATA 20,77
0072E:  DATA 69,64
00730:  DATA 74,68
00732:  DATA 3D,22
00734:  DATA 39,32
00736:  DATA 22,20
00738:  DATA 68,65
0073A:  DATA 69,67
0073C:  DATA 68,74
0073E:  DATA 3D,22
00740:  DATA 35,31
00742:  DATA 22,3E
00744:  DATA 3C,2F
00746:  DATA 54,44
00748:  DATA 3E,20
0074A:  DATA 0A,20
0074C:  DATA 20,20
0074E:  DATA 20,20
00750:  DATA 20,20
00752:  DATA 20,20
00754:  DATA 3C,54
00756:  DATA 48,3E
00758:  DATA 48,75
0075A:  DATA 6D,65
0075C:  DATA 64,61
0075E:  DATA 64,3A
00760:  DATA 3C,2F
00762:  DATA 54,48
00764:  DATA 3E,20
00766:  DATA 0A,20
00768:  DATA 20,20
0076A:  DATA 20,20
0076C:  DATA 20,20
0076E:  DATA 20,20
00770:  DATA 3C,54
00772:  DATA 44,20
00774:  DATA 69,64
00776:  DATA 3D,22
00778:  DATA 64,79
0077A:  DATA 6E,32
0077C:  DATA 22,3E
0077E:  DATA 25,32
00780:  DATA 3C,2F
00782:  DATA 54,44
00784:  DATA 3E,20
00786:  DATA 0A,20
00788:  DATA 20,20
0078A:  DATA 20,20
0078C:  DATA 20,3C
0078E:  DATA 2F,54
00790:  DATA 52,3E
00792:  DATA 20,20
00794:  DATA 20,20
00796:  DATA 20,20
00798:  DATA 20,0A
0079A:  DATA 20,20
0079C:  DATA 20,20
0079E:  DATA 20,20
007A0:  DATA 3C,54
007A2:  DATA 52,3E
007A4:  DATA 20,0A
007A6:  DATA 20,20
007A8:  DATA 20,20
007AA:  DATA 3C,54
007AC:  DATA 44,3E
007AE:  DATA 20,3C
007B0:  DATA 69,6D
007B2:  DATA 67,20
007B4:  DATA 73,72
007B6:  DATA 63,3D
007B8:  DATA 22,68
007BA:  DATA 74,74
007BC:  DATA 70,73
007BE:  DATA 3A,2F
007C0:  DATA 2F,77
007C2:  DATA 37,2E
007C4:  DATA 70,6E
007C6:  DATA 67,77
007C8:  DATA 69,6E
007CA:  DATA 67,2E
007CC:  DATA 63,6F
007CE:  DATA 6D,2F
007D0:  DATA 70,6E
007D2:  DATA 67,73
007D4:  DATA 2F,34
007D6:  DATA 39,33
007D8:  DATA 2F,39
007DA:  DATA 35,38
007DC:  DATA 2F,70
007DE:  DATA 6E,67
007E0:  DATA 2D,74
007E2:  DATA 72,61
007E4:  DATA 6E,73
007E6:  DATA 70,61
007E8:  DATA 72,65
007EA:  DATA 6E,74
007EC:  DATA 2D,73
007EE:  DATA 79,6D
007F0:  DATA 62,6F
007F2:  DATA 6C,2D
007F4:  DATA 6C,6F
007F6:  DATA 67,6F
007F8:  DATA 2D,63
007FA:  DATA 6F,6D
007FC:  DATA 70,75
007FE:  DATA 74,65
00800:  DATA 72,2D
00802:  DATA 69,63
00804:  DATA 6F,6E
00806:  DATA 73,2D
00808:  DATA 74,69
0080A:  DATA 6D,65
0080C:  DATA 2D,73
0080E:  DATA 79,6D
00810:  DATA 62,6F
00812:  DATA 6C,2D
00814:  DATA 6D,69
00816:  DATA 73,63
00818:  DATA 65,6C
0081A:  DATA 6C,61
0081C:  DATA 6E,65
0081E:  DATA 6F,75
00820:  DATA 73,2D
00822:  DATA 61,6E
00824:  DATA 67,6C
00826:  DATA 65,2D
00828:  DATA 6C,6F
0082A:  DATA 67,6F
0082C:  DATA 2E,70
0082E:  DATA 6E,67
00830:  DATA 22,20
00832:  DATA 61,6C
00834:  DATA 74,3D
00836:  DATA 22,54
00838:  DATA 69,65
0083A:  DATA 6D,70
0083C:  DATA 6F,22
0083E:  DATA 20,61
00840:  DATA 6C,69
00842:  DATA 67,6E
00844:  DATA 3D,22
00846:  DATA 63,65
00848:  DATA 6E,74
0084A:  DATA 65,72
0084C:  DATA 22,20
0084E:  DATA 77,69
00850:  DATA 64,74
00852:  DATA 68,3D
00854:  DATA 22,39
00856:  DATA 32,22
00858:  DATA 20,68
0085A:  DATA 65,69
0085C:  DATA 67,68
0085E:  DATA 74,3D
00860:  DATA 22,35
00862:  DATA 31,22
00864:  DATA 3E,20
00866:  DATA 3C,2F
00868:  DATA 54,44
0086A:  DATA 3E,20
0086C:  DATA 0A,20
0086E:  DATA 20,20
00870:  DATA 20,3C
00872:  DATA 54,48
00874:  DATA 3E,20
00876:  DATA 46,65
00878:  DATA 63,68
0087A:  DATA 61,3A
0087C:  DATA 20,3C
0087E:  DATA 2F,54
00880:  DATA 48,3E
00882:  DATA 20,0A
00884:  DATA 20,20
00886:  DATA 20,20
00888:  DATA 3C,54
0088A:  DATA 44,20
0088C:  DATA 69,64
0088E:  DATA 3D,22
00890:  DATA 48,6F
00892:  DATA 72,61
00894:  DATA 41,63
00896:  DATA 74,75
00898:  DATA 61,6C
0089A:  DATA 22,3E
0089C:  DATA 20,3C
0089E:  DATA 2F,54
008A0:  DATA 44,3E
008A2:  DATA 20,0A
008A4:  DATA 20,20
008A6:  DATA 20,20
008A8:  DATA 20,20
008AA:  DATA 3C,2F
008AC:  DATA 54,52
008AE:  DATA 3E,20
008B0:  DATA 0A,20
008B2:  DATA 20,20
008B4:  DATA 3C,2F
008B6:  DATA 54,41
008B8:  DATA 42,4C
008BA:  DATA 45,3E
008BC:  DATA 20,0A
008BE:  DATA 20,0A
008C0:  DATA 20,0A
008C2:  DATA 20,20
008C4:  DATA 20,3C
008C6:  DATA 42,52
008C8:  DATA 2F,3E
008CA:  DATA 20,0A
008CC:  DATA 3C,2F
008CE:  DATA 64,69
008D0:  DATA 76,3E
008D2:  DATA 20,0A
008D4:  DATA 20,0A
008D6:  DATA 20,0A
008D8:  DATA 3C,2F
008DA:  DATA 62,6F
008DC:  DATA 64,79
008DE:  DATA 3E,20
008E0:  DATA 0A,20
008E2:  DATA 0A,3C
008E4:  DATA 73,63
008E6:  DATA 72,69
008E8:  DATA 70,74
008EA:  DATA 20,74
008EC:  DATA 79,70
008EE:  DATA 65,3D
008F0:  DATA 22,74
008F2:  DATA 65,78
008F4:  DATA 74,2F
008F6:  DATA 6A,61
008F8:  DATA 76,61
008FA:  DATA 73,63
008FC:  DATA 72,69
008FE:  DATA 70,74
00900:  DATA 22,3E
00902:  DATA 20,0A
00904:  DATA 2F,2F
00906:  DATA 2F,2F
00908:  DATA 2F,2F
0090A:  DATA 2F,2F
0090C:  DATA 2F,2F
0090E:  DATA 2F,2F
00910:  DATA 2F,2F
00912:  DATA 2F,2F
00914:  DATA 2F,2F
00916:  DATA 2F,2F
00918:  DATA 2F,2F
0091A:  DATA 2F,2F
0091C:  DATA 2F,2F
0091E:  DATA 2F,2F
00920:  DATA 2F,2F
00922:  DATA 2F,2F
00924:  DATA 2F,2F
00926:  DATA 2F,2F
00928:  DATA 2F,2F
0092A:  DATA 2F,2F
0092C:  DATA 2F,2F
0092E:  DATA 2F,2F
00930:  DATA 2F,2F
00932:  DATA 2F,2F
00934:  DATA 2F,2F
00936:  DATA 2F,2F
00938:  DATA 2F,2F
0093A:  DATA 2F,2F
0093C:  DATA 2F,2F
0093E:  DATA 2F,2F
00940:  DATA 2F,2F
00942:  DATA 2F,2F
00944:  DATA 2F,2F
00946:  DATA 2F,2F
00948:  DATA 2F,2F
0094A:  DATA 2F,2F
0094C:  DATA 2F,20
0094E:  DATA 0A,2F
00950:  DATA 2F,2F
00952:  DATA 2F,20
00954:  DATA 20,20
00956:  DATA 20,20
00958:  DATA 20,20
0095A:  DATA 20,20
0095C:  DATA 20,20
0095E:  DATA 20,20
00960:  DATA 20,20
00962:  DATA 20,20
00964:  DATA 20,20
00966:  DATA 20,20
00968:  DATA 20,20
0096A:  DATA 20,20
0096C:  DATA 20,20
0096E:  DATA 20,20
00970:  DATA 20,20
00972:  DATA 20,20
00974:  DATA 20,20
00976:  DATA 20,20
00978:  DATA 20,20
0097A:  DATA 20,20
0097C:  DATA 20,20
0097E:  DATA 20,20
00980:  DATA 20,20
00982:  DATA 20,20
00984:  DATA 20,20
00986:  DATA 20,20
00988:  DATA 20,20
0098A:  DATA 20,20
0098C:  DATA 20,20
0098E:  DATA 20,20
00990:  DATA 20,20
00992:  DATA 20,20
00994:  DATA 2F,2F
00996:  DATA 2F,2F
00998:  DATA 20,0A
0099A:  DATA 2F,2F
0099C:  DATA 2F,2F
0099E:  DATA 20,20
009A0:  DATA 41,4A
009A2:  DATA 41,58
009A4:  DATA 20,72
009A6:  DATA 6F,75
009A8:  DATA 74,69
009AA:  DATA 6E,65
009AC:  DATA 73,20
009AE:  DATA 66,6F
009B0:  DATA 72,20
009B2:  DATA 72,78
009B4:  DATA 2F,74
009B6:  DATA 78,20
009B8:  DATA 6F,66
009BA:  DATA 20,64
009BC:  DATA 61,74
009BE:  DATA 61,20
009C0:  DATA 77,69
009C2:  DATA 74,68
009C4:  DATA 6F,75
009C6:  DATA 74,20
009C8:  DATA 68,61
009CA:  DATA 76,69
009CC:  DATA 6E,67
009CE:  DATA 20,74
009D0:  DATA 6F,20
009D2:  DATA 72,65
009D4:  DATA 6C,6F
009D6:  DATA 61,64
009D8:  DATA 20,70
009DA:  DATA 61,67
009DC:  DATA 65,2E
009DE:  DATA 20,2F
009E0:  DATA 2F,2F
009E2:  DATA 2F,20
009E4:  DATA 0A,2F
009E6:  DATA 2F,2F
009E8:  DATA 2F,20
009EA:  DATA 20,20
009EC:  DATA 20,20
009EE:  DATA 20,20
009F0:  DATA 20,20
009F2:  DATA 20,20
009F4:  DATA 20,20
009F6:  DATA 20,20
009F8:  DATA 20,20
009FA:  DATA 20,20
009FC:  DATA 20,20
009FE:  DATA 20,20
00A00:  DATA 20,20
00A02:  DATA 20,20
00A04:  DATA 20,20
00A06:  DATA 20,20
00A08:  DATA 20,20
00A0A:  DATA 20,20
00A0C:  DATA 20,20
00A0E:  DATA 20,20
00A10:  DATA 20,20
00A12:  DATA 20,20
00A14:  DATA 20,20
00A16:  DATA 20,20
00A18:  DATA 20,20
00A1A:  DATA 20,20
00A1C:  DATA 20,20
00A1E:  DATA 20,20
00A20:  DATA 20,20
00A22:  DATA 20,20
00A24:  DATA 20,20
00A26:  DATA 20,20
00A28:  DATA 20,20
00A2A:  DATA 2F,2F
00A2C:  DATA 2F,2F
00A2E:  DATA 20,0A
00A30:  DATA 2F,2F
00A32:  DATA 2F,2F
00A34:  DATA 20,20
00A36:  DATA 57,72
00A38:  DATA 69,74
00A3A:  DATA 74,65
00A3C:  DATA 6E,20
00A3E:  DATA 62,79
00A40:  DATA 20,43
00A42:  DATA 43,53
00A44:  DATA 2C,20
00A46:  DATA 49,6E
00A48:  DATA 63,2E
00A4A:  DATA 20,20
00A4C:  DATA 20,20
00A4E:  DATA 20,20
00A50:  DATA 20,20
00A52:  DATA 20,20
00A54:  DATA 20,20
00A56:  DATA 20,20
00A58:  DATA 20,20
00A5A:  DATA 20,20
00A5C:  DATA 20,20
00A5E:  DATA 68,74
00A60:  DATA 74,70
00A62:  DATA 3A,2F
00A64:  DATA 2F,77
00A66:  DATA 77,77
00A68:  DATA 2E,63
00A6A:  DATA 63,73
00A6C:  DATA 69,6E
00A6E:  DATA 66,6F
00A70:  DATA 2E,63
00A72:  DATA 6F,6D
00A74:  DATA 20,2F
00A76:  DATA 2F,2F
00A78:  DATA 2F,20
00A7A:  DATA 0A,2F
00A7C:  DATA 2F,2F
00A7E:  DATA 2F,20
00A80:  DATA 20,20
00A82:  DATA 20,20
00A84:  DATA 20,20
00A86:  DATA 20,20
00A88:  DATA 20,20
00A8A:  DATA 20,20
00A8C:  DATA 20,20
00A8E:  DATA 20,20
00A90:  DATA 20,20
00A92:  DATA 20,20
00A94:  DATA 20,20
00A96:  DATA 20,20
00A98:  DATA 20,20
00A9A:  DATA 20,20
00A9C:  DATA 20,20
00A9E:  DATA 20,20
00AA0:  DATA 20,20
00AA2:  DATA 20,20
00AA4:  DATA 20,20
00AA6:  DATA 20,20
00AA8:  DATA 20,20
00AAA:  DATA 20,20
00AAC:  DATA 20,20
00AAE:  DATA 20,20
00AB0:  DATA 20,20
00AB2:  DATA 20,20
00AB4:  DATA 20,20
00AB6:  DATA 20,20
00AB8:  DATA 20,20
00ABA:  DATA 20,20
00ABC:  DATA 20,20
00ABE:  DATA 20,20
00AC0:  DATA 2F,2F
00AC2:  DATA 2F,2F
00AC4:  DATA 20,0A
00AC6:  DATA 2F,2F
00AC8:  DATA 2F,2F
00ACA:  DATA 20,20
00ACC:  DATA 20,20
00ACE:  DATA 20,20
00AD0:  DATA 20,20
00AD2:  DATA 28,43
00AD4:  DATA 29,20
00AD6:  DATA 43,6F
00AD8:  DATA 70,79
00ADA:  DATA 72,69
00ADC:  DATA 67,68
00ADE:  DATA 74,20
00AE0:  DATA 31,39
00AE2:  DATA 39,36
00AE4:  DATA 2C,32
00AE6:  DATA 30,31
00AE8:  DATA 33,20
00AEA:  DATA 43,75
00AEC:  DATA 73,74
00AEE:  DATA 6F,6D
00AF0:  DATA 20,43
00AF2:  DATA 6F,6D
00AF4:  DATA 70,75
00AF6:  DATA 74,65
00AF8:  DATA 72,20
00AFA:  DATA 53,65
00AFC:  DATA 72,76
00AFE:  DATA 69,63
00B00:  DATA 65,73
00B02:  DATA 20,20
00B04:  DATA 20,20
00B06:  DATA 20,20
00B08:  DATA 20,20
00B0A:  DATA 20,2F
00B0C:  DATA 2F,2F
00B0E:  DATA 2F,20
00B10:  DATA 0A,2F
00B12:  DATA 2F,2F
00B14:  DATA 2F,20
00B16:  DATA 54,68
00B18:  DATA 69,73
00B1A:  DATA 20,73
00B1C:  DATA 6F,75
00B1E:  DATA 72,63
00B20:  DATA 65,20
00B22:  DATA 63,6F
00B24:  DATA 64,65
00B26:  DATA 20,6D
00B28:  DATA 61,79
00B2A:  DATA 20,6F
00B2C:  DATA 6E,6C
00B2E:  DATA 79,20
00B30:  DATA 62,65
00B32:  DATA 20,75
00B34:  DATA 73,65
00B36:  DATA 64,20
00B38:  DATA 62,79
00B3A:  DATA 20,6C
00B3C:  DATA 69,63
00B3E:  DATA 65,6E
00B40:  DATA 73,65
00B42:  DATA 64,20
00B44:  DATA 75,73
00B46:  DATA 65,72
00B48:  DATA 73,20
00B4A:  DATA 6F,66
00B4C:  DATA 20,74
00B4E:  DATA 68,65
00B50:  DATA 20,43
00B52:  DATA 43,53
00B54:  DATA 20,20
00B56:  DATA 2F,2F
00B58:  DATA 2F,2F
00B5A:  DATA 20,0A
00B5C:  DATA 2F,2F
00B5E:  DATA 2F,2F
00B60:  DATA 20,43
00B62:  DATA 20,63
00B64:  DATA 6F,6D
00B66:  DATA 70,69
00B68:  DATA 6C,65
00B6A:  DATA 72,2E
00B6C:  DATA 20,20
00B6E:  DATA 54,68
00B70:  DATA 69,73
00B72:  DATA 20,73
00B74:  DATA 6F,75
00B76:  DATA 72,63
00B78:  DATA 65,20
00B7A:  DATA 63,6F
00B7C:  DATA 64,65
00B7E:  DATA 20,6D
00B80:  DATA 61,79
00B82:  DATA 20,6F
00B84:  DATA 6E,6C
00B86:  DATA 79,20
00B88:  DATA 62,65
00B8A:  DATA 20,64
00B8C:  DATA 69,73
00B8E:  DATA 74,72
00B90:  DATA 69,62
00B92:  DATA 75,74
00B94:  DATA 65,64
00B96:  DATA 20,74
00B98:  DATA 6F,20
00B9A:  DATA 6F,74
00B9C:  DATA 68,65
00B9E:  DATA 72,20
00BA0:  DATA 20,2F
00BA2:  DATA 2F,2F
00BA4:  DATA 2F,20
00BA6:  DATA 0A,2F
00BA8:  DATA 2F,2F
00BAA:  DATA 2F,20
00BAC:  DATA 6C,69
00BAE:  DATA 63,65
00BB0:  DATA 6E,73
00BB2:  DATA 65,64
00BB4:  DATA 20,75
00BB6:  DATA 73,65
00BB8:  DATA 72,73
00BBA:  DATA 20,6F
00BBC:  DATA 66,20
00BBE:  DATA 74,68
00BC0:  DATA 65,20
00BC2:  DATA 43,43
00BC4:  DATA 53,20
00BC6:  DATA 43,20
00BC8:  DATA 63,6F
00BCA:  DATA 6D,70
00BCC:  DATA 69,6C
00BCE:  DATA 65,72
00BD0:  DATA 2E,20
00BD2:  DATA 20,4E
00BD4:  DATA 6F,20
00BD6:  DATA 6F,74
00BD8:  DATA 68,65
00BDA:  DATA 72,20
00BDC:  DATA 75,73
00BDE:  DATA 65,2C
00BE0:  DATA 20,20
00BE2:  DATA 20,20
00BE4:  DATA 20,20
00BE6:  DATA 20,20
00BE8:  DATA 20,20
00BEA:  DATA 20,20
00BEC:  DATA 2F,2F
00BEE:  DATA 2F,2F
00BF0:  DATA 20,0A
00BF2:  DATA 2F,2F
00BF4:  DATA 2F,2F
00BF6:  DATA 20,72
00BF8:  DATA 65,70
00BFA:  DATA 72,6F
00BFC:  DATA 64,75
00BFE:  DATA 63,74
00C00:  DATA 69,6F
00C02:  DATA 6E,20
00C04:  DATA 6F,72
00C06:  DATA 20,64
00C08:  DATA 69,73
00C0A:  DATA 74,72
00C0C:  DATA 69,62
00C0E:  DATA 75,74
00C10:  DATA 69,6F
00C12:  DATA 6E,20
00C14:  DATA 69,73
00C16:  DATA 20,70
00C18:  DATA 65,72
00C1A:  DATA 6D,69
00C1C:  DATA 74,74
00C1E:  DATA 65,64
00C20:  DATA 20,77
00C22:  DATA 69,74
00C24:  DATA 68,6F
00C26:  DATA 75,74
00C28:  DATA 20,77
00C2A:  DATA 72,69
00C2C:  DATA 74,74
00C2E:  DATA 65,6E
00C30:  DATA 20,20
00C32:  DATA 20,20
00C34:  DATA 20,20
00C36:  DATA 20,2F
00C38:  DATA 2F,2F
00C3A:  DATA 2F,20
00C3C:  DATA 0A,2F
00C3E:  DATA 2F,2F
00C40:  DATA 2F,20
00C42:  DATA 70,65
00C44:  DATA 72,6D
00C46:  DATA 69,73
00C48:  DATA 73,69
00C4A:  DATA 6F,6E
00C4C:  DATA 2E,20
00C4E:  DATA 20,20
00C50:  DATA 20,20
00C52:  DATA 20,20
00C54:  DATA 20,20
00C56:  DATA 20,20
00C58:  DATA 20,20
00C5A:  DATA 20,20
00C5C:  DATA 20,20
00C5E:  DATA 20,20
00C60:  DATA 20,20
00C62:  DATA 20,20
00C64:  DATA 20,20
00C66:  DATA 20,20
00C68:  DATA 20,20
00C6A:  DATA 20,20
00C6C:  DATA 20,20
00C6E:  DATA 20,20
00C70:  DATA 20,20
00C72:  DATA 20,20
00C74:  DATA 20,20
00C76:  DATA 20,20
00C78:  DATA 20,20
00C7A:  DATA 20,20
00C7C:  DATA 20,20
00C7E:  DATA 20,20
00C80:  DATA 20,20
00C82:  DATA 2F,2F
00C84:  DATA 2F,2F
00C86:  DATA 20,0A
00C88:  DATA 2F,2F
00C8A:  DATA 2F,2F
00C8C:  DATA 2F,2F
00C8E:  DATA 2F,2F
00C90:  DATA 2F,2F
00C92:  DATA 2F,2F
00C94:  DATA 2F,2F
00C96:  DATA 2F,2F
00C98:  DATA 2F,2F
00C9A:  DATA 2F,2F
00C9C:  DATA 2F,2F
00C9E:  DATA 2F,2F
00CA0:  DATA 2F,2F
00CA2:  DATA 2F,2F
00CA4:  DATA 2F,2F
00CA6:  DATA 2F,2F
00CA8:  DATA 2F,2F
00CAA:  DATA 2F,2F
00CAC:  DATA 2F,2F
00CAE:  DATA 2F,2F
00CB0:  DATA 2F,2F
00CB2:  DATA 2F,2F
00CB4:  DATA 2F,2F
00CB6:  DATA 2F,2F
00CB8:  DATA 2F,2F
00CBA:  DATA 2F,2F
00CBC:  DATA 2F,2F
00CBE:  DATA 2F,2F
00CC0:  DATA 2F,2F
00CC2:  DATA 2F,2F
00CC4:  DATA 2F,2F
00CC6:  DATA 2F,2F
00CC8:  DATA 2F,2F
00CCA:  DATA 2F,2F
00CCC:  DATA 2F,2F
00CCE:  DATA 2F,2F
00CD0:  DATA 2F,20
00CD2:  DATA 0A,76
00CD4:  DATA 61,72
00CD6:  DATA 20,61
00CD8:  DATA 6A,61
00CDA:  DATA 78,47
00CDC:  DATA 65,74
00CDE:  DATA 3B,20
00CE0:  DATA 0A,76
00CE2:  DATA 61,72
00CE4:  DATA 20,74
00CE6:  DATA 3B,20
00CE8:  DATA 0A,76
00CEA:  DATA 61,72
00CEC:  DATA 20,77
00CEE:  DATA 61,69
00CF0:  DATA 74,69
00CF2:  DATA 6E,67
00CF4:  DATA 20,3D
00CF6:  DATA 20,30
00CF8:  DATA 3B,20
00CFA:  DATA 0A,76
00CFC:  DATA 61,72
00CFE:  DATA 20,74
00D00:  DATA 56,61
00D02:  DATA 6C,69
00D04:  DATA 64,20
00D06:  DATA 3D,20
00D08:  DATA 30,3B
00D0A:  DATA 20,0A
00D0C:  DATA 76,61
00D0E:  DATA 72,20
00D10:  DATA 6E,65
00D12:  DATA 78,74
00D14:  DATA 43,67
00D16:  DATA 69,20
00D18:  DATA 3D,20
00D1A:  DATA 22,22
00D1C:  DATA 3B,20
00D1E:  DATA 0A,76
00D20:  DATA 61,72
00D22:  DATA 20,6C
00D24:  DATA 61,73
00D26:  DATA 74,43
00D28:  DATA 67,69
00D2A:  DATA 20,3D
00D2C:  DATA 20,22
00D2E:  DATA 22,3B
00D30:  DATA 20,0A
00D32:  DATA 76,61
00D34:  DATA 72,20
00D36:  DATA 69,6F
00D38:  DATA 73,36
00D3A:  DATA 77,6F
00D3C:  DATA 72,6B
00D3E:  DATA 61,72
00D40:  DATA 6F,75
00D42:  DATA 6E,64
00D44:  DATA 20,3D
00D46:  DATA 20,30
00D48:  DATA 3B,20
00D4A:  DATA 0A,20
00D4C:  DATA 0A,66
00D4E:  DATA 75,6E
00D50:  DATA 63,74
00D52:  DATA 69,6F
00D54:  DATA 6E,20
00D56:  DATA 73,65
00D58:  DATA 74,53
00D5A:  DATA 74,61
00D5C:  DATA 72,74
00D5E:  DATA 54,69
00D60:  DATA 6D,65
00D62:  DATA 28,29
00D64:  DATA 20,0A
00D66:  DATA 7B,20
00D68:  DATA 0A,20
00D6A:  DATA 20,20
00D6C:  DATA 74,56
00D6E:  DATA 61,6C
00D70:  DATA 69,64
00D72:  DATA 20,3D
00D74:  DATA 20,31
00D76:  DATA 3B,20
00D78:  DATA 0A,20
00D7A:  DATA 20,20
00D7C:  DATA 74,20
00D7E:  DATA 3D,20
00D80:  DATA 73,65
00D82:  DATA 74,54
00D84:  DATA 69,6D
00D86:  DATA 65,6F
00D88:  DATA 75,74
00D8A:  DATA 28,27
00D8C:  DATA 61,6A
00D8E:  DATA 61,78
00D90:  DATA 28,29
00D92:  DATA 27,2C
00D94:  DATA 20,35
00D96:  DATA 30,30
00D98:  DATA 29,3B
00D9A:  DATA 20,0A
00D9C:  DATA 7D,20
00D9E:  DATA 0A,20
00DA0:  DATA 0A,66
00DA2:  DATA 75,6E
00DA4:  DATA 63,74
00DA6:  DATA 69,6F
00DA8:  DATA 6E,20
00DAA:  DATA 61,6A
00DAC:  DATA 61,78
00DAE:  DATA 28,29
00DB0:  DATA 20,0A
00DB2:  DATA 7B,20
00DB4:  DATA 0A,20
00DB6:  DATA 20,20
00DB8:  DATA 69,66
00DBA:  DATA 20,28
00DBC:  DATA 77,61
00DBE:  DATA 69,74
00DC0:  DATA 69,6E
00DC2:  DATA 67,29
00DC4:  DATA 20,0A
00DC6:  DATA 20,20
00DC8:  DATA 20,7B
00DCA:  DATA 20,0A
00DCC:  DATA 20,20
00DCE:  DATA 20,20
00DD0:  DATA 20,20
00DD2:  DATA 77,61
00DD4:  DATA 69,74
00DD6:  DATA 69,6E
00DD8:  DATA 67,2D
00DDA:  DATA 2D,3B
00DDC:  DATA 20,0A
00DDE:  DATA 20,20
00DE0:  DATA 20,20
00DE2:  DATA 20,20
00DE4:  DATA 69,66
00DE6:  DATA 20,28
00DE8:  DATA 77,61
00DEA:  DATA 69,74
00DEC:  DATA 69,6E
00DEE:  DATA 67,20
00DF0:  DATA 3D,3D
00DF2:  DATA 20,30
00DF4:  DATA 29,20
00DF6:  DATA 0A,20
00DF8:  DATA 20,20
00DFA:  DATA 20,20
00DFC:  DATA 20,7B
00DFE:  DATA 20,0A
00E00:  DATA 20,20
00E02:  DATA 20,20
00E04:  DATA 20,20
00E06:  DATA 20,20
00E08:  DATA 20,69
00E0A:  DATA 66,20
00E0C:  DATA 28,6C
00E0E:  DATA 61,73
00E10:  DATA 74,43
00E12:  DATA 67,69
00E14:  DATA 20,21
00E16:  DATA 3D,20
00E18:  DATA 22,22
00E1A:  DATA 29,20
00E1C:  DATA 0A,20
00E1E:  DATA 20,20
00E20:  DATA 20,20
00E22:  DATA 20,20
00E24:  DATA 20,20
00E26:  DATA 7B,20
00E28:  DATA 0A,20
00E2A:  DATA 20,20
00E2C:  DATA 20,20
00E2E:  DATA 20,20
00E30:  DATA 20,20
00E32:  DATA 20,20
00E34:  DATA 20,69
00E36:  DATA 66,20
00E38:  DATA 28,6E
00E3A:  DATA 65,78
00E3C:  DATA 74,43
00E3E:  DATA 67,69
00E40:  DATA 20,3D
00E42:  DATA 3D,20
00E44:  DATA 22,22
00E46:  DATA 29,20
00E48:  DATA 0A,20
00E4A:  DATA 20,20
00E4C:  DATA 20,20
00E4E:  DATA 20,20
00E50:  DATA 20,20
00E52:  DATA 20,20
00E54:  DATA 20,20
00E56:  DATA 20,20
00E58:  DATA 6E,65
00E5A:  DATA 78,74
00E5C:  DATA 43,67
00E5E:  DATA 69,20
00E60:  DATA 3D,20
00E62:  DATA 6C,61
00E64:  DATA 73,74
00E66:  DATA 43,67
00E68:  DATA 69,3B
00E6A:  DATA 20,0A
00E6C:  DATA 20,20
00E6E:  DATA 20,20
00E70:  DATA 20,20
00E72:  DATA 20,20
00E74:  DATA 20,20
00E76:  DATA 20,20
00E78:  DATA 65,6C
00E7A:  DATA 73,65
00E7C:  DATA 20,0A
00E7E:  DATA 20,20
00E80:  DATA 20,20
00E82:  DATA 20,20
00E84:  DATA 20,20
00E86:  DATA 20,20
00E88:  DATA 20,20
00E8A:  DATA 20,20
00E8C:  DATA 20,6E
00E8E:  DATA 65,78
00E90:  DATA 74,43
00E92:  DATA 67,69
00E94:  DATA 20,3D
00E96:  DATA 20,6C
00E98:  DATA 61,73
00E9A:  DATA 74,43
00E9C:  DATA 67,69
00E9E:  DATA 20,2B
00EA0:  DATA 20,22
00EA2:  DATA 26,22
00EA4:  DATA 20,2B
00EA6:  DATA 20,6E
00EA8:  DATA 65,78
00EAA:  DATA 74,43
00EAC:  DATA 67,69
00EAE:  DATA 3B,20
00EB0:  DATA 0A,20
00EB2:  DATA 20,20
00EB4:  DATA 20,20
00EB6:  DATA 20,20
00EB8:  DATA 20,20
00EBA:  DATA 7D,20
00EBC:  DATA 0A,20
00EBE:  DATA 20,20
00EC0:  DATA 20,20
00EC2:  DATA 20,7D
00EC4:  DATA 20,0A
00EC6:  DATA 20,20
00EC8:  DATA 20,7D
00ECA:  DATA 20,0A
00ECC:  DATA 20,0A
00ECE:  DATA 20,20
00ED0:  DATA 20,69
00ED2:  DATA 66,20
00ED4:  DATA 28,21
00ED6:  DATA 77,61
00ED8:  DATA 69,74
00EDA:  DATA 69,6E
00EDC:  DATA 67,29
00EDE:  DATA 20,0A
00EE0:  DATA 20,20
00EE2:  DATA 20,7B
00EE4:  DATA 20,0A
00EE6:  DATA 20,20
00EE8:  DATA 20,20
00EEA:  DATA 20,20
00EEC:  DATA 61,6A
00EEE:  DATA 61,78
00EF0:  DATA 47,65
00EF2:  DATA 74,3D
00EF4:  DATA 47,65
00EF6:  DATA 74,58
00EF8:  DATA 6D,6C
00EFA:  DATA 48,74
00EFC:  DATA 74,70
00EFE:  DATA 4F,62
00F00:  DATA 6A,65
00F02:  DATA 63,74
00F04:  DATA 28,29
00F06:  DATA 3B,20
00F08:  DATA 0A,20
00F0A:  DATA 0A,20
00F0C:  DATA 20,20
00F0E:  DATA 20,20
00F10:  DATA 20,69
00F12:  DATA 66,20
00F14:  DATA 28,61
00F16:  DATA 6A,61
00F18:  DATA 78,47
00F1A:  DATA 65,74
00F1C:  DATA 3D,3D
00F1E:  DATA 6E,75
00F20:  DATA 6C,6C
00F22:  DATA 29,20
00F24:  DATA 0A,20
00F26:  DATA 20,20
00F28:  DATA 20,20
00F2A:  DATA 20,7B
00F2C:  DATA 20,0A
00F2E:  DATA 20,20
00F30:  DATA 20,20
00F32:  DATA 20,20
00F34:  DATA 20,20
00F36:  DATA 20,61
00F38:  DATA 6C,65
00F3A:  DATA 72,74
00F3C:  DATA 20,28
00F3E:  DATA 22,59
00F40:  DATA 6F,75
00F42:  DATA 72,20
00F44:  DATA 62,72
00F46:  DATA 6F,77
00F48:  DATA 73,65
00F4A:  DATA 72,20
00F4C:  DATA 64,6F
00F4E:  DATA 65,73
00F50:  DATA 20,6E
00F52:  DATA 6F,74
00F54:  DATA 20,73
00F56:  DATA 75,70
00F58:  DATA 70,6F
00F5A:  DATA 72,74
00F5C:  DATA 20,41
00F5E:  DATA 4A,41
00F60:  DATA 58,21
00F62:  DATA 22,29
00F64:  DATA 3B,20
00F66:  DATA 0A,20
00F68:  DATA 20,20
00F6A:  DATA 20,20
00F6C:  DATA 20,20
00F6E:  DATA 20,20
00F70:  DATA 72,65
00F72:  DATA 74,75
00F74:  DATA 72,6E
00F76:  DATA 3B,20
00F78:  DATA 0A,20
00F7A:  DATA 20,20
00F7C:  DATA 20,20
00F7E:  DATA 20,7D
00F80:  DATA 20,0A
00F82:  DATA 20,0A
00F84:  DATA 20,20
00F86:  DATA 20,20
00F88:  DATA 20,20
00F8A:  DATA 77,61
00F8C:  DATA 69,74
00F8E:  DATA 69,6E
00F90:  DATA 67,20
00F92:  DATA 3D,20
00F94:  DATA 35,3B
00F96:  DATA 20,20
00F98:  DATA 2F,2F
00F9A:  DATA 77,61
00F9C:  DATA 69,74
00F9E:  DATA 20,32
00FA0:  DATA 2E,35
00FA2:  DATA 20,73
00FA4:  DATA 65,63
00FA6:  DATA 6F,6E
00FA8:  DATA 64,73
00FAA:  DATA 20,66
00FAC:  DATA 6F,72
00FAE:  DATA 20,61
00FB0:  DATA 20,72
00FB2:  DATA 65,73
00FB4:  DATA 70,6F
00FB6:  DATA 6E,73
00FB8:  DATA 65,20
00FBA:  DATA 0A,20
00FBC:  DATA 0A,20
00FBE:  DATA 20,20
00FC0:  DATA 20,20
00FC2:  DATA 20,61
00FC4:  DATA 6A,61
00FC6:  DATA 78,47
00FC8:  DATA 65,74
00FCA:  DATA 2E,6F
00FCC:  DATA 70,65
00FCE:  DATA 6E,28
00FD0:  DATA 22,50
00FD2:  DATA 4F,53
00FD4:  DATA 54,22
00FD6:  DATA 2C,20
00FD8:  DATA 22,69
00FDA:  DATA 6E,64
00FDC:  DATA 65,78
00FDE:  DATA 2E,78
00FE0:  DATA 6D,6C
00FE2:  DATA 22,2C
00FE4:  DATA 20,74
00FE6:  DATA 72,75
00FE8:  DATA 65,29
00FEA:  DATA 3B,20
00FEC:  DATA 0A,20
00FEE:  DATA 0A,20
00FF0:  DATA 20,20
00FF2:  DATA 20,20
00FF4:  DATA 20,61
00FF6:  DATA 6A,61
00FF8:  DATA 78,47
00FFA:  DATA 65,74
00FFC:  DATA 2E,6F
00FFE:  DATA 6E,72
01000:  DATA 65,61
01002:  DATA 64,79
01004:  DATA 73,74
01006:  DATA 61,74
01008:  DATA 65,63
0100A:  DATA 68,61
0100C:  DATA 6E,67
0100E:  DATA 65,20
01010:  DATA 3D,20
01012:  DATA 73,74
01014:  DATA 61,74
01016:  DATA 65,43
01018:  DATA 68,61
0101A:  DATA 6E,67
0101C:  DATA 65,64
0101E:  DATA 3B,20
01020:  DATA 0A,20
01022:  DATA 0A,20
01024:  DATA 20,20
01026:  DATA 20,20
01028:  DATA 20,69
0102A:  DATA 66,20
0102C:  DATA 28,6E
0102E:  DATA 65,78
01030:  DATA 74,43
01032:  DATA 67,69
01034:  DATA 20,21
01036:  DATA 3D,20
01038:  DATA 22,22
0103A:  DATA 29,20
0103C:  DATA 0A,20
0103E:  DATA 20,20
01040:  DATA 20,20
01042:  DATA 20,7B
01044:  DATA 20,0A
01046:  DATA 20,20
01048:  DATA 20,20
0104A:  DATA 20,20
0104C:  DATA 20,20
0104E:  DATA 20,61
01050:  DATA 6A,61
01052:  DATA 78,47
01054:  DATA 65,74
01056:  DATA 2E,73
01058:  DATA 65,6E
0105A:  DATA 64,28
0105C:  DATA 6E,65
0105E:  DATA 78,74
01060:  DATA 43,67
01062:  DATA 69,29
01064:  DATA 3B,20
01066:  DATA 0A,20
01068:  DATA 20,20
0106A:  DATA 20,20
0106C:  DATA 20,20
0106E:  DATA 20,20
01070:  DATA 6C,61
01072:  DATA 73,74
01074:  DATA 43,67
01076:  DATA 69,20
01078:  DATA 3D,20
0107A:  DATA 6E,65
0107C:  DATA 78,74
0107E:  DATA 43,67
01080:  DATA 69,3B
01082:  DATA 20,0A
01084:  DATA 20,20
01086:  DATA 20,20
01088:  DATA 20,20
0108A:  DATA 20,20
0108C:  DATA 20,6E
0108E:  DATA 65,78
01090:  DATA 74,43
01092:  DATA 67,69
01094:  DATA 20,3D
01096:  DATA 20,22
01098:  DATA 22,3B
0109A:  DATA 20,0A
0109C:  DATA 20,20
0109E:  DATA 20,20
010A0:  DATA 20,20
010A2:  DATA 7D,20
010A4:  DATA 0A,20
010A6:  DATA 20,20
010A8:  DATA 20,20
010AA:  DATA 20,65
010AC:  DATA 6C,73
010AE:  DATA 65,20
010B0:  DATA 0A,20
010B2:  DATA 20,20
010B4:  DATA 20,20
010B6:  DATA 20,7B
010B8:  DATA 20,0A
010BA:  DATA 20,20
010BC:  DATA 20,20
010BE:  DATA 20,20
010C0:  DATA 20,20
010C2:  DATA 20,61
010C4:  DATA 6A,61
010C6:  DATA 78,47
010C8:  DATA 65,74
010CA:  DATA 2E,73
010CC:  DATA 65,6E
010CE:  DATA 64,28
010D0:  DATA 22,49
010D2:  DATA 47,4E
010D4:  DATA 4F,52
010D6:  DATA 45,44
010D8:  DATA 54,41
010DA:  DATA 47,3D
010DC:  DATA 22,2B
010DE:  DATA 69,6F
010E0:  DATA 73,36
010E2:  DATA 77,6F
010E4:  DATA 72,6B
010E6:  DATA 61,72
010E8:  DATA 6F,75
010EA:  DATA 6E,64
010EC:  DATA 29,3B
010EE:  DATA 20,0A
010F0:  DATA 20,0A
010F2:  DATA 20,20
010F4:  DATA 20,20
010F6:  DATA 20,20
010F8:  DATA 20,20
010FA:  DATA 20,69
010FC:  DATA 66,20
010FE:  DATA 28,2B
01100:  DATA 2B,69
01102:  DATA 6F,73
01104:  DATA 36,77
01106:  DATA 6F,72
01108:  DATA 6B,61
0110A:  DATA 72,6F
0110C:  DATA 75,6E
0110E:  DATA 64,20
01110:  DATA 3E,20
01112:  DATA 32,35
01114:  DATA 35,29
01116:  DATA 20,0A
01118:  DATA 20,20
0111A:  DATA 20,20
0111C:  DATA 20,20
0111E:  DATA 20,20
01120:  DATA 20,20
01122:  DATA 20,20
01124:  DATA 69,6F
01126:  DATA 73,36
01128:  DATA 77,6F
0112A:  DATA 72,6B
0112C:  DATA 61,72
0112E:  DATA 6F,75
01130:  DATA 6E,64
01132:  DATA 20,3D
01134:  DATA 20,30
01136:  DATA 3B,20
01138:  DATA 0A,20
0113A:  DATA 20,20
0113C:  DATA 20,20
0113E:  DATA 20,7D
01140:  DATA 20,0A
01142:  DATA 20,20
01144:  DATA 20,7D
01146:  DATA 20,0A
01148:  DATA 20,0A
0114A:  DATA 20,20
0114C:  DATA 20,73
0114E:  DATA 65,74
01150:  DATA 53,74
01152:  DATA 61,72
01154:  DATA 74,54
01156:  DATA 69,6D
01158:  DATA 65,28
0115A:  DATA 29,3B
0115C:  DATA 20,0A
0115E:  DATA 7D,20
01160:  DATA 0A,20
01162:  DATA 0A,66
01164:  DATA 75,6E
01166:  DATA 63,74
01168:  DATA 69,6F
0116A:  DATA 6E,20
0116C:  DATA 73,65
0116E:  DATA 6E,64
01170:  DATA 43,67
01172:  DATA 69,28
01174:  DATA 63,6D
01176:  DATA 64,2C
01178:  DATA 20,76
0117A:  DATA 61,6C
0117C:  DATA 75,65
0117E:  DATA 29,20
01180:  DATA 0A,7B
01182:  DATA 20,0A
01184:  DATA 20,20
01186:  DATA 20,69
01188:  DATA 66,20
0118A:  DATA 28,6E
0118C:  DATA 65,78
0118E:  DATA 74,43
01190:  DATA 67,69
01192:  DATA 20,21
01194:  DATA 3D,20
01196:  DATA 22,22
01198:  DATA 29,20
0119A:  DATA 0A,20
0119C:  DATA 20,20
0119E:  DATA 20,20
011A0:  DATA 20,6E
011A2:  DATA 65,78
011A4:  DATA 74,43
011A6:  DATA 67,69
011A8:  DATA 20,2B
011AA:  DATA 3D,20
011AC:  DATA 22,26
011AE:  DATA 22,3B
011B0:  DATA 20,0A
011B2:  DATA 20,0A
011B4:  DATA 20,20
011B6:  DATA 20,6E
011B8:  DATA 65,78
011BA:  DATA 74,43
011BC:  DATA 67,69
011BE:  DATA 20,2B
011C0:  DATA 3D,20
011C2:  DATA 63,6D
011C4:  DATA 64,20
011C6:  DATA 2B,20
011C8:  DATA 22,3D
011CA:  DATA 22,20
011CC:  DATA 2B,20
011CE:  DATA 76,61
011D0:  DATA 6C,75
011D2:  DATA 65,3B
011D4:  DATA 20,0A
011D6:  DATA 7D,20
011D8:  DATA 0A,20
011DA:  DATA 0A,66
011DC:  DATA 75,6E
011DE:  DATA 63,74
011E0:  DATA 69,6F
011E2:  DATA 6E,20
011E4:  DATA 47,65
011E6:  DATA 74,45
011E8:  DATA 6C,65
011EA:  DATA 6D,65
011EC:  DATA 6E,74
011EE:  DATA 4E,6F
011F0:  DATA 64,65
011F2:  DATA 56,61
011F4:  DATA 6C,75
011F6:  DATA 65,28
011F8:  DATA 78,6D
011FA:  DATA 6C,44
011FC:  DATA 6F,63
011FE:  DATA 2C,20
01200:  DATA 69,64
01202:  DATA 29,20
01204:  DATA 0A,7B
01206:  DATA 20,0A
01208:  DATA 20,20
0120A:  DATA 20,72
0120C:  DATA 65,74
0120E:  DATA 75,72
01210:  DATA 6E,20
01212:  DATA 78,6D
01214:  DATA 6C,44
01216:  DATA 6F,63
01218:  DATA 2E,67
0121A:  DATA 65,74
0121C:  DATA 45,6C
0121E:  DATA 65,6D
01220:  DATA 65,6E
01222:  DATA 74,73
01224:  DATA 42,79
01226:  DATA 54,61
01228:  DATA 67,4E
0122A:  DATA 61,6D
0122C:  DATA 65,28
0122E:  DATA 69,64
01230:  DATA 29,5B
01232:  DATA 30,5D
01234:  DATA 2E,63
01236:  DATA 68,69
01238:  DATA 6C,64
0123A:  DATA 4E,6F
0123C:  DATA 64,65
0123E:  DATA 73,5B
01240:  DATA 30,5D
01242:  DATA 2E,6E
01244:  DATA 6F,64
01246:  DATA 65,56
01248:  DATA 61,6C
0124A:  DATA 75,65
0124C:  DATA 3B,20
0124E:  DATA 0A,7D
01250:  DATA 20,0A
01252:  DATA 20,0A
01254:  DATA 66,75
01256:  DATA 6E,63
01258:  DATA 74,69
0125A:  DATA 6F,6E
0125C:  DATA 20,47
0125E:  DATA 65,74
01260:  DATA 45,6C
01262:  DATA 65,6D
01264:  DATA 65,6E
01266:  DATA 74,41
01268:  DATA 74,74
0126A:  DATA 72,69
0126C:  DATA 62,75
0126E:  DATA 74,65
01270:  DATA 56,61
01272:  DATA 6C,75
01274:  DATA 65,28
01276:  DATA 78,6D
01278:  DATA 6C,44
0127A:  DATA 6F,63
0127C:  DATA 2C,20
0127E:  DATA 65,6C
01280:  DATA 65,6D
01282:  DATA 65,6E
01284:  DATA 74,2C
01286:  DATA 20,61
01288:  DATA 74,74
0128A:  DATA 72,69
0128C:  DATA 62,75
0128E:  DATA 74,65
01290:  DATA 29,20
01292:  DATA 0A,7B
01294:  DATA 20,0A
01296:  DATA 20,20
01298:  DATA 20,76
0129A:  DATA 61,72
0129C:  DATA 20,6E
0129E:  DATA 3B,20
012A0:  DATA 0A,20
012A2:  DATA 20,20
012A4:  DATA 76,61
012A6:  DATA 72,20
012A8:  DATA 69,3B
012AA:  DATA 20,0A
012AC:  DATA 20,0A
012AE:  DATA 20,20
012B0:  DATA 20,6E
012B2:  DATA 20,3D
012B4:  DATA 20,78
012B6:  DATA 6D,6C
012B8:  DATA 44,6F
012BA:  DATA 63,2E
012BC:  DATA 67,65
012BE:  DATA 74,45
012C0:  DATA 6C,65
012C2:  DATA 6D,65
012C4:  DATA 6E,74
012C6:  DATA 73,42
012C8:  DATA 79,54
012CA:  DATA 61,67
012CC:  DATA 4E,61
012CE:  DATA 6D,65
012D0:  DATA 28,65
012D2:  DATA 6C,65
012D4:  DATA 6D,65
012D6:  DATA 6E,74
012D8:  DATA 29,5B
012DA:  DATA 30,5D
012DC:  DATA 2E,61
012DE:  DATA 74,74
012E0:  DATA 72,69
012E2:  DATA 62,75
012E4:  DATA 74,65
012E6:  DATA 73,2E
012E8:  DATA 6C,65
012EA:  DATA 6E,67
012EC:  DATA 74,68
012EE:  DATA 3B,20
012F0:  DATA 0A,20
012F2:  DATA 0A,20
012F4:  DATA 20,20
012F6:  DATA 66,6F
012F8:  DATA 72,20
012FA:  DATA 28,69
012FC:  DATA 3D,30
012FE:  DATA 3B,20
01300:  DATA 69,3C
01302:  DATA 6E,3B
01304:  DATA 20,69
01306:  DATA 2B,2B
01308:  DATA 29,20
0130A:  DATA 0A,20
0130C:  DATA 20,20
0130E:  DATA 7B,20
01310:  DATA 0A,20
01312:  DATA 20,20
01314:  DATA 20,20
01316:  DATA 20,69
01318:  DATA 66,20
0131A:  DATA 28,78
0131C:  DATA 6D,6C
0131E:  DATA 44,6F
01320:  DATA 63,2E
01322:  DATA 67,65
01324:  DATA 74,45
01326:  DATA 6C,65
01328:  DATA 6D,65
0132A:  DATA 6E,74
0132C:  DATA 73,42
0132E:  DATA 79,54
01330:  DATA 61,67
01332:  DATA 4E,61
01334:  DATA 6D,65
01336:  DATA 28,65
01338:  DATA 6C,65
0133A:  DATA 6D,65
0133C:  DATA 6E,74
0133E:  DATA 29,5B
01340:  DATA 30,5D
01342:  DATA 2E,61
01344:  DATA 74,74
01346:  DATA 72,69
01348:  DATA 62,75
0134A:  DATA 74,65
0134C:  DATA 73,5B
0134E:  DATA 69,5D
01350:  DATA 2E,6E
01352:  DATA 61,6D
01354:  DATA 65,20
01356:  DATA 3D,3D
01358:  DATA 20,61
0135A:  DATA 74,74
0135C:  DATA 72,69
0135E:  DATA 62,75
01360:  DATA 74,65
01362:  DATA 29,20
01364:  DATA 0A,20
01366:  DATA 20,20
01368:  DATA 20,20
0136A:  DATA 20,7B
0136C:  DATA 20,0A
0136E:  DATA 20,20
01370:  DATA 20,20
01372:  DATA 20,20
01374:  DATA 20,20
01376:  DATA 20,72
01378:  DATA 65,74
0137A:  DATA 75,72
0137C:  DATA 6E,20
0137E:  DATA 78,6D
01380:  DATA 6C,44
01382:  DATA 6F,63
01384:  DATA 2E,67
01386:  DATA 65,74
01388:  DATA 45,6C
0138A:  DATA 65,6D
0138C:  DATA 65,6E
0138E:  DATA 74,73
01390:  DATA 42,79
01392:  DATA 54,61
01394:  DATA 67,4E
01396:  DATA 61,6D
01398:  DATA 65,28
0139A:  DATA 65,6C
0139C:  DATA 65,6D
0139E:  DATA 65,6E
013A0:  DATA 74,29
013A2:  DATA 5B,30
013A4:  DATA 5D,2E
013A6:  DATA 61,74
013A8:  DATA 74,72
013AA:  DATA 69,62
013AC:  DATA 75,74
013AE:  DATA 65,73
013B0:  DATA 5B,69
013B2:  DATA 5D,2E
013B4:  DATA 76,61
013B6:  DATA 6C,75
013B8:  DATA 65,3B
013BA:  DATA 20,0A
013BC:  DATA 20,20
013BE:  DATA 20,20
013C0:  DATA 20,20
013C2:  DATA 7D,20
013C4:  DATA 0A,20
013C6:  DATA 20,20
013C8:  DATA 7D,20
013CA:  DATA 0A,20
013CC:  DATA 0A,20
013CE:  DATA 20,20
013D0:  DATA 72,65
013D2:  DATA 74,75
013D4:  DATA 72,6E
013D6:  DATA 20,3B
013D8:  DATA 20,0A
013DA:  DATA 7D,20
013DC:  DATA 0A,20
013DE:  DATA 0A,66
013E0:  DATA 75,6E
013E2:  DATA 63,74
013E4:  DATA 69,6F
013E6:  DATA 6E,20
013E8:  DATA 55,70
013EA:  DATA 64,61
013EC:  DATA 74,65
013EE:  DATA 45,78
013F0:  DATA 69,73
013F2:  DATA 74,69
013F4:  DATA 6E,67
013F6:  DATA 54,61
013F8:  DATA 62,6C
013FA:  DATA 65,28
013FC:  DATA 78,6D
013FE:  DATA 6C,44
01400:  DATA 6F,63
01402:  DATA 29,20
01404:  DATA 0A,7B
01406:  DATA 20,0A
01408:  DATA 20,20
0140A:  DATA 20,76
0140C:  DATA 61,72
0140E:  DATA 20,69
01410:  DATA 20,3D
01412:  DATA 20,30
01414:  DATA 3B,20
01416:  DATA 0A,20
01418:  DATA 0A,20
0141A:  DATA 20,20
0141C:  DATA 66,6F
0141E:  DATA 72,28
01420:  DATA 3B,3B
01422:  DATA 29,20
01424:  DATA 0A,20
01426:  DATA 20,20
01428:  DATA 7B,20
0142A:  DATA 0A,20
0142C:  DATA 20,20
0142E:  DATA 20,20
01430:  DATA 20,76
01432:  DATA 61,72
01434:  DATA 20,69
01436:  DATA 64,20
01438:  DATA 3D,20
0143A:  DATA 22,64
0143C:  DATA 79,6E
0143E:  DATA 22,2B
01440:  DATA 69,3B
01442:  DATA 20,0A
01444:  DATA 20,20
01446:  DATA 20,20
01448:  DATA 20,20
0144A:  DATA 69,2B
0144C:  DATA 2B,3B
0144E:  DATA 20,0A
01450:  DATA 20,20
01452:  DATA 20,20
01454:  DATA 20,20
01456:  DATA 69,66
01458:  DATA 20,28
0145A:  DATA 64,6F
0145C:  DATA 63,75
0145E:  DATA 6D,65
01460:  DATA 6E,74
01462:  DATA 2E,67
01464:  DATA 65,74
01466:  DATA 45,6C
01468:  DATA 65,6D
0146A:  DATA 65,6E
0146C:  DATA 74,42
0146E:  DATA 79,49
01470:  DATA 64,28
01472:  DATA 69,64
01474:  DATA 29,29
01476:  DATA 20,0A
01478:  DATA 20,20
0147A:  DATA 20,20
0147C:  DATA 20,20
0147E:  DATA 7B,20
01480:  DATA 20,20
01482:  DATA 20,20
01484:  DATA 20,20
01486:  DATA 20,20
01488:  DATA 20,0A
0148A:  DATA 20,20
0148C:  DATA 20,20
0148E:  DATA 20,20
01490:  DATA 20,20
01492:  DATA 20,64
01494:  DATA 6F,63
01496:  DATA 75,6D
01498:  DATA 65,6E
0149A:  DATA 74,2E
0149C:  DATA 67,65
0149E:  DATA 74,45
014A0:  DATA 6C,65
014A2:  DATA 6D,65
014A4:  DATA 6E,74
014A6:  DATA 42,79
014A8:  DATA 49,64
014AA:  DATA 28,69
014AC:  DATA 64,29
014AE:  DATA 2E,69
014B0:  DATA 6E,6E
014B2:  DATA 65,72
014B4:  DATA 48,54
014B6:  DATA 4D,4C
014B8:  DATA 20,3D
014BA:  DATA 20,47
014BC:  DATA 65,74
014BE:  DATA 45,6C
014C0:  DATA 65,6D
014C2:  DATA 65,6E
014C4:  DATA 74,4E
014C6:  DATA 6F,64
014C8:  DATA 65,56
014CA:  DATA 61,6C
014CC:  DATA 75,65
014CE:  DATA 28,78
014D0:  DATA 6D,6C
014D2:  DATA 44,6F
014D4:  DATA 63,2C
014D6:  DATA 20,69
014D8:  DATA 64,29
014DA:  DATA 3B,20
014DC:  DATA 0A,20
014DE:  DATA 20,20
014E0:  DATA 20,20
014E2:  DATA 20,7D
014E4:  DATA 20,0A
014E6:  DATA 20,20
014E8:  DATA 20,20
014EA:  DATA 20,20
014EC:  DATA 65,6C
014EE:  DATA 73,65
014F0:  DATA 7B,20
014F2:  DATA 0A,20
014F4:  DATA 20,20
014F6:  DATA 20,20
014F8:  DATA 20,20
014FA:  DATA 20,20
014FC:  DATA 62,72
014FE:  DATA 65,61
01500:  DATA 6B,3B
01502:  DATA 20,0A
01504:  DATA 20,20
01506:  DATA 20,20
01508:  DATA 20,20
0150A:  DATA 7D,20
0150C:  DATA 0A,20
0150E:  DATA 20,20
01510:  DATA 7D,20
01512:  DATA 0A,7D
01514:  DATA 20,0A
01516:  DATA 20,0A
01518:  DATA 66,75
0151A:  DATA 6E,63
0151C:  DATA 74,69
0151E:  DATA 6F,6E
01520:  DATA 20,73
01522:  DATA 74,61
01524:  DATA 74,65
01526:  DATA 43,68
01528:  DATA 61,6E
0152A:  DATA 67,65
0152C:  DATA 64,28
0152E:  DATA 29,20
01530:  DATA 0A,7B
01532:  DATA 20,0A
01534:  DATA 20,20
01536:  DATA 20,69
01538:  DATA 66,20
0153A:  DATA 28,61
0153C:  DATA 6A,61
0153E:  DATA 78,47
01540:  DATA 65,74
01542:  DATA 2E,72
01544:  DATA 65,61
01546:  DATA 64,79
01548:  DATA 53,74
0154A:  DATA 61,74
0154C:  DATA 65,3D
0154E:  DATA 3D,34
01550:  DATA 29,20
01552:  DATA 0A,20
01554:  DATA 20,20
01556:  DATA 7B,20
01558:  DATA 0A,20
0155A:  DATA 20,20
0155C:  DATA 20,20
0155E:  DATA 20,55
01560:  DATA 70,64
01562:  DATA 61,74
01564:  DATA 65,45
01566:  DATA 78,69
01568:  DATA 73,74
0156A:  DATA 69,6E
0156C:  DATA 67,54
0156E:  DATA 61,62
01570:  DATA 6C,65
01572:  DATA 28,61
01574:  DATA 6A,61
01576:  DATA 78,47
01578:  DATA 65,74
0157A:  DATA 2E,72
0157C:  DATA 65,73
0157E:  DATA 70,6F
01580:  DATA 6E,73
01582:  DATA 65,58
01584:  DATA 4D,4C
01586:  DATA 2E,64
01588:  DATA 6F,63
0158A:  DATA 75,6D
0158C:  DATA 65,6E
0158E:  DATA 74,45
01590:  DATA 6C,65
01592:  DATA 6D,65
01594:  DATA 6E,74
01596:  DATA 29,3B
01598:  DATA 20,0A
0159A:  DATA 20,0A
0159C:  DATA 20,20
0159E:  DATA 20,20
015A0:  DATA 20,20
015A2:  DATA 77,61
015A4:  DATA 69,74
015A6:  DATA 69,6E
015A8:  DATA 67,20
015AA:  DATA 3D,20
015AC:  DATA 30,3B
015AE:  DATA 20,0A
015B0:  DATA 20,20
015B2:  DATA 7D,20
015B4:  DATA 0A,7D
015B6:  DATA 20,0A
015B8:  DATA 20,0A
015BA:  DATA 66,75
015BC:  DATA 6E,63
015BE:  DATA 74,69
015C0:  DATA 6F,6E
015C2:  DATA 20,47
015C4:  DATA 65,74
015C6:  DATA 58,6D
015C8:  DATA 6C,48
015CA:  DATA 74,74
015CC:  DATA 70,4F
015CE:  DATA 62,6A
015D0:  DATA 65,63
015D2:  DATA 74,28
015D4:  DATA 29,20
015D6:  DATA 0A,7B
015D8:  DATA 20,0A
015DA:  DATA 20,20
015DC:  DATA 20,69
015DE:  DATA 66,20
015E0:  DATA 28,77
015E2:  DATA 69,6E
015E4:  DATA 64,6F
015E6:  DATA 77,2E
015E8:  DATA 58,4D
015EA:  DATA 4C,48
015EC:  DATA 74,74
015EE:  DATA 70,52
015F0:  DATA 65,71
015F2:  DATA 75,65
015F4:  DATA 73,74
015F6:  DATA 29,20
015F8:  DATA 0A,20
015FA:  DATA 20,20
015FC:  DATA 7B,20
015FE:  DATA 0A,20
01600:  DATA 20,20
01602:  DATA 20,20
01604:  DATA 20,2F
01606:  DATA 2F,20
01608:  DATA 63,6F
0160A:  DATA 64,65
0160C:  DATA 20,66
0160E:  DATA 6F,72
01610:  DATA 20,49
01612:  DATA 45,37
01614:  DATA 2B,2C
01616:  DATA 20,46
01618:  DATA 69,72
0161A:  DATA 65,66
0161C:  DATA 6F,78
0161E:  DATA 2C,20
01620:  DATA 43,68
01622:  DATA 72,6F
01624:  DATA 6D,65
01626:  DATA 2C,20
01628:  DATA 4F,70
0162A:  DATA 65,72
0162C:  DATA 61,2C
0162E:  DATA 20,53
01630:  DATA 61,66
01632:  DATA 61,72
01634:  DATA 69,20
01636:  DATA 0A,20
01638:  DATA 20,20
0163A:  DATA 20,20
0163C:  DATA 20,72
0163E:  DATA 65,74
01640:  DATA 75,72
01642:  DATA 6E,20
01644:  DATA 6E,65
01646:  DATA 77,20
01648:  DATA 58,4D
0164A:  DATA 4C,48
0164C:  DATA 74,74
0164E:  DATA 70,52
01650:  DATA 65,71
01652:  DATA 75,65
01654:  DATA 73,74
01656:  DATA 28,29
01658:  DATA 3B,20
0165A:  DATA 0A,20
0165C:  DATA 20,20
0165E:  DATA 7D,20
01660:  DATA 0A,20
01662:  DATA 20,20
01664:  DATA 69,66
01666:  DATA 20,28
01668:  DATA 77,69
0166A:  DATA 6E,64
0166C:  DATA 6F,77
0166E:  DATA 2E,41
01670:  DATA 63,74
01672:  DATA 69,76
01674:  DATA 65,58
01676:  DATA 4F,62
01678:  DATA 6A,65
0167A:  DATA 63,74
0167C:  DATA 29,20
0167E:  DATA 0A,20
01680:  DATA 20,20
01682:  DATA 7B,20
01684:  DATA 0A,20
01686:  DATA 20,20
01688:  DATA 20,20
0168A:  DATA 20,2F
0168C:  DATA 2F,20
0168E:  DATA 63,6F
01690:  DATA 64,65
01692:  DATA 20,66
01694:  DATA 6F,72
01696:  DATA 20,49
01698:  DATA 45,36
0169A:  DATA 2C,20
0169C:  DATA 49,45
0169E:  DATA 35,20
016A0:  DATA 0A,20
016A2:  DATA 20,20
016A4:  DATA 20,20
016A6:  DATA 20,72
016A8:  DATA 65,74
016AA:  DATA 75,72
016AC:  DATA 6E,20
016AE:  DATA 6E,65
016B0:  DATA 77,20
016B2:  DATA 41,63
016B4:  DATA 74,69
016B6:  DATA 76,65
016B8:  DATA 58,4F
016BA:  DATA 62,6A
016BC:  DATA 65,63
016BE:  DATA 74,28
016C0:  DATA 22,4D
016C2:  DATA 69,63
016C4:  DATA 72,6F
016C6:  DATA 73,6F
016C8:  DATA 66,74
016CA:  DATA 2E,58
016CC:  DATA 4D,4C
016CE:  DATA 48,54
016D0:  DATA 54,50
016D2:  DATA 22,29
016D4:  DATA 3B,20
016D6:  DATA 0A,20
016D8:  DATA 20,20
016DA:  DATA 7D,20
016DC:  DATA 0A,20
016DE:  DATA 20,20
016E0:  DATA 72,65
016E2:  DATA 74,75
016E4:  DATA 72,6E
016E6:  DATA 20,6E
016E8:  DATA 75,6C
016EA:  DATA 6C,3B
016EC:  DATA 20,0A
016EE:  DATA 7D,20
016F0:  DATA 0A,20
016F2:  DATA 0A,73
016F4:  DATA 68,6F
016F6:  DATA 77,54
016F8:  DATA 69,6D
016FA:  DATA 65,28
016FC:  DATA 29,3B
016FE:  DATA 20,0A
01700:  DATA 20,0A
01702:  DATA 66,75
01704:  DATA 6E,63
01706:  DATA 74,69
01708:  DATA 6F,6E
0170A:  DATA 20,73
0170C:  DATA 68,6F
0170E:  DATA 77,54
01710:  DATA 69,6D
01712:  DATA 65,28
01714:  DATA 29,7B
01716:  DATA 20,0A
01718:  DATA 20,20
0171A:  DATA 20,6D
0171C:  DATA 79,44
0171E:  DATA 61,74
01720:  DATA 65,20
01722:  DATA 3D,20
01724:  DATA 6E,65
01726:  DATA 77,20
01728:  DATA 44,61
0172A:  DATA 74,65
0172C:  DATA 28,29
0172E:  DATA 3B,20
01730:  DATA 0A,20
01732:  DATA 20,20
01734:  DATA 2F,2F
01736:  DATA 64,6F
01738:  DATA 63,75
0173A:  DATA 6D,65
0173C:  DATA 6E,74
0173E:  DATA 2E,77
01740:  DATA 72,69
01742:  DATA 74,65
01744:  DATA 28,6D
01746:  DATA 79,44
01748:  DATA 61,74
0174A:  DATA 65,29
0174C:  DATA 3B,20
0174E:  DATA 0A,20
01750:  DATA 20,20
01752:  DATA 2F,2F
01754:  DATA 6D,79
01756:  DATA 44,61
01758:  DATA 74,65
0175A:  DATA 2E,74
0175C:  DATA 6F,55
0175E:  DATA 54,43
01760:  DATA 53,74
01762:  DATA 72,69
01764:  DATA 6E,67
01766:  DATA 28,29
01768:  DATA 3B,20
0176A:  DATA 0A,20
0176C:  DATA 20,20
0176E:  DATA 2F,2F
01770:  DATA 64,6F
01772:  DATA 63,75
01774:  DATA 6D,65
01776:  DATA 6E,74
01778:  DATA 2E,67
0177A:  DATA 65,74
0177C:  DATA 45,6C
0177E:  DATA 65,6D
01780:  DATA 65,6E
01782:  DATA 74,42
01784:  DATA 79,49
01786:  DATA 64,28
01788:  DATA 22,48
0178A:  DATA 6F,72
0178C:  DATA 61,41
0178E:  DATA 63,74
01790:  DATA 75,61
01792:  DATA 6C,22
01794:  DATA 29,2E
01796:  DATA 69,6E
01798:  DATA 6E,65
0179A:  DATA 72,48
0179C:  DATA 54,4D
0179E:  DATA 4C,20
017A0:  DATA 3D,20
017A2:  DATA 6D,79
017A4:  DATA 44,61
017A6:  DATA 74,65
017A8:  DATA 2E,74
017AA:  DATA 6F,55
017AC:  DATA 54,43
017AE:  DATA 53,74
017B0:  DATA 72,69
017B2:  DATA 6E,67
017B4:  DATA 28,29
017B6:  DATA 3B,20
017B8:  DATA 0A,20
017BA:  DATA 20,20
017BC:  DATA 68,6F
017BE:  DATA 75,72
017C0:  DATA 73,20
017C2:  DATA 3D,20
017C4:  DATA 6D,79
017C6:  DATA 44,61
017C8:  DATA 74,65
017CA:  DATA 2E,67
017CC:  DATA 65,74
017CE:  DATA 48,6F
017D0:  DATA 75,72
017D2:  DATA 73,28
017D4:  DATA 29,3B
017D6:  DATA 20,0A
017D8:  DATA 20,20
017DA:  DATA 20,6D
017DC:  DATA 69,6E
017DE:  DATA 75,74
017E0:  DATA 65,73
017E2:  DATA 20,3D
017E4:  DATA 20,6D
017E6:  DATA 79,44
017E8:  DATA 61,74
017EA:  DATA 65,2E
017EC:  DATA 67,65
017EE:  DATA 74,4D
017F0:  DATA 69,6E
017F2:  DATA 75,74
017F4:  DATA 65,73
017F6:  DATA 28,29
017F8:  DATA 3B,20
017FA:  DATA 0A,20
017FC:  DATA 20,20
017FE:  DATA 73,65
01800:  DATA 63,6F
01802:  DATA 6E,64
01804:  DATA 73,20
01806:  DATA 3D,20
01808:  DATA 6D,79
0180A:  DATA 44,61
0180C:  DATA 74,65
0180E:  DATA 2E,67
01810:  DATA 65,74
01812:  DATA 53,65
01814:  DATA 63,6F
01816:  DATA 6E,64
01818:  DATA 73,28
0181A:  DATA 29,3B
0181C:  DATA 20,0A
0181E:  DATA 20,20
01820:  DATA 20,69
01822:  DATA 66,20
01824:  DATA 28,68
01826:  DATA 6F,75
01828:  DATA 72,73
0182A:  DATA 20,3C
0182C:  DATA 20,31
0182E:  DATA 30,29
01830:  DATA 20,68
01832:  DATA 6F,75
01834:  DATA 72,73
01836:  DATA 20,3D
01838:  DATA 20,30
0183A:  DATA 20,2B
0183C:  DATA 20,68
0183E:  DATA 6F,75
01840:  DATA 72,73
01842:  DATA 3B,20
01844:  DATA 0A,20
01846:  DATA 20,20
01848:  DATA 69,66
0184A:  DATA 20,28
0184C:  DATA 6D,69
0184E:  DATA 6E,75
01850:  DATA 74,65
01852:  DATA 73,20
01854:  DATA 3C,20
01856:  DATA 31,30
01858:  DATA 29,20
0185A:  DATA 6D,69
0185C:  DATA 6E,75
0185E:  DATA 74,65
01860:  DATA 73,20
01862:  DATA 3D,20
01864:  DATA 22,30
01866:  DATA 22,20
01868:  DATA 2B,20
0186A:  DATA 6D,69
0186C:  DATA 6E,75
0186E:  DATA 74,65
01870:  DATA 73,3B
01872:  DATA 20,0A
01874:  DATA 20,20
01876:  DATA 20,69
01878:  DATA 66,20
0187A:  DATA 28,73
0187C:  DATA 65,63
0187E:  DATA 6F,6E
01880:  DATA 64,73
01882:  DATA 20,3C
01884:  DATA 20,31
01886:  DATA 30,29
01888:  DATA 20,73
0188A:  DATA 65,63
0188C:  DATA 6F,6E
0188E:  DATA 64,73
01890:  DATA 20,3D
01892:  DATA 20,22
01894:  DATA 30,22
01896:  DATA 20,2B
01898:  DATA 20,73
0189A:  DATA 65,63
0189C:  DATA 6F,6E
0189E:  DATA 64,73
018A0:  DATA 3B,20
018A2:  DATA 0A,20
018A4:  DATA 20,20
018A6:  DATA 2F,2F
018A8:  DATA 24,28
018AA:  DATA 22,23
018AC:  DATA 48,6F
018AE:  DATA 72,61
018B0:  DATA 41,63
018B2:  DATA 74,75
018B4:  DATA 61,6C
018B6:  DATA 22,29
018B8:  DATA 2E,74
018BA:  DATA 65,78
018BC:  DATA 74,28
018BE:  DATA 68,6F
018C0:  DATA 75,72
018C2:  DATA 73,2B
018C4:  DATA 20,22
018C6:  DATA 3A,22
018C8:  DATA 20,2B
018CA:  DATA 6D,69
018CC:  DATA 6E,75
018CE:  DATA 74,65
018D0:  DATA 73,2B
018D2:  DATA 20,22
018D4:  DATA 3A,22
018D6:  DATA 20,2B
018D8:  DATA 73,65
018DA:  DATA 63,6F
018DC:  DATA 6E,64
018DE:  DATA 73,29
018E0:  DATA 3B,20
018E2:  DATA 0A,20
018E4:  DATA 20,20
018E6:  DATA 64,6F
018E8:  DATA 63,75
018EA:  DATA 6D,65
018EC:  DATA 6E,74
018EE:  DATA 2E,67
018F0:  DATA 65,74
018F2:  DATA 45,6C
018F4:  DATA 65,6D
018F6:  DATA 65,6E
018F8:  DATA 74,42
018FA:  DATA 79,49
018FC:  DATA 64,28
018FE:  DATA 22,48
01900:  DATA 6F,72
01902:  DATA 61,41
01904:  DATA 63,74
01906:  DATA 75,61
01908:  DATA 6C,22
0190A:  DATA 29,2E
0190C:  DATA 69,6E
0190E:  DATA 6E,65
01910:  DATA 72,48
01912:  DATA 54,4D
01914:  DATA 4C,3D
01916:  DATA 6D,79
01918:  DATA 44,61
0191A:  DATA 74,65
0191C:  DATA 2E,74
0191E:  DATA 6F,55
01920:  DATA 54,43
01922:  DATA 53,74
01924:  DATA 72,69
01926:  DATA 6E,67
01928:  DATA 28,29
0192A:  DATA 3B,20
0192C:  DATA 0A,20
0192E:  DATA 20,20
01930:  DATA 73,65
01932:  DATA 74,54
01934:  DATA 69,6D
01936:  DATA 65,6F
01938:  DATA 75,74
0193A:  DATA 28,22
0193C:  DATA 73,68
0193E:  DATA 6F,77
01940:  DATA 54,69
01942:  DATA 6D,65
01944:  DATA 28,29
01946:  DATA 22,2C
01948:  DATA 20,31
0194A:  DATA 30,30
0194C:  DATA 30,29
0194E:  DATA 3B,20
01950:  DATA 20,20
01952:  DATA 20,0A
01954:  DATA 20,20
01956:  DATA 20,73
01958:  DATA 65,74
0195A:  DATA 54,69
0195C:  DATA 6D,65
0195E:  DATA 6F,75
01960:  DATA 74,28
01962:  DATA 22,55
01964:  DATA 70,64
01966:  DATA 61,74
01968:  DATA 65,45
0196A:  DATA 78,69
0196C:  DATA 73,74
0196E:  DATA 69,6E
01970:  DATA 67,54
01972:  DATA 61,62
01974:  DATA 6C,65
01976:  DATA 28,29
01978:  DATA 22,2C
0197A:  DATA 20,31
0197C:  DATA 30,30
0197E:  DATA 30,29
01980:  DATA 3B,20
01982:  DATA 20,20
01984:  DATA 0A,20
01986:  DATA 0A,7D
01988:  DATA 20,0A
0198A:  DATA 20,0A
0198C:  DATA 3C,2F
0198E:  DATA 73,63
01990:  DATA 72,69
01992:  DATA 70,74
01994:  DATA 3E,20
01996:  DATA 0A,20
01998:  DATA 0A,3C
0199A:  DATA 2F,68
0199C:  DATA 74,6D
0199E:  DATA 6C,3E
019A0:  DATA 20,0A
019A2:  DATA 00,00
*
01F9A:  MOVLB  3
01F9C:  CLRF   x34
01F9E:  CLRF   x35
01FA0:  MOVLW  01
01FA2:  MOVWF  x36
01FA4:  CLRF   FDA
01FA6:  CLRF   FD9
01FA8:  MOVLW  03
01FAA:  MOVWF  x39
01FAC:  MOVLW  2C
01FAE:  MOVWF  x38
01FB0:  MOVLW  03
01FB2:  MOVWF  FEA
01FB4:  MOVLW  30
01FB6:  MOVWF  FE9
01FB8:  MOVFF  339,FE2
01FBC:  MOVFF  338,FE1
01FC0:  MOVFF  336,337
01FC4:  BCF    FD8.0
01FC6:  MOVF   FE5,W
01FC8:  MULWF  FEE
01FCA:  MOVF   FF3,W
01FCC:  ADDWFC x34,F
01FCE:  MOVF   FF4,W
01FD0:  ADDWFC x35,F
01FD2:  DECFSZ x37,F
01FD4:  BRA    1FC4
01FD6:  MOVFF  334,FDE
01FDA:  MOVFF  335,334
01FDE:  CLRF   x35
01FE0:  BTFSC  FD8.0
01FE2:  INCF   x35,F
01FE4:  INCF   x38,F
01FE6:  BTFSC  FD8.2
01FE8:  INCF   x39,F
01FEA:  INCF   x36,F
01FEC:  MOVF   x36,W
01FEE:  SUBLW  05
01FF0:  BNZ   1FB0
01FF2:  MOVLB  0
01FF4:  GOTO   2066 (RETURN)
01FF8:  CLRF   01
01FFA:  CLRF   02
01FFC:  CLRF   00
01FFE:  CLRF   03
02000:  MOVLB  3
02002:  MOVF   x32,W
02004:  BNZ   200A
02006:  MOVF   x31,W
02008:  BZ    203A
0200A:  MOVLW  10
0200C:  MOVWF  x33
0200E:  BCF    FD8.0
02010:  RLCF   x2F,F
02012:  RLCF   x30,F
02014:  RLCF   00,F
02016:  RLCF   03,F
02018:  MOVF   x32,W
0201A:  SUBWF  03,W
0201C:  BNZ   2022
0201E:  MOVF   x31,W
02020:  SUBWF  00,W
02022:  BNC   2032
02024:  MOVF   x31,W
02026:  SUBWF  00,F
02028:  BTFSS  FD8.0
0202A:  DECF   03,F
0202C:  MOVF   x32,W
0202E:  SUBWF  03,F
02030:  BSF    FD8.0
02032:  RLCF   01,F
02034:  RLCF   02,F
02036:  DECFSZ x33,F
02038:  BRA    200E
0203A:  MOVLB  0
0203C:  GOTO   20A6 (RETURN)
*
05152:  MOVFF  FF2,0D
05156:  BCF    FF2.6
05158:  BCF    FF2.7
0515A:  ADDWF  FE8,W
0515C:  CLRF   FF7
0515E:  RLCF   FF7,F
05160:  ADDLW  83
05162:  MOVWF  FF6
05164:  MOVLW  51
05166:  ADDWFC FF7,F
05168:  MOVLW  00
0516A:  MOVWF  FF8
0516C:  MOVWF  FFB
0516E:  TBLRD*-
05170:  MOVF   FF5,W
05172:  MOVWF  FFA
05174:  TBLRD*
05176:  MOVF   FF5,W
05178:  BTFSC  0D.6
0517A:  BSF    FF2.6
0517C:  BTFSC  0D.7
0517E:  BSF    FF2.7
05180:  MOVWF  FF9
05182:  DATA B8,4E
05184:  DATA C0,4E
05186:  DATA 08,4F
05188:  DATA B0,4F
0518A:  DATA DC,4F
0518C:  DATA DC,4F
0518E:  DATA EC,4F
05190:  DATA FC,4F
05192:  DATA 10,50
*
05534:  MOVLB  3
05536:  MOVF   x88,W
05538:  XORWF  x8A,W
0553A:  ANDLW  80
0553C:  MOVWF  x8C
0553E:  BTFSS  x88.7
05540:  BRA    554C
05542:  COMF   x87,F
05544:  COMF   x88,F
05546:  INCF   x87,F
05548:  BTFSC  FD8.2
0554A:  INCF   x88,F
0554C:  BTFSS  x8A.7
0554E:  BRA    555A
05550:  COMF   x89,F
05552:  COMF   x8A,F
05554:  INCF   x89,F
05556:  BTFSC  FD8.2
05558:  INCF   x8A,F
0555A:  MOVF   x87,W
0555C:  MULWF  x89
0555E:  MOVFF  FF3,01
05562:  MOVFF  FF4,00
05566:  MULWF  x8A
05568:  MOVF   FF3,W
0556A:  ADDWF  00,F
0556C:  MOVF   x88,W
0556E:  MULWF  x89
05570:  MOVF   FF3,W
05572:  ADDWFC 00,W
05574:  MOVWF  02
05576:  BTFSS  x8C.7
05578:  BRA    5584
0557A:  COMF   01,F
0557C:  COMF   02,F
0557E:  INCF   01,F
05580:  BTFSC  FD8.2
05582:  INCF   02,F
05584:  MOVLB  0
05586:  RETURN 0
*
06300:  TBLRD*+
06302:  MOVFF  FF6,348
06306:  MOVFF  FF7,349
0630A:  MOVFF  FF8,34A
0630E:  MOVFF  FF5,365
06312:  RCALL  62F2
06314:  MOVFF  348,FF6
06318:  MOVFF  349,FF7
0631C:  MOVFF  34A,FF8
06320:  MOVLB  3
06322:  DECFSZ x47,F
06324:  BRA    6328
06326:  BRA    632C
06328:  MOVLB  0
0632A:  BRA    6300
0632C:  MOVLB  0
0632E:  GOTO   6C3C (RETURN)
06332:  MOVFF  FEA,34F
06336:  MOVFF  FE9,34E
0633A:  MOVLB  3
0633C:  SWAPF  x48,W
0633E:  IORLW  F0
06340:  MOVWF  x4A
06342:  ADDWF  x4A,F
06344:  ADDLW  E2
06346:  MOVWF  x4B
06348:  ADDLW  32
0634A:  MOVWF  x4D
0634C:  MOVF   x48,W
0634E:  ANDLW  0F
06350:  ADDWF  x4B,F
06352:  ADDWF  x4B,F
06354:  ADDWF  x4D,F
06356:  ADDLW  E9
06358:  MOVWF  x4C
0635A:  ADDWF  x4C,F
0635C:  ADDWF  x4C,F
0635E:  SWAPF  x47,W
06360:  ANDLW  0F
06362:  ADDWF  x4C,F
06364:  ADDWF  x4D,F
06366:  RLCF   x4C,F
06368:  RLCF   x4D,F
0636A:  COMF   x4D,F
0636C:  RLCF   x4D,F
0636E:  MOVF   x47,W
06370:  ANDLW  0F
06372:  ADDWF  x4D,F
06374:  RLCF   x4A,F
06376:  MOVLW  07
06378:  MOVWF  x49
0637A:  MOVLW  0A
0637C:  DECF   x4C,F
0637E:  ADDWF  x4D,F
06380:  BNC   637C
06382:  DECF   x4B,F
06384:  ADDWF  x4C,F
06386:  BNC   6382
06388:  DECF   x4A,F
0638A:  ADDWF  x4B,F
0638C:  BNC   6388
0638E:  DECF   x49,F
06390:  ADDWF  x4A,F
06392:  BNC   638E
06394:  MOVLW  03
06396:  MOVWF  FEA
06398:  MOVLW  49
0639A:  MOVWF  FE9
0639C:  MOVLW  07
0639E:  ANDWF  x4E,W
063A0:  BCF    x4E.6
063A2:  ADDWF  FE9,F
063A4:  MOVLW  00
063A6:  ADDWFC FEA,F
063A8:  MOVF   FE9,W
063AA:  SUBLW  4D
063AC:  BNZ   63B6
063AE:  MOVF   FEA,W
063B0:  SUBLW  03
063B2:  BNZ   63B6
063B4:  BSF    x4E.6
063B6:  MOVF   FEF,W
063B8:  MOVWF  00
063BA:  BNZ   63CC
063BC:  BTFSC  x4E.6
063BE:  BRA    63CC
063C0:  BTFSC  x4E.4
063C2:  BRA    63EE
063C4:  BTFSC  x4E.3
063C6:  BRA    63CC
063C8:  MOVLW  20
063CA:  BRA    63D2
063CC:  BSF    x4E.3
063CE:  BCF    x4E.4
063D0:  MOVLW  30
063D2:  ADDWF  00,F
063D4:  MOVFF  FEA,348
063D8:  MOVFF  FE9,347
063DC:  MOVFF  00,365
063E0:  MOVLB  0
063E2:  RCALL  62F2
063E4:  MOVFF  348,FEA
063E8:  MOVFF  347,FE9
063EC:  MOVLB  3
063EE:  MOVF   FEE,W
063F0:  BTFSS  x4E.6
063F2:  BRA    63A8
063F4:  MOVLB  0
063F6:  GOTO   6C4C (RETURN)
063FA:  TBLRD*+
063FC:  MOVF   FF5,F
063FE:  BZ    6420
06400:  MOVFF  FF6,347
06404:  MOVFF  FF7,348
06408:  MOVFF  FF8,349
0640C:  MOVFF  FF5,365
06410:  RCALL  62F2
06412:  MOVFF  347,FF6
06416:  MOVFF  348,FF7
0641A:  MOVFF  349,FF8
0641E:  BRA    63FA
06420:  RETURN 0
06422:  MOVF   FEF,F
06424:  BZ    6444
06426:  MOVFF  FEA,348
0642A:  MOVFF  FE9,347
0642E:  MOVFF  FEF,365
06432:  RCALL  62F2
06434:  MOVFF  348,FEA
06438:  MOVFF  347,FE9
0643C:  INCF   FE9,F
0643E:  BTFSC  FD8.2
06440:  INCF   FEA,F
06442:  BRA    6422
06444:  GOTO   6D12 (RETURN)
*
06602:  MOVFF  36A,01
06606:  MOVFF  369,00
0660A:  TSTFSZ 00
0660C:  INCF   01,F
0660E:  TBLRD*+
06610:  MOVFF  FF5,FEE
06614:  DECFSZ 00,F
06616:  BRA    660E
06618:  DECFSZ 01,F
0661A:  BRA    660E
0661C:  CLRF   FF8
0661E:  RETURN 0
*
06894:  MOVLB  3
06896:  MOVF   x90,W
06898:  CLRF   01
0689A:  SUBWF  x8F,W
0689C:  BC    68A4
0689E:  MOVFF  38F,00
068A2:  BRA    68BC
068A4:  CLRF   00
068A6:  MOVLW  08
068A8:  MOVWF  x91
068AA:  RLCF   x8F,F
068AC:  RLCF   00,F
068AE:  MOVF   x90,W
068B0:  SUBWF  00,W
068B2:  BTFSC  FD8.0
068B4:  MOVWF  00
068B6:  RLCF   01,F
068B8:  DECFSZ x91,F
068BA:  BRA    68AA
068BC:  MOVLB  0
068BE:  RETURN 0
068C0:  MOVFF  328,FEA
068C4:  MOVFF  327,FE9
068C8:  MOVLB  3
068CA:  MOVFF  38F,FEF
068CE:  INCF   FE9,F
068D0:  BTFSC  FD8.2
068D2:  INCF   FEA,F
068D4:  CLRF   FEF
068D6:  INCF   x27,F
068D8:  BTFSC  FD8.2
068DA:  INCF   x28,F
068DC:  MOVLB  0
068DE:  RETURN 0
068E0:  MOVF   01,W
068E2:  MOVFF  38D,38F
068E6:  MOVLW  64
068E8:  MOVLB  3
068EA:  MOVWF  x90
068EC:  MOVLB  0
068EE:  RCALL  6894
068F0:  MOVFF  00,38D
068F4:  MOVF   01,W
068F6:  MOVLW  30
068F8:  BNZ   690A
068FA:  MOVLB  3
068FC:  BTFSS  x8E.1
068FE:  BRA    691E
06900:  BTFSC  x8E.3
06902:  BRA    691E
06904:  BTFSC  x8E.4
06906:  MOVLW  20
06908:  BRA    6912
0690A:  MOVLB  3
0690C:  BCF    x8E.3
0690E:  BCF    x8E.4
06910:  BSF    x8E.0
06912:  ADDWF  01,F
06914:  MOVFF  01,38F
06918:  MOVLB  0
0691A:  RCALL  68C0
0691C:  MOVLB  3
0691E:  MOVFF  38D,38F
06922:  MOVLW  0A
06924:  MOVWF  x90
06926:  MOVLB  0
06928:  RCALL  6894
0692A:  MOVFF  00,38D
0692E:  MOVF   01,W
06930:  MOVLW  30
06932:  BNZ   6944
06934:  MOVLB  3
06936:  BTFSC  x8E.3
06938:  BRA    694E
0693A:  BTFSS  x8E.0
0693C:  BRA    694E
0693E:  BTFSC  x8E.4
06940:  MOVLW  20
06942:  MOVLB  0
06944:  ADDWF  01,F
06946:  MOVFF  01,38F
0694A:  RCALL  68C0
0694C:  MOVLB  3
0694E:  MOVLW  30
06950:  ADDWF  x8D,F
06952:  MOVFF  38D,38F
06956:  MOVLB  0
06958:  RCALL  68C0
0695A:  RETURN 0
*
07E90:  MOVFF  FF2,0D
07E94:  BCF    FF2.6
07E96:  BCF    FF2.7
07E98:  ADDWF  FE8,W
07E9A:  CLRF   FF7
07E9C:  RLCF   FF7,F
07E9E:  ADDLW  C1
07EA0:  MOVWF  FF6
07EA2:  MOVLW  7E
07EA4:  ADDWFC FF7,F
07EA6:  MOVLW  00
07EA8:  MOVWF  FF8
07EAA:  MOVWF  FFB
07EAC:  TBLRD*-
07EAE:  MOVF   FF5,W
07EB0:  MOVWF  FFA
07EB2:  TBLRD*
07EB4:  MOVF   FF5,W
07EB6:  BTFSC  0D.6
07EB8:  BSF    FF2.6
07EBA:  BTFSC  0D.7
07EBC:  BSF    FF2.7
07EBE:  MOVWF  FF9
07EC0:  DATA D6,7C
07EC2:  DATA D6,7C
07EC4:  DATA 36,7D
07EC6:  DATA CC,7D
07EC8:  DATA 32,7E
07ECA:  DATA 24,7D
07ECC:  DATA 9E,7D
....................  
.................... #list 
....................  
.................... #device adc=10 
.................... #device HIGH_INTS=TRUE //Activamos niveles de prioridad 
.................... #fuses HS,WDT4096,NOPROTECT,NOLVP,NODEBUG,NOSTVREN,PUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOLPT1OSC,NOMCLR,NOBROWNOUT,BORV43 
.................... #use delay(clock=20000000) 
*
01A22:  MOVLW  03
01A24:  MOVWF  FEA
01A26:  MOVLW  2A
01A28:  MOVWF  FE9
01A2A:  MOVF   FEF,W
01A2C:  BZ    1A48
01A2E:  MOVLW  06
01A30:  MOVWF  01
01A32:  CLRF   00
01A34:  DECFSZ 00,F
01A36:  BRA    1A34
01A38:  DECFSZ 01,F
01A3A:  BRA    1A32
01A3C:  MOVLW  7B
01A3E:  MOVWF  00
01A40:  DECFSZ 00,F
01A42:  BRA    1A40
01A44:  DECFSZ FEF,F
01A46:  BRA    1A2E
01A48:  RETURN 0
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits=8, parity=N,BRGH1OK,ERRORS) 
*
019A4:  BTFSS  F9E.5
019A6:  BRA    19A4
019A8:  MOVFF  FAB,17
019AC:  MOVFF  FAE,01
019B0:  BTFSS  17.1
019B2:  BRA    19B8
019B4:  BCF    FAB.4
019B6:  BSF    FAB.4
019B8:  GOTO   19BE (RETURN)
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
*
0592E:  MOVFF  357,35C
05932:  MOVFF  356,35B
....................    sc2=s2; 
05936:  MOVFF  359,35E
0593A:  MOVFF  358,35D
....................    if(sc2<sc1 && sc1 <sc2 +n) 
0593E:  MOVLB  3
05940:  MOVF   x5E,W
05942:  SUBWF  x5C,W
05944:  BNC   59B8
05946:  BNZ   594E
05948:  MOVF   x5B,W
0594A:  SUBWF  x5D,W
0594C:  BC    59B8
0594E:  MOVF   x5A,W
05950:  ADDWF  x5D,W
05952:  MOVWF  01
05954:  MOVLW  00
05956:  ADDWFC x5E,W
05958:  MOVWF  03
0595A:  MOVF   x5C,W
0595C:  SUBWF  03,W
0595E:  BNC   59B8
05960:  BNZ   5968
05962:  MOVF   01,W
05964:  SUBWF  x5B,W
05966:  BC    59B8
....................       for(sc1+=n,sc2+=n;0<n;--n) 
05968:  MOVF   x5A,W
0596A:  ADDWF  x5B,F
0596C:  MOVLW  00
0596E:  ADDWFC x5C,F
05970:  MOVF   x5A,W
05972:  ADDWF  x5D,F
05974:  MOVLW  00
05976:  ADDWFC x5E,F
05978:  MOVF   x5A,W
0597A:  SUBLW  00
0597C:  BC    59B6
....................          *--sc1=*--sc2; 
0597E:  MOVF   x5B,W
05980:  BTFSC  FD8.2
05982:  DECF   x5C,F
05984:  DECF   x5B,F
05986:  MOVFF  35B,35F
0598A:  MOVFF  35C,360
0598E:  MOVF   x5D,W
05990:  BTFSC  FD8.2
05992:  DECF   x5E,F
05994:  DECF   x5D,F
05996:  MOVFF  35E,03
0599A:  MOVFF  35D,FE9
0599E:  MOVFF  35E,FEA
059A2:  MOVFF  FEF,361
059A6:  MOVFF  35C,FEA
059AA:  MOVFF  35B,FE9
059AE:  MOVFF  361,FEF
059B2:  DECF   x5A,F
059B4:  BRA    5978
059B6:  BRA    59F6
....................    else 
....................       for(;0<n;--n) 
059B8:  MOVF   x5A,W
059BA:  SUBLW  00
059BC:  BC    59F6
....................          *sc1++=*sc2++; 
059BE:  MOVFF  35C,03
059C2:  MOVF   x5B,W
059C4:  INCF   x5B,F
059C6:  BTFSC  FD8.2
059C8:  INCF   x5C,F
059CA:  MOVWF  x5F
059CC:  MOVFF  03,360
059D0:  MOVFF  35E,03
059D4:  MOVF   x5D,W
059D6:  INCF   x5D,F
059D8:  BTFSC  FD8.2
059DA:  INCF   x5E,F
059DC:  MOVWF  FE9
059DE:  MOVFF  03,FEA
059E2:  MOVFF  FEF,361
059E6:  MOVFF  360,FEA
059EA:  MOVFF  35F,FE9
059EE:  MOVFF  361,FEF
059F2:  DECF   x5A,F
059F4:  BRA    59B8
....................   return s1; 
059F6:  MOVFF  356,01
059FA:  MOVFF  357,02
059FE:  MOVLB  0
05A00:  GOTO   5AD6 (RETURN)
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0695C:  MOVFF  38E,393
06960:  MOVFF  38D,392
06964:  MOVLB  3
06966:  MOVF   x91,F
06968:  BZ    69B2
0696A:  MOVFF  390,03
0696E:  MOVFF  38F,FE9
06972:  MOVFF  390,FEA
06976:  MOVF   FEF,F
06978:  BZ    69B2
....................      *s++ = *s2++; 
0697A:  MOVFF  393,03
0697E:  MOVF   x92,W
06980:  INCF   x92,F
06982:  BTFSC  FD8.2
06984:  INCF   x93,F
06986:  MOVWF  x94
06988:  MOVFF  03,395
0698C:  MOVFF  390,03
06990:  MOVF   x8F,W
06992:  INCF   x8F,F
06994:  BTFSC  FD8.2
06996:  INCF   x90,F
06998:  MOVWF  FE9
0699A:  MOVFF  03,FEA
0699E:  MOVFF  FEF,396
069A2:  MOVFF  395,FEA
069A6:  MOVFF  394,FE9
069AA:  MOVFF  396,FEF
069AE:  DECF   x91,F
069B0:  BRA    6966
....................   for (; n > 0; n--) 
069B2:  MOVF   x91,F
069B4:  BZ    69CE
....................      *s++ = '\0'; 
069B6:  MOVFF  393,03
069BA:  MOVF   x92,W
069BC:  INCF   x92,F
069BE:  BTFSC  FD8.2
069C0:  INCF   x93,F
069C2:  MOVWF  FE9
069C4:  MOVFF  03,FEA
069C8:  CLRF   FEF
069CA:  DECF   x91,F
069CC:  BRA    69B2
....................  
....................   return(s1); 
069CE:  MOVFF  38D,01
069D2:  MOVFF  38E,02
069D6:  MOVLB  0
069D8:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
05478:  MOVLB  3
0547A:  MOVFF  337,FE9
0547E:  MOVFF  338,FEA
05482:  MOVFF  FEF,33B
05486:  MOVFF  33A,03
0548A:  MOVFF  339,FE9
0548E:  MOVFF  33A,FEA
05492:  MOVF   FEF,W
05494:  SUBWF  x3B,W
05496:  BNZ   54C2
....................       if (*s1 == '\0') 
05498:  MOVFF  338,03
0549C:  MOVFF  337,FE9
054A0:  MOVFF  03,FEA
054A4:  MOVF   FEF,F
054A6:  BNZ   54AE
....................          return(0); 
054A8:  MOVLW  00
054AA:  MOVWF  01
054AC:  BRA    54EC
054AE:  MOVFF  338,03
054B2:  MOVF   x37,W
054B4:  INCF   x37,F
054B6:  BTFSC  FD8.2
054B8:  INCF   x38,F
054BA:  INCF   x39,F
054BC:  BTFSC  FD8.2
054BE:  INCF   x3A,F
054C0:  BRA    547A
....................    return((*s1 < *s2) ? -1: 1); 
054C2:  MOVFF  338,03
054C6:  MOVFF  337,FE9
054CA:  MOVFF  338,FEA
054CE:  MOVFF  FEF,33B
054D2:  MOVFF  33A,03
054D6:  MOVFF  339,FE9
054DA:  MOVFF  33A,FEA
054DE:  MOVF   FEF,W
054E0:  SUBWF  x3B,W
054E2:  BC    54E8
054E4:  MOVLW  FF
054E6:  BRA    54EA
054E8:  MOVLW  01
054EA:  MOVWF  01
054EC:  MOVLB  0
054EE:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
054F0:  MOVFF  388,38A
....................    for(su=s;0<n;++su,--n) 
054F4:  MOVFF  387,38C
054F8:  MOVFF  386,38B
054FC:  MOVLB  3
054FE:  MOVF   x89,W
05500:  SUBLW  00
05502:  BC    552A
....................       if(*su==uc) 
05504:  MOVFF  38C,03
05508:  MOVFF  38B,FE9
0550C:  MOVFF  38C,FEA
05510:  MOVF   x8A,W
05512:  SUBWF  FEF,W
05514:  BNZ   5520
....................       return su; 
05516:  MOVFF  38B,01
0551A:  MOVFF  38C,02
0551E:  BRA    5530
05520:  INCF   x8B,F
05522:  BTFSC  FD8.2
05524:  INCF   x8C,F
05526:  DECF   x89,F
05528:  BRA    54FE
....................    return NULL; 
0552A:  MOVLW  00
0552C:  MOVWF  01
0552E:  MOVWF  02
05530:  MOVLB  0
05532:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0534E:  MOVFF  344,348
05352:  MOVFF  343,347
05356:  MOVFF  348,03
0535A:  MOVLB  3
0535C:  MOVFF  347,FE9
05360:  MOVFF  348,FEA
05364:  MOVF   FEF,F
05366:  BZ    53BC
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
05368:  MOVFF  346,34A
0536C:  MOVFF  345,349
05370:  MOVFF  34A,03
05374:  MOVFF  349,FE9
05378:  MOVFF  34A,FEA
0537C:  MOVF   FEF,F
0537E:  BZ    53B0
....................          if (*sc1 == *sc2) 
05380:  MOVFF  347,FE9
05384:  MOVFF  348,FEA
05388:  MOVFF  FEF,34B
0538C:  MOVFF  34A,03
05390:  MOVFF  349,FE9
05394:  MOVFF  34A,FEA
05398:  MOVF   FEF,W
0539A:  SUBWF  x4B,W
0539C:  BNZ   53A8
....................             return(sc1); 
0539E:  MOVFF  347,01
053A2:  MOVFF  348,02
053A6:  BRA    53C2
053A8:  INCF   x49,F
053AA:  BTFSC  FD8.2
053AC:  INCF   x4A,F
053AE:  BRA    5370
053B0:  INCF   x47,F
053B2:  BTFSC  FD8.2
053B4:  INCF   x48,F
053B6:  MOVLB  0
053B8:  BRA    5356
053BA:  MOVLB  3
....................    return(0); 
053BC:  MOVLW  00
053BE:  MOVWF  01
053C0:  MOVWF  02
053C2:  MOVLB  0
053C4:  GOTO   543A (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
052BE:  MOVFF  344,348
052C2:  MOVFF  343,347
052C6:  MOVFF  348,03
052CA:  MOVLB  3
052CC:  MOVFF  347,FE9
052D0:  MOVFF  348,FEA
052D4:  MOVF   FEF,F
052D6:  BZ    5338
....................       for (sc2 = s2; ; sc2++) 
052D8:  MOVFF  346,34A
052DC:  MOVFF  345,349
....................     if (*sc2 == '\0') 
052E0:  MOVFF  34A,03
052E4:  MOVFF  349,FE9
052E8:  MOVFF  34A,FEA
052EC:  MOVF   FEF,F
052EE:  BNZ   5304
....................        return(sc1 - s1); 
052F0:  MOVF   x43,W
052F2:  SUBWF  x47,W
052F4:  MOVWF  00
052F6:  MOVF   x44,W
052F8:  SUBWFB x48,W
052FA:  MOVWF  03
052FC:  MOVFF  00,01
05300:  BRA    5348
05302:  BRA    5324
....................          else if (*sc1 == *sc2) 
05304:  MOVFF  347,FE9
05308:  MOVFF  348,FEA
0530C:  MOVFF  FEF,34B
05310:  MOVFF  34A,03
05314:  MOVFF  349,FE9
05318:  MOVFF  34A,FEA
0531C:  MOVF   FEF,W
0531E:  SUBWF  x4B,W
05320:  BNZ   5324
....................             break; 
05322:  BRA    532C
05324:  INCF   x49,F
05326:  BTFSC  FD8.2
05328:  INCF   x4A,F
0532A:  BRA    52E0
0532C:  INCF   x47,F
0532E:  BTFSC  FD8.2
05330:  INCF   x48,F
05332:  MOVLB  0
05334:  BRA    52C6
05336:  MOVLB  3
....................    return(sc1 - s1); 
05338:  MOVF   x43,W
0533A:  SUBWF  x47,W
0533C:  MOVWF  00
0533E:  MOVF   x44,W
05340:  SUBWFB x48,W
05342:  MOVWF  03
05344:  MOVFF  00,01
05348:  MOVLB  0
0534A:  GOTO   53F8 (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
053C8:  MOVLB  3
053CA:  MOVF   x3B,W
053CC:  IORWF  x3C,W
053CE:  BZ    53D8
053D0:  MOVFF  33C,03
053D4:  MOVF   x3B,W
053D6:  BRA    53DE
053D8:  MOVFF  19,03
053DC:  MOVF   18,W
053DE:  MOVWF  x3F
053E0:  MOVFF  03,340
....................    beg += strspn(beg, s2); 
053E4:  MOVFF  340,344
053E8:  MOVFF  33F,343
053EC:  MOVFF  33E,346
053F0:  MOVFF  33D,345
053F4:  MOVLB  0
053F6:  BRA    52BE
053F8:  MOVF   01,W
053FA:  MOVLB  3
053FC:  ADDWF  x3F,F
053FE:  MOVLW  00
05400:  ADDWFC x40,F
....................    if (*beg == '\0') 
05402:  MOVFF  340,03
05406:  MOVFF  33F,FE9
0540A:  MOVFF  340,FEA
0540E:  MOVF   FEF,F
05410:  BNZ   5426
....................    { 
....................       *save = ' '; 
05412:  MOVFF  18,FE9
05416:  MOVFF  19,FEA
0541A:  MOVLW  20
0541C:  MOVWF  FEF
....................       return(0); 
0541E:  MOVLW  00
05420:  MOVWF  01
05422:  MOVWF  02
05424:  BRA    5474
....................    } 
....................    end = strpbrk(beg, s2); 
05426:  MOVFF  340,344
0542A:  MOVFF  33F,343
0542E:  MOVFF  33E,346
05432:  MOVFF  33D,345
05436:  MOVLB  0
05438:  BRA    534E
0543A:  MOVFF  02,342
0543E:  MOVFF  01,341
....................    if (*end != '\0') 
05442:  MOVFF  342,03
05446:  MOVLB  3
05448:  MOVFF  341,FE9
0544C:  MOVFF  342,FEA
05450:  MOVF   FEF,F
05452:  BZ    5464
....................    { 
....................       *end = '\0'; 
05454:  MOVFF  341,FE9
05458:  MOVFF  342,FEA
0545C:  CLRF   FEF
....................       end++; 
0545E:  INCF   x41,F
05460:  BTFSC  FD8.2
05462:  INCF   x42,F
....................    } 
....................    save = end; 
05464:  MOVFF  342,19
05468:  MOVFF  341,18
....................    return(beg); 
0546C:  MOVFF  33F,01
05470:  MOVFF  340,02
05474:  MOVLB  0
05476:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
058F4:  MOVFF  38E,390
058F8:  MOVFF  38D,38F
058FC:  MOVFF  390,03
05900:  MOVLB  3
05902:  MOVFF  38F,FE9
05906:  MOVFF  390,FEA
0590A:  MOVF   FEF,F
0590C:  BZ    591A
0590E:  INCF   x8F,F
05910:  BTFSC  FD8.2
05912:  INCF   x90,F
05914:  MOVLB  0
05916:  BRA    58FC
05918:  MOVLB  3
....................    return(sc - s); 
0591A:  MOVF   x8D,W
0591C:  SUBWF  x8F,W
0591E:  MOVWF  00
05920:  MOVF   x8E,W
05922:  SUBWFB x90,W
05924:  MOVWF  03
05926:  MOVFF  00,01
0592A:  MOVLB  0
0592C:  RETURN 0
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
05AF0:  MOVLB  3
05AF2:  MOVFF  33F,FE9
05AF6:  MOVFF  340,FEA
05AFA:  MOVFF  FEF,343
05AFE:  MOVFF  342,03
05B02:  MOVFF  341,FE9
05B06:  MOVFF  342,FEA
05B0A:  MOVF   FEF,W
05B0C:  SUBWF  x43,W
05B0E:  BZ    5BA0
05B10:  MOVFF  340,03
05B14:  MOVFF  33F,FE9
05B18:  MOVFF  340,FEA
05B1C:  MOVFF  FEF,343
05B20:  MOVF   x43,W
05B22:  SUBLW  40
05B24:  BC    5B2C
05B26:  MOVF   x43,W
05B28:  SUBLW  5A
05B2A:  BC    5B38
05B2C:  MOVF   x43,W
05B2E:  SUBLW  60
05B30:  BC    5BCA
05B32:  MOVF   x43,W
05B34:  SUBLW  7A
05B36:  BNC   5BCA
05B38:  MOVFF  342,03
05B3C:  MOVFF  341,FE9
05B40:  MOVFF  342,FEA
05B44:  MOVFF  FEF,343
05B48:  MOVF   x43,W
05B4A:  SUBLW  40
05B4C:  BC    5B54
05B4E:  MOVF   x43,W
05B50:  SUBLW  5A
05B52:  BC    5B60
05B54:  MOVF   x43,W
05B56:  SUBLW  60
05B58:  BC    5BCA
05B5A:  MOVF   x43,W
05B5C:  SUBLW  7A
05B5E:  BNC   5BCA
05B60:  MOVFF  33F,FE9
05B64:  MOVFF  340,FEA
05B68:  MOVFF  FEF,343
05B6C:  MOVFF  342,03
05B70:  MOVFF  341,FE9
05B74:  MOVFF  342,FEA
05B78:  MOVLW  20
05B7A:  ADDWF  FEF,W
05B7C:  SUBWF  x43,W
05B7E:  BZ    5BA0
05B80:  MOVFF  341,FE9
05B84:  MOVFF  342,FEA
05B88:  MOVFF  FEF,343
05B8C:  MOVFF  340,03
05B90:  MOVFF  33F,FE9
05B94:  MOVFF  340,FEA
05B98:  MOVLW  20
05B9A:  ADDWF  FEF,W
05B9C:  SUBWF  x43,W
05B9E:  BNZ   5BCA
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
05BA0:  MOVFF  340,03
05BA4:  MOVFF  33F,FE9
05BA8:  MOVFF  340,FEA
05BAC:  MOVF   FEF,F
05BAE:  BNZ   5BB6
....................        return(0); 
05BB0:  MOVLW  00
05BB2:  MOVWF  01
05BB4:  BRA    5BF4
05BB6:  MOVFF  340,03
05BBA:  MOVF   x3F,W
05BBC:  INCF   x3F,F
05BBE:  BTFSC  FD8.2
05BC0:  INCF   x40,F
05BC2:  INCF   x41,F
05BC4:  BTFSC  FD8.2
05BC6:  INCF   x42,F
05BC8:  BRA    5AF2
....................  return((*s1 < *s2) ? -1: 1); 
05BCA:  MOVFF  340,03
05BCE:  MOVFF  33F,FE9
05BD2:  MOVFF  340,FEA
05BD6:  MOVFF  FEF,343
05BDA:  MOVFF  342,03
05BDE:  MOVFF  341,FE9
05BE2:  MOVFF  342,FEA
05BE6:  MOVF   FEF,W
05BE8:  SUBWF  x43,W
05BEA:  BC    5BF0
05BEC:  MOVLW  FF
05BEE:  BRA    5BF2
05BF0:  MOVLW  01
05BF2:  MOVWF  01
05BF4:  MOVLB  0
05BF6:  GOTO   5C18 (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
05CF8:  MOVLB  3
05CFA:  CLRF   x3F
....................    sign = 0; 
05CFC:  CLRF   x3D
....................    base = 10; 
05CFE:  MOVLW  0A
05D00:  MOVWF  x3E
....................    result = 0; 
05D02:  CLRF   x3C
05D04:  CLRF   x3B
....................  
....................    if (!s) 
05D06:  MOVF   x39,W
05D08:  IORWF  x3A,W
05D0A:  BNZ   5D14
....................       return 0; 
05D0C:  MOVLW  00
05D0E:  MOVWF  01
05D10:  MOVWF  02
05D12:  BRA    5EEA
....................    c = s[index++]; 
05D14:  MOVF   x3F,W
05D16:  INCF   x3F,F
05D18:  CLRF   03
05D1A:  ADDWF  x39,W
05D1C:  MOVWF  FE9
05D1E:  MOVF   x3A,W
05D20:  ADDWFC 03,W
05D22:  MOVWF  FEA
05D24:  MOVFF  FEF,340
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
05D28:  MOVF   x40,W
05D2A:  SUBLW  2D
05D2C:  BNZ   5D48
....................    { 
....................       sign = 1;         // Set the sign to negative 
05D2E:  MOVLW  01
05D30:  MOVWF  x3D
....................       c = s[index++]; 
05D32:  MOVF   x3F,W
05D34:  INCF   x3F,F
05D36:  CLRF   03
05D38:  ADDWF  x39,W
05D3A:  MOVWF  FE9
05D3C:  MOVF   x3A,W
05D3E:  ADDWFC 03,W
05D40:  MOVWF  FEA
05D42:  MOVFF  FEF,340
....................    } 
05D46:  BRA    5D62
....................    else if (c == '+') 
05D48:  MOVF   x40,W
05D4A:  SUBLW  2B
05D4C:  BNZ   5D62
....................    { 
....................       c = s[index++]; 
05D4E:  MOVF   x3F,W
05D50:  INCF   x3F,F
05D52:  CLRF   03
05D54:  ADDWF  x39,W
05D56:  MOVWF  FE9
05D58:  MOVF   x3A,W
05D5A:  ADDWFC 03,W
05D5C:  MOVWF  FEA
05D5E:  MOVFF  FEF,340
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
05D62:  MOVF   x40,W
05D64:  SUBLW  2F
05D66:  BTFSC  FD8.0
05D68:  BRA    5ECE
05D6A:  MOVF   x40,W
05D6C:  SUBLW  39
05D6E:  BTFSS  FD8.0
05D70:  BRA    5ECE
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
05D72:  MOVF   x40,W
05D74:  SUBLW  30
05D76:  BNZ   5DBA
05D78:  CLRF   03
05D7A:  MOVF   x3F,W
05D7C:  ADDWF  x39,W
05D7E:  MOVWF  FE9
05D80:  MOVF   x3A,W
05D82:  ADDWFC 03,W
05D84:  MOVWF  FEA
05D86:  MOVF   FEF,W
05D88:  SUBLW  78
05D8A:  BZ    5DA0
05D8C:  CLRF   03
05D8E:  MOVF   x3F,W
05D90:  ADDWF  x39,W
05D92:  MOVWF  FE9
05D94:  MOVF   x3A,W
05D96:  ADDWFC 03,W
05D98:  MOVWF  FEA
05D9A:  MOVF   FEF,W
05D9C:  SUBLW  58
05D9E:  BNZ   5DBA
....................       { 
....................          base = 16; 
05DA0:  MOVLW  10
05DA2:  MOVWF  x3E
....................          index++; 
05DA4:  INCF   x3F,F
....................          c = s[index++]; 
05DA6:  MOVF   x3F,W
05DA8:  INCF   x3F,F
05DAA:  CLRF   03
05DAC:  ADDWF  x39,W
05DAE:  MOVWF  FE9
05DB0:  MOVF   x3A,W
05DB2:  ADDWFC 03,W
05DB4:  MOVWF  FEA
05DB6:  MOVFF  FEF,340
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
05DBA:  MOVF   x3E,W
05DBC:  SUBLW  0A
05DBE:  BNZ   5E08
....................       { 
....................          while (c >= '0' && c <= '9') 
05DC0:  MOVF   x40,W
05DC2:  SUBLW  2F
05DC4:  BC    5E06
05DC6:  MOVF   x40,W
05DC8:  SUBLW  39
05DCA:  BNC   5E06
....................          { 
....................             result = 10*result + (c - '0'); 
05DCC:  CLRF   x88
05DCE:  MOVLW  0A
05DD0:  MOVWF  x87
05DD2:  MOVFF  33C,38A
05DD6:  MOVFF  33B,389
05DDA:  MOVLB  0
05DDC:  CALL   5534
05DE0:  MOVLW  30
05DE2:  MOVLB  3
05DE4:  SUBWF  x40,W
05DE6:  ADDWF  01,W
05DE8:  MOVWF  x3B
05DEA:  MOVLW  00
05DEC:  ADDWFC 02,W
05DEE:  MOVWF  x3C
....................             c = s[index++]; 
05DF0:  MOVF   x3F,W
05DF2:  INCF   x3F,F
05DF4:  CLRF   03
05DF6:  ADDWF  x39,W
05DF8:  MOVWF  FE9
05DFA:  MOVF   x3A,W
05DFC:  ADDWFC 03,W
05DFE:  MOVWF  FEA
05E00:  MOVFF  FEF,340
05E04:  BRA    5DC0
....................          } 
....................       } 
05E06:  BRA    5ECE
....................       else if (base == 16)    // The number is a hexa number 
05E08:  MOVF   x3E,W
05E0A:  SUBLW  10
05E0C:  BNZ   5ECE
....................       { 
....................          c = toupper(c); 
05E0E:  MOVF   x40,W
05E10:  SUBLW  60
05E12:  BC    5E20
05E14:  MOVF   x40,W
05E16:  SUBLW  7A
05E18:  BNC   5E20
05E1A:  MOVF   x40,W
05E1C:  ANDLW  DF
05E1E:  BRA    5E22
05E20:  MOVF   x40,W
05E22:  MOVWF  x40
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
05E24:  MOVF   x40,W
05E26:  SUBLW  2F
05E28:  BC    5E30
05E2A:  MOVF   x40,W
05E2C:  SUBLW  39
05E2E:  BC    5E3C
05E30:  MOVF   x40,W
05E32:  SUBLW  40
05E34:  BC    5ECE
05E36:  MOVF   x40,W
05E38:  SUBLW  46
05E3A:  BNC   5ECE
....................          { 
....................             if (c >= '0' && c <= '9') 
05E3C:  MOVF   x40,W
05E3E:  SUBLW  2F
05E40:  BC    5E76
05E42:  MOVF   x40,W
05E44:  SUBLW  39
05E46:  BNC   5E76
....................                result = (result << 4) + (c - '0'); 
05E48:  RLCF   x3B,W
05E4A:  MOVWF  x41
05E4C:  RLCF   x3C,W
05E4E:  MOVWF  x42
05E50:  RLCF   x41,F
05E52:  RLCF   x42,F
05E54:  RLCF   x41,F
05E56:  RLCF   x42,F
05E58:  RLCF   x41,F
05E5A:  RLCF   x42,F
05E5C:  MOVLW  F0
05E5E:  ANDWF  x41,F
05E60:  MOVLW  30
05E62:  SUBWF  x40,W
05E64:  ADDWF  x41,W
05E66:  MOVWF  01
05E68:  MOVLW  00
05E6A:  ADDWFC x42,W
05E6C:  MOVWF  03
05E6E:  MOVFF  01,33B
05E72:  MOVWF  x3C
05E74:  BRA    5EA2
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
05E76:  RLCF   x3B,W
05E78:  MOVWF  x41
05E7A:  RLCF   x3C,W
05E7C:  MOVWF  x42
05E7E:  RLCF   x41,F
05E80:  RLCF   x42,F
05E82:  RLCF   x41,F
05E84:  RLCF   x42,F
05E86:  RLCF   x41,F
05E88:  RLCF   x42,F
05E8A:  MOVLW  F0
05E8C:  ANDWF  x41,F
05E8E:  MOVLW  41
05E90:  SUBWF  x40,W
05E92:  ADDLW  0A
05E94:  ADDWF  x41,W
05E96:  MOVWF  01
05E98:  MOVLW  00
05E9A:  ADDWFC x42,W
05E9C:  MOVFF  01,33B
05EA0:  MOVWF  x3C
....................  
....................             c = s[index++];c = toupper(c); 
05EA2:  MOVF   x3F,W
05EA4:  INCF   x3F,F
05EA6:  CLRF   03
05EA8:  ADDWF  x39,W
05EAA:  MOVWF  FE9
05EAC:  MOVF   x3A,W
05EAE:  ADDWFC 03,W
05EB0:  MOVWF  FEA
05EB2:  MOVFF  FEF,340
05EB6:  MOVF   x40,W
05EB8:  SUBLW  60
05EBA:  BC    5EC8
05EBC:  MOVF   x40,W
05EBE:  SUBLW  7A
05EC0:  BNC   5EC8
05EC2:  MOVF   x40,W
05EC4:  ANDLW  DF
05EC6:  BRA    5ECA
05EC8:  MOVF   x40,W
05ECA:  MOVWF  x40
05ECC:  BRA    5E24
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
05ECE:  MOVF   x3E,W
05ED0:  SUBLW  0A
05ED2:  BNZ   5EE2
05ED4:  DECFSZ x3D,W
05ED6:  BRA    5EE2
....................       result = -result; 
05ED8:  COMF   x3B,F
05EDA:  COMF   x3C,F
05EDC:  INCF   x3B,F
05EDE:  BTFSC  FD8.2
05EE0:  INCF   x3C,F
....................  
....................    return(result); 
05EE2:  MOVFF  33B,01
05EE6:  MOVFF  33C,02
05EEA:  MOVLB  0
05EEC:  GOTO   74FE (RETURN)
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
05588:  MOVLB  3
0558A:  CLRF   x5F
0558C:  CLRF   x5E
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
0558E:  MOVLW  30
05590:  MOVWF  x61
05592:  MOVLW  31
05594:  MOVWF  x62
05596:  MOVLW  32
05598:  MOVWF  x63
0559A:  MOVLW  33
0559C:  MOVWF  x64
0559E:  MOVLW  34
055A0:  MOVWF  x65
055A2:  MOVLW  35
055A4:  MOVWF  x66
055A6:  MOVLW  36
055A8:  MOVWF  x67
055AA:  MOVLW  37
055AC:  MOVWF  x68
055AE:  MOVLW  38
055B0:  MOVWF  x69
055B2:  MOVLW  39
055B4:  MOVWF  x6A
055B6:  MOVLW  61
055B8:  MOVWF  x6B
055BA:  MOVLW  62
055BC:  MOVWF  x6C
055BE:  MOVLW  63
055C0:  MOVWF  x6D
055C2:  MOVLW  64
055C4:  MOVWF  x6E
055C6:  MOVLW  65
055C8:  MOVWF  x6F
055CA:  MOVLW  66
055CC:  MOVWF  x70
055CE:  MOVLW  67
055D0:  MOVWF  x71
055D2:  MOVLW  68
055D4:  MOVWF  x72
055D6:  MOVLW  69
055D8:  MOVWF  x73
055DA:  MOVLW  6A
055DC:  MOVWF  x74
055DE:  MOVLW  6B
055E0:  MOVWF  x75
055E2:  MOVLW  6C
055E4:  MOVWF  x76
055E6:  MOVLW  6D
055E8:  MOVWF  x77
055EA:  MOVLW  6E
055EC:  MOVWF  x78
055EE:  MOVLW  6F
055F0:  MOVWF  x79
055F2:  MOVLW  70
055F4:  MOVWF  x7A
055F6:  MOVLW  71
055F8:  MOVWF  x7B
055FA:  MOVLW  73
055FC:  MOVWF  x7C
055FE:  MOVLW  74
05600:  MOVWF  x7D
05602:  MOVLW  75
05604:  MOVWF  x7E
05606:  MOVLW  76
05608:  MOVWF  x7F
0560A:  MOVLW  77
0560C:  MOVWF  x80
0560E:  MOVLW  78
05610:  MOVWF  x81
05612:  MOVLW  79
05614:  MOVWF  x82
05616:  MOVLW  7A
05618:  MOVWF  x83
0561A:  CLRF   x84
....................    for(sc=s;isspace(*sc);++sc); 
0561C:  MOVFF  354,359
05620:  MOVFF  353,358
05624:  MOVFF  359,03
05628:  MOVFF  358,FE9
0562C:  MOVFF  359,FEA
05630:  MOVF   FEF,W
05632:  SUBLW  20
05634:  BNZ   563E
05636:  INCF   x58,F
05638:  BTFSC  FD8.2
0563A:  INCF   x59,F
0563C:  BRA    5624
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
0563E:  MOVFF  359,03
05642:  MOVFF  358,FE9
05646:  MOVFF  359,FEA
0564A:  MOVF   FEF,W
0564C:  SUBLW  2D
0564E:  BZ    5662
05650:  MOVFF  359,03
05654:  MOVFF  358,FE9
05658:  MOVFF  359,FEA
0565C:  MOVF   FEF,W
0565E:  SUBLW  2B
05660:  BNZ   5678
05662:  MOVFF  359,03
05666:  MOVF   x58,W
05668:  INCF   x58,F
0566A:  BTFSC  FD8.2
0566C:  INCF   x59,F
0566E:  MOVWF  FE9
05670:  MOVFF  03,FEA
05674:  MOVF   FEF,W
05676:  BRA    567A
05678:  MOVLW  2B
0567A:  MOVWF  x60
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
0567C:  MOVF   x60,W
0567E:  SUBLW  2D
05680:  BZ    5696
05682:  BTFSC  x57.7
05684:  BRA    5696
05686:  DECFSZ x57,W
05688:  BRA    568C
0568A:  BRA    5696
0568C:  BTFSC  x57.7
0568E:  BRA    569A
05690:  MOVF   x57,W
05692:  SUBLW  24
05694:  BC    569A
....................    goto StrtoulGO; 
05696:  BRA    58AE
05698:  BRA    57A2
....................  
....................    else if (base) 
0569A:  MOVF   x57,F
0569C:  BZ    5736
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
0569E:  MOVF   x57,W
056A0:  SUBLW  10
056A2:  BNZ   56E2
056A4:  MOVFF  359,03
056A8:  MOVFF  358,FE9
056AC:  MOVFF  359,FEA
056B0:  MOVF   FEF,W
056B2:  SUBLW  30
056B4:  BNZ   56E2
056B6:  MOVLW  01
056B8:  ADDWF  x58,W
056BA:  MOVWF  FE9
056BC:  MOVLW  00
056BE:  ADDWFC x59,W
056C0:  MOVWF  FEA
056C2:  MOVF   FEF,W
056C4:  SUBLW  78
056C6:  BZ    56DA
056C8:  MOVLW  01
056CA:  ADDWF  x58,W
056CC:  MOVWF  FE9
056CE:  MOVLW  00
056D0:  ADDWFC x59,W
056D2:  MOVWF  FEA
056D4:  MOVF   FEF,W
056D6:  SUBLW  58
056D8:  BNZ   56E2
....................          sc+=2; 
056DA:  MOVLW  02
056DC:  ADDWF  x58,F
056DE:  MOVLW  00
056E0:  ADDWFC x59,F
....................       if(base==8 && *sc =='0') 
056E2:  MOVF   x57,W
056E4:  SUBLW  08
056E6:  BNZ   5702
056E8:  MOVFF  359,03
056EC:  MOVFF  358,FE9
056F0:  MOVFF  359,FEA
056F4:  MOVF   FEF,W
056F6:  SUBLW  30
056F8:  BNZ   5702
....................          sc+=1; 
056FA:  MOVLW  01
056FC:  ADDWF  x58,F
056FE:  MOVLW  00
05700:  ADDWFC x59,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
05702:  MOVF   x57,W
05704:  SUBLW  02
05706:  BNZ   5734
05708:  MOVFF  359,03
0570C:  MOVFF  358,FE9
05710:  MOVFF  359,FEA
05714:  MOVF   FEF,W
05716:  SUBLW  30
05718:  BNZ   5734
0571A:  MOVLW  01
0571C:  ADDWF  x58,W
0571E:  MOVWF  FE9
05720:  MOVLW  00
05722:  ADDWFC x59,W
05724:  MOVWF  FEA
05726:  MOVF   FEF,W
05728:  SUBLW  62
0572A:  BNZ   5734
....................          sc+=2; 
0572C:  MOVLW  02
0572E:  ADDWF  x58,F
05730:  MOVLW  00
05732:  ADDWFC x59,F
....................  
....................    } 
05734:  BRA    57A2
....................    else if(*sc!='0') // base is 0, find base 
05736:  MOVFF  359,03
0573A:  MOVFF  358,FE9
0573E:  MOVFF  359,FEA
05742:  MOVF   FEF,W
05744:  SUBLW  30
05746:  BZ    574E
....................       base=10; 
05748:  MOVLW  0A
0574A:  MOVWF  x57
0574C:  BRA    57A2
....................    else if (sc[1]=='x' || sc[1]=='X') 
0574E:  MOVLW  01
05750:  ADDWF  x58,W
05752:  MOVWF  FE9
05754:  MOVLW  00
05756:  ADDWFC x59,W
05758:  MOVWF  FEA
0575A:  MOVF   FEF,W
0575C:  SUBLW  78
0575E:  BZ    5772
05760:  MOVLW  01
05762:  ADDWF  x58,W
05764:  MOVWF  FE9
05766:  MOVLW  00
05768:  ADDWFC x59,W
0576A:  MOVWF  FEA
0576C:  MOVF   FEF,W
0576E:  SUBLW  58
05770:  BNZ   5780
....................       base =16,sc+=2; 
05772:  MOVLW  10
05774:  MOVWF  x57
05776:  MOVLW  02
05778:  ADDWF  x58,F
0577A:  MOVLW  00
0577C:  ADDWFC x59,F
0577E:  BRA    57A2
....................    else if(sc[1]=='b') 
05780:  MOVLW  01
05782:  ADDWF  x58,W
05784:  MOVWF  FE9
05786:  MOVLW  00
05788:  ADDWFC x59,W
0578A:  MOVWF  FEA
0578C:  MOVF   FEF,W
0578E:  SUBLW  62
05790:  BNZ   579E
....................       base=2,sc+=2; 
05792:  MOVLW  02
05794:  MOVWF  x57
05796:  ADDWF  x58,F
05798:  MOVLW  00
0579A:  ADDWFC x59,F
0579C:  BRA    57A2
....................    else 
....................       base=8; 
0579E:  MOVLW  08
057A0:  MOVWF  x57
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
057A2:  MOVFF  359,35B
057A6:  MOVFF  358,35A
057AA:  MOVFF  359,03
057AE:  MOVFF  358,FE9
057B2:  MOVFF  359,FEA
057B6:  MOVF   FEF,W
057B8:  SUBLW  30
057BA:  BNZ   57C4
057BC:  INCF   x58,F
057BE:  BTFSC  FD8.2
057C0:  INCF   x59,F
057C2:  BRA    57AA
....................    sd=memchr(digits,tolower(*sc),base); 
057C4:  MOVFF  359,03
057C8:  MOVFF  358,FE9
057CC:  MOVFF  359,FEA
057D0:  MOVFF  FEF,385
057D4:  MOVF   x85,W
057D6:  SUBLW  40
057D8:  BC    57E6
057DA:  MOVF   x85,W
057DC:  SUBLW  5A
057DE:  BNC   57E6
057E0:  MOVF   x85,W
057E2:  IORLW  20
057E4:  BRA    57E8
057E6:  MOVF   x85,W
057E8:  MOVWF  x85
057EA:  MOVLW  03
057EC:  MOVWF  x87
057EE:  MOVLW  61
057F0:  MOVWF  x86
057F2:  MOVFF  385,388
057F6:  MOVFF  357,389
057FA:  MOVLB  0
057FC:  RCALL  54F0
057FE:  MOVFF  02,35D
05802:  MOVFF  01,35C
....................    for(; sd!=0; ) 
05806:  MOVLB  3
05808:  MOVF   x5C,F
0580A:  BNZ   5810
0580C:  MOVF   x5D,F
0580E:  BZ    58A2
....................    { 
....................       x=x*base+(int16)(sd-digits); 
05810:  CLRF   03
05812:  MOVF   x57,W
05814:  MOVWF  00
05816:  BTFSC  FE8.7
05818:  DECF   03,F
0581A:  MOVWF  x85
0581C:  MOVFF  03,386
05820:  MOVFF  35F,388
05824:  MOVFF  35E,387
05828:  MOVFF  03,38A
0582C:  MOVWF  x89
0582E:  MOVLB  0
05830:  RCALL  5534
05832:  MOVFF  01,385
05836:  MOVLW  61
05838:  MOVLB  3
0583A:  SUBWF  x5C,W
0583C:  MOVWF  00
0583E:  MOVLW  03
05840:  SUBWFB x5D,W
05842:  MOVWF  03
05844:  MOVF   00,W
05846:  ADDWF  01,W
05848:  MOVWF  01
0584A:  MOVF   02,W
0584C:  ADDWFC 03,F
0584E:  MOVFF  01,35E
05852:  MOVFF  03,35F
....................       ++sc; 
05856:  INCF   x58,F
05858:  BTFSC  FD8.2
0585A:  INCF   x59,F
....................       sd=memchr(digits,tolower(*sc),base); 
0585C:  MOVFF  359,03
05860:  MOVFF  358,FE9
05864:  MOVFF  359,FEA
05868:  MOVFF  FEF,385
0586C:  MOVF   x85,W
0586E:  SUBLW  40
05870:  BC    587E
05872:  MOVF   x85,W
05874:  SUBLW  5A
05876:  BNC   587E
05878:  MOVF   x85,W
0587A:  IORLW  20
0587C:  BRA    5880
0587E:  MOVF   x85,W
05880:  MOVWF  x85
05882:  MOVLW  03
05884:  MOVWF  x87
05886:  MOVLW  61
05888:  MOVWF  x86
0588A:  MOVFF  385,388
0588E:  MOVFF  357,389
05892:  MOVLB  0
05894:  RCALL  54F0
05896:  MOVFF  02,35D
0589A:  MOVFF  01,35C
0589E:  BRA    5806
058A0:  MOVLB  3
....................    } 
....................    if(s1==sc) 
058A2:  MOVF   x58,W
058A4:  SUBWF  x5A,W
058A6:  BNZ   58CE
058A8:  MOVF   x59,W
058AA:  SUBWF  x5B,W
058AC:  BNZ   58CE
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
058AE:  MOVF   x55,W
058B0:  IORWF  x56,W
058B2:  BZ    58C6
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
058B4:  MOVFF  355,FE9
058B8:  MOVFF  356,FEA
058BC:  MOVFF  354,FEC
058C0:  MOVF   FED,F
058C2:  MOVFF  353,FEF
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
058C6:  MOVLW  00
058C8:  MOVWF  01
058CA:  MOVWF  02
058CC:  BRA    58EE
....................    } 
....................    if (endptr) 
058CE:  MOVF   x55,W
058D0:  IORWF  x56,W
058D2:  BZ    58E6
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
058D4:  MOVFF  355,FE9
058D8:  MOVFF  356,FEA
058DC:  MOVFF  359,FEC
058E0:  MOVF   FED,F
058E2:  MOVFF  358,FEF
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
058E6:  MOVFF  35E,01
058EA:  MOVFF  35F,02
058EE:  MOVLB  0
058F0:  GOTO   5A84 (RETURN)
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
02040:  MOVFF  1D,32F
02044:  MOVFF  1C,32E
02048:  MOVFF  1B,32D
0204C:  MOVFF  1A,32C
02050:  MOVLW  41
02052:  MOVLB  3
02054:  MOVWF  x33
02056:  MOVLW  C6
02058:  MOVWF  x32
0205A:  MOVLW  4E
0205C:  MOVWF  x31
0205E:  MOVLW  6D
02060:  MOVWF  x30
02062:  MOVLB  0
02064:  BRA    1F9A
02066:  MOVLW  39
02068:  MOVLB  3
0206A:  ADDWF  00,W
0206C:  MOVWF  1A
0206E:  MOVLW  30
02070:  ADDWFC 01,W
02072:  MOVWF  1B
02074:  MOVLW  00
02076:  ADDWFC 02,W
02078:  MOVWF  1C
0207A:  MOVLW  00
0207C:  ADDWFC 03,W
0207E:  MOVWF  1D
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
02080:  MOVFF  1C,00
02084:  MOVFF  1D,01
02088:  CLRF   02
0208A:  CLRF   03
0208C:  MOVFF  1D,32E
02090:  MOVFF  1C,32D
02094:  MOVFF  1D,330
02098:  MOVFF  1C,32F
0209C:  MOVLW  7F
0209E:  MOVWF  x32
020A0:  SETF   x31
020A2:  MOVLB  0
020A4:  BRA    1FF8
020A6:  MOVFF  00,01
020AA:  MOVFF  03,02
020AE:  GOTO   21C2 (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
01F86:  MOVFF  32F,1D
01F8A:  MOVFF  32E,1C
01F8E:  MOVFF  32D,1B
01F92:  MOVFF  32C,1A
01F96:  GOTO   21C0 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /** Configuracin para el uso del stack tcip **/ 
.................... #define STACK_USE_ICMP        1  //Mdulo de respuesta ICMP (ping) 
.................... #define STACK_USE_ARP         1  //Para solucionar direccionamiento MAC de las IP 
.................... #define STACK_USE_TCP         1  //Para enviar paquetes TCP  
.................... #define STACK_USE_HTTP        1  //Uso de las funciones http del stack. 
.................... #define STACK_USE_CCS_PICENS  1  //CCS PICENS (Embedded Ethernet) 18F4620 + ENC28J60 
.................... #define STACK_USE_MCPENC      1  //Uso del enc28j60 por el stack (stacktsk.c) 
.................... #define STACK_USE_MAC         1  //Uso de la tarjeta de red 
....................  
.................... #define HTTP_SOCKET 80         //N de puerto asociado al socket. 
.................... int8 AD0; 
.................... /********** Definicin del patillaje de conexin al enc28j60 ******************/ 
.................... /* Existen varias posibilidades: 
....................  
.................... Opcin 1. No definir nada, en cuyo caso se implementar una comunicacin SPI por  
.................... software y se tomarn la definicin de patillas establecida en enc28j60.c 
....................  
.................... SO  PIN_D7 ---- ENC >>>> PIC 
.................... SI  PIN_D6 ---- PIC >>>> ENC 
.................... CLK PIN_D5 
.................... CS  PIN_D4 
.................... RST PIN_D3 
.................... INT PIN_D2 
.................... WOL PIN_D1 
....................  
.................... Opcin 2. Definir todas las patillas de la comunicacin SPI, en cuyo caso se  
.................... implementar una comunicacin SPI por software con la definicin de patillas  
.................... elegida. Por ejemplo... 
....................  
.................... #define PIN_ENC_MAC_SO  PIN_C4   //Entrada serie de datos 
.................... #define PIN_ENC_MAC_SI  PIN_C5   //Salida serie de datos 
.................... #define PIN_ENC_MAC_CLK PIN_B4   //Seal de reloj 
.................... #define PIN_ENC_MAC_CS  PIN_B5   //Chip select 
.................... #define PIN_ENC_MAC_RST PIN_B6   //Reset 
.................... #define PIN_ENC_MAC_INT PIN_B7   //Interrupcin 
....................  
.................... Opcin 3. El que aqu se ha utilizado, que consiste en habilitar el uso de SPI  
.................... por hardware del PIC y definir las patillas ajenas al hardware del mdulo SPI  
.................... (CS, INT y RST). En este caso es imprescindible definir tambin la patilla SO  
.................... para que el stack (dentro de enc28j60.c) no habilite SPI por software. Da igual  
.................... que patilla SO se defina, la que se deber cablear ser la SO real del PIC    */ 
....................  
.................... #define ENC_MAC_USE_SPI 1           //Uso del SPI por hardware 
....................  
.................... #define PIN_ENC_MAC_SO  PIN_C5      //Entrada serie de datos 
.................... #define PIN_ENC_MAC_SI  PIN_C4    //Salida serie de datos (no necesario definir) 
.................... #define PIN_ENC_MAC_CLK PIN_C3    //Seal de reloj  (no necesario definir) 
.................... #define PIN_ENC_MAC_CS  PIN_C1      //Chip select 
.................... #define PIN_ENC_MAC_RST PIN_C0      //Reset 
.................... #define PIN_ENC_MAC_INT PIN_C2      //Interrupcin 
....................  
.................... /******************************************************************************/ 
....................  
.................... #include "tcpip/stacktsk.c"      //Carga el stack TCP/IP de Microchip  
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #case 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        192   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        168   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        1 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        10 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           1 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x02 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x04 
.................... #define MY_DEFAULT_MAC_BYTE5            0x05 
.................... #define MY_DEFAULT_MAC_BYTE6            0x06 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     5 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder		2/9/05	Added hexatob(), btohexa_high(), and 
....................  *								btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *						'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:			None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
.................... 	// Convert lowercase to uppercase 
.................... 	if(AsciiChars.v[1] > 'F') 
.................... 		AsciiChars.v[1] -= 'a'-'A'; 
.................... 	if(AsciiChars.v[0] > 'F') 
.................... 		AsciiChars.v[0] -= 'a'-'A'; 
....................  
.................... 	// Convert 0-9, A-F to 0x0-0xF 
.................... 	if(AsciiChars.v[1] > '9') 
.................... 		AsciiChars.v[1] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[1] -= '0'; 
....................  
.................... 	if(AsciiChars.v[0] > '9') 
.................... 		AsciiChars.v[0] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[0] -= '0'; 
....................  
.................... 	// Concatenate 
.................... 	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
.................... 	b >>= 4; 
.................... 	return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
.................... 	b &= 0x0F; 
.................... 	return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
02440:  MOVFF  3D8,3D9
....................     new.v[1]=v.v[0]; 
02444:  MOVFF  3D7,3DA
....................  
....................     return(new.Val); 
02448:  MOVLB  3
0244A:  MOVFF  3D9,01
0244E:  MOVFF  3DA,02
02452:  MOVLB  0
02454:  RETURN 0
.................... } 
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
03374:  MOVFF  3C3,3C4
....................     new.v[1]=v.v[2]; 
03378:  MOVFF  3C2,3C5
....................     new.v[2]=v.v[1]; 
0337C:  MOVFF  3C1,3C6
....................     new.v[3]=v.v[0]; 
03380:  MOVFF  3C0,3C7
....................  
....................     return(new.Val); 
03384:  MOVFF  3C4,00
03388:  MOVFF  3C5,01
0338C:  MOVFF  3C6,02
03390:  MOVFF  3C7,03
03394:  RETURN 0
.................... } 
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
.................... 	WORD i; 
.................... 	WORD *val; 
....................  
.................... 	union 
.................... 	{ 
.................... 		DWORD Val; 
.................... 		struct 
.................... 		{ 
.................... 			WORD_VAL LSB; 
.................... 			WORD_VAL MSB; 
.................... 		} words; 
.................... 	} tempSum, sum; 
....................  
.................... 	sum.Val = 0; 
*
030E8:  MOVLB  3
030EA:  CLRF   xC9
030EC:  CLRF   xC8
030EE:  CLRF   xC7
030F0:  CLRF   xC6
....................  
.................... 	i = count >> 1; 
030F2:  BCF    FD8.0
030F4:  RRCF   xBD,W
030F6:  MOVWF  xBF
030F8:  RRCF   xBC,W
030FA:  MOVWF  xBE
.................... 	val = (WORD *)buffer; 
030FC:  MOVFF  3BB,3C1
03100:  MOVFF  3BA,3C0
....................  
.................... 	while( i-- ) 
03104:  MOVFF  3BF,03
03108:  MOVF   xBE,W
0310A:  BTFSC  FD8.2
0310C:  DECF   xBF,F
0310E:  DECF   xBE,F
03110:  IORWF  03,W
03112:  BZ    3142
.................... 		sum.Val += *val++; 
03114:  MOVFF  3C1,03
03118:  MOVFF  3C0,00
0311C:  MOVLW  02
0311E:  ADDWF  xC0,F
03120:  BTFSC  FD8.0
03122:  INCF   xC1,F
03124:  MOVFF  00,FE9
03128:  MOVFF  03,FEA
0312C:  MOVFF  FEC,03
03130:  MOVF   FED,F
03132:  MOVF   FEF,W
03134:  ADDWF  xC6,F
03136:  MOVF   03,W
03138:  ADDWFC xC7,F
0313A:  MOVLW  00
0313C:  ADDWFC xC8,F
0313E:  ADDWFC xC9,F
03140:  BRA    3104
....................  
.................... 	if ( count & 1 ) 
03142:  MOVF   xBC,W
03144:  ANDLW  01
03146:  MOVWF  00
03148:  CLRF   03
0314A:  MOVF   00,W
0314C:  IORWF  03,W
0314E:  BZ    3164
.................... 		sum.Val += *(BYTE *)val; 
03150:  MOVFF  3C0,FE9
03154:  MOVFF  3C1,FEA
03158:  MOVF   FEF,W
0315A:  ADDWF  xC6,F
0315C:  MOVLW  00
0315E:  ADDWFC xC7,F
03160:  ADDWFC xC8,F
03162:  ADDWFC xC9,F
....................  
.................... 	tempSum.Val = sum.Val; 
03164:  MOVFF  3C9,3C5
03168:  MOVFF  3C8,3C4
0316C:  MOVFF  3C7,3C3
03170:  MOVFF  3C6,3C2
....................  
.................... 	while( (i = tempSum.words.MSB.Val) != 0u ) 
03174:  MOVFF  3C5,3BF
03178:  MOVFF  3C4,3BE
0317C:  MOVF   xBE,F
0317E:  BNZ   3184
03180:  MOVF   xBF,F
03182:  BZ    31C2
.................... 	{ 
.................... 		sum.words.MSB.Val = 0; 
03184:  CLRF   xC9
03186:  CLRF   xC8
.................... 		sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
03188:  CLRF   xCD
0318A:  CLRF   xCC
0318C:  MOVFF  3C7,3CB
03190:  MOVFF  3C6,3CA
03194:  CLRF   02
03196:  CLRF   03
03198:  MOVF   xBE,W
0319A:  ADDWF  xC6,W
0319C:  MOVWF  xC6
0319E:  MOVF   xBF,W
031A0:  ADDWFC xC7,W
031A2:  MOVWF  xC7
031A4:  MOVF   02,W
031A6:  ADDWFC xCC,W
031A8:  MOVWF  xC8
031AA:  MOVF   03,W
031AC:  ADDWFC xCD,W
031AE:  MOVWF  xC9
.................... 		tempSum.Val = sum.Val; 
031B0:  MOVFF  3C9,3C5
031B4:  MOVFF  3C8,3C4
031B8:  MOVFF  3C7,3C3
031BC:  MOVFF  3C6,3C2
031C0:  BRA    3174
.................... 	} 
....................  
.................... 	return (~sum.words.LSB.Val); 
031C2:  MOVFF  3C7,03
031C6:  COMF   03,F
031C8:  MOVF   xC6,W
031CA:  XORLW  FF
031CC:  MOVWF  01
031CE:  MOVFF  03,02
031D2:  MOVLB  0
031D4:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
....................  
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
01A8C:  MOVLW  83
01A8E:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
01A90:  MOVLW  85
01A92:  MOVWF  FD7
01A94:  MOVLW  ED
01A96:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
01A98:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
01A9A:  MOVLW  C0
01A9C:  IORWF  FF2,F
01A9E:  GOTO   2364 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
0379E:  BCF    FF2.5
....................     ret=TickCount; 
037A0:  MOVFF  52,37C
037A4:  MOVFF  51,37B
....................     enable_interrupts(INT_TIMER0); 
037A8:  BSF    FF2.5
....................     return ret; 
037AA:  MOVLB  3
037AC:  MOVFF  37B,01
037B0:  MOVFF  37C,02
037B4:  MOVLB  0
037B6:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
000BA:  INCF   51,F
000BC:  BTFSC  FD8.2
000BE:  INCF   52,F
....................  
....................         second_counter_intermediate++; 
000C0:  INCF   54,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
000C2:  MOVF   54,W
000C4:  SUBLW  09
000C6:  BC    00CC
....................             second_counter++; //increment this ever 1s 
000C8:  INCF   53,F
....................             second_counter_intermediate=0; 
000CA:  CLRF   54
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
000CC:  MOVLW  85
000CE:  MOVWF  FD7
000D0:  MOVLW  ED
000D2:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_D7   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_D6   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_D5 
....................       #define PIN_ENC_MAC_CS  PIN_D4 
....................       #define PIN_ENC_MAC_RST PIN_D3 
....................       #define PIN_ENC_MAC_INT PIN_D2 
....................       #define PIN_ENC_MAC_WOL PIN_D1 
....................       #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       //#define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................       #define mac_enc_spi_tris_init()  *0xF95= (0b10000110); 
....................      #endif 
....................  
.................... #define SPISelectEthernet()      output_low(PIN_ENC_MAC_CS) //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS)   //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define   RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define   WCR (0b010<<5)         // Write Control Register command 
.................... #define BFS (0b100<<5)         // Bit Field Set command 
.................... #define   BFC (0b101<<5)         // Bit Field Clear command 
.................... #define   RCR (0b000<<5)         // Read Control Register command 
.................... #define RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define   WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define   SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
000D4:  BCF    FF2.2
000D6:  GOTO   0074
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................  
....................    #ifdef mac_enc_spi_tris_init 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
....................    #endif 
....................  
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
*
01AA2:  BCF    FC6.5
01AA4:  BCF    F94.5
01AA6:  BSF    F94.4
01AA8:  BCF    F94.3
01AAA:  MOVLW  20
01AAC:  MOVWF  FC6
01AAE:  MOVLW  40
01AB0:  MOVWF  FC7
....................  #else 
....................     
....................    output_low(PIN_ENC_MAC_CLK); 
....................    output_float(PIN_ENC_MAC_SO); 
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
01AB2:  BCF    F94.1
01AB4:  BSF    F8B.1
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
01AB6:  BCF    F94.0
01AB8:  BSF    F8B.0
01ABA:  GOTO   1D9C (RETURN)
.................... } 
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
01ABE:  MOVF   FC9,W
01AC0:  MOVFF  3E2,FC9
01AC4:  RRCF   FC7,W
01AC6:  BNC   1AC4
01AC8:  MOVFF  FC9,01
....................  #else 
01ACC:  RETURN 0
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
....................       output_high(PIN_ENC_MAC_CLK); 
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
....................       output_low(PIN_ENC_MAC_CLK); 
....................    } 
....................    return(in); 
....................  #endif 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
01D9A:  BRA    1AA2
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
01D9C:  MOVLW  1D
01D9E:  MOVLB  3
01DA0:  MOVWF  xD7
01DA2:  MOVLB  0
01DA4:  RCALL  1ACE
01DA6:  MOVFF  01,329
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
01DAA:  MOVLB  3
01DAC:  BTFSS  x29.3
01DAE:  BRA    1DB4
01DB0:  MOVLB  0
01DB2:  BRA    1D9C
01DB4:  MOVF   x29,W
01DB6:  XORLW  FF
01DB8:  ANDLW  01
01DBA:  BTFSC  FD8.2
01DBC:  BRA    1DC2
01DBE:  MOVLB  0
01DC0:  BRA    1D9C
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
01DC2:  MOVLB  0
01DC4:  BRA    1AF8
....................     delay_ms(1); 
01DC6:  MOVLW  01
01DC8:  MOVLB  3
01DCA:  MOVWF  x2A
01DCC:  MOVLB  0
01DCE:  RCALL  1A22
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
01DD0:  CLRF   50
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
01DD2:  BSF    59.0
....................    NextPacketLocation.Val = RXSTART; 
01DD4:  CLRF   56
01DD6:  CLRF   55
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
01DD8:  MOVLW  08
01DDA:  MOVLB  3
01DDC:  MOVWF  xDD
01DDE:  CLRF   xDE
01DE0:  MOVLB  0
01DE2:  RCALL  1B0C
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
01DE4:  MOVLW  09
01DE6:  MOVLB  3
01DE8:  MOVWF  xDD
01DEA:  CLRF   xDE
01DEC:  MOVLB  0
01DEE:  RCALL  1B0C
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
01DF0:  MOVLW  0C
01DF2:  MOVLB  3
01DF4:  MOVWF  xDD
01DF6:  MOVLW  F7
01DF8:  MOVWF  xDE
01DFA:  MOVLB  0
01DFC:  RCALL  1B0C
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
01DFE:  MOVLW  0D
01E00:  MOVLB  3
01E02:  MOVWF  xDD
01E04:  MOVLW  1B
01E06:  MOVWF  xDE
01E08:  MOVLB  0
01E0A:  RCALL  1B0C
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
01E0C:  MOVLW  0A
01E0E:  MOVLB  3
01E10:  MOVWF  xDD
01E12:  MOVLW  F7
01E14:  MOVWF  xDE
01E16:  MOVLB  0
01E18:  RCALL  1B0C
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
01E1A:  MOVLW  0B
01E1C:  MOVLB  3
01E1E:  MOVWF  xDD
01E20:  MOVLW  1B
01E22:  MOVWF  xDE
01E24:  MOVLB  0
01E26:  RCALL  1B0C
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
01E28:  MOVLW  04
01E2A:  MOVLB  3
01E2C:  MOVWF  xDD
01E2E:  MOVLW  F8
01E30:  MOVWF  xDE
01E32:  MOVLB  0
01E34:  RCALL  1B0C
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
01E36:  MOVLW  05
01E38:  MOVLB  3
01E3A:  MOVWF  xDD
01E3C:  MOVLW  1B
01E3E:  MOVWF  xDE
01E40:  MOVLB  0
01E42:  RCALL  1B0C
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
01E44:  MOVLW  02
01E46:  MOVLB  3
01E48:  MOVWF  xDB
01E4A:  CLRF   xDA
01E4C:  MOVLB  0
01E4E:  RCALL  1B66
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
01E50:  MOVLB  3
01E52:  CLRF   xDD
01E54:  MOVLW  0D
01E56:  MOVWF  xDE
01E58:  MOVLB  0
01E5A:  RCALL  1B0C
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
01E5C:  MOVLW  02
01E5E:  MOVLB  3
01E60:  MOVWF  xDD
01E62:  MOVLW  32
01E64:  MOVWF  xDE
01E66:  MOVLB  0
01E68:  RCALL  1B0C
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
01E6A:  MOVLW  03
01E6C:  MOVLB  3
01E6E:  MOVWF  xDD
01E70:  MOVLW  40
01E72:  MOVWF  xDE
01E74:  MOVLB  0
01E76:  RCALL  1B0C
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
01E78:  MOVLW  09
01E7A:  MOVLB  3
01E7C:  MOVWF  xDD
01E7E:  MOVLW  3F
01E80:  MOVWF  xDE
01E82:  MOVLB  0
01E84:  RCALL  1B0C
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
01E86:  MOVLW  06
01E88:  MOVLB  3
01E8A:  MOVWF  xDD
01E8C:  MOVLW  12
01E8E:  MOVWF  xDE
01E90:  MOVLB  0
01E92:  RCALL  1B0C
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
01E94:  MOVLW  07
01E96:  MOVLB  3
01E98:  MOVWF  xDD
01E9A:  MOVLW  0C
01E9C:  MOVWF  xDE
01E9E:  MOVLB  0
01EA0:  RCALL  1B0C
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
01EA2:  MOVLW  0A
01EA4:  MOVLB  3
01EA6:  MOVWF  xDD
01EA8:  MOVLW  EE
01EAA:  MOVWF  xDE
01EAC:  MOVLB  0
01EAE:  RCALL  1B0C
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
01EB0:  MOVLW  0B
01EB2:  MOVLB  3
01EB4:  MOVWF  xDD
01EB6:  MOVLW  05
01EB8:  MOVWF  xDE
01EBA:  MOVLB  0
01EBC:  RCALL  1B0C
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
01EBE:  MOVLW  03
01EC0:  MOVLB  3
01EC2:  MOVWF  xDB
01EC4:  MOVLW  04
01EC6:  MOVWF  xDA
01EC8:  MOVLB  0
01ECA:  RCALL  1B66
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
01ECC:  MOVLW  04
01ECE:  MOVLB  3
01ED0:  MOVWF  xDD
01ED2:  MOVFF  23,3DE
01ED6:  MOVLB  0
01ED8:  RCALL  1B0C
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
01EDA:  MOVLW  05
01EDC:  MOVLB  3
01EDE:  MOVWF  xDD
01EE0:  MOVFF  24,3DE
01EE4:  MOVLB  0
01EE6:  RCALL  1B0C
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
01EE8:  MOVLW  02
01EEA:  MOVLB  3
01EEC:  MOVWF  xDD
01EEE:  MOVFF  25,3DE
01EF2:  MOVLB  0
01EF4:  RCALL  1B0C
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
01EF6:  MOVLW  03
01EF8:  MOVLB  3
01EFA:  MOVWF  xDD
01EFC:  MOVFF  26,3DE
01F00:  MOVLB  0
01F02:  RCALL  1B0C
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
01F04:  MOVLB  3
01F06:  CLRF   xDD
01F08:  MOVFF  27,3DE
01F0C:  MOVLB  0
01F0E:  RCALL  1B0C
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
01F10:  MOVLW  01
01F12:  MOVLB  3
01F14:  MOVWF  xDD
01F16:  MOVFF  28,3DE
01F1A:  MOVLB  0
01F1C:  RCALL  1B0C
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
01F1E:  MOVLW  12
01F20:  MOVLB  3
01F22:  MOVWF  xD7
01F24:  MOVLB  0
01F26:  RCALL  1ACE
01F28:  MOVFF  01,5A
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
01F2C:  MOVLW  10
01F2E:  MOVLB  3
01F30:  MOVWF  x2E
01F32:  MOVLW  01
01F34:  MOVWF  x30
01F36:  CLRF   x2F
01F38:  MOVLB  0
01F3A:  RCALL  1BCE
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
01F3C:  MOVLW  14
01F3E:  MOVLB  3
01F40:  MOVWF  x2E
01F42:  MOVLW  04
01F44:  MOVWF  x30
01F46:  MOVLW  72
01F48:  MOVWF  x2F
01F4A:  MOVLB  0
01F4C:  RCALL  1BCE
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
01F4E:  MOVLB  3
01F50:  CLRF   x2A
01F52:  MOVLB  0
01F54:  BRA    1CFE
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
01F56:  MOVLW  1F
01F58:  MOVLB  3
01F5A:  MOVWF  xDF
01F5C:  MOVLW  04
01F5E:  MOVWF  xE0
01F60:  MOVLB  0
01F62:  RCALL  1B48
01F64:  GOTO   2366 (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
038BA:  MOVLW  1F
038BC:  MOVLB  3
038BE:  MOVWF  xD7
038C0:  MOVLB  0
038C2:  CALL   1ACE
038C6:  MOVFF  01,3B9
038CA:  MOVLW  00
038CC:  MOVLB  3
038CE:  BTFSC  01.3
038D0:  MOVLW  01
038D2:  XORLW  00
038D4:  BZ    38DA
038D6:  MOVLW  00
038D8:  BRA    38DC
038DA:  MOVLW  01
038DC:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
038DE:  MOVLB  0
038E0:  RETURN 0
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
02750:  MOVLW  1F
02752:  MOVLB  3
02754:  MOVWF  xD7
02756:  MOVLB  0
02758:  CALL   1ACE
0275C:  MOVFF  01,3B9
02760:  MOVLW  00
02762:  MOVLB  3
02764:  BTFSC  01.3
02766:  MOVLW  01
02768:  XORLW  00
0276A:  BNZ   2770
0276C:  MOVLW  00
0276E:  BRA    2772
02770:  MOVLW  FF
02772:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
02774:  MOVLB  0
02776:  RETURN 0
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
*
00004:  RETURN 0
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
02370:  BTFSS  59.0
02372:  BRA    2376
....................       return; 
02374:  BRA    23DA
....................    WasDiscarded = TRUE; 
02376:  BSF    59.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
02378:  MOVLW  01
0237A:  SUBWF  55,W
0237C:  MOVLB  3
0237E:  MOVWF  x7B
02380:  MOVLW  00
02382:  SUBWFB 56,W
02384:  MOVWF  x7C
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
02386:  MOVF   x7C,W
02388:  SUBLW  1A
0238A:  BC    239E
0238C:  XORLW  FF
0238E:  BNZ   2396
02390:  MOVF   x7B,W
02392:  SUBLW  F7
02394:  BC    239E
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
02396:  MOVLW  1B
02398:  MOVWF  x7C
0239A:  MOVLW  F7
0239C:  MOVWF  x7B
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
0239E:  MOVLW  1E
023A0:  MOVWF  xDF
023A2:  MOVLW  40
023A4:  MOVWF  xE0
023A6:  MOVLB  0
023A8:  CALL   1B48
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
023AC:  MOVLB  3
023AE:  CLRF   xDB
023B0:  MOVLW  0C
023B2:  MOVWF  xDA
023B4:  MOVLB  0
023B6:  CALL   1B66
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
023BA:  MOVLW  0C
023BC:  MOVLB  3
023BE:  MOVWF  xDD
023C0:  MOVFF  37B,3DE
023C4:  MOVLB  0
023C6:  CALL   1B0C
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
023CA:  MOVLW  0D
023CC:  MOVLB  3
023CE:  MOVWF  xDD
023D0:  MOVFF  37C,3DE
023D4:  MOVLB  0
023D6:  CALL   1B0C
023DA:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
*
038E2:  MOVLW  01
038E4:  MOVLB  3
038E6:  MOVWF  xDB
038E8:  MOVLW  19
038EA:  MOVWF  xDA
038EC:  MOVLB  0
038EE:  CALL   1B66
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
038F2:  MOVLW  19
038F4:  MOVLB  3
038F6:  MOVWF  xD7
038F8:  MOVLB  0
038FA:  CALL   1ACE
038FE:  MOVFF  01,3B8
....................  
....................       BankSel(ERXWRPTL); 
03902:  MOVLB  3
03904:  CLRF   xDB
03906:  MOVLW  0E
03908:  MOVWF  xDA
0390A:  MOVLB  0
0390C:  CALL   1B66
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
03910:  MOVLW  0E
03912:  MOVLB  3
03914:  MOVWF  xD7
03916:  MOVLB  0
03918:  CALL   1ACE
0391C:  MOVFF  01,3BA
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
03920:  MOVLW  0F
03922:  MOVLB  3
03924:  MOVWF  xD7
03926:  MOVLB  0
03928:  CALL   1ACE
0392C:  MOVFF  01,3BB
....................  
....................       BankSel(EPKTCNT); 
03930:  MOVLW  01
03932:  MOVLB  3
03934:  MOVWF  xDB
03936:  MOVLW  19
03938:  MOVWF  xDA
0393A:  MOVLB  0
0393C:  CALL   1B66
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
03940:  MOVLW  19
03942:  MOVLB  3
03944:  MOVWF  xD7
03946:  MOVLB  0
03948:  CALL   1ACE
0394C:  MOVFF  01,3BC
03950:  MOVLB  3
03952:  MOVF   xB8,W
03954:  SUBWF  01,W
03956:  BTFSC  FD8.2
03958:  BRA    395E
0395A:  MOVLB  0
0395C:  BRA    38F2
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
0395E:  CLRF   xDB
03960:  MOVLW  0C
03962:  MOVWF  xDA
03964:  MOVLB  0
03966:  CALL   1B66
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
0396A:  MOVLW  0C
0396C:  MOVLB  3
0396E:  MOVWF  xD7
03970:  MOVLB  0
03972:  CALL   1ACE
03976:  MOVFF  01,3B8
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
0397A:  MOVLW  0D
0397C:  MOVLB  3
0397E:  MOVWF  xD7
03980:  MOVLB  0
03982:  CALL   1ACE
03986:  MOVFF  01,3B9
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
0398A:  MOVLB  3
0398C:  MOVF   xB9,W
0398E:  SUBWF  xBB,W
03990:  BNC   39BE
03992:  BNZ   399A
03994:  MOVF   xBA,W
03996:  SUBWF  xB8,W
03998:  BC    39BE
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
0399A:  MOVF   xB8,W
0399C:  SUBWF  xBA,W
0399E:  MOVWF  00
039A0:  MOVF   xB9,W
039A2:  SUBWFB xBB,W
039A4:  MOVWF  03
039A6:  MOVF   00,W
039A8:  XORLW  FF
039AA:  ADDLW  F8
039AC:  MOVWF  00
039AE:  MOVLW  1B
039B0:  SUBFWB 03,F
039B2:  MOVFF  00,01
039B6:  MOVFF  03,02
039BA:  BRA    39F4
....................    } 
039BC:  BRA    39F4
....................    else if ( WritePT.Val == ReadPT.Val ) 
039BE:  MOVF   xB8,W
039C0:  SUBWF  xBA,W
039C2:  BNZ   39D6
039C4:  MOVF   xB9,W
039C6:  SUBWF  xBB,W
039C8:  BNZ   39D6
....................    { 
....................       return RXSIZE - 1; 
039CA:  MOVLW  F7
039CC:  MOVWF  01
039CE:  MOVLW  1B
039D0:  MOVWF  02
039D2:  BRA    39F4
....................    } 
039D4:  BRA    39F4
....................    else 
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
039D6:  MOVF   xBA,W
039D8:  SUBWF  xB8,W
039DA:  MOVWF  xBC
039DC:  MOVF   xBB,W
039DE:  SUBWFB xB9,W
039E0:  MOVWF  xBD
039E2:  MOVLW  01
039E4:  SUBWF  xBC,W
039E6:  MOVWF  00
039E8:  MOVLW  00
039EA:  SUBWFB xBD,W
039EC:  MOVWF  03
039EE:  MOVFF  00,01
039F2:  MOVWF  02
....................    } 
039F4:  MOVLB  0
039F6:  GOTO   3C72 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
*
02456:  MOVLW  01
02458:  MOVLB  3
0245A:  MOVWF  xDB
0245C:  MOVLW  19
0245E:  MOVWF  xDA
02460:  MOVLB  0
02462:  CALL   1B66
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
02466:  MOVLW  19
02468:  MOVLB  3
0246A:  MOVWF  xD7
0246C:  MOVLB  0
0246E:  CALL   1ACE
02472:  MOVFF  01,347
02476:  MOVLB  3
02478:  MOVF   x47,F
0247A:  BNZ   2482
....................       return FALSE; 
0247C:  MOVLW  00
0247E:  MOVWF  01
02480:  BRA    258E
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
02482:  BTFSC  59.0
02484:  BRA    2492
....................    { 
....................       MACDiscardRx(); 
02486:  MOVLB  0
02488:  RCALL  2370
....................       return FALSE; 
0248A:  MOVLW  00
0248C:  MOVWF  01
0248E:  MOVLB  3
02490:  BRA    258E
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
02492:  MOVFF  56,58
02496:  MOVFF  55,57
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
0249A:  CLRF   xDB
0249C:  CLRF   xDA
0249E:  MOVLB  0
024A0:  CALL   1B66
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
024A4:  MOVLB  3
024A6:  CLRF   xDD
024A8:  MOVFF  55,3DE
024AC:  MOVLB  0
024AE:  CALL   1B0C
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
024B2:  MOVLW  01
024B4:  MOVLB  3
024B6:  MOVWF  xDD
024B8:  MOVFF  56,3DE
024BC:  MOVLB  0
024BE:  CALL   1B0C
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
024C2:  MOVLW  03
024C4:  MOVLB  3
024C6:  MOVWF  x48
024C8:  MOVLW  33
024CA:  MOVWF  x47
024CC:  MOVFF  348,3C7
024D0:  MOVWF  xC6
024D2:  CLRF   xC9
024D4:  MOVLW  14
024D6:  MOVWF  xC8
024D8:  MOVLB  0
024DA:  RCALL  23DC
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
024DC:  MOVFF  346,3D8
024E0:  MOVFF  345,3D7
024E4:  RCALL  2440
024E6:  MOVFF  02,346
024EA:  MOVFF  01,345
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
024EE:  MOVLB  3
024F0:  MOVF   x34,W
024F2:  SUBLW  1A
024F4:  BC    2500
024F6:  XORLW  FF
024F8:  BNZ   252C
024FA:  MOVF   x33,W
024FC:  SUBLW  F7
024FE:  BNC   252C
02500:  MOVLW  03
02502:  MOVWF  x48
02504:  MOVLW  33
02506:  MOVWF  FE9
02508:  MOVFF  348,FEA
0250C:  BTFSC  FEF.0
0250E:  BRA    252C
02510:  BTFSC  x38.7
02512:  BRA    252C
02514:  BTFSC  x37.4
02516:  BRA    252C
02518:  MOVF   x36,W
0251A:  SUBLW  04
0251C:  BC    2528
0251E:  XORLW  FF
02520:  BNZ   252C
02522:  MOVF   x35,W
02524:  SUBLW  EE
02526:  BNC   252C
02528:  BTFSC  x37.7
0252A:  BRA    252E
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
0252C:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
0252E:  MOVFF  334,56
02532:  MOVFF  333,55
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
02536:  MOVFF  330,03
0253A:  MOVFF  32F,347
0253E:  MOVFF  330,348
02542:  MOVFF  330,FEA
02546:  MOVFF  32F,FE9
0254A:  MOVLW  03
0254C:  MOVWF  FE2
0254E:  MOVLW  3F
02550:  MOVWF  FE1
02552:  MOVLW  06
02554:  MOVWF  01
02556:  MOVFF  FE6,FEE
0255A:  DECFSZ 01,F
0255C:  BRA    2556
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
0255E:  MOVFF  332,03
02562:  MOVFF  331,FE9
02566:  MOVFF  03,FEA
0256A:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
0256C:  MOVF   x46,W
0256E:  SUBLW  08
02570:  BNZ   2588
02572:  MOVF   x45,F
02574:  BZ    257C
02576:  MOVF   x45,W
02578:  SUBLW  06
0257A:  BNZ   2588
....................     { 
....................        *type = header.Type.v[0]; 
0257C:  MOVFF  331,FE9
02580:  MOVFF  332,FEA
02584:  MOVFF  345,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
02588:  BCF    59.0
....................    return TRUE; 
0258A:  MOVLW  01
0258C:  MOVWF  01
0258E:  MOVLB  0
02590:  GOTO   7CEE (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
....................    BankSel(EWRPTL); 
*
02892:  MOVLB  3
02894:  CLRF   xDB
02896:  MOVLW  02
02898:  MOVWF  xDA
0289A:  MOVLB  0
0289C:  CALL   1B66
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
028A0:  MOVLW  02
028A2:  MOVLB  3
028A4:  MOVWF  xDD
028A6:  MOVLW  F8
028A8:  MOVWF  xDE
028AA:  MOVLB  0
028AC:  CALL   1B0C
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
028B0:  MOVLW  03
028B2:  MOVLB  3
028B4:  MOVWF  xDD
028B6:  MOVLW  1B
028B8:  MOVWF  xDE
028BA:  MOVLB  0
028BC:  CALL   1B0C
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
028C0:  MOVLW  06
028C2:  MOVLB  3
028C4:  ADDWF  xD8,F
028C6:  MOVLW  1C
028C8:  ADDWFC xD9,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
028CA:  MOVLW  03
028CC:  MOVWF  xDB
028CE:  MOVLW  D8
028D0:  MOVWF  xDA
028D2:  MOVWF  FE9
028D4:  MOVFF  3DB,FEA
028D8:  MOVFF  FEF,3DC
028DC:  MOVLW  06
028DE:  MOVWF  xDD
028E0:  MOVFF  3DC,3DE
028E4:  MOVLB  0
028E6:  CALL   1B0C
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
028EA:  MOVLW  03
028EC:  MOVLB  3
028EE:  MOVWF  xDB
028F0:  MOVLW  D8
028F2:  MOVWF  xDA
028F4:  MOVLW  01
028F6:  ADDWF  xDA,W
028F8:  MOVWF  FE9
028FA:  MOVLW  00
028FC:  ADDWFC xDB,W
028FE:  MOVWF  FEA
02900:  MOVFF  FEF,3DC
02904:  MOVLW  07
02906:  MOVWF  xDD
02908:  MOVFF  3DC,3DE
0290C:  MOVLB  0
0290E:  CALL   1B0C
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
02912:  MOVLB  3
02914:  CLRF   xDB
02916:  MOVLB  0
02918:  RCALL  2826
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
0291A:  MOVFF  3D6,3DD
0291E:  MOVFF  3D5,3DC
02922:  MOVLB  3
02924:  CLRF   xDF
02926:  MOVLW  06
02928:  MOVWF  xDE
0292A:  MOVLB  0
0292C:  RCALL  2844
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
0292E:  MOVLB  3
02930:  CLRF   xDB
02932:  MOVLW  23
02934:  MOVWF  xDA
02936:  MOVFF  3DB,3DD
0293A:  MOVWF  xDC
0293C:  CLRF   xDF
0293E:  MOVLW  06
02940:  MOVWF  xDE
02942:  MOVLB  0
02944:  RCALL  2844
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
02946:  MOVLW  08
02948:  MOVLB  3
0294A:  MOVWF  xDB
0294C:  MOVLB  0
0294E:  RCALL  2826
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
02950:  MOVLB  3
02952:  MOVF   xD7,F
02954:  BNZ   295A
02956:  MOVLW  00
02958:  BRA    295C
0295A:  MOVLW  06
0295C:  MOVWF  xDA
0295E:  MOVWF  xDB
02960:  MOVLB  0
02962:  RCALL  2826
02964:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
02966:  MOVLW  1C
02968:  MOVLB  3
0296A:  MOVWF  xD7
0296C:  MOVLB  0
0296E:  CALL   1ACE
02972:  MOVFF  01,3C4
02976:  MOVLW  00
02978:  MOVLB  3
0297A:  BTFSC  01.1
0297C:  MOVLW  01
0297E:  XORLW  00
02980:  BZ    29A2
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
02982:  MOVLW  1F
02984:  MOVWF  xDF
02986:  MOVLW  80
02988:  MOVWF  xE0
0298A:  MOVLB  0
0298C:  CALL   1B48
....................       BFCReg(ECON1, ECON1_TXRST); 
02990:  MOVLW  1F
02992:  MOVLB  3
02994:  MOVWF  xDC
02996:  MOVLW  80
02998:  MOVWF  xDD
0299A:  MOVLB  0
0299C:  CALL   1B2A
029A0:  MOVLB  3
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
029A2:  MOVLW  1C
029A4:  MOVWF  xDC
029A6:  MOVLW  0A
029A8:  MOVWF  xDD
029AA:  MOVLB  0
029AC:  CALL   1B2A
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
029B0:  MOVLW  1F
029B2:  MOVLB  3
029B4:  MOVWF  xDF
029B6:  MOVLW  08
029B8:  MOVWF  xE0
029BA:  MOVLB  0
029BC:  CALL   1B48
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
029C0:  MOVF   5A,W
029C2:  SUBLW  05
029C4:  BTFSS  FD8.2
029C6:  BRA    2B8C
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
029C8:  MOVLW  1C
029CA:  MOVLB  3
029CC:  MOVWF  xD7
029CE:  MOVLB  0
029D0:  CALL   1ACE
029D4:  MOVFF  01,3C4
029D8:  MOVLB  3
029DA:  MOVF   01,W
029DC:  ANDLW  0A
029DE:  BTFSS  FD8.2
029E0:  BRA    29E6
029E2:  MOVLB  0
029E4:  BRA    29C8
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
029E6:  MOVLW  1C
029E8:  MOVWF  xD7
029EA:  MOVLB  0
029EC:  CALL   1ACE
029F0:  MOVFF  01,3C4
029F4:  MOVLW  00
029F6:  MOVLB  3
029F8:  BTFSC  01.1
029FA:  MOVLW  01
029FC:  XORLW  00
029FE:  BTFSC  FD8.2
02A00:  BRA    2B8E
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
02A02:  MOVLW  1F
02A04:  MOVWF  xDC
02A06:  MOVLW  08
02A08:  MOVWF  xDD
02A0A:  MOVLB  0
02A0C:  CALL   1B2A
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
02A10:  MOVLB  3
02A12:  CLRF   xDB
02A14:  CLRF   xDA
02A16:  MOVLB  0
02A18:  CALL   1B66
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
02A1C:  MOVLB  3
02A1E:  CLRF   xD7
02A20:  MOVLB  0
02A22:  CALL   1ACE
02A26:  MOVFF  01,3B8
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
02A2A:  MOVLW  01
02A2C:  MOVLB  3
02A2E:  MOVWF  xD7
02A30:  MOVLB  0
02A32:  CALL   1ACE
02A36:  MOVFF  01,3B9
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
02A3A:  MOVLW  06
02A3C:  MOVLB  3
02A3E:  MOVWF  xD7
02A40:  MOVLB  0
02A42:  CALL   1ACE
02A46:  MOVFF  01,3BA
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
02A4A:  MOVLW  07
02A4C:  MOVLB  3
02A4E:  MOVWF  xD7
02A50:  MOVLB  0
02A52:  CALL   1ACE
02A56:  MOVFF  01,3BB
....................          TXEnd.Val++; 
02A5A:  MOVLB  3
02A5C:  INCF   xBA,F
02A5E:  BTFSC  FD8.2
02A60:  INCF   xBB,F
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
02A62:  CLRF   xDD
02A64:  MOVFF  3BA,3DE
02A68:  MOVLB  0
02A6A:  CALL   1B0C
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
02A6E:  MOVLW  01
02A70:  MOVLB  3
02A72:  MOVWF  xDD
02A74:  MOVFF  3BB,3DE
02A78:  MOVLB  0
02A7A:  CALL   1B0C
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
02A7E:  MOVLW  03
02A80:  MOVLB  3
02A82:  MOVWF  xC5
02A84:  MOVLW  BC
02A86:  MOVWF  xC4
02A88:  MOVFF  3C5,3C7
02A8C:  MOVWF  xC6
02A8E:  CLRF   xC9
02A90:  MOVLW  07
02A92:  MOVWF  xC8
02A94:  MOVLB  0
02A96:  RCALL  23DC
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
02A98:  MOVLB  3
02A9A:  CLRF   xC3
02A9C:  MOVF   xC3,W
02A9E:  SUBLW  0F
02AA0:  BNC   2B70
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
02AA2:  MOVLW  1C
02AA4:  MOVWF  xD7
02AA6:  MOVLB  0
02AA8:  CALL   1ACE
02AAC:  MOVFF  01,3C4
02AB0:  MOVLW  00
02AB2:  MOVLB  3
02AB4:  BTFSC  01.1
02AB6:  MOVLW  01
02AB8:  XORLW  00
02ABA:  BZ    2B66
02ABC:  BTFSS  xBF.5
02ABE:  BRA    2B66
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
02AC0:  MOVLW  1F
02AC2:  MOVWF  xDF
02AC4:  MOVLW  80
02AC6:  MOVWF  xE0
02AC8:  MOVLB  0
02ACA:  CALL   1B48
....................                BFCReg(ECON1, ECON1_TXRST); 
02ACE:  MOVLW  1F
02AD0:  MOVLB  3
02AD2:  MOVWF  xDC
02AD4:  MOVLW  80
02AD6:  MOVWF  xDD
02AD8:  MOVLB  0
02ADA:  CALL   1B2A
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
02ADE:  MOVLW  1C
02AE0:  MOVLB  3
02AE2:  MOVWF  xDC
02AE4:  MOVLW  0A
02AE6:  MOVWF  xDD
02AE8:  MOVLB  0
02AEA:  CALL   1B2A
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
02AEE:  MOVLW  1F
02AF0:  MOVLB  3
02AF2:  MOVWF  xDF
02AF4:  MOVLW  08
02AF6:  MOVWF  xE0
02AF8:  MOVLB  0
02AFA:  CALL   1B48
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
02AFE:  MOVLW  1C
02B00:  MOVLB  3
02B02:  MOVWF  xD7
02B04:  MOVLB  0
02B06:  CALL   1ACE
02B0A:  MOVFF  01,3C4
02B0E:  MOVLB  3
02B10:  MOVF   01,W
02B12:  ANDLW  0A
02B14:  BTFSS  FD8.2
02B16:  BRA    2B1C
02B18:  MOVLB  0
02B1A:  BRA    2AFE
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
02B1C:  MOVLW  1F
02B1E:  MOVWF  xDC
02B20:  MOVLW  08
02B22:  MOVWF  xDD
02B24:  MOVLB  0
02B26:  CALL   1B2A
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
02B2A:  MOVLB  3
02B2C:  CLRF   xDD
02B2E:  MOVFF  3BA,3DE
02B32:  MOVLB  0
02B34:  CALL   1B0C
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
02B38:  MOVLW  01
02B3A:  MOVLB  3
02B3C:  MOVWF  xDD
02B3E:  MOVFF  3BB,3DE
02B42:  MOVLB  0
02B44:  CALL   1B0C
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
02B48:  MOVLW  03
02B4A:  MOVLB  3
02B4C:  MOVWF  xC5
02B4E:  MOVLW  BC
02B50:  MOVWF  xC4
02B52:  MOVFF  3C5,3C7
02B56:  MOVWF  xC6
02B58:  CLRF   xC9
02B5A:  MOVLW  07
02B5C:  MOVWF  xC8
02B5E:  MOVLB  0
02B60:  RCALL  23DC
....................             } 
02B62:  BRA    2B6A
02B64:  MOVLB  3
....................             else 
....................             { 
....................                break; 
02B66:  BRA    2B70
02B68:  MOVLB  0
....................             } 
02B6A:  MOVLB  3
02B6C:  INCF   xC3,F
02B6E:  BRA    2A9C
....................          } 
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
02B70:  CLRF   xDD
02B72:  MOVFF  3B8,3DE
02B76:  MOVLB  0
02B78:  CALL   1B0C
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
02B7C:  MOVLW  01
02B7E:  MOVLB  3
02B80:  MOVWF  xDD
02B82:  MOVFF  3B9,3DE
02B86:  MOVLB  0
02B88:  CALL   1B0C
02B8C:  MOVLB  3
....................       } 
....................    } 
02B8E:  MOVLB  0
02B90:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
02EAA:  MOVLW  14
02EAC:  ADDWF  57,W
02EAE:  MOVLB  3
02EB0:  MOVWF  x64
02EB2:  MOVLW  00
02EB4:  ADDWFC 58,W
02EB6:  MOVWF  x65
02EB8:  MOVF   x60,W
02EBA:  ADDWF  x64,W
02EBC:  MOVWF  x62
02EBE:  MOVF   x61,W
02EC0:  ADDWFC x65,W
02EC2:  MOVWF  x63
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
02EC4:  MOVF   x63,W
02EC6:  SUBLW  1A
02EC8:  BC    2EDC
02ECA:  XORLW  FF
02ECC:  BNZ   2ED4
02ECE:  MOVF   x62,W
02ED0:  SUBLW  F7
02ED2:  BC    2EDC
....................       ReadPT.Val -= RXSIZE; 
02ED4:  MOVLW  F8
02ED6:  SUBWF  x62,F
02ED8:  MOVLW  1B
02EDA:  SUBWFB x63,F
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
02EDC:  CLRF   xDB
02EDE:  CLRF   xDA
02EE0:  MOVLB  0
02EE2:  CALL   1B66
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
02EE6:  MOVLB  3
02EE8:  CLRF   xDD
02EEA:  MOVFF  362,3DE
02EEE:  MOVLB  0
02EF0:  CALL   1B0C
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
02EF4:  MOVLW  01
02EF6:  MOVLB  3
02EF8:  MOVWF  xDD
02EFA:  MOVFF  363,3DE
02EFE:  MOVLB  0
02F00:  CALL   1B0C
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
02F04:  MOVLW  02
02F06:  MOVLB  3
02F08:  MOVWF  xDD
02F0A:  MOVFF  362,3DE
02F0E:  MOVLB  0
02F10:  CALL   1B0C
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
02F14:  MOVLW  03
02F16:  MOVLB  3
02F18:  MOVWF  xDD
02F1A:  MOVFF  363,3DE
02F1E:  MOVLB  0
02F20:  CALL   1B0C
02F24:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
02778:  MOVFF  3D1,50
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
0277C:  MOVLW  07
0277E:  MOVLB  3
02780:  ADDWF  xD2,F
02782:  MOVLW  1C
02784:  ADDWFC xD3,F
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
02786:  CLRF   xDB
02788:  MOVLW  02
0278A:  MOVWF  xDA
0278C:  MOVLB  0
0278E:  CALL   1B66
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
02792:  MOVLW  03
02794:  MOVLB  3
02796:  MOVWF  xD5
02798:  MOVLW  D2
0279A:  MOVWF  xD4
0279C:  MOVWF  FE9
0279E:  MOVFF  3D5,FEA
027A2:  MOVFF  FEF,3D6
027A6:  CLRF   xDD
027A8:  MOVFF  3D6,3DE
027AC:  MOVLB  0
027AE:  CALL   1B0C
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
027B2:  MOVLW  03
027B4:  MOVLB  3
027B6:  MOVWF  xD5
027B8:  MOVLW  D2
027BA:  MOVWF  xD4
027BC:  MOVLW  01
027BE:  ADDWF  xD4,W
027C0:  MOVWF  FE9
027C2:  MOVLW  00
027C4:  ADDWFC xD5,W
027C6:  MOVWF  FEA
027C8:  MOVFF  FEF,3D6
027CC:  MOVLW  01
027CE:  MOVWF  xDD
027D0:  MOVFF  3D6,3DE
027D4:  MOVLB  0
027D6:  CALL   1B0C
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
027DA:  MOVLW  03
027DC:  MOVLB  3
027DE:  MOVWF  xD5
027E0:  MOVLW  D2
027E2:  MOVWF  xD4
027E4:  MOVWF  FE9
027E6:  MOVFF  3D5,FEA
027EA:  MOVFF  FEF,3D6
027EE:  MOVLW  02
027F0:  MOVWF  xDD
027F2:  MOVFF  3D6,3DE
027F6:  MOVLB  0
027F8:  CALL   1B0C
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
027FC:  MOVLW  03
027FE:  MOVLB  3
02800:  MOVWF  xD5
02802:  MOVLW  D2
02804:  MOVWF  xD4
02806:  MOVLW  01
02808:  ADDWF  xD4,W
0280A:  MOVWF  FE9
0280C:  MOVLW  00
0280E:  ADDWFC xD5,W
02810:  MOVWF  FEA
02812:  MOVFF  FEF,3D6
02816:  MOVLW  03
02818:  MOVWF  xDD
0281A:  MOVFF  3D6,3DE
0281E:  MOVLB  0
02820:  CALL   1B0C
02824:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
02DA2:  MOVLW  14
02DA4:  ADDWF  57,W
02DA6:  MOVLB  3
02DA8:  MOVWF  x8E
02DAA:  MOVLW  00
02DAC:  ADDWFC 58,W
02DAE:  MOVWF  x8F
02DB0:  MOVF   x88,W
02DB2:  ADDWF  x8E,W
02DB4:  MOVWF  x8C
02DB6:  MOVF   x89,W
02DB8:  ADDWFC x8F,W
02DBA:  MOVWF  x8D
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
02DBC:  MOVF   x8D,W
02DBE:  SUBLW  1A
02DC0:  BC    2DD4
02DC2:  XORLW  FF
02DC4:  BNZ   2DCC
02DC6:  MOVF   x8C,W
02DC8:  SUBLW  F7
02DCA:  BC    2DD4
....................    { 
....................       temp.Val -= RXSIZE; 
02DCC:  MOVLW  F8
02DCE:  SUBWF  x8C,F
02DD0:  MOVLW  1B
02DD2:  SUBWFB x8D,F
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
02DD4:  CLRF   xDB
02DD6:  MOVLW  10
02DD8:  MOVWF  xDA
02DDA:  MOVLB  0
02DDC:  CALL   1B66
....................    WriteReg(EDMASTL, temp.v[0]); 
02DE0:  MOVLW  10
02DE2:  MOVLB  3
02DE4:  MOVWF  xDD
02DE6:  MOVFF  38C,3DE
02DEA:  MOVLB  0
02DEC:  CALL   1B0C
....................    WriteReg(EDMASTH, temp.v[1]); 
02DF0:  MOVLW  11
02DF2:  MOVLB  3
02DF4:  MOVWF  xDD
02DF6:  MOVFF  38D,3DE
02DFA:  MOVLB  0
02DFC:  CALL   1B0C
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
02E00:  MOVLW  01
02E02:  MOVLB  3
02E04:  SUBWF  x8A,W
02E06:  MOVWF  00
02E08:  MOVLW  00
02E0A:  SUBWFB x8B,W
02E0C:  MOVWF  03
02E0E:  MOVF   00,W
02E10:  ADDWF  x8C,F
02E12:  MOVF   03,W
02E14:  ADDWFC x8D,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
02E16:  MOVF   x8D,W
02E18:  SUBLW  1A
02E1A:  BC    2E2E
02E1C:  XORLW  FF
02E1E:  BNZ   2E26
02E20:  MOVF   x8C,W
02E22:  SUBLW  F7
02E24:  BC    2E2E
....................    { 
....................       temp.Val -= RXSIZE; 
02E26:  MOVLW  F8
02E28:  SUBWF  x8C,F
02E2A:  MOVLW  1B
02E2C:  SUBWFB x8D,F
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
02E2E:  MOVLW  12
02E30:  MOVWF  xDD
02E32:  MOVFF  38C,3DE
02E36:  MOVLB  0
02E38:  CALL   1B0C
....................    WriteReg(EDMANDH, temp.v[1]); 
02E3C:  MOVLW  13
02E3E:  MOVLB  3
02E40:  MOVWF  xDD
02E42:  MOVFF  38D,3DE
02E46:  MOVLB  0
02E48:  CALL   1B0C
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
02E4C:  MOVLW  1F
02E4E:  MOVLB  3
02E50:  MOVWF  xDF
02E52:  MOVLW  30
02E54:  MOVWF  xE0
02E56:  MOVLB  0
02E58:  CALL   1B48
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
02E5C:  MOVLW  1F
02E5E:  MOVLB  3
02E60:  MOVWF  xD7
02E62:  MOVLB  0
02E64:  CALL   1ACE
02E68:  MOVFF  01,38E
02E6C:  MOVLW  00
02E6E:  MOVLB  3
02E70:  BTFSC  01.5
02E72:  MOVLW  01
02E74:  XORLW  00
02E76:  BTFSC  FD8.2
02E78:  BRA    2E7E
02E7A:  MOVLB  0
02E7C:  BRA    2E5C
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
02E7E:  MOVLW  16
02E80:  MOVWF  xD7
02E82:  MOVLB  0
02E84:  CALL   1ACE
02E88:  MOVFF  01,38D
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
02E8C:  MOVLW  17
02E8E:  MOVLB  3
02E90:  MOVWF  xD7
02E92:  MOVLB  0
02E94:  CALL   1ACE
02E98:  MOVFF  01,38C
....................    return temp.Val; 
02E9C:  MOVLB  3
02E9E:  MOVFF  38C,01
02EA2:  MOVFF  38D,02
02EA6:  MOVLB  0
02EA8:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
039FA:  MOVLW  06
039FC:  MOVLB  3
039FE:  ADDWF  xD1,W
03A00:  MOVWF  xD7
03A02:  MOVLW  1C
03A04:  ADDWFC xD2,W
03A06:  MOVWF  xD8
03A08:  MOVLW  01
03A0A:  ADDWF  xD7,W
03A0C:  MOVWF  xD5
03A0E:  MOVLW  00
03A10:  ADDWFC xD8,W
03A12:  MOVWF  xD6
.................... #endif 
....................    BankSel(EDMASTL); 
03A14:  CLRF   xDB
03A16:  MOVLW  10
03A18:  MOVWF  xDA
03A1A:  MOVLB  0
03A1C:  CALL   1B66
....................    WriteReg(EDMASTL, temp.v[0]); 
03A20:  MOVLW  10
03A22:  MOVLB  3
03A24:  MOVWF  xDD
03A26:  MOVFF  3D5,3DE
03A2A:  MOVLB  0
03A2C:  CALL   1B0C
....................    WriteReg(EDMASTH, temp.v[1]); 
03A30:  MOVLW  11
03A32:  MOVLB  3
03A34:  MOVWF  xDD
03A36:  MOVFF  3D6,3DE
03A3A:  MOVLB  0
03A3C:  CALL   1B0C
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
03A40:  MOVLW  01
03A42:  MOVLB  3
03A44:  SUBWF  xD3,W
03A46:  MOVWF  00
03A48:  MOVLW  00
03A4A:  SUBWFB xD4,W
03A4C:  MOVWF  03
03A4E:  MOVF   00,W
03A50:  ADDWF  xD5,F
03A52:  MOVF   03,W
03A54:  ADDWFC xD6,F
....................    WriteReg(EDMANDL, temp.v[0]); 
03A56:  MOVLW  12
03A58:  MOVWF  xDD
03A5A:  MOVFF  3D5,3DE
03A5E:  MOVLB  0
03A60:  CALL   1B0C
....................    WriteReg(EDMANDH, temp.v[1]); 
03A64:  MOVLW  13
03A66:  MOVLB  3
03A68:  MOVWF  xDD
03A6A:  MOVFF  3D6,3DE
03A6E:  MOVLB  0
03A70:  CALL   1B0C
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
03A74:  MOVLW  1F
03A76:  MOVLB  3
03A78:  MOVWF  xDF
03A7A:  MOVLW  30
03A7C:  MOVWF  xE0
03A7E:  MOVLB  0
03A80:  CALL   1B48
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
03A84:  MOVLW  1F
03A86:  MOVLB  3
03A88:  MOVWF  xD7
03A8A:  MOVLB  0
03A8C:  CALL   1ACE
03A90:  MOVFF  01,3D7
03A94:  MOVLW  00
03A96:  MOVLB  3
03A98:  BTFSC  01.5
03A9A:  MOVLW  01
03A9C:  XORLW  00
03A9E:  BTFSC  FD8.2
03AA0:  BRA    3AA6
03AA2:  MOVLB  0
03AA4:  BRA    3A84
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
03AA6:  MOVLW  16
03AA8:  MOVWF  xD7
03AAA:  MOVLB  0
03AAC:  CALL   1ACE
03AB0:  MOVFF  01,3D6
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
03AB4:  MOVLW  17
03AB6:  MOVLB  3
03AB8:  MOVWF  xD7
03ABA:  MOVLB  0
03ABC:  CALL   1ACE
03AC0:  MOVFF  01,3D5
....................    return temp.Val; 
03AC4:  MOVLB  3
03AC6:  MOVFF  3D5,01
03ACA:  MOVFF  3D6,02
03ACE:  MOVLB  0
03AD0:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
03202:  MOVLB  3
03204:  MOVF   xB8,F
03206:  BNZ   3216
03208:  MOVF   xB9,F
0320A:  BNZ   3216
....................    { 
....................       return 0xFFFF; 
0320C:  MOVLW  FF
0320E:  MOVWF  01
03210:  MOVWF  02
03212:  BRA    3356
....................    } 
03214:  BRA    3244
....................    else if(len == 1u) 
03216:  DECFSZ xB8,W
03218:  BRA    3244
0321A:  MOVF   xB9,F
0321C:  BNZ   3244
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
0321E:  MOVLB  0
03220:  RCALL  31D6
03222:  MOVLB  3
03224:  CLRF   xBD
03226:  MOVFF  01,3BC
0322A:  MOVFF  01,03
0322E:  MOVLW  00
03230:  CLRF   00
03232:  DECF   00,F
03234:  XORWF  00,F
03236:  MOVLW  FF
03238:  XORWF  03,F
0323A:  MOVFF  00,01
0323E:  MOVFF  03,02
03242:  BRA    3356
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
03244:  CLRF   xDB
03246:  CLRF   xDA
03248:  MOVLB  0
0324A:  CALL   1B66
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
0324E:  MOVLB  3
03250:  CLRF   xD7
03252:  MOVLB  0
03254:  CALL   1ACE
03258:  MOVFF  01,3BA
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
0325C:  MOVLW  01
0325E:  MOVLB  3
03260:  MOVWF  xD7
03262:  MOVLB  0
03264:  CALL   1ACE
03268:  MOVFF  01,3BB
....................    WriteReg(EDMASTL, temp.v[0]); 
0326C:  MOVLW  10
0326E:  MOVLB  3
03270:  MOVWF  xDD
03272:  MOVFF  3BA,3DE
03276:  MOVLB  0
03278:  CALL   1B0C
....................    WriteReg(EDMASTH, temp.v[1]); 
0327C:  MOVLW  11
0327E:  MOVLB  3
03280:  MOVWF  xDD
03282:  MOVFF  3BB,3DE
03286:  MOVLB  0
03288:  CALL   1B0C
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
0328C:  MOVLB  3
0328E:  MOVF   xBB,W
03290:  SUBLW  1B
03292:  BNC   32CA
03294:  BNZ   329C
03296:  MOVF   xBA,W
03298:  SUBLW  F7
0329A:  BNC   32CA
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
0329C:  MOVLW  01
0329E:  SUBWF  xB8,W
032A0:  MOVWF  00
032A2:  MOVLW  00
032A4:  SUBWFB xB9,W
032A6:  MOVWF  03
032A8:  MOVF   00,W
032AA:  ADDWF  xBA,F
032AC:  MOVF   03,W
032AE:  ADDWFC xBB,F
....................       if(temp.Val > RXSTOP) 
032B0:  MOVF   xBB,W
032B2:  SUBLW  1A
032B4:  BC    32C8
032B6:  XORLW  FF
032B8:  BNZ   32C0
032BA:  MOVF   xBA,W
032BC:  SUBLW  F7
032BE:  BC    32C8
....................       { 
....................          temp.Val -= RXSIZE; 
032C0:  MOVLW  F8
032C2:  SUBWF  xBA,F
032C4:  MOVLW  1B
032C6:  SUBWFB xBB,F
....................       } 
....................    } 
032C8:  BRA    32DE
....................    else 
....................    { 
....................       temp.Val += len-1; 
032CA:  MOVLW  01
032CC:  SUBWF  xB8,W
032CE:  MOVWF  00
032D0:  MOVLW  00
032D2:  SUBWFB xB9,W
032D4:  MOVWF  03
032D6:  MOVF   00,W
032D8:  ADDWF  xBA,F
032DA:  MOVF   03,W
032DC:  ADDWFC xBB,F
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
032DE:  MOVLW  12
032E0:  MOVWF  xDD
032E2:  MOVFF  3BA,3DE
032E6:  MOVLB  0
032E8:  CALL   1B0C
....................    WriteReg(EDMANDH, temp.v[1]); 
032EC:  MOVLW  13
032EE:  MOVLB  3
032F0:  MOVWF  xDD
032F2:  MOVFF  3BB,3DE
032F6:  MOVLB  0
032F8:  CALL   1B0C
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
032FC:  MOVLW  1F
032FE:  MOVLB  3
03300:  MOVWF  xDF
03302:  MOVLW  30
03304:  MOVWF  xE0
03306:  MOVLB  0
03308:  CALL   1B48
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
0330C:  MOVLW  1F
0330E:  MOVLB  3
03310:  MOVWF  xD7
03312:  MOVLB  0
03314:  CALL   1ACE
03318:  MOVFF  01,3BC
0331C:  MOVLW  00
0331E:  MOVLB  3
03320:  BTFSC  01.5
03322:  MOVLW  01
03324:  XORLW  00
03326:  BTFSC  FD8.2
03328:  BRA    332E
0332A:  MOVLB  0
0332C:  BRA    330C
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
0332E:  MOVLW  16
03330:  MOVWF  xD7
03332:  MOVLB  0
03334:  CALL   1ACE
03338:  MOVFF  01,3BA
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
0333C:  MOVLW  17
0333E:  MOVLB  3
03340:  MOVWF  xD7
03342:  MOVLB  0
03344:  CALL   1ACE
03348:  MOVFF  01,3BB
....................    return temp.Val; 
0334C:  MOVLB  3
0334E:  MOVFF  3BA,01
03352:  MOVFF  3BB,02
03356:  MOVLB  0
03358:  RETURN 0
.................... } 
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
031D6:  BCF    F94.1
031D8:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
031DA:  MOVLW  3A
031DC:  MOVLB  3
031DE:  MOVWF  xE2
031E0:  MOVLB  0
031E2:  CALL   1ABE
....................    c=ENCSPIXfer(0); 
031E6:  MOVLB  3
031E8:  CLRF   xE2
031EA:  MOVLB  0
031EC:  CALL   1ABE
031F0:  MOVFF  01,3BC
....................    SPIUnselectEthernet(); 
031F4:  BCF    F94.1
031F6:  BSF    F8B.1
....................    return(c); 
031F8:  MOVLB  3
031FA:  MOVFF  3BC,01
031FE:  MOVLB  0
03200:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
*
023DC:  MOVLB  3
023DE:  CLRF   xCB
023E0:  CLRF   xCA
.................... { 
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
....................  
....................    SPISelectEthernet(); 
023E2:  BCF    F94.1
023E4:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
023E6:  MOVLW  3A
023E8:  MOVWF  xE2
023EA:  MOVLB  0
023EC:  CALL   1ABE
....................    while(i<len) 
023F0:  MOVLB  3
023F2:  MOVF   xCB,W
023F4:  SUBWF  xC9,W
023F6:  BNC   2430
023F8:  BNZ   2400
023FA:  MOVF   xC8,W
023FC:  SUBWF  xCA,W
023FE:  BC    2430
....................    { 
....................       *val=ENCSPIXfer(0); 
02400:  MOVFF  3C7,03
02404:  MOVFF  3C6,3CC
02408:  MOVFF  3C7,3CD
0240C:  CLRF   xE2
0240E:  MOVLB  0
02410:  CALL   1ABE
02414:  MOVFF  3CD,FEA
02418:  MOVFF  3CC,FE9
0241C:  MOVFF  01,FEF
....................       val++; 
02420:  MOVLB  3
02422:  INCF   xC6,F
02424:  BTFSC  FD8.2
02426:  INCF   xC7,F
....................       i++; 
02428:  INCF   xCA,F
0242A:  BTFSC  FD8.2
0242C:  INCF   xCB,F
0242E:  BRA    23F2
....................    } 
....................    SPIUnselectEthernet(); 
02430:  BCF    F94.1
02432:  BSF    F8B.1
....................  
....................    return(i); 
02434:  MOVFF  3CA,01
02438:  MOVFF  3CB,02
0243C:  MOVLB  0
0243E:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
02826:  BCF    F94.1
02828:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
0282A:  MOVLW  7A
0282C:  MOVLB  3
0282E:  MOVWF  xE2
02830:  MOVLB  0
02832:  CALL   1ABE
....................    ENCSPIXfer(val); 
02836:  MOVFF  3DB,3E2
0283A:  CALL   1ABE
....................    SPIUnselectEthernet(); 
0283E:  BCF    F94.1
02840:  BSF    F8B.1
02842:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
02844:  BCF    F94.1
02846:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
02848:  MOVLW  7A
0284A:  MOVLB  3
0284C:  MOVWF  xE2
0284E:  MOVLB  0
02850:  CALL   1ABE
....................    while(len--) 
02854:  MOVLB  3
02856:  MOVFF  3DF,03
0285A:  MOVF   xDE,W
0285C:  BTFSC  FD8.2
0285E:  DECF   xDF,F
02860:  DECF   xDE,F
02862:  IORWF  03,W
02864:  BZ    288A
....................    { 
....................       ENCSPIXfer(*val); 
02866:  MOVFF  3DD,03
0286A:  MOVFF  3DC,FE9
0286E:  MOVFF  3DD,FEA
02872:  MOVFF  FEF,3E0
02876:  MOVFF  3E0,3E2
0287A:  MOVLB  0
0287C:  CALL   1ABE
....................       val++; 
02880:  MOVLB  3
02882:  INCF   xDC,F
02884:  BTFSC  FD8.2
02886:  INCF   xDD,F
02888:  BRA    2856
....................    } 
....................    SPIUnselectEthernet(); 
0288A:  BCF    F94.1
0288C:  BSF    F8B.1
0288E:  MOVLB  0
02890:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
01AF8:  BCF    F94.1
01AFA:  BCF    F8B.1
....................    ENCSPIXfer(SR); 
01AFC:  MOVLB  3
01AFE:  SETF   xE2
01B00:  MOVLB  0
01B02:  RCALL  1ABE
....................    SPIUnselectEthernet(); 
01B04:  BCF    F94.1
01B06:  BSF    F8B.1
01B08:  GOTO   1DC6 (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
01ACE:  BCF    F94.1
01AD0:  BCF    F8B.1
....................    ENCSPIXfer(RCR | Address); 
01AD2:  MOVFF  3D7,3D9
01AD6:  MOVFF  3D7,3E2
01ADA:  MOVLB  0
01ADC:  RCALL  1ABE
....................    c=ENCSPIXfer(0); 
01ADE:  MOVLB  3
01AE0:  CLRF   xE2
01AE2:  MOVLB  0
01AE4:  RCALL  1ABE
01AE6:  MOVFF  01,3D8
....................    SPIUnselectEthernet(); 
01AEA:  BCF    F94.1
01AEC:  BSF    F8B.1
....................    return(c); 
01AEE:  MOVLB  3
01AF0:  MOVFF  3D8,01
01AF4:  MOVLB  0
01AF6:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
01B9C:  BCF    F94.1
01B9E:  BCF    F8B.1
....................  
....................    ENCSPIXfer(RCR | Address); 
01BA0:  MOVFF  331,333
01BA4:  MOVFF  331,3E2
01BA8:  MOVLB  0
01BAA:  RCALL  1ABE
....................    ENCSPIXfer(0); 
01BAC:  MOVLB  3
01BAE:  CLRF   xE2
01BB0:  MOVLB  0
01BB2:  RCALL  1ABE
....................    c=ENCSPIXfer(0); 
01BB4:  MOVLB  3
01BB6:  CLRF   xE2
01BB8:  MOVLB  0
01BBA:  RCALL  1ABE
01BBC:  MOVFF  01,332
....................  
....................    SPIUnselectEthernet(); 
01BC0:  BCF    F94.1
01BC2:  BSF    F8B.1
....................  
....................    return(c); 
01BC4:  MOVLB  3
01BC6:  MOVFF  332,01
01BCA:  MOVLB  0
01BCC:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
01C62:  MOVLW  02
01C64:  MOVLB  3
01C66:  MOVWF  xDB
01C68:  MOVLW  14
01C6A:  MOVWF  xDA
01C6C:  MOVLB  0
01C6E:  RCALL  1B66
....................    WriteReg(MIREGADR, Register); 
01C70:  MOVLW  14
01C72:  MOVLB  3
01C74:  MOVWF  xDD
01C76:  MOVFF  32E,3DE
01C7A:  MOVLB  0
01C7C:  RCALL  1B0C
....................    WriteReg(MICMD, MICMD_MIIRD); 
01C7E:  MOVLW  12
01C80:  MOVLB  3
01C82:  MOVWF  xDD
01C84:  MOVLW  01
01C86:  MOVWF  xDE
01C88:  MOVLB  0
01C8A:  RCALL  1B0C
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
01C8C:  MOVLW  03
01C8E:  MOVLB  3
01C90:  MOVWF  xDB
01C92:  MOVLW  0A
01C94:  MOVWF  xDA
01C96:  MOVLB  0
01C98:  RCALL  1B66
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
01C9A:  MOVLW  0A
01C9C:  MOVLB  3
01C9E:  MOVWF  x31
01CA0:  MOVLB  0
01CA2:  RCALL  1B9C
01CA4:  MOVFF  01,331
01CA8:  MOVLW  00
01CAA:  MOVLB  3
01CAC:  BTFSC  01.0
01CAE:  MOVLW  01
01CB0:  XORLW  00
01CB2:  BTFSC  FD8.2
01CB4:  BRA    1CBA
01CB6:  MOVLB  0
01CB8:  BRA    1C9A
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
01CBA:  MOVLW  02
01CBC:  MOVWF  xDB
01CBE:  MOVLW  14
01CC0:  MOVWF  xDA
01CC2:  MOVLB  0
01CC4:  RCALL  1B66
....................    WriteReg(MICMD, 0x00); 
01CC6:  MOVLW  12
01CC8:  MOVLB  3
01CCA:  MOVWF  xDD
01CCC:  CLRF   xDE
01CCE:  MOVLB  0
01CD0:  RCALL  1B0C
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
01CD2:  MOVLW  18
01CD4:  MOVLB  3
01CD6:  MOVWF  x31
01CD8:  MOVLB  0
01CDA:  RCALL  1B9C
01CDC:  MOVFF  01,32F
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
01CE0:  MOVLW  19
01CE2:  MOVLB  3
01CE4:  MOVWF  x31
01CE6:  MOVLB  0
01CE8:  RCALL  1B9C
01CEA:  MOVFF  01,330
....................    return Result; 
01CEE:  MOVLB  3
01CF0:  MOVFF  32F,01
01CF4:  MOVFF  330,02
01CF8:  MOVLB  0
01CFA:  GOTO   1D14 (RETURN)
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
01B0C:  BCF    F94.1
01B0E:  BCF    F8B.1
....................    ENCSPIXfer(WCR | Address); 
01B10:  MOVLB  3
01B12:  MOVF   xDD,W
01B14:  IORLW  40
01B16:  MOVWF  xDF
01B18:  MOVWF  xE2
01B1A:  MOVLB  0
01B1C:  RCALL  1ABE
....................    ENCSPIXfer(Data); 
01B1E:  MOVFF  3DE,3E2
01B22:  RCALL  1ABE
....................    SPIUnselectEthernet(); 
01B24:  BCF    F94.1
01B26:  BSF    F8B.1
01B28:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01B2A:  BCF    F94.1
01B2C:  BCF    F8B.1
....................    ENCSPIXfer(BFC | Address); 
01B2E:  MOVLB  3
01B30:  MOVF   xDC,W
01B32:  IORLW  A0
01B34:  MOVWF  xDE
01B36:  MOVWF  xE2
01B38:  MOVLB  0
01B3A:  RCALL  1ABE
....................    ENCSPIXfer(Data); 
01B3C:  MOVFF  3DD,3E2
01B40:  RCALL  1ABE
....................    SPIUnselectEthernet(); 
01B42:  BCF    F94.1
01B44:  BSF    F8B.1
01B46:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01B48:  BCF    F94.1
01B4A:  BCF    F8B.1
....................    ENCSPIXfer(BFS | Address); 
01B4C:  MOVLB  3
01B4E:  MOVF   xDF,W
01B50:  IORLW  80
01B52:  MOVWF  xE1
01B54:  MOVWF  xE2
01B56:  MOVLB  0
01B58:  RCALL  1ABE
....................    ENCSPIXfer(Data); 
01B5A:  MOVFF  3E0,3E2
01B5E:  RCALL  1ABE
....................    SPIUnselectEthernet(); 
01B60:  BCF    F94.1
01B62:  BSF    F8B.1
01B64:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
01BCE:  MOVLW  02
01BD0:  MOVLB  3
01BD2:  MOVWF  xDB
01BD4:  MOVLW  14
01BD6:  MOVWF  xDA
01BD8:  MOVLB  0
01BDA:  RCALL  1B66
....................    WriteReg(MIREGADR, Register); 
01BDC:  MOVLW  14
01BDE:  MOVLB  3
01BE0:  MOVWF  xDD
01BE2:  MOVFF  32E,3DE
01BE6:  MOVLB  0
01BE8:  RCALL  1B0C
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
01BEA:  MOVLW  03
01BEC:  MOVLB  3
01BEE:  MOVWF  x32
01BF0:  MOVLW  2F
01BF2:  MOVWF  x31
01BF4:  MOVWF  FE9
01BF6:  MOVFF  332,FEA
01BFA:  MOVFF  FEF,333
01BFE:  MOVLW  16
01C00:  MOVWF  xDD
01C02:  MOVFF  333,3DE
01C06:  MOVLB  0
01C08:  RCALL  1B0C
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
01C0A:  MOVLW  03
01C0C:  MOVLB  3
01C0E:  MOVWF  x32
01C10:  MOVLW  2F
01C12:  MOVWF  x31
01C14:  MOVLW  01
01C16:  ADDWF  x31,W
01C18:  MOVWF  FE9
01C1A:  MOVLW  00
01C1C:  ADDWFC x32,W
01C1E:  MOVWF  FEA
01C20:  MOVFF  FEF,333
01C24:  MOVLW  17
01C26:  MOVWF  xDD
01C28:  MOVFF  333,3DE
01C2C:  MOVLB  0
01C2E:  RCALL  1B0C
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
01C30:  MOVLW  03
01C32:  MOVLB  3
01C34:  MOVWF  xDB
01C36:  MOVLW  0A
01C38:  MOVWF  xDA
01C3A:  MOVLB  0
01C3C:  RCALL  1B66
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
01C3E:  MOVLW  0A
01C40:  MOVLB  3
01C42:  MOVWF  x31
01C44:  MOVLB  0
01C46:  RCALL  1B9C
01C48:  MOVFF  01,331
01C4C:  MOVLW  00
01C4E:  MOVLB  3
01C50:  BTFSC  01.0
01C52:  MOVLW  01
01C54:  XORLW  00
01C56:  BTFSC  FD8.2
01C58:  BRA    1C5E
01C5A:  MOVLB  0
01C5C:  BRA    1C3E
01C5E:  MOVLB  0
01C60:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
01B66:  MOVLW  1F
01B68:  MOVLB  3
01B6A:  MOVWF  xDC
01B6C:  MOVLW  03
01B6E:  MOVWF  xDD
01B70:  MOVLB  0
01B72:  RCALL  1B2A
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
01B74:  MOVLW  03
01B76:  MOVLB  3
01B78:  MOVWF  xDD
01B7A:  MOVLW  DA
01B7C:  MOVWF  xDC
01B7E:  MOVLW  01
01B80:  ADDWF  xDC,W
01B82:  MOVWF  FE9
01B84:  MOVLW  00
01B86:  ADDWFC xDD,W
01B88:  MOVWF  FEA
01B8A:  MOVFF  FEF,3DE
01B8E:  MOVLW  1F
01B90:  MOVWF  xDF
01B92:  MOVFF  3DE,3E0
01B96:  MOVLB  0
01B98:  RCALL  1B48
01B9A:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
01CFE:  MOVLW  1F
01D00:  MOVLB  3
01D02:  MOVWF  xDC
01D04:  MOVLW  0C
01D06:  MOVWF  xDD
01D08:  MOVLB  0
01D0A:  RCALL  1B2A
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
01D0C:  MOVLB  3
01D0E:  CLRF   x2E
01D10:  MOVLB  0
01D12:  BRA    1C62
01D14:  MOVFF  02,32D
01D18:  MOVFF  01,32C
....................    if(DuplexState == USE_PHY) 
01D1C:  MOVLB  3
01D1E:  MOVF   x2A,W
01D20:  SUBLW  02
01D22:  BNZ   1D2C
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
01D24:  CLRF   x2A
01D26:  BTFSC  x2D.0
01D28:  INCF   x2A,F
....................    } 
01D2A:  BRA    1D42
....................    else 
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
01D2C:  BCF    x2D.0
01D2E:  BTFSC  x2A.0
01D30:  BSF    x2D.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
01D32:  CLRF   x2E
01D34:  MOVFF  32D,330
01D38:  MOVFF  32C,32F
01D3C:  MOVLB  0
01D3E:  RCALL  1BCE
01D40:  MOVLB  3
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
01D42:  MOVLW  02
01D44:  MOVWF  xDB
01D46:  MOVWF  xDA
01D48:  MOVLB  0
01D4A:  RCALL  1B66
....................    Register = ReadMACReg(MACON3); 
01D4C:  MOVLW  02
01D4E:  MOVLB  3
01D50:  MOVWF  x31
01D52:  MOVLB  0
01D54:  RCALL  1B9C
01D56:  MOVFF  01,32B
....................    Register.MACON3bits.FULDPX = DuplexState; 
01D5A:  MOVLB  3
01D5C:  BCF    x2B.0
01D5E:  BTFSC  x2A.0
01D60:  BSF    x2B.0
....................    WriteReg(MACON3, Register.Val); 
01D62:  MOVLW  02
01D64:  MOVWF  xDD
01D66:  MOVFF  32B,3DE
01D6A:  MOVLB  0
01D6C:  RCALL  1B0C
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
01D6E:  MOVLB  3
01D70:  MOVF   x2A,F
01D72:  BZ    1D78
01D74:  MOVLW  15
01D76:  BRA    1D7A
01D78:  MOVLW  12
01D7A:  MOVWF  x2E
01D7C:  MOVLW  04
01D7E:  MOVWF  xDD
01D80:  MOVFF  32E,3DE
01D84:  MOVLB  0
01D86:  RCALL  1B0C
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
01D88:  MOVLW  1F
01D8A:  MOVLB  3
01D8C:  MOVWF  xDF
01D8E:  MOVLW  04
01D90:  MOVWF  xE0
01D92:  MOVLB  0
01D94:  RCALL  1B48
01D96:  GOTO   1F56 (RETURN)
.................... }//end MACSetDuplex 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(char* file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
03006:  MOVLW  03
03008:  MOVLB  3
0300A:  MOVWF  x4E
0300C:  MOVLW  39
0300E:  MOVWF  x4D
03010:  MOVFF  34E,3C7
03014:  MOVWF  xC6
03016:  CLRF   xC9
03018:  MOVLW  14
0301A:  MOVWF  xC8
0301C:  MOVLB  0
0301E:  CALL   23DC
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
03022:  MOVLB  3
03024:  MOVF   x39,W
03026:  ANDLW  F0
03028:  SUBLW  40
0302A:  BZ    3032
....................     	return FALSE; 
0302C:  MOVLW  00
0302E:  MOVWF  01
03030:  BRA    30E2
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
03032:  MOVF   x39,W
03034:  ANDLW  0F
03036:  MOVWF  00
03038:  RLCF   00,W
0303A:  MOVWF  5D
0303C:  RLCF   5D,F
0303E:  MOVLW  FC
03040:  ANDWF  5D,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
03042:  CLRF   x89
03044:  CLRF   x88
03046:  CLRF   x8B
03048:  MOVFF  5D,38A
0304C:  MOVLB  0
0304E:  RCALL  2DA2
03050:  MOVFF  02,338
03054:  MOVFF  01,337
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
03058:  MOVLB  3
0305A:  CLRF   x61
0305C:  MOVFF  5D,360
03060:  MOVLB  0
03062:  RCALL  2EAA
....................  
....................     if(CalcChecksum.Val) 
03064:  MOVLB  3
03066:  MOVF   x37,W
03068:  IORWF  x38,W
0306A:  BZ    3072
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
0306C:  MOVLW  00
0306E:  MOVWF  01
03070:  BRA    30E2
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
03072:  MOVLW  03
03074:  MOVWF  xD2
03076:  MOVLW  39
03078:  MOVWF  xD1
0307A:  MOVLB  0
0307C:  RCALL  2F26
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
0307E:  MOVLB  3
03080:  MOVF   x2F,W
03082:  IORWF  x30,W
03084:  BZ    309E
....................         localIP->Val    = header.DestAddress.Val; 
03086:  MOVFF  32F,FE9
0308A:  MOVFF  330,FEA
0308E:  MOVFF  349,FEF
03092:  MOVFF  34A,FEC
03096:  MOVFF  34B,FEC
0309A:  MOVFF  34C,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
0309E:  MOVLW  06
030A0:  ADDWF  x31,W
030A2:  MOVWF  FE9
030A4:  MOVLW  00
030A6:  ADDWFC x32,W
030A8:  MOVWF  FEA
030AA:  MOVFF  345,FEF
030AE:  MOVFF  346,FEC
030B2:  MOVFF  347,FEC
030B6:  MOVFF  348,FEC
....................     *protocol           = header.Protocol; 
030BA:  MOVFF  333,FE9
030BE:  MOVFF  334,FEA
030C2:  MOVFF  342,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
030C6:  MOVFF  335,FE9
030CA:  MOVFF  336,FEA
030CE:  MOVF   5D,W
030D0:  SUBWF  x3B,W
030D2:  MOVWF  00
030D4:  MOVLW  00
030D6:  SUBWFB x3C,W
030D8:  MOVFF  00,FEF
030DC:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
030DE:  MOVLW  01
030E0:  MOVWF  01
030E2:  MOVLB  0
030E4:  GOTO   7D5E (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
03AD2:  MOVLW  14
03AD4:  MOVWF  5D
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
03AD6:  MOVLW  45
03AD8:  MOVLB  3
03ADA:  MOVWF  xBD
....................     header.TypeOfService    = IP_SERVICE; 
03ADC:  CLRF   xBE
....................     header.TotalLength      = sizeof(header) + len; 
03ADE:  MOVLW  14
03AE0:  ADDWF  xBB,W
03AE2:  MOVWF  xBF
03AE4:  MOVLW  00
03AE6:  ADDWFC xBC,W
03AE8:  MOVWF  xC0
....................     header.Identification   = ++_Identifier; 
03AEA:  INCF   5B,F
03AEC:  BTFSC  FD8.2
03AEE:  INCF   5C,F
03AF0:  MOVFF  5C,3C2
03AF4:  MOVFF  5B,3C1
....................     header.FragmentInfo     = 0; 
03AF8:  CLRF   xC4
03AFA:  CLRF   xC3
....................     header.TimeToLive       = MY_IP_TTL; 
03AFC:  MOVLW  64
03AFE:  MOVWF  xC5
....................     header.Protocol         = protocol; 
03B00:  MOVFF  3BA,3C6
....................     header.HeaderChecksum   = 0; 
03B04:  CLRF   xC8
03B06:  CLRF   xC7
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
03B08:  MOVFF  22,3CC
03B0C:  MOVFF  21,3CB
03B10:  MOVFF  20,3CA
03B14:  MOVFF  1F,3C9
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
03B18:  MOVLW  06
03B1A:  ADDWF  xB8,W
03B1C:  MOVWF  FE9
03B1E:  MOVLW  00
03B20:  ADDWFC xB9,W
03B22:  MOVWF  FEA
03B24:  MOVFF  FEF,3CD
03B28:  MOVFF  FEC,3CE
03B2C:  MOVFF  FEC,3CF
03B30:  MOVFF  FEC,3D0
....................  
....................     SwapIPHeader(&header); 
03B34:  MOVLW  03
03B36:  MOVWF  xD2
03B38:  MOVLW  BD
03B3A:  MOVWF  xD1
03B3C:  MOVLB  0
03B3E:  CALL   2F26
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
03B42:  MOVLB  3
03B44:  MOVFF  3B8,01
03B48:  MOVFF  3B9,03
03B4C:  MOVFF  3B8,3D1
03B50:  MOVFF  3B9,3D2
03B54:  MOVLW  14
03B56:  ADDWF  xBB,W
03B58:  MOVWF  xD3
03B5A:  MOVLW  00
03B5C:  ADDWFC xBC,W
03B5E:  MOVWF  xD4
03B60:  MOVFF  3B9,3D6
03B64:  MOVFF  3B8,3D5
03B68:  CLRF   xD7
03B6A:  MOVWF  xD9
03B6C:  MOVFF  3D3,3D8
03B70:  MOVLB  0
03B72:  CALL   2892
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
03B76:  MOVLW  03
03B78:  MOVLB  3
03B7A:  MOVWF  xD2
03B7C:  MOVLW  BD
03B7E:  MOVWF  xD1
03B80:  MOVFF  3D2,3DD
03B84:  MOVWF  xDC
03B86:  CLRF   xDF
03B88:  MOVLW  14
03B8A:  MOVWF  xDE
03B8C:  MOVLB  0
03B8E:  CALL   2844
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
03B92:  MOVLB  3
03B94:  CLRF   xD2
03B96:  CLRF   xD1
03B98:  CLRF   xD4
03B9A:  MOVLW  14
03B9C:  MOVWF  xD3
03B9E:  MOVLB  0
03BA0:  RCALL  39FA
03BA2:  MOVFF  02,3C8
03BA6:  MOVFF  01,3C7
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
03BAA:  MOVFF  50,3D1
03BAE:  MOVLB  3
03BB0:  CLRF   xD3
03BB2:  MOVLW  0A
03BB4:  MOVWF  xD2
03BB6:  MOVLB  0
03BB8:  CALL   2778
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
03BBC:  MOVLW  03
03BBE:  MOVLB  3
03BC0:  MOVWF  xD2
03BC2:  MOVLW  C7
03BC4:  MOVWF  xD1
03BC6:  MOVFF  3D2,3DD
03BCA:  MOVWF  xDC
03BCC:  CLRF   xDF
03BCE:  MOVLW  02
03BD0:  MOVWF  xDE
03BD2:  MOVLB  0
03BD4:  CALL   2844
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
03BD8:  MOVFF  50,3D1
03BDC:  MOVLB  3
03BDE:  CLRF   xD3
03BE0:  MOVLW  14
03BE2:  MOVWF  xD2
03BE4:  MOVLB  0
03BE6:  CALL   2778
.................... #endif 
....................  
....................     return 0x0; 
03BEA:  MOVLW  00
03BEC:  MOVWF  01
03BEE:  MOVWF  02
03BF0:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
0335A:  MOVF   5D,W
0335C:  MOVLB  3
0335E:  ADDWF  x5C,W
03360:  MOVWF  x5E
03362:  MOVLW  00
03364:  ADDWFC x5D,W
03366:  MOVWF  x5F
03368:  MOVWF  x61
0336A:  MOVFF  35E,360
0336E:  MOVLB  0
03370:  RCALL  2EAA
03372:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
02F26:  MOVLW  02
02F28:  MOVLB  3
02F2A:  ADDWF  xD1,W
02F2C:  MOVWF  01
02F2E:  MOVLW  00
02F30:  ADDWFC xD2,W
02F32:  MOVWF  03
02F34:  MOVFF  01,3D3
02F38:  MOVWF  xD4
02F3A:  MOVLW  02
02F3C:  ADDWF  xD1,W
02F3E:  MOVWF  FE9
02F40:  MOVLW  00
02F42:  ADDWFC xD2,W
02F44:  MOVWF  FEA
02F46:  MOVFF  FEC,3D6
02F4A:  MOVF   FED,F
02F4C:  MOVFF  FEF,3D5
02F50:  MOVFF  3D6,3D8
02F54:  MOVFF  3D5,3D7
02F58:  MOVLB  0
02F5A:  CALL   2440
02F5E:  MOVFF  3D4,FEA
02F62:  MOVFF  3D3,FE9
02F66:  MOVFF  02,FEC
02F6A:  MOVF   FED,F
02F6C:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
02F70:  MOVLW  04
02F72:  MOVLB  3
02F74:  ADDWF  xD1,W
02F76:  MOVWF  01
02F78:  MOVLW  00
02F7A:  ADDWFC xD2,W
02F7C:  MOVWF  03
02F7E:  MOVFF  01,3D3
02F82:  MOVWF  xD4
02F84:  MOVLW  04
02F86:  ADDWF  xD1,W
02F88:  MOVWF  FE9
02F8A:  MOVLW  00
02F8C:  ADDWFC xD2,W
02F8E:  MOVWF  FEA
02F90:  MOVFF  FEC,3D6
02F94:  MOVF   FED,F
02F96:  MOVFF  FEF,3D5
02F9A:  MOVFF  3D6,3D8
02F9E:  MOVFF  3D5,3D7
02FA2:  MOVLB  0
02FA4:  CALL   2440
02FA8:  MOVFF  3D4,FEA
02FAC:  MOVFF  3D3,FE9
02FB0:  MOVFF  02,FEC
02FB4:  MOVF   FED,F
02FB6:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
02FBA:  MOVLW  0A
02FBC:  MOVLB  3
02FBE:  ADDWF  xD1,W
02FC0:  MOVWF  01
02FC2:  MOVLW  00
02FC4:  ADDWFC xD2,W
02FC6:  MOVWF  03
02FC8:  MOVFF  01,3D3
02FCC:  MOVWF  xD4
02FCE:  MOVLW  0A
02FD0:  ADDWF  xD1,W
02FD2:  MOVWF  FE9
02FD4:  MOVLW  00
02FD6:  ADDWFC xD2,W
02FD8:  MOVWF  FEA
02FDA:  MOVFF  FEC,3D6
02FDE:  MOVF   FED,F
02FE0:  MOVFF  FEF,3D5
02FE4:  MOVFF  3D6,3D8
02FE8:  MOVFF  3D5,3D7
02FEC:  MOVLB  0
02FEE:  CALL   2440
02FF2:  MOVFF  3D4,FEA
02FF6:  MOVFF  3D3,FE9
02FFA:  MOVFF  02,FEC
02FFE:  MOVF   FED,F
03000:  MOVFF  01,FEF
03004:  RETURN 0
.................... } 
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
.................... 	TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
.................... 	WORD RemoteWindow; 
.................... 	 
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
020B2:  MOVLB  3
020B4:  CLRF   x29
020B6:  MOVF   x29,W
020B8:  SUBLW  04
020BA:  BNC   218C
....................     { 
....................         ps = &TCB[s]; 
020BC:  MOVF   x29,W
020BE:  MULLW  24
020C0:  MOVF   FF3,W
020C2:  CLRF   03
020C4:  ADDLW  60
020C6:  MOVWF  01
020C8:  MOVLW  00
020CA:  ADDWFC 03,F
020CC:  MOVFF  01,32A
020D0:  MOVFF  03,32B
....................  
....................         ps->smState             = TCP_CLOSED; 
020D4:  MOVFF  32A,FE9
020D8:  MOVFF  32B,FEA
020DC:  MOVLW  0A
020DE:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
020E0:  MOVLW  23
020E2:  ADDWF  x2A,W
020E4:  MOVWF  FE9
020E6:  MOVLW  00
020E8:  ADDWFC x2B,W
020EA:  MOVWF  FEA
020EC:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
020EE:  MOVLW  23
020F0:  ADDWF  x2A,W
020F2:  MOVWF  FE9
020F4:  MOVLW  00
020F6:  ADDWFC x2B,W
020F8:  MOVWF  FEA
020FA:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
020FC:  MOVLW  23
020FE:  ADDWF  x2A,W
02100:  MOVWF  FE9
02102:  MOVLW  00
02104:  ADDWFC x2B,W
02106:  MOVWF  FEA
02108:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
0210A:  MOVLW  23
0210C:  ADDWF  x2A,W
0210E:  MOVWF  FE9
02110:  MOVLW  00
02112:  ADDWFC x2B,W
02114:  MOVWF  FEA
02116:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
02118:  MOVLW  23
0211A:  ADDWF  x2A,W
0211C:  MOVWF  FE9
0211E:  MOVLW  00
02120:  ADDWFC x2B,W
02122:  MOVWF  FEA
02124:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
02126:  MOVLW  0F
02128:  ADDWF  x2A,W
0212A:  MOVWF  FE9
0212C:  MOVLW  00
0212E:  ADDWFC x2B,W
02130:  MOVWF  FEA
02132:  INCFSZ FEF,W
02134:  BRA    2138
02136:  BRA    2162
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
02138:  MOVLW  0F
0213A:  ADDWF  x2A,W
0213C:  MOVWF  FE9
0213E:  MOVLW  00
02140:  ADDWFC x2B,W
02142:  MOVWF  FEA
02144:  MOVFF  FEF,32C
02148:  MOVFF  32C,37C
0214C:  MOVLB  0
0214E:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
02152:  MOVLW  0F
02154:  MOVLB  3
02156:  ADDWF  x2A,W
02158:  MOVWF  FE9
0215A:  MOVLW  00
0215C:  ADDWFC x2B,W
0215E:  MOVWF  FEA
02160:  SETF   FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
02162:  MOVLW  21
02164:  ADDWF  x2A,W
02166:  MOVWF  FE9
02168:  MOVLW  00
0216A:  ADDWFC x2B,W
0216C:  MOVWF  FEA
0216E:  CLRF   FEC
02170:  MOVF   FED,F
02172:  MOVLW  1E
02174:  MOVWF  FEF
....................       ps->TxCount            = 0; 
02176:  MOVLW  10
02178:  ADDWF  x2A,W
0217A:  MOVWF  FE9
0217C:  MOVLW  00
0217E:  ADDWFC x2B,W
02180:  MOVWF  FEA
02182:  CLRF   FEC
02184:  MOVF   FED,F
02186:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
02188:  INCF   x29,F
0218A:  BRA    20B6
....................     TCPInit_RandSeed+=get_timer0(); 
0218C:  MOVF   FD6,W
0218E:  MOVLB  1
02190:  ADDWF  x14,F
02192:  MOVF   FD7,W
02194:  ADDWFC x15,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
02196:  MOVF   FCE,W
02198:  ADDWF  x14,F
0219A:  MOVF   FCF,W
0219C:  ADDWFC x15,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
0219E:  MOVF   FCC,W
021A0:  ADDWF  x14,F
021A2:  MOVLW  00
021A4:  ADDWFC x15,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
021A6:  MOVF   FB2,W
021A8:  ADDWF  x14,F
021AA:  MOVF   FB3,W
021AC:  ADDWFC x15,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
021AE:  MOVLB  3
021B0:  CLRF   x2F
021B2:  CLRF   x2E
021B4:  MOVFF  115,32D
021B8:  MOVFF  114,32C
021BC:  MOVLB  0
021BE:  BRA    1F86
....................     _NextPort=rand(); 
021C0:  BRA    2040
021C2:  MOVFF  02,5F
021C6:  MOVFF  01,5E
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
021CA:  MOVLW  04
021CC:  ADDWF  5F,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
021CE:  MOVF   5F,W
021D0:  SUBLW  12
021D2:  BC    21E8
021D4:  XORLW  FF
021D6:  BNZ   21DE
021D8:  MOVF   5E,W
021DA:  SUBLW  87
021DC:  BC    21E8
021DE:  MOVLW  88
021E0:  SUBWF  5E,F
021E2:  MOVLW  13
021E4:  SUBWFB 5F,F
021E6:  BRA    21CE
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
021E8:  MOVF   5F,W
021EA:  SUBLW  03
021EC:  BNC   21F2
021EE:  MOVLW  04
021F0:  ADDWF  5F,F
021F2:  GOTO   236A (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
021F6:  MOVLB  3
021F8:  CLRF   x2E
021FA:  MOVF   x2E,W
021FC:  SUBLW  04
021FE:  BNC   22E6
....................    { 
....................       ps = &TCB[s]; 
02200:  MOVF   x2E,W
02202:  MULLW  24
02204:  MOVF   FF3,W
02206:  CLRF   03
02208:  ADDLW  60
0220A:  MOVWF  01
0220C:  MOVLW  00
0220E:  ADDWFC 03,F
02210:  MOVFF  01,32F
02214:  MOVFF  03,330
....................  
....................       if(ps->smState == TCP_CLOSED) 
02218:  MOVFF  32F,FE9
0221C:  MOVFF  330,FEA
02220:  MOVF   FEF,W
02222:  SUBLW  0A
02224:  BNZ   22E2
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
02226:  MOVFF  32F,FE9
0222A:  MOVFF  330,FEA
0222E:  CLRF   FEF
....................          ps->localPort           = port; 
02230:  MOVLW  0B
02232:  ADDWF  x2F,W
02234:  MOVWF  FE9
02236:  MOVLW  00
02238:  ADDWFC x30,W
0223A:  MOVWF  FEA
0223C:  MOVFF  32D,FEC
02240:  MOVF   FED,F
02242:  MOVFF  32C,FEF
....................          ps->remotePort          = 0; 
02246:  MOVLW  0D
02248:  ADDWF  x2F,W
0224A:  MOVWF  FE9
0224C:  MOVLW  00
0224E:  ADDWFC x30,W
02250:  MOVWF  FEA
02252:  CLRF   FEC
02254:  MOVF   FED,F
02256:  CLRF   FEF
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
02258:  MOVLW  07
0225A:  ADDWF  x2F,W
0225C:  MOVWF  FE9
0225E:  MOVLW  00
02260:  ADDWFC x30,W
02262:  MOVWF  FEA
02264:  MOVF   FEE,F
02266:  MOVF   FEE,F
02268:  CLRF   FEC
0226A:  MOVF   FED,F
0226C:  CLRF   FEF
0226E:  MOVF   FED,F
02270:  CLRF   FEF
02272:  MOVF   FED,F
02274:  CLRF   FEF
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
02276:  MOVLW  23
02278:  ADDWF  x2F,W
0227A:  MOVWF  FE9
0227C:  MOVLW  00
0227E:  ADDWFC x30,W
02280:  MOVWF  FEA
02282:  BSF    FEF.0
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
02284:  MOVLW  23
02286:  ADDWF  x2F,W
02288:  MOVWF  FE9
0228A:  MOVLW  00
0228C:  ADDWFC x30,W
0228E:  MOVWF  FEA
02290:  BCF    FEF.3
....................          if(ps->TxBuffer != INVALID_BUFFER) 
02292:  MOVLW  0F
02294:  ADDWF  x2F,W
02296:  MOVWF  FE9
02298:  MOVLW  00
0229A:  ADDWFC x30,W
0229C:  MOVWF  FEA
0229E:  INCFSZ FEF,W
022A0:  BRA    22A4
022A2:  BRA    22CE
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
022A4:  MOVLW  0F
022A6:  ADDWF  x2F,W
022A8:  MOVWF  FE9
022AA:  MOVLW  00
022AC:  ADDWFC x30,W
022AE:  MOVWF  FEA
022B0:  MOVFF  FEF,331
022B4:  MOVFF  331,37C
022B8:  MOVLB  0
022BA:  CALL   0004
....................             ps->TxBuffer        = INVALID_BUFFER; 
022BE:  MOVLW  0F
022C0:  MOVLB  3
022C2:  ADDWF  x2F,W
022C4:  MOVWF  FE9
022C6:  MOVLW  00
022C8:  ADDWFC x30,W
022CA:  MOVWF  FEA
022CC:  SETF   FEF
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
022CE:  MOVLW  23
022D0:  ADDWF  x2F,W
022D2:  MOVWF  FE9
022D4:  MOVLW  00
022D6:  ADDWFC x30,W
022D8:  MOVWF  FEA
022DA:  BSF    FEF.1
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
022DC:  MOVFF  32E,01
022E0:  BRA    22EA
....................       } 
022E2:  INCF   x2E,F
022E4:  BRA    21FA
....................    } 
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
022E6:  MOVLW  FE
022E8:  MOVWF  01
022EA:  MOVLB  0
022EC:  GOTO   2316 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          lbFound = TRUE; 
....................          break; 
....................       } 
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
....................       return INVALID_SOCKET; 
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
....................    ps->SND_ACK = 0; 
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
....................  
....................    ps->smState = TCP_SYN_SENT; 
....................    ps->SND_SEQ++; 
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
*
05194:  MOVLB  3
05196:  MOVF   x37,W
05198:  MULLW  24
0519A:  MOVF   FF3,W
0519C:  CLRF   x39
0519E:  MOVWF  x38
051A0:  MOVLW  60
051A2:  ADDWF  x38,W
051A4:  MOVWF  FE9
051A6:  MOVLW  00
051A8:  ADDWFC x39,W
051AA:  MOVWF  FEA
051AC:  MOVF   FEF,W
051AE:  SUBLW  03
051B0:  BZ    51B6
051B2:  MOVLW  00
051B4:  BRA    51B8
051B6:  MOVLW  01
051B8:  MOVWF  01
051BA:  MOVLB  0
051BC:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
06EEA:  MOVLB  3
06EEC:  MOVF   x37,W
06EEE:  MULLW  24
06EF0:  MOVF   FF3,W
06EF2:  CLRF   03
06EF4:  ADDLW  60
06EF6:  MOVWF  01
06EF8:  MOVLW  00
06EFA:  ADDWFC 03,F
06EFC:  MOVFF  01,338
06F00:  MOVFF  03,339
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
06F04:  MOVFF  338,FE9
06F08:  MOVFF  339,FEA
06F0C:  MOVF   FEF,W
06F0E:  SUBLW  03
06F10:  BZ    6F32
06F12:  MOVFF  338,FE9
06F16:  MOVFF  339,FEA
06F1A:  MOVF   FEF,W
06F1C:  SUBLW  02
06F1E:  BZ    6F32
....................    { 
....................       CloseSocket(ps); 
06F20:  MOVFF  339,37A
06F24:  MOVFF  338,379
06F28:  MOVLB  0
06F2A:  CALL   37B8
....................       return; 
06F2E:  BRA    7022
06F30:  MOVLB  3
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
06F32:  MOVFF  337,33A
06F36:  MOVLB  0
06F38:  CALL   5EF0
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
06F3C:  MOVLW  01
06F3E:  MOVLB  3
06F40:  ADDWF  x38,W
06F42:  MOVWF  01
06F44:  MOVLW  00
06F46:  ADDWFC x39,W
06F48:  MOVWF  03
06F4A:  MOVFF  01,33A
06F4E:  MOVWF  x3B
06F50:  MOVLW  0B
06F52:  ADDWF  x38,W
06F54:  MOVWF  FE9
06F56:  MOVLW  00
06F58:  ADDWFC x39,W
06F5A:  MOVWF  FEA
06F5C:  MOVFF  FEC,33D
06F60:  MOVF   FED,F
06F62:  MOVFF  FEF,33C
06F66:  MOVLW  0D
06F68:  ADDWF  x38,W
06F6A:  MOVWF  FE9
06F6C:  MOVLW  00
06F6E:  ADDWFC x39,W
06F70:  MOVWF  FEA
06F72:  MOVFF  FEC,33F
06F76:  MOVF   FED,F
06F78:  MOVFF  FEF,33E
06F7C:  MOVLW  16
06F7E:  ADDWF  x38,W
06F80:  MOVWF  FE9
06F82:  MOVLW  00
06F84:  ADDWFC x39,W
06F86:  MOVWF  FEA
06F88:  MOVFF  FEF,340
06F8C:  MOVFF  FEC,341
06F90:  MOVFF  FEC,342
06F94:  MOVFF  FEC,343
06F98:  MOVLW  1A
06F9A:  ADDWF  x38,W
06F9C:  MOVWF  FE9
06F9E:  MOVLW  00
06FA0:  ADDWFC x39,W
06FA2:  MOVWF  FEA
06FA4:  MOVFF  FEF,344
06FA8:  MOVFF  FEC,345
06FAC:  MOVFF  FEC,346
06FB0:  MOVFF  FEC,347
06FB4:  MOVFF  03,381
06FB8:  MOVFF  01,380
06FBC:  MOVFF  33D,383
06FC0:  MOVFF  33C,382
06FC4:  MOVFF  33F,385
06FC8:  MOVFF  33E,384
06FCC:  MOVFF  343,389
06FD0:  MOVFF  342,388
06FD4:  MOVFF  341,387
06FD8:  MOVFF  340,386
06FDC:  MOVFF  347,38D
06FE0:  MOVFF  346,38C
06FE4:  MOVFF  345,38B
06FE8:  MOVFF  344,38A
06FEC:  MOVLW  11
06FEE:  MOVWF  x8E
06FF0:  SETF   x8F
06FF2:  CLRF   x91
06FF4:  CLRF   x90
06FF6:  MOVLB  0
06FF8:  CALL   3BF2
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
06FFC:  MOVLW  16
06FFE:  MOVLB  3
07000:  ADDWF  x38,W
07002:  MOVWF  FE9
07004:  MOVLW  00
07006:  ADDWFC x39,W
07008:  MOVWF  FEA
0700A:  MOVLW  01
0700C:  ADDWF  FEE,F
0700E:  MOVLW  00
07010:  ADDWFC FEE,F
07012:  ADDWFC FEE,F
07014:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
07016:  MOVFF  338,FE9
0701A:  MOVFF  339,FEA
0701E:  MOVLW  04
07020:  MOVWF  FEF
07022:  MOVLB  0
....................  
....................    return; 
07024:  GOTO   7C8C (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
05FE2:  MOVLB  3
05FE4:  MOVF   x6C,W
05FE6:  MULLW  24
05FE8:  MOVF   FF3,W
05FEA:  CLRF   03
05FEC:  ADDLW  60
05FEE:  MOVWF  01
05FF0:  MOVLW  00
05FF2:  ADDWFC 03,F
05FF4:  MOVFF  01,36D
05FF8:  MOVFF  03,36E
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
05FFC:  MOVLW  0F
05FFE:  ADDWF  x6D,W
06000:  MOVWF  FE9
06002:  MOVLW  00
06004:  ADDWFC x6E,W
06006:  MOVWF  FEA
06008:  INCFSZ FEF,W
0600A:  BRA    6012
....................       return FALSE; 
0600C:  MOVLW  00
0600E:  MOVWF  01
06010:  BRA    61A8
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
06012:  MOVLW  23
06014:  ADDWF  x6D,W
06016:  MOVWF  FE9
06018:  MOVLW  00
0601A:  ADDWFC x6E,W
0601C:  MOVWF  FEA
0601E:  MOVFF  FEF,00
06022:  RRCF   00,W
06024:  ANDLW  01
06026:  BNZ   602E
....................       return FALSE; 
06028:  MOVLW  00
0602A:  MOVWF  01
0602C:  BRA    61A8
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
0602E:  MOVLW  01
06030:  ADDWF  x6D,W
06032:  MOVWF  01
06034:  MOVLW  00
06036:  ADDWFC x6E,W
06038:  MOVWF  03
0603A:  MOVFF  01,36F
0603E:  MOVWF  x70
06040:  MOVLW  0B
06042:  ADDWF  x6D,W
06044:  MOVWF  FE9
06046:  MOVLW  00
06048:  ADDWFC x6E,W
0604A:  MOVWF  FEA
0604C:  MOVFF  FEC,372
06050:  MOVF   FED,F
06052:  MOVFF  FEF,371
06056:  MOVLW  0D
06058:  ADDWF  x6D,W
0605A:  MOVWF  FE9
0605C:  MOVLW  00
0605E:  ADDWFC x6E,W
06060:  MOVWF  FEA
06062:  MOVFF  FEC,374
06066:  MOVF   FED,F
06068:  MOVFF  FEF,373
0606C:  MOVLW  16
0606E:  ADDWF  x6D,W
06070:  MOVWF  FE9
06072:  MOVLW  00
06074:  ADDWFC x6E,W
06076:  MOVWF  FEA
06078:  MOVFF  FEF,375
0607C:  MOVFF  FEC,376
06080:  MOVFF  FEC,377
06084:  MOVFF  FEC,378
06088:  MOVLW  1A
0608A:  ADDWF  x6D,W
0608C:  MOVWF  FE9
0608E:  MOVLW  00
06090:  ADDWFC x6E,W
06092:  MOVWF  FEA
06094:  MOVFF  FEF,379
06098:  MOVFF  FEC,37A
0609C:  MOVFF  FEC,37B
060A0:  MOVFF  FEC,37C
060A4:  MOVLW  0F
060A6:  ADDWF  x6D,W
060A8:  MOVWF  FE9
060AA:  MOVLW  00
060AC:  ADDWFC x6E,W
060AE:  MOVWF  FEA
060B0:  MOVFF  FEF,37D
060B4:  MOVLW  10
060B6:  ADDWF  x6D,W
060B8:  MOVWF  FE9
060BA:  MOVLW  00
060BC:  ADDWFC x6E,W
060BE:  MOVWF  FEA
060C0:  MOVFF  FEC,37F
060C4:  MOVF   FED,F
060C6:  MOVFF  FEF,37E
060CA:  MOVFF  03,381
060CE:  MOVFF  01,380
060D2:  MOVFF  372,383
060D6:  MOVFF  371,382
060DA:  MOVFF  374,385
060DE:  MOVFF  373,384
060E2:  MOVFF  378,389
060E6:  MOVFF  377,388
060EA:  MOVFF  376,387
060EE:  MOVFF  375,386
060F2:  MOVFF  37C,38D
060F6:  MOVFF  37B,38C
060FA:  MOVFF  37A,38B
060FE:  MOVFF  379,38A
06102:  MOVLW  18
06104:  MOVWF  x8E
06106:  MOVFF  37D,38F
0610A:  MOVFF  37F,391
0610E:  MOVFF  37E,390
06112:  MOVLB  0
06114:  CALL   3BF2
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
06118:  MOVLW  16
0611A:  MOVLB  3
0611C:  ADDWF  x6D,W
0611E:  MOVWF  01
06120:  MOVLW  00
06122:  ADDWFC x6E,W
06124:  MOVWF  03
06126:  MOVFF  01,36F
0612A:  MOVWF  x70
0612C:  MOVWF  FEA
0612E:  MOVFF  01,FE9
06132:  MOVFF  FEF,371
06136:  MOVFF  FEC,372
0613A:  MOVFF  FEC,373
0613E:  MOVFF  FEC,374
06142:  MOVLW  10
06144:  ADDWF  x6D,W
06146:  MOVWF  FE9
06148:  MOVLW  00
0614A:  ADDWFC x6E,W
0614C:  MOVWF  FEA
0614E:  MOVFF  FEC,03
06152:  MOVF   FED,F
06154:  MOVFF  FEF,00
06158:  MOVFF  03,01
0615C:  CLRF   02
0615E:  CLRF   03
06160:  MOVF   x71,W
06162:  ADDWF  00,F
06164:  MOVF   x72,W
06166:  ADDWFC 01,F
06168:  MOVF   x73,W
0616A:  ADDWFC 02,F
0616C:  MOVF   x74,W
0616E:  ADDWFC 03,F
06170:  MOVFF  370,FEA
06174:  MOVFF  36F,FE9
06178:  MOVFF  00,FEF
0617C:  MOVFF  01,FEC
06180:  MOVFF  02,FEC
06184:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
06188:  MOVLW  23
0618A:  ADDWF  x6D,W
0618C:  MOVWF  FE9
0618E:  MOVLW  00
06190:  ADDWFC x6E,W
06192:  MOVWF  FEA
06194:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
06196:  MOVLW  23
06198:  ADDWF  x6D,W
0619A:  MOVWF  FE9
0619C:  MOVLW  00
0619E:  ADDWFC x6E,W
061A0:  MOVWF  FEA
061A2:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
061A4:  MOVLW  01
061A6:  MOVWF  01
061A8:  MOVLB  0
061AA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
05F3E:  MOVLB  3
05F40:  MOVF   x5A,W
05F42:  MULLW  24
05F44:  MOVF   FF3,W
05F46:  CLRF   x5C
05F48:  MOVWF  x5B
05F4A:  MOVLW  14
05F4C:  ADDWF  x5B,W
05F4E:  MOVWF  01
05F50:  MOVLW  00
05F52:  ADDWFC x5C,W
05F54:  MOVWF  03
05F56:  MOVF   01,W
05F58:  ADDLW  60
05F5A:  MOVWF  FE9
05F5C:  MOVLW  00
05F5E:  ADDWFC 03,W
05F60:  MOVWF  FEA
05F62:  MOVFF  FEC,35C
05F66:  MOVF   FED,F
05F68:  MOVFF  FEF,35B
05F6C:  MOVF   x5B,F
05F6E:  BNZ   5F7A
05F70:  MOVF   x5C,F
05F72:  BNZ   5F7A
....................       return FALSE; 
05F74:  MOVLW  00
05F76:  MOVWF  01
05F78:  BRA    5FD6
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
05F7A:  MOVF   x5A,W
05F7C:  MULLW  24
05F7E:  MOVF   FF3,W
05F80:  CLRF   x5C
05F82:  MOVWF  x5B
05F84:  MOVLW  0F
05F86:  ADDWF  x5B,W
05F88:  MOVWF  01
05F8A:  MOVLW  00
05F8C:  ADDWFC x5C,W
05F8E:  MOVWF  03
05F90:  MOVF   01,W
05F92:  ADDLW  60
05F94:  MOVWF  FE9
05F96:  MOVLW  00
05F98:  ADDWFC 03,W
05F9A:  MOVWF  FEA
05F9C:  INCFSZ FEF,W
05F9E:  BRA    5FB0
....................       return IPIsTxReady(FALSE); 
05FA0:  CLRF   xB8
05FA2:  MOVLB  0
05FA4:  CALL   38BA
05FA8:  MOVF   01,W
05FAA:  MOVLB  3
05FAC:  BRA    5FD6
05FAE:  BRA    5FD6
....................    else 
....................       return TCB[s].Flags.bIsPutReady; 
05FB0:  MOVF   x5A,W
05FB2:  MULLW  24
05FB4:  MOVF   FF3,W
05FB6:  CLRF   x5C
05FB8:  MOVWF  x5B
05FBA:  MOVLW  23
05FBC:  ADDWF  x5B,F
05FBE:  MOVLW  00
05FC0:  ADDWFC x5C,F
05FC2:  MOVLW  60
05FC4:  ADDWF  x5B,W
05FC6:  MOVWF  FE9
05FC8:  MOVLW  00
05FCA:  ADDWFC x5C,W
05FCC:  MOVWF  FEA
05FCE:  MOVLW  00
05FD0:  BTFSC  FEF.1
05FD2:  MOVLW  01
05FD4:  MOVWF  01
05FD6:  MOVLB  0
05FD8:  RETURN 0
.................... } 
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
*
06448:  MOVFF  355,35A
0644C:  RCALL  5F3E
0644E:  MOVF   01,F
06450:  BNZ   645A
....................       return(0); 
06452:  MOVLW  00
06454:  MOVWF  01
06456:  MOVWF  02
06458:  BRA    653E
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
0645A:  MOVLB  3
0645C:  MOVF   x55,W
0645E:  MULLW  24
06460:  MOVF   FF3,W
06462:  CLRF   x5B
06464:  MOVWF  x5A
06466:  MOVLW  0F
06468:  ADDWF  x5A,W
0646A:  MOVWF  01
0646C:  MOVLW  00
0646E:  ADDWFC x5B,W
06470:  MOVWF  03
06472:  MOVF   01,W
06474:  ADDLW  60
06476:  MOVWF  FE9
06478:  MOVLW  00
0647A:  ADDWFC 03,W
0647C:  MOVWF  FEA
0647E:  INCFSZ FEF,W
06480:  BRA    6488
....................       txCount = 0; 
06482:  CLRF   x57
06484:  CLRF   x56
06486:  BRA    64B4
....................    else 
....................       txCount = TCB[s].TxCount; 
06488:  MOVF   x55,W
0648A:  MULLW  24
0648C:  MOVF   FF3,W
0648E:  CLRF   x5B
06490:  MOVWF  x5A
06492:  MOVLW  10
06494:  ADDWF  x5A,W
06496:  MOVWF  01
06498:  MOVLW  00
0649A:  ADDWFC x5B,W
0649C:  MOVWF  03
0649E:  MOVF   01,W
064A0:  ADDLW  60
064A2:  MOVWF  FE9
064A4:  MOVLW  00
064A6:  ADDWFC 03,W
064A8:  MOVWF  FEA
064AA:  MOVFF  FEC,357
064AE:  MOVF   FED,F
064B0:  MOVFF  FEF,356
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
064B4:  MOVLW  CA
064B6:  BSF    FD8.0
064B8:  SUBFWB x56,W
064BA:  MOVWF  x58
064BC:  MOVLW  03
064BE:  SUBFWB x57,W
064C0:  MOVWF  x59
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
064C2:  MOVF   x55,W
064C4:  MULLW  24
064C6:  MOVF   FF3,W
064C8:  CLRF   x5B
064CA:  MOVWF  x5A
064CC:  MOVLW  14
064CE:  ADDWF  x5A,W
064D0:  MOVWF  01
064D2:  MOVLW  00
064D4:  ADDWFC x5B,W
064D6:  MOVWF  03
064D8:  MOVF   01,W
064DA:  ADDLW  60
064DC:  MOVWF  FE9
064DE:  MOVLW  00
064E0:  ADDWFC 03,W
064E2:  MOVWF  FEA
064E4:  MOVFF  FEC,03
064E8:  MOVF   FED,F
064EA:  MOVFF  FEF,01
064EE:  MOVF   03,W
064F0:  SUBWF  x59,W
064F2:  BNC   6528
064F4:  BNZ   64FC
064F6:  MOVF   x58,W
064F8:  SUBWF  01,W
064FA:  BC    6528
064FC:  MOVF   x55,W
064FE:  MULLW  24
06500:  MOVF   FF3,W
06502:  CLRF   x5B
06504:  MOVWF  x5A
06506:  MOVLW  14
06508:  ADDWF  x5A,W
0650A:  MOVWF  01
0650C:  MOVLW  00
0650E:  ADDWFC x5B,W
06510:  MOVWF  03
06512:  MOVF   01,W
06514:  ADDLW  60
06516:  MOVWF  FE9
06518:  MOVLW  00
0651A:  ADDWFC 03,W
0651C:  MOVWF  FEA
0651E:  MOVFF  FEC,03
06522:  MOVF   FED,F
06524:  MOVF   FEF,W
06526:  BRA    652E
06528:  MOVFF  359,03
0652C:  MOVF   x58,W
0652E:  MOVWF  x58
06530:  MOVFF  03,359
....................  
....................    return(txAvail); 
06534:  MOVFF  358,01
06538:  MOVFF  359,02
0653C:  MOVLB  0
0653E:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return 0; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return 0; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    while (n--) 
....................    { 
....................       MACPut(*ptr++); 
....................       ps->RemoteWindow -= 1; 
....................       ps->TxCount += 1; 
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return(len); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
*
061AC:  MOVLB  3
061AE:  MOVF   x66,W
061B0:  MULLW  24
061B2:  MOVF   FF3,W
061B4:  CLRF   03
061B6:  ADDLW  60
061B8:  MOVWF  01
061BA:  MOVLW  00
061BC:  ADDWFC 03,F
061BE:  MOVFF  01,368
061C2:  MOVFF  03,369
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
061C6:  MOVLW  14
061C8:  ADDWF  x68,W
061CA:  MOVWF  FE9
061CC:  MOVLW  00
061CE:  ADDWFC x69,W
061D0:  MOVWF  FEA
061D2:  MOVFF  FEC,36D
061D6:  MOVF   FED,F
061D8:  MOVFF  FEF,36C
061DC:  MOVF   x6C,F
061DE:  BNZ   61EA
061E0:  MOVF   x6D,F
061E2:  BNZ   61EA
....................       return FALSE; 
061E4:  MOVLW  00
061E6:  MOVWF  01
061E8:  BRA    62EC
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
061EA:  MOVLW  0F
061EC:  ADDWF  x68,W
061EE:  MOVWF  FE9
061F0:  MOVLW  00
061F2:  ADDWFC x69,W
061F4:  MOVWF  FEA
061F6:  INCFSZ FEF,W
061F8:  BRA    626C
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
061FA:  MOVLW  0F
061FC:  ADDWF  x68,W
061FE:  MOVWF  01
06200:  MOVLW  00
06202:  ADDWFC x69,W
06204:  MOVWF  03
06206:  MOVFF  01,36C
0620A:  MOVWF  x6D
0620C:  CLRF   xB8
0620E:  MOVLB  0
06210:  CALL   2750
06214:  MOVFF  36D,FEA
06218:  MOVFF  36C,FE9
0621C:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
06220:  MOVLW  0F
06222:  MOVLB  3
06224:  ADDWF  x68,W
06226:  MOVWF  FE9
06228:  MOVLW  00
0622A:  ADDWFC x69,W
0622C:  MOVWF  FEA
0622E:  INCFSZ FEF,W
06230:  BRA    6238
....................          return FALSE; 
06232:  MOVLW  00
06234:  MOVWF  01
06236:  BRA    62EC
....................  
....................       ps->TxCount = 0; 
06238:  MOVLW  10
0623A:  ADDWF  x68,W
0623C:  MOVWF  FE9
0623E:  MOVLW  00
06240:  ADDWFC x69,W
06242:  MOVWF  FEA
06244:  CLRF   FEC
06246:  MOVF   FED,F
06248:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
0624A:  MOVLW  0F
0624C:  ADDWF  x68,W
0624E:  MOVWF  FE9
06250:  MOVLW  00
06252:  ADDWFC x69,W
06254:  MOVWF  FEA
06256:  MOVFF  FEF,36C
0625A:  MOVFF  36C,3D1
0625E:  CLRF   xD3
06260:  MOVLW  28
06262:  MOVWF  xD2
06264:  MOVLB  0
06266:  CALL   2778
0626A:  MOVLB  3
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
0626C:  MOVLW  23
0626E:  ADDWF  x68,W
06270:  MOVWF  FE9
06272:  MOVLW  00
06274:  ADDWFC x69,W
06276:  MOVWF  FEA
06278:  BSF    FEF.4
....................  
....................    MACPut(byte); 
0627A:  MOVFF  367,3DB
0627E:  MOVLB  0
06280:  CALL   2826
....................    ps->RemoteWindow--; 
06284:  MOVLW  14
06286:  MOVLB  3
06288:  ADDWF  x68,W
0628A:  MOVWF  FE9
0628C:  MOVLW  00
0628E:  ADDWFC x69,W
06290:  MOVWF  FEA
06292:  MOVLW  FF
06294:  ADDWF  FEF,F
06296:  BC    629C
06298:  MOVF   FEE,F
0629A:  DECF   FED,F
....................  
....................    tempCount = ps->TxCount; 
0629C:  MOVLW  10
0629E:  ADDWF  x68,W
062A0:  MOVWF  FE9
062A2:  MOVLW  00
062A4:  ADDWFC x69,W
062A6:  MOVWF  FEA
062A8:  MOVFF  FEC,36B
062AC:  MOVF   FED,F
062AE:  MOVFF  FEF,36A
....................    tempCount++; 
062B2:  INCF   x6A,F
062B4:  BTFSC  FD8.2
062B6:  INCF   x6B,F
....................    ps->TxCount = tempCount; 
062B8:  MOVLW  10
062BA:  ADDWF  x68,W
062BC:  MOVWF  FE9
062BE:  MOVLW  00
062C0:  ADDWFC x69,W
062C2:  MOVWF  FEA
062C4:  MOVFF  36B,FEC
062C8:  MOVF   FED,F
062CA:  MOVFF  36A,FEF
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
062CE:  MOVF   x6B,W
062D0:  SUBLW  02
062D2:  BC    62E8
062D4:  XORLW  FF
062D6:  BNZ   62DE
062D8:  MOVF   x6A,W
062DA:  SUBLW  C9
062DC:  BC    62E8
....................       TCPFlush(s); 
062DE:  MOVFF  366,36C
062E2:  MOVLB  0
062E4:  RCALL  5FE2
062E6:  MOVLB  3
....................  
....................    return TRUE; 
062E8:  MOVLW  01
062EA:  MOVWF  01
062EC:  MOVLB  0
062EE:  GOTO   62FC (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
05EF0:  MOVLB  3
05EF2:  MOVF   x3A,W
05EF4:  MULLW  24
05EF6:  MOVF   FF3,W
05EF8:  CLRF   03
05EFA:  ADDLW  60
05EFC:  MOVWF  01
05EFE:  MOVLW  00
05F00:  ADDWFC 03,F
05F02:  MOVFF  01,33B
05F06:  MOVFF  03,33C
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
05F0A:  MOVLW  23
05F0C:  ADDWF  x3B,W
05F0E:  MOVWF  FE9
05F10:  MOVLW  00
05F12:  ADDWFC x3C,W
05F14:  MOVWF  FEA
05F16:  BTFSC  FEF.3
05F18:  BRA    5F20
....................         return FALSE; 
05F1A:  MOVLW  00
05F1C:  MOVWF  01
05F1E:  BRA    5F3A
....................  
....................     MACDiscardRx(); 
05F20:  MOVLB  0
05F22:  CALL   2370
....................     ps->Flags.bIsGetReady = FALSE; 
05F26:  MOVLW  23
05F28:  MOVLB  3
05F2A:  ADDWF  x3B,W
05F2C:  MOVWF  FE9
05F2E:  MOVLW  00
05F30:  ADDWFC x3C,W
05F32:  MOVWF  FEA
05F34:  BCF    FEF.3
....................  
....................     return TRUE; 
05F36:  MOVLW  01
05F38:  MOVWF  01
05F3A:  MOVLB  0
05F3C:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
051EA:  MOVLB  3
051EC:  MOVF   x37,W
051EE:  MULLW  24
051F0:  MOVF   FF3,W
051F2:  CLRF   03
051F4:  ADDLW  60
051F6:  MOVWF  01
051F8:  MOVLW  00
051FA:  ADDWFC 03,F
051FC:  MOVFF  01,33A
05200:  MOVFF  03,33B
....................  
....................     if ( ps->Flags.bIsGetReady ) 
05204:  MOVLW  23
05206:  ADDWF  x3A,W
05208:  MOVWF  FE9
0520A:  MOVLW  00
0520C:  ADDWFC x3B,W
0520E:  MOVWF  FEA
05210:  BTFSS  FEF.3
05212:  BRA    52B6
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
05214:  MOVLW  23
05216:  ADDWF  x3A,W
05218:  MOVWF  FE9
0521A:  MOVLW  00
0521C:  ADDWFC x3B,W
0521E:  MOVWF  FEA
05220:  BTFSS  FEF.2
05222:  BRA    5240
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
05224:  CLRF   x5D
05226:  MOVLW  14
05228:  MOVWF  x5C
0522A:  MOVLB  0
0522C:  CALL   335A
....................  
....................             ps->Flags.bFirstRead = FALSE; 
05230:  MOVLW  23
05232:  MOVLB  3
05234:  ADDWF  x3A,W
05236:  MOVWF  FE9
05238:  MOVLW  00
0523A:  ADDWFC x3B,W
0523C:  MOVWF  FEA
0523E:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
05240:  MOVLW  12
05242:  ADDWF  x3A,W
05244:  MOVWF  FE9
05246:  MOVLW  00
05248:  ADDWFC x3B,W
0524A:  MOVWF  FEA
0524C:  MOVFF  FEC,33D
05250:  MOVF   FED,F
05252:  MOVFF  FEF,33C
05256:  MOVF   x3C,F
05258:  BNZ   527A
0525A:  MOVF   x3D,F
0525C:  BNZ   527A
....................         { 
....................             MACDiscardRx(); 
0525E:  MOVLB  0
05260:  CALL   2370
....................             ps->Flags.bIsGetReady = FALSE; 
05264:  MOVLW  23
05266:  MOVLB  3
05268:  ADDWF  x3A,W
0526A:  MOVWF  FE9
0526C:  MOVLW  00
0526E:  ADDWFC x3B,W
05270:  MOVWF  FEA
05272:  BCF    FEF.3
....................             return FALSE; 
05274:  MOVLW  00
05276:  MOVWF  01
05278:  BRA    52BA
....................         } 
....................  
....................          ps->RxCount--; 
0527A:  MOVLW  12
0527C:  ADDWF  x3A,W
0527E:  MOVWF  FE9
05280:  MOVLW  00
05282:  ADDWFC x3B,W
05284:  MOVWF  FEA
05286:  MOVLW  FF
05288:  ADDWF  FEF,F
0528A:  BC    5290
0528C:  MOVF   FEE,F
0528E:  DECF   FED,F
....................          *data = MACGet(); 
05290:  MOVFF  339,03
05294:  MOVFF  338,33C
05298:  MOVFF  339,33D
0529C:  MOVLB  0
0529E:  CALL   31D6
052A2:  MOVFF  33D,FEA
052A6:  MOVFF  33C,FE9
052AA:  MOVFF  01,FEF
....................         return TRUE; 
052AE:  MOVLW  01
052B0:  MOVWF  01
052B2:  MOVLB  3
052B4:  BRA    52BA
....................     } 
....................     return FALSE; 
052B6:  MOVLW  00
052B8:  MOVWF  01
052BA:  MOVLB  0
052BC:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
051BE:  MOVLB  3
051C0:  MOVF   x37,W
051C2:  MULLW  24
051C4:  MOVF   FF3,W
051C6:  CLRF   x39
051C8:  MOVWF  x38
051CA:  MOVLW  23
051CC:  ADDWF  x38,F
051CE:  MOVLW  00
051D0:  ADDWFC x39,F
051D2:  MOVLW  60
051D4:  ADDWF  x38,W
051D6:  MOVWF  FE9
051D8:  MOVLW  00
051DA:  ADDWFC x39,W
051DC:  MOVWF  FEA
051DE:  MOVLW  00
051E0:  BTFSC  FEF.3
051E2:  MOVLW  01
051E4:  MOVWF  01
051E6:  MOVLB  0
051E8:  RETURN 0
.................... } 
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
04CD4:  MOVLB  3
04CD6:  CLRF   x3A
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
04CD8:  CLRF   x2F
04CDA:  MOVF   x2F,W
04CDC:  SUBLW  04
04CDE:  BTFSS  FD8.0
04CE0:  BRA    514C
....................    { 
....................       ps = &TCB[s]; 
04CE2:  MOVF   x2F,W
04CE4:  MULLW  24
04CE6:  MOVF   FF3,W
04CE8:  CLRF   03
04CEA:  ADDLW  60
04CEC:  MOVWF  01
04CEE:  MOVLW  00
04CF0:  ADDWFC 03,F
04CF2:  MOVFF  01,334
04CF6:  MOVFF  03,335
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
04CFA:  MOVLW  23
04CFC:  ADDWF  x34,W
04CFE:  MOVWF  FE9
04D00:  MOVLW  00
04D02:  ADDWFC x35,W
04D04:  MOVWF  FEA
04D06:  BTFSC  FEF.3
04D08:  BRA    4D1A
04D0A:  MOVLW  23
04D0C:  ADDWF  x34,W
04D0E:  MOVWF  FE9
04D10:  MOVLW  00
04D12:  ADDWFC x35,W
04D14:  MOVWF  FEA
04D16:  BTFSS  FEF.4
04D18:  BRA    4D1C
....................          continue; 
04D1A:  BRA    5148
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
04D1C:  MOVFF  334,FE9
04D20:  MOVFF  335,FEA
04D24:  MOVF   FEF,W
04D26:  SUBLW  0A
04D28:  BZ    4D4A
04D2A:  MOVFF  334,FE9
04D2E:  MOVFF  335,FEA
04D32:  MOVF   FEF,F
04D34:  BNZ   4D4C
04D36:  MOVLW  23
04D38:  ADDWF  x34,W
04D3A:  MOVWF  FE9
04D3C:  MOVLW  00
04D3E:  ADDWFC x35,W
04D40:  MOVWF  FEA
04D42:  MOVF   FEF,W
04D44:  ANDLW  01
04D46:  SUBLW  01
04D48:  BNZ   4D4C
....................          continue; 
04D4A:  BRA    5148
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
04D4C:  MOVFF  334,FE9
04D50:  MOVFF  335,FEA
04D54:  MOVF   FEF,W
04D56:  SUBLW  03
04D58:  BNZ   4D70
04D5A:  MOVLW  23
04D5C:  ADDWF  x34,W
04D5E:  MOVWF  FE9
04D60:  MOVLW  00
04D62:  ADDWFC x35,W
04D64:  MOVWF  FEA
04D66:  MOVF   FEF,W
04D68:  ANDLW  01
04D6A:  SUBLW  01
04D6C:  BNZ   4D70
....................          continue; 
04D6E:  BRA    5148
....................  
....................  
....................       tick = TickGet(); 
04D70:  MOVLB  0
04D72:  CALL   379E
04D76:  MOVFF  02,333
04D7A:  MOVFF  01,332
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
04D7E:  MOVLW  1F
04D80:  MOVLB  3
04D82:  ADDWF  x34,W
04D84:  MOVWF  FE9
04D86:  MOVLW  00
04D88:  ADDWFC x35,W
04D8A:  MOVWF  FEA
04D8C:  MOVFF  FEC,03
04D90:  MOVF   FED,F
04D92:  MOVFF  FEF,01
04D96:  MOVF   x33,W
04D98:  SUBWF  03,W
04D9A:  BNC   4DA4
04D9C:  BNZ   4DA8
04D9E:  MOVF   01,W
04DA0:  SUBWF  x32,W
04DA2:  BNC   4DA8
04DA4:  MOVLW  00
04DA6:  BRA    4DAA
04DA8:  MOVLW  01
04DAA:  CLRF   03
04DAC:  IORWF  03,W
04DAE:  BZ    4DE6
04DB0:  MOVLW  1F
04DB2:  ADDWF  x34,W
04DB4:  MOVWF  FE9
04DB6:  MOVLW  00
04DB8:  ADDWFC x35,W
04DBA:  MOVWF  FEA
04DBC:  MOVFF  FEC,03
04DC0:  MOVF   FED,F
04DC2:  MOVF   FEF,W
04DC4:  SUBLW  FF
04DC6:  MOVWF  x3B
04DC8:  MOVLW  FF
04DCA:  SUBFWB 03,W
04DCC:  MOVWF  x3C
04DCE:  MOVF   x32,W
04DD0:  ADDWF  x3B,F
04DD2:  MOVF   x33,W
04DD4:  ADDWFC x3C,F
04DD6:  MOVLW  01
04DD8:  ADDWF  x3B,W
04DDA:  MOVWF  01
04DDC:  MOVLW  00
04DDE:  ADDWFC x3C,W
04DE0:  MOVWF  03
04DE2:  MOVF   01,W
04DE4:  BRA    4E06
04DE6:  MOVLW  1F
04DE8:  ADDWF  x34,W
04DEA:  MOVWF  FE9
04DEC:  MOVLW  00
04DEE:  ADDWFC x35,W
04DF0:  MOVWF  FEA
04DF2:  MOVFF  FEC,03
04DF6:  MOVF   FED,F
04DF8:  MOVF   FEF,W
04DFA:  SUBWF  x32,W
04DFC:  MOVWF  00
04DFE:  MOVF   03,W
04E00:  SUBWFB x33,W
04E02:  MOVWF  03
04E04:  MOVF   00,W
04E06:  MOVWF  x30
04E08:  MOVFF  03,331
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
04E0C:  MOVLW  21
04E0E:  ADDWF  x34,W
04E10:  MOVWF  FE9
04E12:  MOVLW  00
04E14:  ADDWFC x35,W
04E16:  MOVWF  FEA
04E18:  MOVFF  FEC,03
04E1C:  MOVF   FED,F
04E1E:  MOVFF  FEF,01
04E22:  MOVF   x31,W
04E24:  SUBWF  03,W
04E26:  BNC   4E32
04E28:  BNZ   4E30
04E2A:  MOVF   x30,W
04E2C:  SUBWF  01,W
04E2E:  BNC   4E32
....................          continue; 
04E30:  BRA    5148
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
04E32:  MOVLW  01
04E34:  MOVWF  xB8
04E36:  MOVLB  0
04E38:  CALL   38BA
04E3C:  MOVF   01,F
04E3E:  BNZ   4E42
....................          return; 
04E40:  BRA    514C
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
04E42:  MOVLW  1F
04E44:  MOVLB  3
04E46:  ADDWF  x34,W
04E48:  MOVWF  01
04E4A:  MOVLW  00
04E4C:  ADDWFC x35,W
04E4E:  MOVWF  03
04E50:  MOVFF  01,33B
04E54:  MOVWF  x3C
04E56:  MOVLB  0
04E58:  CALL   379E
04E5C:  MOVFF  33C,FEA
04E60:  MOVFF  33B,FE9
04E64:  MOVFF  02,FEC
04E68:  MOVF   FED,F
04E6A:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
04E6E:  MOVLW  21
04E70:  MOVLB  3
04E72:  ADDWF  x34,W
04E74:  MOVWF  FE9
04E76:  MOVLW  00
04E78:  ADDWFC x35,W
04E7A:  MOVWF  FEA
04E7C:  BCF    FD8.0
04E7E:  RLCF   FEF,W
04E80:  MOVWF  02
04E82:  RLCF   FEC,W
04E84:  MOVWF  03
04E86:  MOVF   02,W
04E88:  MOVF   FED,F
04E8A:  MOVWF  FEF
04E8C:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
04E90:  MOVLW  1E
04E92:  ADDWF  x34,W
04E94:  MOVWF  FE9
04E96:  MOVLW  00
04E98:  ADDWFC x35,W
04E9A:  MOVWF  FEA
04E9C:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
04E9E:  MOVFF  334,FE9
04EA2:  MOVFF  335,FEA
04EA6:  MOVLW  01
04EA8:  SUBWF  FEF,W
04EAA:  ADDLW  F7
04EAC:  BTFSC  FD8.0
04EAE:  BRA    503E
04EB0:  ADDLW  09
04EB2:  MOVLB  0
04EB4:  GOTO   5152
....................       { 
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
04EB8:  MOVLW  02
04EBA:  MOVLB  3
04EBC:  MOVWF  x3A
....................          break; 
04EBE:  BRA    503E
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
04EC0:  MOVLW  1E
04EC2:  MOVLB  3
04EC4:  ADDWF  x34,W
04EC6:  MOVWF  FE9
04EC8:  MOVLW  00
04ECA:  ADDWFC x35,W
04ECC:  MOVWF  FEA
04ECE:  MOVF   FEF,W
04ED0:  SUBLW  03
04ED2:  BNC   4EDA
....................          { 
....................             flags = SYN | ACK; 
04ED4:  MOVLW  12
04ED6:  MOVWF  x3A
....................          } 
04ED8:  BRA    4F06
....................          else 
....................          { 
....................             if(ps->Flags.bServer) 
04EDA:  MOVLW  23
04EDC:  ADDWF  x34,W
04EDE:  MOVWF  FE9
04EE0:  MOVLW  00
04EE2:  ADDWFC x35,W
04EE4:  MOVWF  FEA
04EE6:  BTFSS  FEF.0
04EE8:  BRA    4EF6
....................             { 
....................                ps->smState = TCP_LISTEN; 
04EEA:  MOVFF  334,FE9
04EEE:  MOVFF  335,FEA
04EF2:  CLRF   FEF
....................             } 
04EF4:  BRA    4F06
....................             else 
....................             { 
....................                flags = SYN; 
04EF6:  MOVLW  02
04EF8:  MOVWF  x3A
....................                ps->smState = TCP_SYN_SENT; 
04EFA:  MOVFF  334,FE9
04EFE:  MOVFF  335,FEA
04F02:  MOVLW  01
04F04:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
04F06:  BRA    503E
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
04F08:  MOVLW  1E
04F0A:  MOVLB  3
04F0C:  ADDWF  x34,W
04F0E:  MOVWF  FE9
04F10:  MOVLW  00
04F12:  ADDWFC x35,W
04F14:  MOVWF  FEA
04F16:  MOVF   FEF,W
04F18:  SUBLW  03
04F1A:  BNC   4F5E
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
04F1C:  MOVLW  0F
04F1E:  ADDWF  x34,W
04F20:  MOVWF  FE9
04F22:  MOVLW  00
04F24:  ADDWFC x35,W
04F26:  MOVWF  FEA
04F28:  INCFSZ FEF,W
04F2A:  BRA    4F2E
04F2C:  BRA    4F54
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
04F2E:  MOVLW  0F
04F30:  ADDWF  x34,W
04F32:  MOVWF  FE9
04F34:  MOVLW  00
04F36:  ADDWFC x35,W
04F38:  MOVWF  FEA
04F3A:  MOVFF  FEF,33B
04F3E:  MOVFF  33B,3D1
04F42:  CLRF   xD3
04F44:  CLRF   xD2
04F46:  MOVLB  0
04F48:  CALL   2778
....................                MACFlush(); 
04F4C:  CALL   2966
....................             } 
04F50:  BRA    4F5A
04F52:  MOVLB  3
....................             else 
....................                flags = ACK; 
04F54:  MOVLW  10
04F56:  MOVWF  x3A
04F58:  MOVLB  0
....................          } 
04F5A:  BRA    4FAC
04F5C:  MOVLB  3
....................          else 
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
04F5E:  MOVLW  0F
04F60:  ADDWF  x34,W
04F62:  MOVWF  FE9
04F64:  MOVLW  00
04F66:  ADDWFC x35,W
04F68:  MOVWF  FEA
04F6A:  INCFSZ FEF,W
04F6C:  BRA    4F70
04F6E:  BRA    4F9A
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
04F70:  MOVLW  0F
04F72:  ADDWF  x34,W
04F74:  MOVWF  FE9
04F76:  MOVLW  00
04F78:  ADDWFC x35,W
04F7A:  MOVWF  FEA
04F7C:  MOVFF  FEF,33B
04F80:  MOVFF  33B,37C
04F84:  MOVLB  0
04F86:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
04F8A:  MOVLW  0F
04F8C:  MOVLB  3
04F8E:  ADDWF  x34,W
04F90:  MOVWF  FE9
04F92:  MOVLW  00
04F94:  ADDWFC x35,W
04F96:  MOVWF  FEA
04F98:  SETF   FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
04F9A:  MOVLW  11
04F9C:  MOVWF  x3A
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
04F9E:  MOVFF  334,FE9
04FA2:  MOVFF  335,FEA
04FA6:  MOVLW  04
04FA8:  MOVWF  FEF
04FAA:  MOVLB  0
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
04FAC:  MOVLB  3
04FAE:  BRA    503E
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
04FB0:  MOVLW  1E
04FB2:  MOVLB  3
04FB4:  ADDWF  x34,W
04FB6:  MOVWF  FE9
04FB8:  MOVLW  00
04FBA:  ADDWFC x35,W
04FBC:  MOVWF  FEA
04FBE:  MOVF   FEF,W
04FC0:  SUBLW  03
04FC2:  BNC   4FCA
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
04FC4:  MOVLW  01
04FC6:  MOVWF  x3A
....................          } 
04FC8:  BRA    4FDA
....................          else 
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
04FCA:  MOVFF  335,37A
04FCE:  MOVFF  334,379
04FD2:  MOVLB  0
04FD4:  CALL   37B8
04FD8:  MOVLB  3
....................          } 
....................          break; 
04FDA:  BRA    503E
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
04FDC:  MOVFF  335,37A
04FE0:  MOVFF  334,379
04FE4:  CALL   37B8
....................          break; 
04FE8:  MOVLB  3
04FEA:  BRA    503E
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
04FEC:  MOVFF  335,37A
04FF0:  MOVFF  334,379
04FF4:  CALL   37B8
....................          break; 
04FF8:  MOVLB  3
04FFA:  BRA    503E
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
04FFC:  MOVLW  01
04FFE:  MOVLB  3
05000:  MOVWF  x3A
....................          ps->smState = TCP_LAST_ACK; 
05002:  MOVFF  334,FE9
05006:  MOVFF  335,FEA
0500A:  MOVLW  09
0500C:  MOVWF  FEF
....................          break; 
0500E:  BRA    503E
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
05010:  MOVLW  1E
05012:  MOVLB  3
05014:  ADDWF  x34,W
05016:  MOVWF  FE9
05018:  MOVLW  00
0501A:  ADDWFC x35,W
0501C:  MOVWF  FEA
0501E:  MOVF   FEF,W
05020:  SUBLW  03
05022:  BNC   502A
....................             flags = FIN; 
05024:  MOVLW  01
05026:  MOVWF  x3A
05028:  BRA    503A
....................          else 
....................             CloseSocket(ps); 
0502A:  MOVFF  335,37A
0502E:  MOVFF  334,379
05032:  MOVLB  0
05034:  CALL   37B8
05038:  MOVLB  3
....................          break; 
0503A:  BRA    503E
0503C:  MOVLB  3
....................       } 
....................  
....................  
....................       if(flags) 
0503E:  MOVF   x3A,F
05040:  BTFSC  FD8.2
05042:  BRA    5148
....................       { 
....................          if(flags & ACK) 
05044:  BTFSS  x3A.4
05046:  BRA    5066
....................             seq = ps->SND_SEQ; 
05048:  MOVLW  16
0504A:  ADDWF  x34,W
0504C:  MOVWF  FE9
0504E:  MOVLW  00
05050:  ADDWFC x35,W
05052:  MOVWF  FEA
05054:  MOVFF  FEF,336
05058:  MOVFF  FEC,337
0505C:  MOVFF  FEC,338
05060:  MOVFF  FEC,339
05064:  BRA    50A4
....................          else 
....................             seq = ps->SND_SEQ++; 
05066:  MOVLW  16
05068:  ADDWF  x34,W
0506A:  MOVWF  FE9
0506C:  MOVLW  00
0506E:  ADDWFC x35,W
05070:  MOVWF  FEA
05072:  MOVF   FEE,F
05074:  MOVF   FEE,F
05076:  MOVF   FEE,F
05078:  MOVFF  FED,03
0507C:  MOVFF  FED,02
05080:  MOVFF  FED,01
05084:  MOVFF  FEF,00
05088:  MOVLW  01
0508A:  ADDWF  FEE,F
0508C:  MOVLW  00
0508E:  ADDWFC FEE,F
05090:  ADDWFC FEE,F
05092:  ADDWFC FED,F
05094:  MOVFF  03,339
05098:  MOVFF  02,338
0509C:  MOVFF  01,337
050A0:  MOVFF  00,336
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
050A4:  MOVLW  01
050A6:  ADDWF  x34,W
050A8:  MOVWF  01
050AA:  MOVLW  00
050AC:  ADDWFC x35,W
050AE:  MOVWF  03
050B0:  MOVFF  01,33B
050B4:  MOVWF  x3C
050B6:  MOVLW  0B
050B8:  ADDWF  x34,W
050BA:  MOVWF  FE9
050BC:  MOVLW  00
050BE:  ADDWFC x35,W
050C0:  MOVWF  FEA
050C2:  MOVFF  FEC,33E
050C6:  MOVF   FED,F
050C8:  MOVFF  FEF,33D
050CC:  MOVLW  0D
050CE:  ADDWF  x34,W
050D0:  MOVWF  FE9
050D2:  MOVLW  00
050D4:  ADDWFC x35,W
050D6:  MOVWF  FEA
050D8:  MOVFF  FEC,340
050DC:  MOVF   FED,F
050DE:  MOVFF  FEF,33F
050E2:  MOVLW  1A
050E4:  ADDWF  x34,W
050E6:  MOVWF  FE9
050E8:  MOVLW  00
050EA:  ADDWFC x35,W
050EC:  MOVWF  FEA
050EE:  MOVFF  FEF,341
050F2:  MOVFF  FEC,342
050F6:  MOVFF  FEC,343
050FA:  MOVFF  FEC,344
050FE:  MOVFF  03,381
05102:  MOVFF  01,380
05106:  MOVFF  33E,383
0510A:  MOVFF  33D,382
0510E:  MOVFF  340,385
05112:  MOVFF  33F,384
05116:  MOVFF  339,389
0511A:  MOVFF  338,388
0511E:  MOVFF  337,387
05122:  MOVFF  336,386
05126:  MOVFF  344,38D
0512A:  MOVFF  343,38C
0512E:  MOVFF  342,38B
05132:  MOVFF  341,38A
05136:  MOVFF  33A,38E
0513A:  SETF   x8F
0513C:  CLRF   x91
0513E:  CLRF   x90
05140:  MOVLB  0
05142:  CALL   3BF2
05146:  MOVLB  3
....................       } 
05148:  INCF   x2F,F
0514A:  BRA    4CDA
0514C:  MOVLB  0
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
0514E:  GOTO   7E88 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
04856:  MOVLW  06
04858:  MOVLB  3
0485A:  ADDWF  x2F,W
0485C:  MOVWF  FE9
0485E:  MOVLW  00
04860:  ADDWFC x30,W
04862:  MOVWF  FEA
04864:  MOVFF  FEF,00
04868:  MOVFF  FEC,01
0486C:  MOVFF  FEC,02
04870:  MOVFF  FEC,03
04874:  MOVFF  00,349
04878:  MOVFF  01,34A
0487C:  MOVFF  02,34B
04880:  MOVFF  03,34C
....................    pseudoHeader.DestAddress        = *localIP; 
04884:  MOVFF  331,FE9
04888:  MOVFF  332,FEA
0488C:  MOVFF  FEF,00
04890:  MOVFF  FEC,01
04894:  MOVFF  FEC,02
04898:  MOVFF  FEC,03
0489C:  MOVFF  00,34D
048A0:  MOVFF  01,34E
048A4:  MOVFF  02,34F
048A8:  MOVFF  03,350
....................    pseudoHeader.Zero               = 0x0; 
048AC:  CLRF   x51
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
048AE:  MOVLW  06
048B0:  MOVWF  x52
....................    pseudoHeader.TCPLength          = len; 
048B2:  MOVFF  334,354
048B6:  MOVFF  333,353
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
048BA:  MOVFF  354,3D8
048BE:  MOVFF  353,3D7
048C2:  MOVLB  0
048C4:  CALL   2440
048C8:  MOVFF  02,354
048CC:  MOVFF  01,353
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
048D0:  MOVLW  03
048D2:  MOVLB  3
048D4:  MOVWF  x5C
048D6:  MOVLW  49
048D8:  MOVWF  x5B
048DA:  MOVFF  35C,3BB
048DE:  MOVWF  xBA
048E0:  CLRF   xBD
048E2:  MOVLW  0C
048E4:  MOVWF  xBC
048E6:  MOVLB  0
048E8:  CALL   30E8
048EC:  MOVFF  01,356
048F0:  MOVLB  3
048F2:  COMF   x56,F
048F4:  MOVFF  02,357
048F8:  COMF   x57,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
048FA:  MOVFF  334,3B9
048FE:  MOVFF  333,3B8
04902:  MOVLB  0
04904:  CALL   3202
04908:  MOVFF  02,359
0490C:  MOVFF  01,358
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
04910:  MOVLB  3
04912:  MOVF   x59,W
04914:  SUBWF  x56,W
04916:  BNZ   491E
04918:  MOVF   x58,W
0491A:  SUBWF  x57,W
0491C:  BZ    492C
....................    { 
....................       MACDiscardRx(); 
0491E:  MOVLB  0
04920:  CALL   2370
....................       return TRUE; 
04924:  MOVLW  01
04926:  MOVWF  01
04928:  BRA    4A00
0492A:  MOVLB  3
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
0492C:  CLRF   x5D
0492E:  CLRF   x5C
04930:  MOVLB  0
04932:  CALL   335A
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
04936:  MOVLW  03
04938:  MOVLB  3
0493A:  MOVWF  x5C
0493C:  MOVLW  35
0493E:  MOVWF  x5B
04940:  MOVFF  35C,3C7
04944:  MOVWF  xC6
04946:  CLRF   xC9
04948:  MOVLW  14
0494A:  MOVWF  xC8
0494C:  MOVLB  0
0494E:  CALL   23DC
....................    SwapTCPHeader(&TCPHeader); 
04952:  MOVLW  03
04954:  MOVLB  3
04956:  MOVWF  xB9
04958:  MOVLW  35
0495A:  MOVWF  xB8
0495C:  MOVLB  0
0495E:  CALL   3396
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
04962:  MOVLB  3
04964:  SWAPF  x41,W
04966:  ANDLW  0F
04968:  MOVWF  00
0496A:  RLCF   00,F
0496C:  RLCF   00,F
0496E:  MOVLW  FC
04970:  ANDWF  00,F
04972:  MOVF   00,W
04974:  ADDLW  EC
04976:  MOVWF  x5A
....................    len = len - optionsSize - sizeof(TCPHeader); 
04978:  MOVF   x5A,W
0497A:  SUBWF  x33,W
0497C:  MOVWF  x5B
0497E:  MOVLW  00
04980:  SUBWFB x34,W
04982:  MOVWF  x5C
04984:  MOVLW  14
04986:  SUBWF  x5B,W
04988:  MOVWF  x33
0498A:  MOVLW  00
0498C:  SUBWFB x5C,W
0498E:  MOVWF  x34
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
04990:  SWAPF  x41,W
04992:  ANDLW  0F
04994:  MOVWF  00
04996:  RLCF   00,W
04998:  MOVWF  x5B
0499A:  RLCF   x5B,F
0499C:  MOVLW  FC
0499E:  ANDWF  x5B,F
049A0:  CLRF   x5D
049A2:  MOVFF  35B,35C
049A6:  MOVLB  0
049A8:  CALL   335A
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
049AC:  MOVLW  03
049AE:  MOVLB  3
049B0:  MOVWF  x5C
049B2:  MOVLW  35
049B4:  MOVWF  x5B
049B6:  MOVFF  330,35E
049BA:  MOVFF  32F,35D
049BE:  MOVLB  0
049C0:  GOTO   35BC
049C4:  MOVFF  01,355
....................    if(socket != INVALID_SOCKET) 
049C8:  MOVLB  3
049CA:  MOVF   x55,W
049CC:  SUBLW  FE
049CE:  BZ    49F6
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
049D0:  MOVFF  355,35B
049D4:  MOVFF  330,35D
049D8:  MOVFF  32F,35C
049DC:  MOVLW  03
049DE:  MOVWF  x5F
049E0:  MOVLW  35
049E2:  MOVWF  x5E
049E4:  MOVFF  334,361
049E8:  MOVFF  333,360
049EC:  MOVLB  0
049EE:  GOTO   3E26
....................    } 
049F2:  BRA    49FC
049F4:  MOVLB  3
....................    else 
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
049F6:  MOVLB  0
049F8:  CALL   2370
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
049FC:  MOVLW  01
049FE:  MOVWF  01
04A00:  GOTO   7DBE (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
03BF2:  MOVLW  01
03BF4:  MOVLB  3
03BF6:  MOVWF  xB8
03BF8:  MOVLB  0
03BFA:  RCALL  38BA
03BFC:  MOVF   01,F
03BFE:  BZ    3BF2
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
03C00:  MOVLB  3
03C02:  INCFSZ x8F,W
03C04:  BRA    3C16
....................       buff = MACGetTxBuffer(TRUE); 
03C06:  MOVLW  01
03C08:  MOVWF  xB8
03C0A:  MOVLB  0
03C0C:  CALL   2750
03C10:  MOVFF  01,38F
03C14:  MOVLB  3
....................  
....................    if(buff == INVALID_BUFFER) 
03C16:  INCFSZ x8F,W
03C18:  BRA    3C1C
....................       return; 
03C1A:  BRA    3E22
....................  
....................    IPSetTxBuffer(buff, 0); 
03C1C:  MOVFF  38F,3D1
03C20:  CLRF   xD3
03C22:  MOVLW  14
03C24:  MOVWF  xD2
03C26:  MOVLB  0
03C28:  CALL   2778
....................  
....................    header.SourcePort           = localPort; 
03C2C:  MOVFF  383,395
03C30:  MOVFF  382,394
....................    header.DestPort             = remotePort; 
03C34:  MOVFF  385,397
03C38:  MOVFF  384,396
....................    header.SeqNumber            = tseq; 
03C3C:  MOVFF  389,39B
03C40:  MOVFF  388,39A
03C44:  MOVFF  387,399
03C48:  MOVFF  386,398
....................    header.AckNumber            = tack; 
03C4C:  MOVFF  38D,39F
03C50:  MOVFF  38C,39E
03C54:  MOVFF  38B,39D
03C58:  MOVFF  38A,39C
....................    header.Flags.bits.Reserved2 = 0; 
03C5C:  MOVLW  3F
03C5E:  MOVLB  3
03C60:  ANDWF  xA1,W
03C62:  MOVWF  xA1
....................    header.DataOffset.Reserved3 = 0; 
03C64:  MOVLW  F0
03C66:  ANDWF  xA0,W
03C68:  MOVWF  xA0
....................    header.Flags.b              = flags; 
03C6A:  MOVFF  38E,3A1
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
03C6E:  MOVLB  0
03C70:  BRA    38E2
03C72:  MOVFF  02,3A3
03C76:  MOVFF  01,3A2
.................... #if !defined(STACK_USE_SLIP) 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
03C7A:  MOVLB  3
03C7C:  MOVF   xA3,F
03C7E:  BNZ   3C86
03C80:  MOVF   xA2,W
03C82:  SUBLW  28
03C84:  BC    3C90
....................    { 
....................       header.Window -= 40; 
03C86:  MOVLW  28
03C88:  SUBWF  xA2,F
03C8A:  MOVLW  00
03C8C:  SUBWFB xA3,F
....................    } 
03C8E:  BRA    3C94
....................    else 
....................       header.Window = 0; 
03C90:  CLRF   xA3
03C92:  CLRF   xA2
.................... #endif 
....................  
....................    header.Checksum             = 0; 
03C94:  CLRF   xA5
03C96:  CLRF   xA4
....................    header.UrgentPointer        = 0; 
03C98:  CLRF   xA7
03C9A:  CLRF   xA6
....................  
....................    SwapTCPHeader(&header); 
03C9C:  MOVLW  03
03C9E:  MOVWF  xB9
03CA0:  MOVLW  94
03CA2:  MOVWF  xB8
03CA4:  MOVLB  0
03CA6:  CALL   3396
....................  
....................    len += sizeof(header); 
03CAA:  MOVLW  14
03CAC:  MOVLB  3
03CAE:  ADDWF  x90,F
03CB0:  MOVLW  00
03CB2:  ADDWFC x91,F
....................  
....................    if ( flags & SYN ) 
03CB4:  BTFSS  x8E.1
03CB6:  BRA    3CD6
....................    { 
....................       len += sizeof(options); 
03CB8:  MOVLW  04
03CBA:  ADDWF  x90,F
03CBC:  MOVLW  00
03CBE:  ADDWFC x91,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
03CC0:  MOVLW  02
03CC2:  MOVWF  xA8
....................       options.Length = 0x04; 
03CC4:  MOVLW  04
03CC6:  MOVWF  xA9
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
03CC8:  MOVWF  xAA
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
03CCA:  CLRF   xAB
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
03CCC:  MOVLW  0F
03CCE:  ANDWF  xA0,W
03CD0:  IORLW  60
03CD2:  MOVWF  xA0
....................    } 
03CD4:  BRA    3CDE
....................    else 
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
03CD6:  MOVLW  0F
03CD8:  ANDWF  xA0,W
03CDA:  IORLW  50
03CDC:  MOVWF  xA0
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
03CDE:  MOVFF  22,3AF
03CE2:  MOVFF  21,3AE
03CE6:  MOVFF  20,3AD
03CEA:  MOVFF  1F,3AC
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
03CEE:  MOVLW  06
03CF0:  ADDWF  x80,W
03CF2:  MOVWF  FE9
03CF4:  MOVLW  00
03CF6:  ADDWFC x81,W
03CF8:  MOVWF  FEA
03CFA:  MOVFF  FEF,00
03CFE:  MOVFF  FEC,01
03D02:  MOVFF  FEC,02
03D06:  MOVFF  FEC,03
03D0A:  MOVFF  00,3B0
03D0E:  MOVFF  01,3B1
03D12:  MOVFF  02,3B2
03D16:  MOVFF  03,3B3
....................    pseudoHeader.Zero           = 0x0; 
03D1A:  CLRF   xB4
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
03D1C:  MOVLW  06
03D1E:  MOVWF  xB5
....................    pseudoHeader.TCPLength      = len; 
03D20:  MOVFF  391,3B7
03D24:  MOVFF  390,3B6
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
03D28:  MOVFF  3B7,3D8
03D2C:  MOVFF  3B6,3D7
03D30:  MOVLB  0
03D32:  CALL   2440
03D36:  MOVFF  02,3B7
03D3A:  MOVFF  01,3B6
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
03D3E:  MOVLW  03
03D40:  MOVLB  3
03D42:  MOVWF  xB9
03D44:  MOVLW  AC
03D46:  MOVWF  xB8
03D48:  MOVFF  3B9,3BB
03D4C:  MOVWF  xBA
03D4E:  CLRF   xBD
03D50:  MOVLW  0C
03D52:  MOVWF  xBC
03D54:  MOVLB  0
03D56:  CALL   30E8
03D5A:  MOVFF  01,3A4
03D5E:  MOVLB  3
03D60:  COMF   xA4,F
03D62:  MOVFF  02,3A5
03D66:  COMF   xA5,F
....................    checkSum.Val = header.Checksum; 
03D68:  MOVFF  3A5,393
03D6C:  MOVFF  3A4,392
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
03D70:  MOVFF  381,3B9
03D74:  MOVFF  380,3B8
03D78:  MOVLW  06
03D7A:  MOVWF  xBA
03D7C:  MOVFF  391,3BC
03D80:  MOVFF  390,3BB
03D84:  MOVLB  0
03D86:  RCALL  3AD2
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
03D88:  MOVLW  03
03D8A:  MOVLB  3
03D8C:  MOVWF  xB9
03D8E:  MOVLW  94
03D90:  MOVWF  xB8
03D92:  MOVFF  3B9,3DD
03D96:  MOVWF  xDC
03D98:  CLRF   xDF
03D9A:  MOVLW  14
03D9C:  MOVWF  xDE
03D9E:  MOVLB  0
03DA0:  CALL   2844
....................  
....................    if ( flags & SYN ) 
03DA4:  MOVLB  3
03DA6:  BTFSS  x8E.1
03DA8:  BRA    3DC6
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
03DAA:  MOVLW  03
03DAC:  MOVWF  xB9
03DAE:  MOVLW  A8
03DB0:  MOVWF  xB8
03DB2:  MOVFF  3B9,3DD
03DB6:  MOVWF  xDC
03DB8:  CLRF   xDF
03DBA:  MOVLW  04
03DBC:  MOVWF  xDE
03DBE:  MOVLB  0
03DC0:  CALL   2844
03DC4:  MOVLB  3
....................  
....................    IPSetTxBuffer(buff, 0); 
03DC6:  MOVFF  38F,3D1
03DCA:  CLRF   xD3
03DCC:  MOVLW  14
03DCE:  MOVWF  xD2
03DD0:  MOVLB  0
03DD2:  CALL   2778
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
03DD6:  MOVFF  391,3B9
03DDA:  MOVFF  390,3B8
03DDE:  CALL   3202
03DE2:  MOVFF  02,393
03DE6:  MOVFF  01,392
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
03DEA:  MOVFF  38F,3D1
03DEE:  MOVLB  3
03DF0:  CLRF   xD3
03DF2:  MOVLW  24
03DF4:  MOVWF  xD2
03DF6:  MOVLB  0
03DF8:  CALL   2778
....................    MACPut(checkSum.v[1]); 
03DFC:  MOVFF  393,3DB
03E00:  CALL   2826
....................    MACPut(checkSum.v[0]); 
03E04:  MOVFF  392,3DB
03E08:  CALL   2826
....................    MACSetTxBuffer(buff, 0); 
03E0C:  MOVFF  38F,3D1
03E10:  MOVLB  3
03E12:  CLRF   xD3
03E14:  CLRF   xD2
03E16:  MOVLB  0
03E18:  CALL   2778
....................  
....................    MACFlush(); 
03E1C:  CALL   2966
03E20:  MOVLB  3
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
03E22:  MOVLB  0
03E24:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
035BC:  MOVLW  FE
035BE:  MOVLB  3
035C0:  MOVWF  x62
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
035C2:  CLRF   x61
035C4:  MOVF   x61,W
035C6:  SUBLW  04
035C8:  BTFSS  FD8.0
035CA:  BRA    36C0
....................    { 
....................       ps = &TCB[s]; 
035CC:  MOVF   x61,W
035CE:  MULLW  24
035D0:  MOVF   FF3,W
035D2:  CLRF   03
035D4:  ADDLW  60
035D6:  MOVWF  01
035D8:  MOVLW  00
035DA:  ADDWFC 03,F
035DC:  MOVFF  01,35F
035E0:  MOVFF  03,360
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
035E4:  MOVFF  35F,FE9
035E8:  MOVFF  360,FEA
035EC:  MOVF   FEF,W
035EE:  SUBLW  0A
035F0:  BZ    36BC
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
035F2:  MOVLW  0B
035F4:  ADDWF  x5F,W
035F6:  MOVWF  FE9
035F8:  MOVLW  00
035FA:  ADDWFC x60,W
035FC:  MOVWF  FEA
035FE:  MOVFF  FEC,364
03602:  MOVF   FED,F
03604:  MOVFF  FEF,363
03608:  MOVLW  02
0360A:  ADDWF  x5B,W
0360C:  MOVWF  FE9
0360E:  MOVLW  00
03610:  ADDWFC x5C,W
03612:  MOVWF  FEA
03614:  MOVFF  FEC,03
03618:  MOVF   FED,F
0361A:  MOVF   FEF,W
0361C:  SUBWF  x63,W
0361E:  BNZ   36BC
03620:  MOVF   03,W
03622:  SUBWF  x64,W
03624:  BNZ   36BC
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
03626:  MOVFF  35F,FE9
0362A:  MOVFF  360,FEA
0362E:  MOVF   FEF,F
03630:  BNZ   3636
....................                partialMatch = s; 
03632:  MOVFF  361,362
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
03636:  MOVLW  0D
03638:  ADDWF  x5F,W
0363A:  MOVWF  FE9
0363C:  MOVLW  00
0363E:  ADDWFC x60,W
03640:  MOVWF  FEA
03642:  MOVFF  FEC,364
03646:  MOVF   FED,F
03648:  MOVFF  FEF,363
0364C:  MOVFF  35B,FE9
03650:  MOVFF  35C,FEA
03654:  MOVFF  FEC,03
03658:  MOVF   FED,F
0365A:  MOVF   FEF,W
0365C:  SUBWF  x63,W
0365E:  BNZ   36BC
03660:  MOVF   03,W
03662:  SUBWF  x64,W
03664:  BNZ   36BC
03666:  MOVLW  07
03668:  ADDWF  x5F,W
0366A:  MOVWF  FE9
0366C:  MOVLW  00
0366E:  ADDWFC x60,W
03670:  MOVWF  FEA
03672:  MOVFF  FEF,363
03676:  MOVFF  FEC,364
0367A:  MOVFF  FEC,365
0367E:  MOVFF  FEC,366
03682:  MOVLW  06
03684:  ADDWF  x5D,W
03686:  MOVWF  FE9
03688:  MOVLW  00
0368A:  ADDWFC x5E,W
0368C:  MOVWF  FEA
0368E:  MOVFF  FEF,00
03692:  MOVFF  FEC,01
03696:  MOVFF  FEC,02
0369A:  MOVFF  FEC,03
0369E:  MOVF   00,W
036A0:  SUBWF  x63,W
036A2:  BNZ   36BC
036A4:  MOVF   01,W
036A6:  SUBWF  x64,W
036A8:  BNZ   36BC
036AA:  MOVF   02,W
036AC:  SUBWF  x65,W
036AE:  BNZ   36BC
036B0:  MOVF   03,W
036B2:  SUBWF  x66,W
036B4:  BNZ   36BC
....................             { 
....................                return s; 
036B6:  MOVFF  361,01
036BA:  BRA    3798
....................             } 
....................          } 
....................       } 
036BC:  INCF   x61,F
036BE:  BRA    35C4
....................    } 
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
036C0:  MOVF   x62,W
036C2:  SUBLW  FE
036C4:  BNZ   36CC
....................       return INVALID_SOCKET; 
036C6:  MOVLW  FE
036C8:  MOVWF  01
036CA:  BRA    3798
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
036CC:  MOVF   x62,W
036CE:  MULLW  24
036D0:  MOVF   FF3,W
036D2:  CLRF   03
036D4:  ADDLW  60
036D6:  MOVWF  01
036D8:  MOVLW  00
036DA:  ADDWFC 03,F
036DC:  MOVFF  01,35F
036E0:  MOVFF  03,360
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
036E4:  MOVLW  01
036E6:  ADDWF  x5F,W
036E8:  MOVWF  01
036EA:  MOVLW  00
036EC:  ADDWFC x60,W
036EE:  MOVWF  03
036F0:  MOVFF  01,363
036F4:  MOVWF  x64
036F6:  MOVWF  FEA
036F8:  MOVFF  01,FE9
036FC:  MOVFF  35E,FE2
03700:  MOVFF  35D,FE1
03704:  MOVLW  0A
03706:  MOVWF  01
03708:  MOVFF  FE6,FEE
0370C:  DECFSZ 01,F
0370E:  BRA    3708
....................    ps->remotePort          = h->SourcePort; 
03710:  MOVLW  0D
03712:  ADDWF  x5F,W
03714:  MOVWF  01
03716:  MOVLW  00
03718:  ADDWFC x60,W
0371A:  MOVFF  35B,FE9
0371E:  MOVFF  35C,FEA
03722:  MOVFF  FEC,03
03726:  MOVF   FED,F
03728:  MOVFF  FEF,365
0372C:  MOVWF  FEA
0372E:  MOVFF  01,FE9
03732:  MOVFF  03,FEC
03736:  MOVF   FED,F
03738:  MOVFF  365,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
0373C:  MOVLW  23
0373E:  ADDWF  x5F,W
03740:  MOVWF  FE9
03742:  MOVLW  00
03744:  ADDWFC x60,W
03746:  MOVWF  FEA
03748:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
0374A:  MOVLW  0F
0374C:  ADDWF  x5F,W
0374E:  MOVWF  FE9
03750:  MOVLW  00
03752:  ADDWFC x60,W
03754:  MOVWF  FEA
03756:  INCFSZ FEF,W
03758:  BRA    375C
0375A:  BRA    3786
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
0375C:  MOVLW  0F
0375E:  ADDWF  x5F,W
03760:  MOVWF  FE9
03762:  MOVLW  00
03764:  ADDWFC x60,W
03766:  MOVWF  FEA
03768:  MOVFF  FEF,363
0376C:  MOVFF  363,37C
03770:  MOVLB  0
03772:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
03776:  MOVLW  0F
03778:  MOVLB  3
0377A:  ADDWF  x5F,W
0377C:  MOVWF  FE9
0377E:  MOVLW  00
03780:  ADDWFC x60,W
03782:  MOVWF  FEA
03784:  SETF   FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
03786:  MOVLW  23
03788:  ADDWF  x5F,W
0378A:  MOVWF  FE9
0378C:  MOVLW  00
0378E:  ADDWFC x60,W
03790:  MOVWF  FEA
03792:  BSF    FEF.1
....................  
....................    return partialMatch; 
03794:  MOVFF  362,01
03798:  MOVLB  0
0379A:  GOTO   49C4 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
03396:  MOVLB  3
03398:  MOVFF  3B8,01
0339C:  MOVFF  3B9,03
033A0:  MOVFF  3B8,3BA
033A4:  MOVFF  3B9,3BB
033A8:  MOVFF  3B8,FE9
033AC:  MOVFF  3B9,FEA
033B0:  MOVFF  FEC,3BD
033B4:  MOVF   FED,F
033B6:  MOVFF  FEF,3BC
033BA:  MOVFF  3BD,3D8
033BE:  MOVFF  3BC,3D7
033C2:  MOVLB  0
033C4:  CALL   2440
033C8:  MOVFF  3BB,FEA
033CC:  MOVFF  3BA,FE9
033D0:  MOVFF  02,FEC
033D4:  MOVF   FED,F
033D6:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
033DA:  MOVLW  02
033DC:  MOVLB  3
033DE:  ADDWF  xB8,W
033E0:  MOVWF  01
033E2:  MOVLW  00
033E4:  ADDWFC xB9,W
033E6:  MOVWF  03
033E8:  MOVFF  01,3BA
033EC:  MOVWF  xBB
033EE:  MOVLW  02
033F0:  ADDWF  xB8,W
033F2:  MOVWF  FE9
033F4:  MOVLW  00
033F6:  ADDWFC xB9,W
033F8:  MOVWF  FEA
033FA:  MOVFF  FEC,3BD
033FE:  MOVF   FED,F
03400:  MOVFF  FEF,3BC
03404:  MOVFF  3BD,3D8
03408:  MOVFF  3BC,3D7
0340C:  MOVLB  0
0340E:  CALL   2440
03412:  MOVFF  3BB,FEA
03416:  MOVFF  3BA,FE9
0341A:  MOVFF  02,FEC
0341E:  MOVF   FED,F
03420:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
03424:  MOVLW  04
03426:  MOVLB  3
03428:  ADDWF  xB8,W
0342A:  MOVWF  01
0342C:  MOVLW  00
0342E:  ADDWFC xB9,W
03430:  MOVWF  03
03432:  MOVFF  01,3BA
03436:  MOVWF  xBB
03438:  MOVLW  04
0343A:  ADDWF  xB8,W
0343C:  MOVWF  FE9
0343E:  MOVLW  00
03440:  ADDWFC xB9,W
03442:  MOVWF  FEA
03444:  MOVFF  FEF,3BC
03448:  MOVFF  FEC,3BD
0344C:  MOVFF  FEC,3BE
03450:  MOVFF  FEC,3BF
03454:  MOVFF  3BF,3C3
03458:  MOVFF  3BE,3C2
0345C:  MOVFF  3BD,3C1
03460:  MOVFF  3BC,3C0
03464:  MOVLB  0
03466:  RCALL  3374
03468:  MOVFF  3BB,FEA
0346C:  MOVFF  3BA,FE9
03470:  MOVFF  00,FEF
03474:  MOVFF  01,FEC
03478:  MOVFF  02,FEC
0347C:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
03480:  MOVLW  08
03482:  MOVLB  3
03484:  ADDWF  xB8,W
03486:  MOVWF  01
03488:  MOVLW  00
0348A:  ADDWFC xB9,W
0348C:  MOVWF  03
0348E:  MOVFF  01,3BA
03492:  MOVWF  xBB
03494:  MOVLW  08
03496:  ADDWF  xB8,W
03498:  MOVWF  FE9
0349A:  MOVLW  00
0349C:  ADDWFC xB9,W
0349E:  MOVWF  FEA
034A0:  MOVFF  FEF,3BC
034A4:  MOVFF  FEC,3BD
034A8:  MOVFF  FEC,3BE
034AC:  MOVFF  FEC,3BF
034B0:  MOVFF  3BF,3C3
034B4:  MOVFF  3BE,3C2
034B8:  MOVFF  3BD,3C1
034BC:  MOVFF  3BC,3C0
034C0:  MOVLB  0
034C2:  RCALL  3374
034C4:  MOVFF  3BB,FEA
034C8:  MOVFF  3BA,FE9
034CC:  MOVFF  00,FEF
034D0:  MOVFF  01,FEC
034D4:  MOVFF  02,FEC
034D8:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
034DC:  MOVLW  0E
034DE:  MOVLB  3
034E0:  ADDWF  xB8,W
034E2:  MOVWF  01
034E4:  MOVLW  00
034E6:  ADDWFC xB9,W
034E8:  MOVWF  03
034EA:  MOVFF  01,3BA
034EE:  MOVWF  xBB
034F0:  MOVLW  0E
034F2:  ADDWF  xB8,W
034F4:  MOVWF  FE9
034F6:  MOVLW  00
034F8:  ADDWFC xB9,W
034FA:  MOVWF  FEA
034FC:  MOVFF  FEC,3BD
03500:  MOVF   FED,F
03502:  MOVFF  FEF,3BC
03506:  MOVFF  3BD,3D8
0350A:  MOVFF  3BC,3D7
0350E:  MOVLB  0
03510:  CALL   2440
03514:  MOVFF  3BB,FEA
03518:  MOVFF  3BA,FE9
0351C:  MOVFF  02,FEC
03520:  MOVF   FED,F
03522:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
03526:  MOVLW  10
03528:  MOVLB  3
0352A:  ADDWF  xB8,W
0352C:  MOVWF  01
0352E:  MOVLW  00
03530:  ADDWFC xB9,W
03532:  MOVWF  03
03534:  MOVFF  01,3BA
03538:  MOVWF  xBB
0353A:  MOVLW  10
0353C:  ADDWF  xB8,W
0353E:  MOVWF  FE9
03540:  MOVLW  00
03542:  ADDWFC xB9,W
03544:  MOVWF  FEA
03546:  MOVFF  FEC,3BD
0354A:  MOVF   FED,F
0354C:  MOVFF  FEF,3BC
03550:  MOVFF  3BD,3D8
03554:  MOVFF  3BC,3D7
03558:  MOVLB  0
0355A:  CALL   2440
0355E:  MOVFF  3BB,FEA
03562:  MOVFF  3BA,FE9
03566:  MOVFF  02,FEC
0356A:  MOVF   FED,F
0356C:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
03570:  MOVLW  12
03572:  MOVLB  3
03574:  ADDWF  xB8,W
03576:  MOVWF  01
03578:  MOVLW  00
0357A:  ADDWFC xB9,W
0357C:  MOVWF  03
0357E:  MOVFF  01,3BA
03582:  MOVWF  xBB
03584:  MOVLW  12
03586:  ADDWF  xB8,W
03588:  MOVWF  FE9
0358A:  MOVLW  00
0358C:  ADDWFC xB9,W
0358E:  MOVWF  FEA
03590:  MOVFF  FEC,3BD
03594:  MOVF   FED,F
03596:  MOVFF  FEF,3BC
0359A:  MOVFF  3BD,3D8
0359E:  MOVFF  3BC,3D7
035A2:  MOVLB  0
035A4:  CALL   2440
035A8:  MOVFF  3BB,FEA
035AC:  MOVFF  3BA,FE9
035B0:  MOVFF  02,FEC
035B4:  MOVF   FED,F
035B6:  MOVFF  01,FEF
035BA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
037B8:  MOVLW  0F
037BA:  MOVLB  3
037BC:  ADDWF  x79,W
037BE:  MOVWF  FE9
037C0:  MOVLW  00
037C2:  ADDWFC x7A,W
037C4:  MOVWF  FEA
037C6:  INCFSZ FEF,W
037C8:  BRA    37CC
037CA:  BRA    3804
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
037CC:  MOVLW  0F
037CE:  ADDWF  x79,W
037D0:  MOVWF  FE9
037D2:  MOVLW  00
037D4:  ADDWFC x7A,W
037D6:  MOVWF  FEA
037D8:  MOVFF  FEF,37B
037DC:  MOVFF  37B,37C
037E0:  MOVLB  0
037E2:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
037E6:  MOVLW  0F
037E8:  MOVLB  3
037EA:  ADDWF  x79,W
037EC:  MOVWF  FE9
037EE:  MOVLW  00
037F0:  ADDWFC x7A,W
037F2:  MOVWF  FEA
037F4:  SETF   FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
037F6:  MOVLW  23
037F8:  ADDWF  x79,W
037FA:  MOVWF  FE9
037FC:  MOVLW  00
037FE:  ADDWFC x7A,W
03800:  MOVWF  FEA
03802:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
03804:  MOVLW  07
03806:  ADDWF  x79,W
03808:  MOVWF  FE9
0380A:  MOVLW  00
0380C:  ADDWFC x7A,W
0380E:  MOVWF  FEA
03810:  MOVF   FEE,F
03812:  MOVF   FEE,F
03814:  CLRF   FEC
03816:  MOVF   FED,F
03818:  CLRF   FEF
0381A:  MOVF   FED,F
0381C:  CLRF   FEF
0381E:  MOVF   FED,F
03820:  CLRF   FEF
....................     ps->remotePort = 0x00; 
03822:  MOVLW  0D
03824:  ADDWF  x79,W
03826:  MOVWF  FE9
03828:  MOVLW  00
0382A:  ADDWFC x7A,W
0382C:  MOVWF  FEA
0382E:  CLRF   FEC
03830:  MOVF   FED,F
03832:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
03834:  MOVLW  23
03836:  ADDWF  x79,W
03838:  MOVWF  FE9
0383A:  MOVLW  00
0383C:  ADDWFC x7A,W
0383E:  MOVWF  FEA
03840:  BTFSS  FEF.3
03842:  BRA    384C
....................     { 
....................         MACDiscardRx(); 
03844:  MOVLB  0
03846:  CALL   2370
0384A:  MOVLB  3
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
0384C:  MOVLW  23
0384E:  ADDWF  x79,W
03850:  MOVWF  FE9
03852:  MOVLW  00
03854:  ADDWFC x7A,W
03856:  MOVWF  FEA
03858:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
0385A:  MOVLW  21
0385C:  ADDWF  x79,W
0385E:  MOVWF  FE9
03860:  MOVLW  00
03862:  ADDWFC x7A,W
03864:  MOVWF  FEA
03866:  CLRF   FEC
03868:  MOVF   FED,F
0386A:  MOVLW  1E
0386C:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
0386E:  MOVLW  23
03870:  ADDWF  x79,W
03872:  MOVWF  FE9
03874:  MOVLW  00
03876:  ADDWFC x7A,W
03878:  MOVWF  FEA
0387A:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
0387C:  MOVLW  23
0387E:  ADDWF  x79,W
03880:  MOVWF  FE9
03882:  MOVLW  00
03884:  ADDWFC x7A,W
03886:  MOVWF  FEA
03888:  BTFSS  FEF.0
0388A:  BRA    3898
....................     { 
....................         ps->smState = TCP_LISTEN; 
0388C:  MOVFF  379,FE9
03890:  MOVFF  37A,FEA
03894:  CLRF   FEF
....................     } 
03896:  BRA    38A4
....................     else 
....................     { 
....................         ps->smState = TCP_CLOSED; 
03898:  MOVFF  379,FE9
0389C:  MOVFF  37A,FEA
038A0:  MOVLW  0A
038A2:  MOVWF  FEF
....................     } 
....................  
....................    ps->TxCount = 0; 
038A4:  MOVLW  10
038A6:  ADDWF  x79,W
038A8:  MOVWF  FE9
038AA:  MOVLW  00
038AC:  ADDWFC x7A,W
038AE:  MOVWF  FEA
038B0:  CLRF   FEC
038B2:  MOVF   FED,F
038B4:  CLRF   FEF
....................  
....................     return; 
038B6:  MOVLB  0
038B8:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
03E26:  MOVLB  3
03E28:  MOVF   x5B,W
03E2A:  MULLW  24
03E2C:  MOVF   FF3,W
03E2E:  CLRF   03
03E30:  ADDLW  60
03E32:  MOVWF  01
03E34:  MOVLW  00
03E36:  ADDWFC 03,F
03E38:  MOVFF  01,372
03E3C:  MOVFF  03,373
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
03E40:  CLRF   x74
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
03E42:  MOVLW  1E
03E44:  ADDWF  x72,W
03E46:  MOVWF  FE9
03E48:  MOVLW  00
03E4A:  ADDWFC x73,W
03E4C:  MOVWF  FEA
03E4E:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
03E50:  MOVLW  1F
03E52:  ADDWF  x72,W
03E54:  MOVWF  01
03E56:  MOVLW  00
03E58:  ADDWFC x73,W
03E5A:  MOVWF  03
03E5C:  MOVFF  01,379
03E60:  MOVWF  x7A
03E62:  MOVLB  0
03E64:  RCALL  379E
03E66:  MOVFF  37A,FEA
03E6A:  MOVFF  379,FE9
03E6E:  MOVFF  02,FEC
03E72:  MOVF   FED,F
03E74:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
03E78:  MOVLW  21
03E7A:  MOVLB  3
03E7C:  ADDWF  x72,W
03E7E:  MOVWF  FE9
03E80:  MOVLW  00
03E82:  ADDWFC x73,W
03E84:  MOVWF  FEA
03E86:  CLRF   FEC
03E88:  MOVF   FED,F
03E8A:  MOVLW  1E
03E8C:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
03E8E:  MOVLW  0D
03E90:  ADDWF  x5E,W
03E92:  MOVWF  FE9
03E94:  MOVLW  00
03E96:  ADDWFC x5F,W
03E98:  MOVWF  FEA
03E9A:  BTFSS  FEF.2
03E9C:  BRA    3EDA
....................    { 
....................       MACDiscardRx(); 
03E9E:  MOVLB  0
03EA0:  CALL   2370
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
03EA4:  MOVLB  3
03EA6:  MOVFF  372,01
03EAA:  MOVFF  373,03
03EAE:  MOVFF  372,379
03EB2:  MOVFF  373,37A
03EB6:  MOVLW  23
03EB8:  ADDWF  x72,W
03EBA:  MOVWF  FE9
03EBC:  MOVLW  00
03EBE:  ADDWFC x73,W
03EC0:  MOVWF  FEA
03EC2:  BTFSS  FEF.0
03EC4:  BRA    3ECA
03EC6:  MOVLW  00
03EC8:  BRA    3ECC
03ECA:  MOVLW  01
03ECC:  MOVFF  37A,FEA
03ED0:  MOVFF  379,FE9
03ED4:  MOVWF  FEF
....................       return; 
03ED6:  GOTO   4850
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
03EDA:  MOVLW  16
03EDC:  ADDWF  x72,W
03EDE:  MOVWF  FE9
03EE0:  MOVLW  00
03EE2:  ADDWFC x73,W
03EE4:  MOVWF  FEA
03EE6:  MOVFF  FEF,366
03EEA:  MOVFF  FEC,367
03EEE:  MOVFF  FEC,368
03EF2:  MOVFF  FEC,369
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
03EF6:  MOVLW  0E
03EF8:  ADDWF  x5E,W
03EFA:  MOVWF  FE9
03EFC:  MOVLW  00
03EFE:  ADDWFC x5F,W
03F00:  MOVWF  FEA
03F02:  MOVFF  FEC,03
03F06:  MOVF   FED,F
03F08:  MOVFF  FEF,379
03F0C:  MOVFF  03,37A
03F10:  CLRF   x7B
03F12:  CLRF   x7C
03F14:  MOVLW  08
03F16:  ADDWF  x5E,W
03F18:  MOVWF  FE9
03F1A:  MOVLW  00
03F1C:  ADDWFC x5F,W
03F1E:  MOVWF  FEA
03F20:  MOVFF  FEF,00
03F24:  MOVFF  FEC,01
03F28:  MOVFF  FEC,02
03F2C:  MOVFF  FEC,03
03F30:  MOVF   00,W
03F32:  SUBWF  x66,W
03F34:  MOVWF  00
03F36:  MOVF   01,W
03F38:  SUBWFB x67,W
03F3A:  MOVWF  01
03F3C:  MOVF   02,W
03F3E:  SUBWFB x68,W
03F40:  MOVWF  02
03F42:  MOVF   03,W
03F44:  SUBWFB x69,W
03F46:  MOVWF  03
03F48:  MOVF   00,W
03F4A:  SUBWF  x79,F
03F4C:  MOVF   01,W
03F4E:  SUBWFB x7A,F
03F50:  MOVF   02,W
03F52:  SUBWFB x7B,F
03F54:  MOVF   03,W
03F56:  SUBWFB x7C,F
03F58:  MOVLW  10
03F5A:  ADDWF  x72,W
03F5C:  MOVWF  FE9
03F5E:  MOVLW  00
03F60:  ADDWFC x73,W
03F62:  MOVWF  FEA
03F64:  MOVFF  FEC,03
03F68:  MOVF   FED,F
03F6A:  MOVFF  FEF,00
03F6E:  MOVFF  03,01
03F72:  CLRF   02
03F74:  CLRF   03
03F76:  MOVF   00,W
03F78:  SUBWF  x79,W
03F7A:  MOVWF  x75
03F7C:  MOVF   01,W
03F7E:  SUBWFB x7A,W
03F80:  MOVWF  x76
03F82:  MOVF   02,W
03F84:  SUBWFB x7B,W
03F86:  MOVWF  x77
03F88:  MOVF   03,W
03F8A:  SUBWFB x7C,W
03F8C:  MOVWF  x78
....................    if(temp < 0) 
03F8E:  BTFSS  x78.7
03F90:  BRA    3FA6
....................    { 
....................       ps->RemoteWindow = 0; 
03F92:  MOVLW  14
03F94:  ADDWF  x72,W
03F96:  MOVWF  FE9
03F98:  MOVLW  00
03F9A:  ADDWFC x73,W
03F9C:  MOVWF  FEA
03F9E:  CLRF   FEC
03FA0:  MOVF   FED,F
03FA2:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
03FA4:  BRA    3FBA
....................    else 
....................    { 
....................       ps->RemoteWindow = ack; 
03FA6:  MOVLW  14
03FA8:  ADDWF  x72,W
03FAA:  MOVWF  FE9
03FAC:  MOVLW  00
03FAE:  ADDWFC x73,W
03FB0:  MOVWF  FEA
03FB2:  MOVFF  362,FEF
03FB6:  MOVFF  363,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
03FBA:  MOVFF  372,FE9
03FBE:  MOVFF  373,FEA
03FC2:  DECFSZ FEF,W
03FC4:  BRA    4130
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
03FC6:  MOVLW  0D
03FC8:  ADDWF  x5E,W
03FCA:  MOVWF  FE9
03FCC:  MOVLW  00
03FCE:  ADDWFC x5F,W
03FD0:  MOVWF  FEA
03FD2:  BTFSC  FEF.1
03FD4:  BRA    3FFA
....................       { 
....................          MACDiscardRx(); 
03FD6:  MOVLB  0
03FD8:  CALL   2370
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
03FDC:  MOVLW  0D
03FDE:  MOVLB  3
03FE0:  ADDWF  x5E,W
03FE2:  MOVWF  FE9
03FE4:  MOVLW  00
03FE6:  ADDWFC x5F,W
03FE8:  MOVWF  FEA
03FEA:  BTFSS  FEF.4
03FEC:  BRA    3FF6
....................           { 
....................             flags = RST; 
03FEE:  MOVLW  04
03FF0:  MOVWF  x74
....................             goto SendTCPControlPacket; 
03FF2:  GOTO   47DA
....................            } 
....................  
....................          return; 
03FF6:  GOTO   4850
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
03FFA:  MOVLW  1A
03FFC:  ADDWF  x72,W
03FFE:  MOVWF  01
04000:  MOVLW  00
04002:  ADDWFC x73,W
04004:  MOVFF  01,379
04008:  MOVWF  x7A
0400A:  MOVLW  04
0400C:  ADDWF  x5E,W
0400E:  MOVWF  FE9
04010:  MOVLW  00
04012:  ADDWFC x5F,W
04014:  MOVWF  FEA
04016:  MOVFF  FEF,37B
0401A:  MOVFF  FEC,37C
0401E:  MOVFF  FEC,37D
04022:  MOVFF  FEC,37E
04026:  MOVF   x60,W
04028:  ADDWF  x7B,F
0402A:  MOVF   x61,W
0402C:  ADDWFC x7C,F
0402E:  MOVLW  00
04030:  ADDWFC x7D,F
04032:  ADDWFC x7E,F
04034:  MOVLW  01
04036:  ADDWF  x7B,W
04038:  MOVWF  00
0403A:  MOVLW  00
0403C:  ADDWFC x7C,W
0403E:  MOVWF  01
04040:  MOVLW  00
04042:  ADDWFC x7D,W
04044:  MOVWF  02
04046:  MOVLW  00
04048:  ADDWFC x7E,W
0404A:  MOVFF  37A,FEA
0404E:  MOVFF  379,FE9
04052:  MOVFF  00,FEF
04056:  MOVFF  01,FEC
0405A:  MOVFF  02,FEC
0405E:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
04060:  MOVLW  1A
04062:  ADDWF  x72,W
04064:  MOVWF  FE9
04066:  MOVLW  00
04068:  ADDWFC x73,W
0406A:  MOVWF  FEA
0406C:  MOVFF  FEF,362
04070:  MOVFF  FEC,363
04074:  MOVFF  FEC,364
04078:  MOVFF  FEC,365
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
0407C:  MOVLW  0D
0407E:  ADDWF  x5E,W
04080:  MOVWF  FE9
04082:  MOVLW  00
04084:  ADDWFC x5F,W
04086:  MOVWF  FEA
04088:  BTFSC  FEF.4
0408A:  BRA    40A6
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
0408C:  MOVFF  372,FE9
04090:  MOVFF  373,FEA
04094:  MOVLW  02
04096:  MOVWF  FEF
....................          MACDiscardRx(); 
04098:  MOVLB  0
0409A:  CALL   2370
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
0409E:  MOVLW  12
040A0:  MOVLB  3
040A2:  MOVWF  x74
....................          goto SendTCPControlPacket; 
040A4:  BRA    47DA
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
040A6:  MOVFF  372,FE9
040AA:  MOVFF  373,FEA
040AE:  MOVLW  03
040B0:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
040B2:  MOVLW  10
040B4:  MOVWF  x74
....................  
....................       ps->RemoteWindow = h->Window; 
040B6:  MOVLW  14
040B8:  ADDWF  x72,W
040BA:  MOVWF  01
040BC:  MOVLW  00
040BE:  ADDWFC x73,W
040C0:  MOVWF  03
040C2:  MOVWF  x7A
040C4:  MOVLW  0E
040C6:  ADDWF  x5E,W
040C8:  MOVWF  FE9
040CA:  MOVLW  00
040CC:  ADDWFC x5F,W
040CE:  MOVWF  FEA
040D0:  MOVFF  FEC,03
040D4:  MOVF   FED,F
040D6:  MOVFF  FEF,37B
040DA:  MOVFF  37A,FEA
040DE:  MOVFF  01,FE9
040E2:  MOVFF  03,FEC
040E6:  MOVF   FED,F
040E8:  MOVFF  37B,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
040EC:  MOVF   x60,W
040EE:  IORWF  x61,W
040F0:  BZ    4126
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
040F2:  MOVLW  23
040F4:  ADDWF  x72,W
040F6:  MOVWF  FE9
040F8:  MOVLW  00
040FA:  ADDWFC x73,W
040FC:  MOVWF  FEA
040FE:  BSF    FEF.3
....................          ps->RxCount             = len; 
04100:  MOVLW  12
04102:  ADDWF  x72,W
04104:  MOVWF  FE9
04106:  MOVLW  00
04108:  ADDWFC x73,W
0410A:  MOVWF  FEA
0410C:  MOVFF  361,FEC
04110:  MOVF   FED,F
04112:  MOVFF  360,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
04116:  MOVLW  23
04118:  ADDWF  x72,W
0411A:  MOVWF  FE9
0411C:  MOVLW  00
0411E:  ADDWFC x73,W
04120:  MOVWF  FEA
04122:  BSF    FEF.2
....................       } 
04124:  BRA    412E
....................       else   // No application data in this packet 
....................       { 
....................          MACDiscardRx(); 
04126:  MOVLB  0
04128:  CALL   2370
0412C:  MOVLB  3
....................       } 
....................       goto SendTCPControlPacket; 
0412E:  BRA    47DA
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
04130:  MOVFF  372,FE9
04134:  MOVFF  373,FEA
04138:  MOVF   FEF,F
0413A:  BTFSS  FD8.2
0413C:  BRA    42BC
....................    { 
....................       MACDiscardRx(); 
0413E:  MOVLB  0
04140:  CALL   2370
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
04144:  MOVLW  0D
04146:  MOVLB  3
04148:  ADDWF  x5E,W
0414A:  MOVWF  FE9
0414C:  MOVLW  00
0414E:  ADDWFC x5F,W
04150:  MOVWF  FEA
04152:  BTFSC  FEF.1
04154:  BRA    415C
....................       { 
....................          flags = RST; 
04156:  MOVLW  04
04158:  MOVWF  x74
....................          goto SendTCPControlPacket; 
0415A:  BRA    47DA
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
0415C:  MOVLW  1A
0415E:  ADDWF  x72,W
04160:  MOVWF  01
04162:  MOVLW  00
04164:  ADDWFC x73,W
04166:  MOVFF  01,379
0416A:  MOVWF  x7A
0416C:  MOVLW  04
0416E:  ADDWF  x5E,W
04170:  MOVWF  FE9
04172:  MOVLW  00
04174:  ADDWFC x5F,W
04176:  MOVWF  FEA
04178:  MOVFF  FEF,37B
0417C:  MOVFF  FEC,37C
04180:  MOVFF  FEC,37D
04184:  MOVFF  FEC,37E
04188:  MOVF   x60,W
0418A:  ADDWF  x7B,F
0418C:  MOVF   x61,W
0418E:  ADDWFC x7C,F
04190:  MOVLW  00
04192:  ADDWFC x7D,F
04194:  ADDWFC x7E,F
04196:  MOVLW  01
04198:  ADDWF  x7B,W
0419A:  MOVWF  00
0419C:  MOVLW  00
0419E:  ADDWFC x7C,W
041A0:  MOVWF  01
041A2:  MOVLW  00
041A4:  ADDWFC x7D,W
041A6:  MOVWF  02
041A8:  MOVLW  00
041AA:  ADDWFC x7E,W
041AC:  MOVFF  37A,FEA
041B0:  MOVFF  379,FE9
041B4:  MOVFF  00,FEF
041B8:  MOVFF  01,FEC
041BC:  MOVFF  02,FEC
041C0:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
041C2:  MOVLW  14
041C4:  ADDWF  x72,W
041C6:  MOVWF  01
041C8:  MOVLW  00
041CA:  ADDWFC x73,W
041CC:  MOVWF  03
041CE:  MOVWF  x7A
041D0:  MOVLW  0E
041D2:  ADDWF  x5E,W
041D4:  MOVWF  FE9
041D6:  MOVLW  00
041D8:  ADDWFC x5F,W
041DA:  MOVWF  FEA
041DC:  MOVFF  FEC,03
041E0:  MOVF   FED,F
041E2:  MOVFF  FEF,37B
041E6:  MOVFF  37A,FEA
041EA:  MOVFF  01,FE9
041EE:  MOVFF  03,FEC
041F2:  MOVF   FED,F
041F4:  MOVFF  37B,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
041F8:  MOVLW  01
041FA:  ADDWF  x72,W
041FC:  MOVWF  01
041FE:  MOVLW  00
04200:  ADDWFC x73,W
04202:  MOVWF  03
04204:  MOVFF  01,379
04208:  MOVWF  x7A
0420A:  MOVWF  FEA
0420C:  MOVFF  01,FE9
04210:  MOVFF  35D,FE2
04214:  MOVFF  35C,FE1
04218:  MOVLW  0A
0421A:  MOVWF  01
0421C:  MOVFF  FE6,FEE
04220:  DECFSZ 01,F
04222:  BRA    421C
....................       ps->remotePort = h->SourcePort; 
04224:  MOVLW  0D
04226:  ADDWF  x72,W
04228:  MOVWF  01
0422A:  MOVLW  00
0422C:  ADDWFC x73,W
0422E:  MOVFF  35E,FE9
04232:  MOVFF  35F,FEA
04236:  MOVFF  FEC,03
0423A:  MOVF   FED,F
0423C:  MOVFF  FEF,37B
04240:  MOVWF  FEA
04242:  MOVFF  01,FE9
04246:  MOVFF  03,FEC
0424A:  MOVF   FED,F
0424C:  MOVFF  37B,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
04250:  MOVFF  372,FE9
04254:  MOVFF  373,FEA
04258:  MOVLW  02
0425A:  MOVWF  FEF
....................       seq = ps->SND_SEQ++; 
0425C:  MOVLW  16
0425E:  ADDWF  x72,W
04260:  MOVWF  FE9
04262:  MOVLW  00
04264:  ADDWFC x73,W
04266:  MOVWF  FEA
04268:  MOVF   FEE,F
0426A:  MOVF   FEE,F
0426C:  MOVF   FEE,F
0426E:  MOVFF  FED,03
04272:  MOVFF  FED,02
04276:  MOVFF  FED,01
0427A:  MOVFF  FEF,00
0427E:  MOVLW  01
04280:  ADDWF  FEE,F
04282:  MOVLW  00
04284:  ADDWFC FEE,F
04286:  ADDWFC FEE,F
04288:  ADDWFC FED,F
0428A:  MOVFF  03,369
0428E:  MOVFF  02,368
04292:  MOVFF  01,367
04296:  MOVFF  00,366
....................       ack =  ps->SND_ACK; 
0429A:  MOVLW  1A
0429C:  ADDWF  x72,W
0429E:  MOVWF  FE9
042A0:  MOVLW  00
042A2:  ADDWFC x73,W
042A4:  MOVWF  FEA
042A6:  MOVFF  FEF,362
042AA:  MOVFF  FEC,363
042AE:  MOVFF  FEC,364
042B2:  MOVFF  FEC,365
....................       flags = SYN | ACK; 
042B6:  MOVLW  12
042B8:  MOVWF  x74
....................       goto SendTCPControlPacket; 
042BA:  BRA    47DA
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
042BC:  MOVLW  1A
042BE:  ADDWF  x72,W
042C0:  MOVWF  FE9
042C2:  MOVLW  00
042C4:  ADDWFC x73,W
042C6:  MOVWF  FEA
042C8:  MOVFF  FEF,36A
042CC:  MOVFF  FEC,36B
042D0:  MOVFF  FEC,36C
042D4:  MOVFF  FEC,36D
....................    prevSeq = ps->SND_SEQ; 
042D8:  MOVLW  16
042DA:  ADDWF  x72,W
042DC:  MOVWF  FE9
042DE:  MOVLW  00
042E0:  ADDWFC x73,W
042E2:  MOVWF  FEA
042E4:  MOVFF  FEF,36E
042E8:  MOVFF  FEC,36F
042EC:  MOVFF  FEC,370
042F0:  MOVFF  FEC,371
....................  
....................    ack = h->SeqNumber; 
042F4:  MOVLW  04
042F6:  ADDWF  x5E,W
042F8:  MOVWF  FE9
042FA:  MOVLW  00
042FC:  ADDWFC x5F,W
042FE:  MOVWF  FEA
04300:  MOVFF  FEF,362
04304:  MOVFF  FEC,363
04308:  MOVFF  FEC,364
0430C:  MOVFF  FEC,365
....................    ack += (DWORD)len; 
04310:  CLRF   02
04312:  CLRF   03
04314:  MOVF   x60,W
04316:  ADDWF  x62,F
04318:  MOVF   x61,W
0431A:  ADDWFC x63,F
0431C:  MOVF   02,W
0431E:  ADDWFC x64,F
04320:  MOVF   03,W
04322:  ADDWFC x65,F
....................    seq = ps->SND_SEQ; 
04324:  MOVLW  16
04326:  ADDWF  x72,W
04328:  MOVWF  FE9
0432A:  MOVLW  00
0432C:  ADDWFC x73,W
0432E:  MOVWF  FEA
04330:  MOVFF  FEF,366
04334:  MOVFF  FEC,367
04338:  MOVFF  FEC,368
0433C:  MOVFF  FEC,369
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
04340:  MOVLW  04
04342:  ADDWF  x5E,W
04344:  MOVWF  FE9
04346:  MOVLW  00
04348:  ADDWFC x5F,W
0434A:  MOVWF  FEA
0434C:  MOVFF  FEF,379
04350:  MOVFF  FEC,37A
04354:  MOVFF  FEC,37B
04358:  MOVFF  FEC,37C
0435C:  MOVF   x6A,W
0435E:  SUBWF  x79,W
04360:  BTFSS  FD8.2
04362:  BRA    47BE
04364:  MOVF   x6B,W
04366:  SUBWF  x7A,W
04368:  BTFSS  FD8.2
0436A:  BRA    47BE
0436C:  MOVF   x6C,W
0436E:  SUBWF  x7B,W
04370:  BTFSS  FD8.2
04372:  BRA    47BE
04374:  MOVF   x6D,W
04376:  SUBWF  x7C,W
04378:  BTFSS  FD8.2
0437A:  BRA    47BE
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
0437C:  MOVFF  372,FE9
04380:  MOVFF  373,FEA
04384:  MOVF   FEF,W
04386:  SUBLW  02
04388:  BNZ   4410
....................          { 
....................             if(h->Flags.bits.flagACK) 
0438A:  MOVLW  0D
0438C:  ADDWF  x5E,W
0438E:  MOVWF  FE9
04390:  MOVLW  00
04392:  ADDWFC x5F,W
04394:  MOVWF  FEA
04396:  BTFSS  FEF.4
04398:  BRA    4406
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
0439A:  MOVLW  1A
0439C:  ADDWF  x72,W
0439E:  MOVWF  FE9
043A0:  MOVLW  00
043A2:  ADDWFC x73,W
043A4:  MOVWF  FEA
043A6:  MOVFF  362,FEF
043AA:  MOVFF  363,FEC
043AE:  MOVFF  364,FEC
043B2:  MOVFF  365,FEC
....................                ps->smState = TCP_ESTABLISHED; 
043B6:  MOVFF  372,FE9
043BA:  MOVFF  373,FEA
043BE:  MOVLW  03
043C0:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
043C2:  MOVF   x60,W
043C4:  IORWF  x61,W
043C6:  BZ    43FC
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
043C8:  MOVLW  23
043CA:  ADDWF  x72,W
043CC:  MOVWF  FE9
043CE:  MOVLW  00
043D0:  ADDWFC x73,W
043D2:  MOVWF  FEA
043D4:  BSF    FEF.3
....................                   ps->RxCount             = len; 
043D6:  MOVLW  12
043D8:  ADDWF  x72,W
043DA:  MOVWF  FE9
043DC:  MOVLW  00
043DE:  ADDWFC x73,W
043E0:  MOVWF  FEA
043E2:  MOVFF  361,FEC
043E6:  MOVF   FED,F
043E8:  MOVFF  360,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
043EC:  MOVLW  23
043EE:  ADDWF  x72,W
043F0:  MOVWF  FE9
043F2:  MOVLW  00
043F4:  ADDWFC x73,W
043F6:  MOVWF  FEA
043F8:  BSF    FEF.2
....................                } 
043FA:  BRA    4404
....................                else 
....................                   MACDiscardRx(); 
043FC:  MOVLB  0
043FE:  CALL   2370
04402:  MOVLB  3
....................             } 
04404:  BRA    440E
....................             else   // No ACK to our SYN 
....................             { 
....................                MACDiscardRx(); 
04406:  MOVLB  0
04408:  CALL   2370
0440C:  MOVLB  3
....................             } 
....................          } 
0440E:  BRA    47BC
....................          // Connection is established, closing, or otherwise 
....................          else 
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
04410:  MOVLW  1A
04412:  ADDWF  x72,W
04414:  MOVWF  FE9
04416:  MOVLW  00
04418:  ADDWFC x73,W
0441A:  MOVWF  FEA
0441C:  MOVFF  362,FEF
04420:  MOVFF  363,FEC
04424:  MOVFF  364,FEC
04428:  MOVFF  365,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
0442C:  MOVFF  372,FE9
04430:  MOVFF  373,FEA
04434:  MOVF   FEF,W
04436:  SUBLW  03
04438:  BTFSS  FD8.2
0443A:  BRA    45EE
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
0443C:  MOVLW  0D
0443E:  ADDWF  x5E,W
04440:  MOVWF  FE9
04442:  MOVLW  00
04444:  ADDWFC x5F,W
04446:  MOVWF  FEA
04448:  BTFSS  FEF.4
0444A:  BRA    44A6
0444C:  MOVLW  23
0444E:  ADDWF  x72,W
04450:  MOVWF  FE9
04452:  MOVLW  00
04454:  ADDWFC x73,W
04456:  MOVWF  FEA
04458:  BTFSC  FEF.1
0445A:  BRA    44A6
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
0445C:  MOVLW  0F
0445E:  ADDWF  x72,W
04460:  MOVWF  FE9
04462:  MOVLW  00
04464:  ADDWFC x73,W
04466:  MOVWF  FEA
04468:  INCFSZ FEF,W
0446A:  BRA    446E
0446C:  BRA    44A6
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
0446E:  MOVLW  0F
04470:  ADDWF  x72,W
04472:  MOVWF  FE9
04474:  MOVLW  00
04476:  ADDWFC x73,W
04478:  MOVWF  FEA
0447A:  MOVFF  FEF,379
0447E:  MOVFF  379,37C
04482:  MOVLB  0
04484:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
04488:  MOVLW  0F
0448A:  MOVLB  3
0448C:  ADDWF  x72,W
0448E:  MOVWF  FE9
04490:  MOVLW  00
04492:  ADDWFC x73,W
04494:  MOVWF  FEA
04496:  SETF   FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
04498:  MOVLW  23
0449A:  ADDWF  x72,W
0449C:  MOVWF  FE9
0449E:  MOVLW  00
044A0:  ADDWFC x73,W
044A2:  MOVWF  FEA
044A4:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
044A6:  MOVLW  0D
044A8:  ADDWF  x5E,W
044AA:  MOVWF  FE9
044AC:  MOVLW  00
044AE:  ADDWFC x5F,W
044B0:  MOVWF  FEA
044B2:  BTFSS  FEF.0
044B4:  BRA    4556
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
044B6:  MOVLW  11
044B8:  MOVWF  x74
....................                   seq = ps->SND_SEQ++; 
044BA:  MOVLW  16
044BC:  ADDWF  x72,W
044BE:  MOVWF  FE9
044C0:  MOVLW  00
044C2:  ADDWFC x73,W
044C4:  MOVWF  FEA
044C6:  MOVF   FEE,F
044C8:  MOVF   FEE,F
044CA:  MOVF   FEE,F
044CC:  MOVFF  FED,03
044D0:  MOVFF  FED,02
044D4:  MOVFF  FED,01
044D8:  MOVFF  FEF,00
044DC:  MOVLW  01
044DE:  ADDWF  FEE,F
044E0:  MOVLW  00
044E2:  ADDWFC FEE,F
044E4:  ADDWFC FEE,F
044E6:  ADDWFC FED,F
044E8:  MOVFF  03,369
044EC:  MOVFF  02,368
044F0:  MOVFF  01,367
044F4:  MOVFF  00,366
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
044F8:  MOVLW  1A
044FA:  ADDWF  x72,W
044FC:  MOVWF  FE9
044FE:  MOVLW  00
04500:  ADDWFC x73,W
04502:  MOVWF  FEA
04504:  MOVLW  01
04506:  ADDWF  FEF,W
04508:  MOVWF  00
0450A:  MOVLW  00
0450C:  ADDWFC FEC,W
0450E:  MOVWF  01
04510:  MOVLW  00
04512:  ADDWFC FEC,W
04514:  MOVWF  02
04516:  MOVLW  00
04518:  ADDWFC FEC,W
0451A:  MOVF   FED,F
0451C:  MOVF   FED,F
0451E:  MOVF   FED,F
04520:  MOVFF  00,FEF
04524:  MOVFF  01,FEC
04528:  MOVFF  02,FEC
0452C:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
0452E:  MOVLW  1A
04530:  ADDWF  x72,W
04532:  MOVWF  FE9
04534:  MOVLW  00
04536:  ADDWFC x73,W
04538:  MOVWF  FEA
0453A:  MOVFF  FEF,362
0453E:  MOVFF  FEC,363
04542:  MOVFF  FEC,364
04546:  MOVFF  FEC,365
....................                   ps->smState = TCP_LAST_ACK; 
0454A:  MOVFF  372,FE9
0454E:  MOVFF  373,FEA
04552:  MOVLW  09
04554:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
04556:  MOVF   x60,W
04558:  IORWF  x61,W
0455A:  BZ    45E4
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
0455C:  MOVLW  23
0455E:  ADDWF  x72,W
04560:  MOVWF  FE9
04562:  MOVLW  00
04564:  ADDWFC x73,W
04566:  MOVWF  FEA
04568:  BTFSC  FEF.3
0456A:  BRA    45A2
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
0456C:  MOVLW  23
0456E:  ADDWF  x72,W
04570:  MOVWF  FE9
04572:  MOVLW  00
04574:  ADDWFC x73,W
04576:  MOVWF  FEA
04578:  BSF    FEF.3
....................                      ps->RxCount             = len; 
0457A:  MOVLW  12
0457C:  ADDWF  x72,W
0457E:  MOVWF  FE9
04580:  MOVLW  00
04582:  ADDWFC x73,W
04584:  MOVWF  FEA
04586:  MOVFF  361,FEC
0458A:  MOVF   FED,F
0458C:  MOVFF  360,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
04590:  MOVLW  23
04592:  ADDWF  x72,W
04594:  MOVWF  FE9
04596:  MOVLW  00
04598:  ADDWFC x73,W
0459A:  MOVWF  FEA
0459C:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
0459E:  BSF    x74.4
....................                   } 
045A0:  BRA    45E2
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
045A2:  MOVLW  16
045A4:  ADDWF  x72,W
045A6:  MOVWF  FE9
045A8:  MOVLW  00
045AA:  ADDWFC x73,W
045AC:  MOVWF  FEA
045AE:  MOVFF  36E,FEF
045B2:  MOVFF  36F,FEC
045B6:  MOVFF  370,FEC
045BA:  MOVFF  371,FEC
....................                      ps->SND_ACK = prevAck; 
045BE:  MOVLW  1A
045C0:  ADDWF  x72,W
045C2:  MOVWF  FE9
045C4:  MOVLW  00
045C6:  ADDWFC x73,W
045C8:  MOVWF  FEA
045CA:  MOVFF  36A,FEF
045CE:  MOVFF  36B,FEC
045D2:  MOVFF  36C,FEC
045D6:  MOVFF  36D,FEC
....................  
....................                      MACDiscardRx(); 
045DA:  MOVLB  0
045DC:  CALL   2370
045E0:  MOVLB  3
....................                   } 
....................                } 
045E2:  BRA    45EC
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
....................                { 
....................                   MACDiscardRx(); 
045E4:  MOVLB  0
045E6:  CALL   2370
045EA:  MOVLB  3
....................                } 
....................             } 
045EC:  BRA    47BC
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
045EE:  MOVFF  372,FE9
045F2:  MOVFF  373,FEA
045F6:  MOVF   FEF,W
045F8:  SUBLW  09
045FA:  BNZ   4626
....................             { 
....................                MACDiscardRx(); 
045FC:  MOVLB  0
045FE:  CALL   2370
....................  
....................                if(h->Flags.bits.flagACK) 
04602:  MOVLW  0D
04604:  MOVLB  3
04606:  ADDWF  x5E,W
04608:  MOVWF  FE9
0460A:  MOVLW  00
0460C:  ADDWFC x5F,W
0460E:  MOVWF  FEA
04610:  BTFSS  FEF.4
04612:  BRA    4624
....................                { 
....................                   CloseSocket(ps); 
04614:  MOVFF  373,37A
04618:  MOVFF  372,379
0461C:  MOVLB  0
0461E:  CALL   37B8
04622:  MOVLB  3
....................                } 
....................             } 
04624:  BRA    47BC
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
04626:  MOVFF  372,FE9
0462A:  MOVFF  373,FEA
0462E:  MOVF   FEF,W
04630:  SUBLW  04
04632:  BNZ   46F8
....................             { 
....................                MACDiscardRx(); 
04634:  MOVLB  0
04636:  CALL   2370
....................  
....................                if(h->Flags.bits.flagFIN) 
0463A:  MOVLW  0D
0463C:  MOVLB  3
0463E:  ADDWF  x5E,W
04640:  MOVWF  FE9
04642:  MOVLW  00
04644:  ADDWFC x5F,W
04646:  MOVWF  FEA
04648:  BTFSS  FEF.0
0464A:  BRA    46D6
....................                { 
....................                   flags = ACK; 
0464C:  MOVLW  10
0464E:  MOVWF  x74
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
04650:  MOVLW  1A
04652:  ADDWF  x72,W
04654:  MOVWF  FE9
04656:  MOVLW  00
04658:  ADDWFC x73,W
0465A:  MOVWF  FEA
0465C:  MOVLW  01
0465E:  ADDWF  FEF,W
04660:  MOVWF  00
04662:  MOVLW  00
04664:  ADDWFC FEC,W
04666:  MOVWF  01
04668:  MOVLW  00
0466A:  ADDWFC FEC,W
0466C:  MOVWF  02
0466E:  MOVLW  00
04670:  ADDWFC FEC,W
04672:  MOVF   FED,F
04674:  MOVF   FED,F
04676:  MOVF   FED,F
04678:  MOVFF  00,FEF
0467C:  MOVFF  01,FEC
04680:  MOVFF  02,FEC
04684:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
04686:  MOVLW  1A
04688:  ADDWF  x72,W
0468A:  MOVWF  FE9
0468C:  MOVLW  00
0468E:  ADDWFC x73,W
04690:  MOVWF  FEA
04692:  MOVFF  FEF,362
04696:  MOVFF  FEC,363
0469A:  MOVFF  FEC,364
0469E:  MOVFF  FEC,365
....................                   if(h->Flags.bits.flagACK) 
046A2:  MOVLW  0D
046A4:  ADDWF  x5E,W
046A6:  MOVWF  FE9
046A8:  MOVLW  00
046AA:  ADDWFC x5F,W
046AC:  MOVWF  FEA
046AE:  BTFSS  FEF.4
046B0:  BRA    46C4
....................                   { 
....................                      CloseSocket(ps); 
046B2:  MOVFF  373,37A
046B6:  MOVFF  372,379
046BA:  MOVLB  0
046BC:  CALL   37B8
....................                   } 
046C0:  BRA    46D2
046C2:  MOVLB  3
....................                   else 
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
046C4:  MOVFF  372,FE9
046C8:  MOVFF  373,FEA
046CC:  MOVLW  06
046CE:  MOVWF  FEF
046D0:  MOVLB  0
....................                   } 
....................                } 
046D2:  BRA    46F4
046D4:  MOVLB  3
....................                else if(h->Flags.bits.flagACK) 
046D6:  MOVLW  0D
046D8:  ADDWF  x5E,W
046DA:  MOVWF  FE9
046DC:  MOVLW  00
046DE:  ADDWFC x5F,W
046E0:  MOVWF  FEA
046E2:  BTFSS  FEF.4
046E4:  BRA    46F2
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
046E6:  MOVFF  372,FE9
046EA:  MOVFF  373,FEA
046EE:  MOVLW  05
046F0:  MOVWF  FEF
046F2:  MOVLB  0
....................                } 
....................             } 
046F4:  BRA    47BA
046F6:  MOVLB  3
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
046F8:  MOVFF  372,FE9
046FC:  MOVFF  373,FEA
04700:  MOVF   FEF,W
04702:  SUBLW  05
04704:  BNZ   4786
....................             { 
....................                MACDiscardRx(); 
04706:  MOVLB  0
04708:  CALL   2370
....................  
....................                if(h->Flags.bits.flagFIN) 
0470C:  MOVLW  0D
0470E:  MOVLB  3
04710:  ADDWF  x5E,W
04712:  MOVWF  FE9
04714:  MOVLW  00
04716:  ADDWFC x5F,W
04718:  MOVWF  FEA
0471A:  BTFSS  FEF.0
0471C:  BRA    4784
....................                { 
....................                   flags = ACK; 
0471E:  MOVLW  10
04720:  MOVWF  x74
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
04722:  MOVLW  1A
04724:  ADDWF  x72,W
04726:  MOVWF  FE9
04728:  MOVLW  00
0472A:  ADDWFC x73,W
0472C:  MOVWF  FEA
0472E:  MOVLW  01
04730:  ADDWF  FEF,W
04732:  MOVWF  00
04734:  MOVLW  00
04736:  ADDWFC FEC,W
04738:  MOVWF  01
0473A:  MOVLW  00
0473C:  ADDWFC FEC,W
0473E:  MOVWF  02
04740:  MOVLW  00
04742:  ADDWFC FEC,W
04744:  MOVF   FED,F
04746:  MOVF   FED,F
04748:  MOVF   FED,F
0474A:  MOVFF  00,FEF
0474E:  MOVFF  01,FEC
04752:  MOVFF  02,FEC
04756:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
04758:  MOVLW  1A
0475A:  ADDWF  x72,W
0475C:  MOVWF  FE9
0475E:  MOVLW  00
04760:  ADDWFC x73,W
04762:  MOVWF  FEA
04764:  MOVFF  FEF,362
04768:  MOVFF  FEC,363
0476C:  MOVFF  FEC,364
04770:  MOVFF  FEC,365
....................                   CloseSocket(ps); 
04774:  MOVFF  373,37A
04778:  MOVFF  372,379
0477C:  MOVLB  0
0477E:  CALL   37B8
04782:  MOVLB  3
....................                } 
....................             } 
04784:  BRA    47BC
....................             else if ( ps->smState == TCP_CLOSING ) 
04786:  MOVFF  372,FE9
0478A:  MOVFF  373,FEA
0478E:  MOVF   FEF,W
04790:  SUBLW  06
04792:  BNZ   47BC
....................             { 
....................                MACDiscardRx(); 
04794:  MOVLB  0
04796:  CALL   2370
....................  
....................                if ( h->Flags.bits.flagACK ) 
0479A:  MOVLW  0D
0479C:  MOVLB  3
0479E:  ADDWF  x5E,W
047A0:  MOVWF  FE9
047A2:  MOVLW  00
047A4:  ADDWFC x5F,W
047A6:  MOVWF  FEA
047A8:  BTFSS  FEF.4
047AA:  BRA    47BC
....................                { 
....................                   CloseSocket(ps); 
047AC:  MOVFF  373,37A
047B0:  MOVFF  372,379
047B4:  MOVLB  0
047B6:  CALL   37B8
047BA:  MOVLB  3
....................                } 
....................             } 
....................          } 
....................       } 
047BC:  BRA    47DA
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
....................       { 
....................          MACDiscardRx(); 
047BE:  MOVLB  0
047C0:  CALL   2370
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
047C4:  MOVLW  10
047C6:  MOVLB  3
047C8:  MOVWF  x74
....................          ack = prevAck; 
047CA:  MOVFF  36D,365
047CE:  MOVFF  36C,364
047D2:  MOVFF  36B,363
047D6:  MOVFF  36A,362
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
047DA:  MOVF   x74,F
047DC:  BZ    4850
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
047DE:  MOVLW  02
047E0:  ADDWF  x5E,W
047E2:  MOVWF  FE9
047E4:  MOVLW  00
047E6:  ADDWFC x5F,W
047E8:  MOVWF  FEA
047EA:  MOVFF  FEC,37A
047EE:  MOVF   FED,F
047F0:  MOVFF  FEF,379
047F4:  MOVFF  35E,FE9
047F8:  MOVFF  35F,FEA
047FC:  MOVFF  FEC,37C
04800:  MOVF   FED,F
04802:  MOVFF  FEF,37B
04806:  MOVFF  35D,381
0480A:  MOVFF  35C,380
0480E:  MOVFF  37A,383
04812:  MOVFF  379,382
04816:  MOVFF  37C,385
0481A:  MOVFF  37B,384
0481E:  MOVFF  369,389
04822:  MOVFF  368,388
04826:  MOVFF  367,387
0482A:  MOVFF  366,386
0482E:  MOVFF  365,38D
04832:  MOVFF  364,38C
04836:  MOVFF  363,38B
0483A:  MOVFF  362,38A
0483E:  MOVFF  374,38E
04842:  SETF   x8F
04844:  CLRF   x91
04846:  CLRF   x90
04848:  MOVLB  0
0484A:  CALL   3BF2
0484E:  MOVLB  3
....................    } 
04850:  MOVLB  0
04852:  GOTO   49F2 (RETURN)
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #define debug_icmp 
.................... //#define debug_icmp   debug_printf 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
.................... //    debug_icmp("\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
04AE4:  MOVLW  03
04AE6:  MOVLB  3
04AE8:  MOVWF  x88
04AEA:  MOVLW  3B
04AEC:  MOVWF  x87
04AEE:  MOVFF  388,3C7
04AF2:  MOVWF  xC6
04AF4:  CLRF   xC9
04AF6:  MOVLW  08
04AF8:  MOVWF  xC8
04AFA:  MOVLB  0
04AFC:  CALL   23DC
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
04B00:  MOVLB  3
04B02:  CLRF   x86
04B04:  CLRF   x85
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
04B06:  MOVFF  336,03
04B0A:  MOVFF  335,FE9
04B0E:  MOVFF  336,FEA
04B12:  MOVFF  FEF,387
04B16:  CLRF   x89
04B18:  MOVLW  14
04B1A:  MOVWF  x88
04B1C:  CLRF   x8B
04B1E:  MOVFF  387,38A
04B22:  MOVLB  0
04B24:  CALL   2DA2
04B28:  MOVFF  02,384
04B2C:  MOVFF  01,383
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
04B30:  MOVLB  3
04B32:  MOVFF  335,FE9
04B36:  MOVFF  336,FEA
04B3A:  MOVLW  08
04B3C:  SUBWF  FEF,W
04B3E:  MOVWF  FEF
....................     MACGetArray(data, *len); 
04B40:  MOVFF  336,03
04B44:  MOVFF  335,FE9
04B48:  MOVFF  336,FEA
04B4C:  MOVFF  FEF,387
04B50:  MOVFF  334,3C7
04B54:  MOVFF  333,3C6
04B58:  CLRF   xC9
04B5A:  MOVFF  387,3C8
04B5E:  MOVLB  0
04B60:  CALL   23DC
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
04B64:  MOVLW  03
04B66:  MOVLB  3
04B68:  MOVWF  x88
04B6A:  MOVLW  3B
04B6C:  MOVWF  x87
04B6E:  MOVLB  0
04B70:  RCALL  4A04
....................  
....................     *code = packet.Type; 
04B72:  MOVLB  3
04B74:  MOVFF  331,FE9
04B78:  MOVFF  332,FEA
04B7C:  MOVFF  33B,FEF
....................     *id = packet.Identifier; 
04B80:  MOVFF  337,FE9
04B84:  MOVFF  338,FEA
04B88:  MOVFF  340,FEC
04B8C:  MOVF   FED,F
04B8E:  MOVFF  33F,FEF
....................     *seq = packet.SequenceNumber; 
04B92:  MOVFF  339,FE9
04B96:  MOVFF  33A,FEA
04B9A:  MOVFF  342,FEC
04B9E:  MOVF   FED,F
04BA0:  MOVFF  341,FEF
....................  
.................... //    debug_icmp("%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
04BA4:  MOVF   x85,W
04BA6:  SUBWF  x83,W
04BA8:  BNZ   4BB0
04BAA:  MOVF   x86,W
04BAC:  SUBWF  x84,W
04BAE:  BZ    4BB4
04BB0:  MOVLW  00
04BB2:  BRA    4BB6
04BB4:  MOVLW  01
04BB6:  MOVWF  01
04BB8:  MOVLB  0
04BBA:  GOTO   7E12 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
04BBE:  MOVLW  01
04BC0:  MOVLB  3
04BC2:  MOVWF  xB8
04BC4:  MOVLB  0
04BC6:  CALL   2750
04BCA:  MOVFF  01,383
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
04BCE:  MOVLB  3
04BD0:  INCFSZ x83,W
04BD2:  BRA    4BD6
....................       return; 
04BD4:  BRA    4CCE
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
04BD6:  MOVFF  383,3D1
04BDA:  CLRF   xD3
04BDC:  MOVLW  14
04BDE:  MOVWF  xD2
04BE0:  MOVLB  0
04BE2:  CALL   2778
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
04BE6:  CLRF   03
04BE8:  MOVLB  3
04BEA:  MOVF   x34,W
04BEC:  ADDLW  08
04BEE:  MOVWF  x81
04BF0:  MOVLW  00
04BF2:  ADDWFC 03,W
04BF4:  MOVWF  x82
....................  
....................     packet.Code             = 0; 
04BF6:  CLRF   x3A
....................     packet.Type             = code; 
04BF8:  MOVFF  331,339
....................     packet.Checksum         = 0; 
04BFC:  CLRF   x3C
04BFE:  CLRF   x3B
....................     packet.Identifier       = id; 
04C00:  MOVFF  336,33E
04C04:  MOVFF  335,33D
....................     packet.SequenceNumber   = seq; 
04C08:  MOVFF  338,340
04C0C:  MOVFF  337,33F
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
04C10:  MOVLW  03
04C12:  MOVWF  FEA
04C14:  MOVLW  41
04C16:  MOVWF  FE9
04C18:  MOVFF  333,FE2
04C1C:  MOVFF  332,FE1
04C20:  MOVF   x34,W
04C22:  MOVWF  01
04C24:  BZ    4C2E
04C26:  MOVFF  FE6,FEE
04C2A:  DECFSZ 01,F
04C2C:  BRA    4C26
....................  
....................     SwapICMPPacket(&packet); 
04C2E:  MOVLW  03
04C30:  MOVWF  x88
04C32:  MOVLW  39
04C34:  MOVWF  x87
04C36:  MOVLB  0
04C38:  RCALL  4A04
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
04C3A:  MOVLW  08
04C3C:  MOVLB  3
04C3E:  ADDWF  x34,W
04C40:  CLRF   x85
04C42:  MOVWF  x84
04C44:  MOVFF  330,3B9
04C48:  MOVFF  32F,3B8
04C4C:  MOVLW  01
04C4E:  MOVWF  xBA
04C50:  MOVFF  385,3BC
04C54:  MOVFF  384,3BB
04C58:  MOVLB  0
04C5A:  CALL   3AD2
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
04C5E:  MOVLW  03
04C60:  MOVLB  3
04C62:  MOVWF  x85
04C64:  MOVLW  39
04C66:  MOVWF  x84
04C68:  MOVFF  385,3DD
04C6C:  MOVWF  xDC
04C6E:  MOVFF  382,3DF
04C72:  MOVFF  381,3DE
04C76:  MOVLB  0
04C78:  CALL   2844
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
04C7C:  MOVLB  3
04C7E:  CLRF   xD2
04C80:  MOVLW  14
04C82:  MOVWF  xD1
04C84:  MOVFF  382,3D4
04C88:  MOVFF  381,3D3
04C8C:  MOVLB  0
04C8E:  CALL   39FA
04C92:  MOVFF  02,33C
04C96:  MOVFF  01,33B
....................    IPSetTxBuffer(MyTxBuffer, 2); 
04C9A:  MOVFF  383,3D1
04C9E:  MOVLB  3
04CA0:  CLRF   xD3
04CA2:  MOVLW  16
04CA4:  MOVWF  xD2
04CA6:  MOVLB  0
04CA8:  CALL   2778
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
04CAC:  MOVLW  03
04CAE:  MOVLB  3
04CB0:  MOVWF  x85
04CB2:  MOVLW  3B
04CB4:  MOVWF  x84
04CB6:  MOVFF  385,3DD
04CBA:  MOVWF  xDC
04CBC:  CLRF   xDF
04CBE:  MOVLW  02
04CC0:  MOVWF  xDE
04CC2:  MOVLB  0
04CC4:  CALL   2844
.................... #endif 
....................  
....................  
....................     MACFlush(); 
04CC8:  CALL   2966
04CCC:  MOVLB  3
04CCE:  MOVLB  0
04CD0:  GOTO   7E70 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
04A04:  MOVLW  04
04A06:  MOVLB  3
04A08:  ADDWF  x87,W
04A0A:  MOVWF  01
04A0C:  MOVLW  00
04A0E:  ADDWFC x88,W
04A10:  MOVWF  03
04A12:  MOVFF  01,389
04A16:  MOVWF  x8A
04A18:  MOVLW  04
04A1A:  ADDWF  x87,W
04A1C:  MOVWF  FE9
04A1E:  MOVLW  00
04A20:  ADDWFC x88,W
04A22:  MOVWF  FEA
04A24:  MOVFF  FEC,38C
04A28:  MOVF   FED,F
04A2A:  MOVFF  FEF,38B
04A2E:  MOVFF  38C,3D8
04A32:  MOVFF  38B,3D7
04A36:  MOVLB  0
04A38:  CALL   2440
04A3C:  MOVFF  38A,FEA
04A40:  MOVFF  389,FE9
04A44:  MOVFF  02,FEC
04A48:  MOVF   FED,F
04A4A:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
04A4E:  MOVLW  06
04A50:  MOVLB  3
04A52:  ADDWF  x87,W
04A54:  MOVWF  01
04A56:  MOVLW  00
04A58:  ADDWFC x88,W
04A5A:  MOVWF  03
04A5C:  MOVFF  01,389
04A60:  MOVWF  x8A
04A62:  MOVLW  06
04A64:  ADDWF  x87,W
04A66:  MOVWF  FE9
04A68:  MOVLW  00
04A6A:  ADDWFC x88,W
04A6C:  MOVWF  FEA
04A6E:  MOVFF  FEC,38C
04A72:  MOVF   FED,F
04A74:  MOVFF  FEF,38B
04A78:  MOVFF  38C,3D8
04A7C:  MOVFF  38B,3D7
04A80:  MOVLB  0
04A82:  CALL   2440
04A86:  MOVFF  38A,FEA
04A8A:  MOVFF  389,FE9
04A8E:  MOVFF  02,FEC
04A92:  MOVF   FED,F
04A94:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
04A98:  MOVLW  02
04A9A:  MOVLB  3
04A9C:  ADDWF  x87,W
04A9E:  MOVWF  01
04AA0:  MOVLW  00
04AA2:  ADDWFC x88,W
04AA4:  MOVWF  03
04AA6:  MOVFF  01,389
04AAA:  MOVWF  x8A
04AAC:  MOVLW  02
04AAE:  ADDWF  x87,W
04AB0:  MOVWF  FE9
04AB2:  MOVLW  00
04AB4:  ADDWFC x88,W
04AB6:  MOVWF  FEA
04AB8:  MOVFF  FEC,38C
04ABC:  MOVF   FED,F
04ABE:  MOVFF  FEF,38B
04AC2:  MOVFF  38C,3D8
04AC6:  MOVFF  38B,3D7
04ACA:  MOVLB  0
04ACC:  CALL   2440
04AD0:  MOVFF  38A,FEA
04AD4:  MOVFF  389,FE9
04AD8:  MOVFF  02,FEC
04ADC:  MOVF   FED,F
04ADE:  MOVFF  01,FEF
04AE2:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
01F68:  BCF    59.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
01F6A:  MOVLB  1
01F6C:  SETF   x16
....................     Cache.MACAddr.v[1] = 0xff; 
01F6E:  SETF   x17
....................     Cache.MACAddr.v[2] = 0xff; 
01F70:  SETF   x18
....................     Cache.MACAddr.v[3] = 0xff; 
01F72:  SETF   x19
....................     Cache.MACAddr.v[4] = 0xff; 
01F74:  SETF   x1A
....................     Cache.MACAddr.v[5] = 0xff; 
01F76:  SETF   x1B
....................  
....................     Cache.IPAddr.Val = 0x0; 
01F78:  CLRF   x1F
01F7A:  CLRF   x1E
01F7C:  CLRF   x1D
01F7E:  CLRF   x1C
01F80:  MOVLB  0
01F82:  GOTO   2368 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
*
02D12:  MOVLW  00
02D14:  BTFSC  59.1
02D16:  MOVLW  01
02D18:  XORLW  00
02D1A:  BZ    2D1E
02D1C:  BRA    2D7C
....................     { 
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
02D1E:  MOVLW  03
02D20:  MOVLB  3
02D22:  MOVWF  x3B
02D24:  MOVLW  2F
02D26:  MOVWF  x3A
02D28:  MOVLW  03
02D2A:  MOVWF  x3D
02D2C:  MOVLW  39
02D2E:  MOVWF  x3C
02D30:  MOVLB  0
02D32:  BRA    2668
02D34:  MOVF   01,F
02D36:  BNZ   2D3A
....................             break; 
02D38:  BRA    2D9A
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
02D3A:  CALL   2370
....................  
....................         if ( opCode == ARP_REPLY ) 
02D3E:  MOVLB  3
02D40:  MOVF   x39,F
02D42:  BNZ   2D78
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
02D44:  MOVLW  01
02D46:  MOVWF  FEA
02D48:  MOVLW  16
02D4A:  MOVWF  FE9
02D4C:  MOVLW  03
02D4E:  MOVWF  FE2
02D50:  MOVLW  2F
02D52:  MOVWF  FE1
02D54:  MOVLW  06
02D56:  MOVWF  01
02D58:  MOVFF  FE6,FEE
02D5C:  DECFSZ 01,F
02D5E:  BRA    2D58
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
02D60:  MOVFF  338,11F
02D64:  MOVFF  337,11E
02D68:  MOVFF  336,11D
02D6C:  MOVFF  335,11C
....................             break; 
02D70:  MOVLB  0
02D72:  BRA    2D9A
....................         } 
02D74:  BRA    2D7C
02D76:  MOVLB  3
....................         else 
....................             smARP = SM_ARP_REPLY; 
02D78:  BSF    59.1
02D7A:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
02D7C:  MOVLW  03
02D7E:  MOVLB  3
02D80:  MOVWF  x3B
02D82:  MOVLW  2F
02D84:  MOVWF  x3A
02D86:  CLRF   x3C
02D88:  MOVLB  0
02D8A:  BRA    2B92
02D8C:  MOVF   01,F
02D8E:  BZ    2D94
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
02D90:  BCF    59.1
.................... 		} 
02D92:  BRA    2D9A
....................         else 
....................             return FALSE; 
02D94:  MOVLW  00
02D96:  MOVWF  01
02D98:  BRA    2D9E
....................         break; 
....................  
....................     } 
....................     return TRUE; 
02D9A:  MOVLW  01
02D9C:  MOVWF  01
02D9E:  GOTO   7D28 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
....................     { 
....................         *MACAddr = Cache.MACAddr; 
....................         return TRUE; 
....................     } 
....................     return FALSE; 
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arp 
.................... //#define debug_arp debug_printf 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
02668:  MOVLW  03
0266A:  MOVLB  3
0266C:  MOVWF  xC7
0266E:  MOVLW  3E
02670:  MOVWF  xC6
02672:  CLRF   xC9
02674:  MOVLW  1C
02676:  MOVWF  xC8
02678:  MOVLB  0
0267A:  RCALL  23DC
....................  
....................     MACDiscardRx(); 
0267C:  RCALL  2370
....................  
....................     SwapARPPacket(&packet); 
0267E:  MOVLW  03
02680:  MOVLB  3
02682:  MOVWF  x5B
02684:  MOVLW  3E
02686:  MOVWF  x5A
02688:  MOVLB  0
0268A:  RCALL  2594
....................  
....................    //debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................      // packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................      // packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................      // packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................      // packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
0268C:  MOVLB  3
0268E:  DECFSZ x3E,W
02690:  BRA    26A2
02692:  MOVF   x3F,F
02694:  BNZ   26A2
02696:  MOVF   x42,W
02698:  SUBLW  06
0269A:  BNZ   26A2
0269C:  MOVF   x43,W
0269E:  SUBLW  04
026A0:  BZ    26A8
....................          return FALSE; 
026A2:  MOVLW  00
026A4:  MOVWF  01
026A6:  BRA    274A
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
026A8:  MOVF   x44,W
026AA:  SUBLW  02
026AC:  BNZ   26C2
026AE:  MOVF   x45,F
026B0:  BNZ   26C2
....................         *opCode = ARP_REPLY; 
026B2:  MOVFF  33D,03
026B6:  MOVFF  33C,FE9
026BA:  MOVFF  33D,FEA
026BE:  CLRF   FEF
026C0:  BRA    26EE
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
026C2:  DECFSZ x44,W
026C4:  BRA    26DC
026C6:  MOVF   x45,F
026C8:  BNZ   26DC
....................         *opCode = ARP_REQUEST; 
026CA:  MOVFF  33D,03
026CE:  MOVFF  33C,FE9
026D2:  MOVFF  33D,FEA
026D6:  MOVLW  01
026D8:  MOVWF  FEF
026DA:  BRA    26EE
....................     else 
....................     { 
....................         *opCode = ARP_UNKNOWN; 
026DC:  MOVFF  33C,FE9
026E0:  MOVFF  33D,FEA
026E4:  MOVLW  02
026E6:  MOVWF  FEF
....................         return FALSE; 
026E8:  MOVLW  00
026EA:  MOVWF  01
026EC:  BRA    274A
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
026EE:  MOVF   1F,W
026F0:  SUBWF  x56,W
026F2:  BNZ   2746
026F4:  MOVF   20,W
026F6:  SUBWF  x57,W
026F8:  BNZ   2746
026FA:  MOVF   21,W
026FC:  SUBWF  x58,W
026FE:  BNZ   2746
02700:  MOVF   22,W
02702:  SUBWF  x59,W
02704:  BNZ   2746
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
02706:  MOVFF  33A,FE9
0270A:  MOVFF  33B,FEA
0270E:  MOVLW  03
02710:  MOVWF  FE2
02712:  MOVLW  46
02714:  MOVWF  FE1
02716:  MOVLW  06
02718:  MOVWF  01
0271A:  MOVFF  FE6,FEE
0271E:  DECFSZ 01,F
02720:  BRA    271A
....................         remote->IPAddr      = packet.SenderIPAddr; 
02722:  MOVLW  06
02724:  ADDWF  x3A,W
02726:  MOVWF  FE9
02728:  MOVLW  00
0272A:  ADDWFC x3B,W
0272C:  MOVWF  FEA
0272E:  MOVFF  34C,FEF
02732:  MOVFF  34D,FEC
02736:  MOVFF  34E,FEC
0273A:  MOVFF  34F,FEC
....................         return TRUE; 
0273E:  MOVLW  01
02740:  MOVWF  01
02742:  BRA    274A
....................     } 
02744:  BRA    274A
....................     else 
....................         return FALSE; 
02746:  MOVLW  00
02748:  MOVWF  01
0274A:  MOVLB  0
0274C:  GOTO   2D34 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
02B92:  MOVLW  01
02B94:  MOVLB  3
02B96:  MOVWF  xB8
02B98:  MOVLB  0
02B9A:  RCALL  2750
02B9C:  MOVFF  01,359
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
02BA0:  MOVLB  3
02BA2:  INCFSZ x59,W
02BA4:  BRA    2BAC
....................       return FALSE; 
02BA6:  MOVLW  00
02BA8:  MOVWF  01
02BAA:  BRA    2D0C
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
02BAC:  MOVFF  359,3D1
02BB0:  CLRF   xD3
02BB2:  CLRF   xD2
02BB4:  MOVLB  0
02BB6:  RCALL  2778
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
02BB8:  MOVLB  3
02BBA:  CLRF   x3E
02BBC:  MOVLW  01
02BBE:  MOVWF  x3D
....................     packet.Protocol                 = ARP_IP; 
02BC0:  MOVLW  08
02BC2:  MOVWF  x40
02BC4:  CLRF   x3F
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
02BC6:  MOVLW  06
02BC8:  MOVWF  x41
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
02BCA:  MOVLW  04
02BCC:  MOVWF  x42
....................  
....................     if ( opCode == ARP_REQUEST ) 
02BCE:  DECFSZ x3C,W
02BD0:  BRA    2BE6
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
02BD2:  CLRF   x44
02BD4:  MOVLW  01
02BD6:  MOVWF  x43
....................         packet.TargetMACAddr.v[0]   = 0xff; 
02BD8:  SETF   x4F
....................         packet.TargetMACAddr.v[1]   = 0xff; 
02BDA:  SETF   x50
....................         packet.TargetMACAddr.v[2]   = 0xff; 
02BDC:  SETF   x51
....................         packet.TargetMACAddr.v[3]   = 0xff; 
02BDE:  SETF   x52
....................         packet.TargetMACAddr.v[4]   = 0xff; 
02BE0:  SETF   x53
....................         packet.TargetMACAddr.v[5]   = 0xff; 
02BE2:  SETF   x54
....................     } 
02BE4:  BRA    2C08
....................     else 
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
02BE6:  CLRF   x44
02BE8:  MOVLW  02
02BEA:  MOVWF  x43
....................         packet.TargetMACAddr        = remote->MACAddr; 
02BEC:  MOVFF  33A,FE1
02BF0:  MOVFF  33B,FE2
02BF4:  MOVLW  03
02BF6:  MOVWF  FEA
02BF8:  MOVLW  4F
02BFA:  MOVWF  FE9
02BFC:  MOVLW  06
02BFE:  MOVWF  01
02C00:  MOVFF  FE6,FEE
02C04:  DECFSZ 01,F
02C06:  BRA    2C00
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
02C08:  MOVLW  03
02C0A:  MOVWF  FEA
02C0C:  MOVLW  45
02C0E:  MOVWF  FE9
02C10:  CLRF   FE2
02C12:  MOVLW  23
02C14:  MOVWF  FE1
02C16:  MOVLW  06
02C18:  MOVWF  01
02C1A:  MOVFF  FE6,FEE
02C1E:  DECFSZ 01,F
02C20:  BRA    2C1A
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
02C22:  MOVFF  22,34E
02C26:  MOVFF  21,34D
02C2A:  MOVFF  20,34C
02C2E:  MOVFF  1F,34B
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
02C32:  MOVLW  06
02C34:  ADDWF  x3A,W
02C36:  MOVWF  FE9
02C38:  MOVLW  00
02C3A:  ADDWFC x3B,W
02C3C:  MOVWF  FEA
02C3E:  MOVFF  FEF,00
02C42:  MOVFF  FEC,01
02C46:  MOVFF  FEC,02
02C4A:  MOVFF  FEC,03
02C4E:  MOVF   00,W
02C50:  XORWF  x4B,W
02C52:  MOVWF  x5A
02C54:  MOVF   01,W
02C56:  XORWF  x4C,W
02C58:  MOVWF  x5B
02C5A:  MOVF   02,W
02C5C:  XORWF  x4D,W
02C5E:  MOVWF  x5C
02C60:  MOVF   03,W
02C62:  XORWF  x4E,W
02C64:  MOVWF  x5D
02C66:  MOVF   x5A,W
02C68:  ANDWF  29,W
02C6A:  MOVWF  00
02C6C:  MOVF   x5B,W
02C6E:  ANDWF  2A,W
02C70:  MOVWF  01
02C72:  MOVF   x5C,W
02C74:  ANDWF  2B,W
02C76:  MOVWF  02
02C78:  MOVF   x5D,W
02C7A:  ANDWF  2C,W
02C7C:  MOVWF  03
02C7E:  MOVF   00,F
02C80:  BNZ   2C8E
02C82:  MOVF   01,F
02C84:  BNZ   2C8E
02C86:  MOVF   02,F
02C88:  BNZ   2C8E
02C8A:  MOVF   03,F
02C8C:  BZ    2CA0
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
02C8E:  MOVFF  30,358
02C92:  MOVFF  2F,357
02C96:  MOVFF  2E,356
02C9A:  MOVFF  2D,355
....................     } 
02C9E:  BRA    2CCC
....................     else 
....................         packet.TargetIPAddr             = remote->IPAddr; 
02CA0:  MOVLW  06
02CA2:  ADDWF  x3A,W
02CA4:  MOVWF  FE9
02CA6:  MOVLW  00
02CA8:  ADDWFC x3B,W
02CAA:  MOVWF  FEA
02CAC:  MOVFF  FEF,00
02CB0:  MOVFF  FEC,01
02CB4:  MOVFF  FEC,02
02CB8:  MOVFF  FEC,03
02CBC:  MOVFF  00,355
02CC0:  MOVFF  01,356
02CC4:  MOVFF  02,357
02CC8:  MOVFF  03,358
....................  
....................     SwapARPPacket(&packet); 
02CCC:  MOVLW  03
02CCE:  MOVWF  x5B
02CD0:  MOVLW  3D
02CD2:  MOVWF  x5A
02CD4:  MOVLB  0
02CD6:  RCALL  2594
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
02CD8:  MOVLW  03
02CDA:  MOVLB  3
02CDC:  MOVWF  xD6
02CDE:  MOVLW  4F
02CE0:  MOVWF  xD5
02CE2:  MOVLW  06
02CE4:  MOVWF  xD7
02CE6:  CLRF   xD9
02CE8:  MOVLW  1C
02CEA:  MOVWF  xD8
02CEC:  MOVLB  0
02CEE:  RCALL  2892
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
02CF0:  MOVLW  03
02CF2:  MOVLB  3
02CF4:  MOVWF  xDD
02CF6:  MOVLW  3D
02CF8:  MOVWF  xDC
02CFA:  CLRF   xDF
02CFC:  MOVLW  1C
02CFE:  MOVWF  xDE
02D00:  MOVLB  0
02D02:  RCALL  2844
....................  
....................     MACFlush(); 
02D04:  RCALL  2966
....................     
....................    return TRUE; 
02D06:  MOVLW  01
02D08:  MOVWF  01
02D0A:  MOVLB  3
02D0C:  MOVLB  0
02D0E:  GOTO   2D8C (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
02594:  MOVLB  3
02596:  MOVFF  35A,01
0259A:  MOVFF  35B,03
0259E:  MOVFF  35A,35C
025A2:  MOVFF  35B,35D
025A6:  MOVFF  35A,FE9
025AA:  MOVFF  35B,FEA
025AE:  MOVFF  FEC,35F
025B2:  MOVF   FED,F
025B4:  MOVFF  FEF,35E
025B8:  MOVFF  35F,3D8
025BC:  MOVFF  35E,3D7
025C0:  MOVLB  0
025C2:  RCALL  2440
025C4:  MOVFF  35D,FEA
025C8:  MOVFF  35C,FE9
025CC:  MOVFF  02,FEC
025D0:  MOVF   FED,F
025D2:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
025D6:  MOVLW  02
025D8:  MOVLB  3
025DA:  ADDWF  x5A,W
025DC:  MOVWF  01
025DE:  MOVLW  00
025E0:  ADDWFC x5B,W
025E2:  MOVWF  03
025E4:  MOVFF  01,35C
025E8:  MOVWF  x5D
025EA:  MOVLW  02
025EC:  ADDWF  x5A,W
025EE:  MOVWF  FE9
025F0:  MOVLW  00
025F2:  ADDWFC x5B,W
025F4:  MOVWF  FEA
025F6:  MOVFF  FEC,35F
025FA:  MOVF   FED,F
025FC:  MOVFF  FEF,35E
02600:  MOVFF  35F,3D8
02604:  MOVFF  35E,3D7
02608:  MOVLB  0
0260A:  RCALL  2440
0260C:  MOVFF  35D,FEA
02610:  MOVFF  35C,FE9
02614:  MOVFF  02,FEC
02618:  MOVF   FED,F
0261A:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
0261E:  MOVLW  06
02620:  MOVLB  3
02622:  ADDWF  x5A,W
02624:  MOVWF  01
02626:  MOVLW  00
02628:  ADDWFC x5B,W
0262A:  MOVWF  03
0262C:  MOVFF  01,35C
02630:  MOVWF  x5D
02632:  MOVLW  06
02634:  ADDWF  x5A,W
02636:  MOVWF  FE9
02638:  MOVLW  00
0263A:  ADDWFC x5B,W
0263C:  MOVWF  FEA
0263E:  MOVFF  FEC,35F
02642:  MOVF   FED,F
02644:  MOVFF  FEF,35E
02648:  MOVFF  35F,3D8
0264C:  MOVFF  35E,3D7
02650:  MOVLB  0
02652:  RCALL  2440
02654:  MOVFF  35D,FEA
02658:  MOVFF  35C,FE9
0265C:  MOVFF  02,FEC
02660:  MOVF   FED,F
02662:  MOVFF  01,FEF
02666:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///                              HTTP.C 
.................... /// 
.................... /// Simple webserver for the Microchip TCP/IP stack. 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES 
.................... /// 
.................... /// **** CONFIGURATION **** 
.................... /// 
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c 
.................... ///        in your application.  Defining this to be true will cause 
.................... ///        the stack to include the HTTP portion and execute the init 
.................... ///        and process any HTTP tasks. 
.................... /// 
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP 
.................... ///        connections. 
.................... /// 
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the 
.................... ///        HTTP server.  You probably will be fine with just 1.  The 
.................... ///        more sockets you use the more RAM is used to hold buffers 
.................... ///        and state configuration. 
.................... /// 
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several 
.................... ///        buffers.  This limits the size of your GET or POST requests 
.................... ///        and all CGI POST data: 
.................... ///            If using GET, then max amount of cgi data is this value 
.................... ///            minus everything else on the initial GET command (which 
.................... ///            also includes the filename).  I believe the max specified 
.................... ///            by W3C is 255. 
.................... ///            If using POST, then this is the maximum size for one 
.................... ///            key=value pair (including the '=' sign). 
.................... ///        These values do not inlude any escape characters. 
.................... /// 
.................... /// HTTP_USE_CHUNKS - Set to TRUE to make the HTTP server 1.1 compliant 
.................... ///      and will use Transfer-Encoding: chunked.  Default is FALSE. 
.................... /// 
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape 
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have 
.................... ///      two escape characters after the %.  An example of each: 
.................... ///         If FALSE: %A 
.................... ///         If TRUE: %0A 
.................... /// 
.................... /// HTTP_USE_CONTENT_TYPE - Set to TRUE if your http_get_page() has a third 
.................... ///      parameter which is the content-type of the requested page. 
.................... /// 
.................... /// **** HOW IT WORKS **** 
.................... /// 
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will 
.................... /// then listen for GET or POST requests.  When it gets a GET or POST 
.................... /// request it passes the page request to the callback function 
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or 
.................... /// a pointer to the constant memory area that holds the page in program 
.................... /// memory.  If it was a POST request it waits until the HTTP header is 
.................... /// done and then saves the POST data into a buffer, and passes the 
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will 
.................... /// parse the CGI post data and act upon it.  When done, the HTTP 
.................... /// server then responds by sending the page.  If the page is to have 
.................... /// variable data, it can be represented by an escape code - %0 or %1 
.................... /// for example.  When the HTTP stack sees such an escape code it calls 
.................... /// the callback function http_format_char() to format the escape code 
.................... /// into the needed variable data (such as ADC readings).  After the 
.................... /// HTTP stack is done sending the request it will close the port. 
.................... /// If the page didn't exist in program memory it will send a 404 File 
.................... /// not found error.  If there was a problem/timeout parsing the request 
.................... /// the HTTP stack will send a 500 Internal Server Error response. 
.................... /// 
.................... /// **** CALL BACK FUNCTIONS **** 
.................... /// 
.................... /// Your main application must provide the following callback functions to 
.................... /// fill application dependent needs: 
.................... /// 
.................... /// http_get_page(char *file); 
.................... ///    If HTTP_USE_CONTENT_TYPE is FALSE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is TRUE then see the next paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, returns address to page in 
.................... ///    program memory.  If it doesn't exist, returns 0. 
.................... /// 
.................... /// http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... ///    If HTTP_USE_CONTENT_TYPE is TRUE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is FALSE then see the previous paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, saves value to retAddress.  If 
.................... ///    the file doesn't exist, will save 0 to retAddress.  retStr is the 
.................... ///    content-type (text/html, text/xml, etc). 
.................... /// 
.................... /// http_exec_cgi(int32 file, char *key, char *val); 
.................... ///    A call-back function provided by your application that processes incoming 
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// int http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... ///    Given an escaped character in the program memory HTTP file, convert to 
.................... ///    variable data.  id is the escaped character, *str is where to save the 
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str. 
.................... ///    Returns the number of bytes written to *str.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// **** LIMITATIONS **** 
.................... /// 
.................... /// When creating web pages with forms, keep your form names (keys) simple 
.................... /// because the HTTP stack does not format the escape characters.  For example, 
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord". 
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving 
.................... /// the value, but not the key.  Therefore keep your keys simple. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// * Author         Date           Comment 
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... /// 
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST 
.................... /// 
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix 
.................... ///                                 many bugs.  The biggest bug is that 
.................... ///                                 it can send pages and receive CGI that 
.................... ///                                 is larger than 1 TCP packet.  Also 
.................... ///                                 added the HTTP_USE_CHUNKS, 
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and 
.................... ///                                 HTTP_USE_CONTENT_TYPE paremeters. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(char* file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
....................  
.................... //#define debug_http   debug_printf 
.................... #define debug_http(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
....................  
.................... const char http_404_error[]="<HTML><BODY><H1>404 Error</H1><HR><P>File Not found.</BODY></HTML>"; 
.................... const char http_500_error[]="<HTML><BODY><H1>500 Error</H1><HR><P>Internal Server Error</BODY></HTML>"; 
....................  
.................... //key=val pair string, & delimited 
.................... void http_parse_cgi_str(int32 file, char *cgistr); 
....................  
.................... int8 http_socket[HTTP_NUM_SOCKETS]={INVALID_SOCKET}; 
....................  
.................... enum { 
....................    HTTP_DISABLED = 0xFF, 
....................    HTTP_IGNORE, 
....................    HTTP_LISTEN_WAIT, 
....................    HTTP_CONNECTED, 
....................    HTTP_GET_HEADERS, 
....................    HTTP_GET_POST, 
....................    HTTP_GET_POST_CONTINUE, 
....................    HTTP_SEND_RESPONSE, 
....................    HTTP_SEND_RESPONSE_CONTINUE, 
....................    HTTP_CLOSE, 
....................    HTTP_CLOSE_WAITING, 
....................    HTTP_CLOSED 
.................... } http_state[HTTP_NUM_SOCKETS]={HTTP_IGNORE}; 
....................  
.................... //strips out any escape characters that the HTTP client may have inserted. 
.................... // (+ is replaced with space) 
.................... // (%xx is replaced with character representation of xx) 
.................... char * http_escape_chars(char *str) 
.................... { 
....................    char *ostr; 
....................    char new[3]; 
....................    char c; 
....................    char val; 
....................  
....................    new[2]=0; 
*
05A04:  MOVLB  3
05A06:  CLRF   x50
....................  
....................    ostr = str; 
05A08:  MOVFF  34B,34D
05A0C:  MOVFF  34A,34C
....................  
....................    while((c=*str) != 0) 
05A10:  MOVFF  34B,03
05A14:  MOVFF  34A,FE9
05A18:  MOVFF  34B,FEA
05A1C:  MOVFF  FEF,351
05A20:  MOVF   x51,F
05A22:  BZ    5AE4
....................    { 
....................       if (c=='+') 
05A24:  MOVF   x51,W
05A26:  SUBLW  2B
05A28:  BNZ   5A42
....................          *str++=' '; 
05A2A:  MOVFF  34B,03
05A2E:  MOVF   x4A,W
05A30:  INCF   x4A,F
05A32:  BTFSC  FD8.2
05A34:  INCF   x4B,F
05A36:  MOVWF  FE9
05A38:  MOVFF  03,FEA
05A3C:  MOVLW  20
05A3E:  MOVWF  FEF
05A40:  BRA    5AE0
....................       else if (c=='%') 
05A42:  MOVF   x51,W
05A44:  SUBLW  25
05A46:  BNZ   5ADA
....................       { 
....................          memcpy(new, str + 1, 2); 
05A48:  MOVLW  01
05A4A:  ADDWF  x4A,W
05A4C:  MOVWF  x53
05A4E:  MOVLW  00
05A50:  ADDWFC x4B,W
05A52:  MOVWF  x54
05A54:  MOVLW  03
05A56:  MOVWF  FEA
05A58:  MOVLW  4E
05A5A:  MOVWF  FE9
05A5C:  MOVFF  354,FE2
05A60:  MOVFF  353,FE1
05A64:  MOVLW  02
05A66:  MOVWF  01
05A68:  MOVFF  FE6,FEE
05A6C:  DECFSZ 01,F
05A6E:  BRA    5A68
....................          val = strtoul(new, 0, 16); 
05A70:  MOVLW  03
05A72:  MOVWF  x54
05A74:  MOVLW  4E
05A76:  MOVWF  x53
05A78:  CLRF   x56
05A7A:  CLRF   x55
05A7C:  MOVLW  10
05A7E:  MOVWF  x57
05A80:  MOVLB  0
05A82:  BRA    5588
05A84:  MOVFF  01,352
....................          *str++ = val; 
05A88:  MOVLB  3
05A8A:  MOVFF  34B,03
05A8E:  MOVF   x4A,W
05A90:  INCF   x4A,F
05A92:  BTFSC  FD8.2
05A94:  INCF   x4B,F
05A96:  MOVWF  FE9
05A98:  MOVFF  03,FEA
05A9C:  MOVFF  352,FEF
....................          memmove(str, str + 2, strlen(str) - 1); 
05AA0:  MOVLW  02
05AA2:  ADDWF  x4A,W
05AA4:  MOVWF  x53
05AA6:  MOVLW  00
05AA8:  ADDWFC x4B,W
05AAA:  MOVWF  x54
05AAC:  MOVFF  34B,38E
05AB0:  MOVFF  34A,38D
05AB4:  MOVLB  0
05AB6:  RCALL  58F4
05AB8:  MOVLW  01
05ABA:  SUBWF  01,W
05ABC:  MOVLB  3
05ABE:  MOVWF  x55
05AC0:  MOVFF  34B,357
05AC4:  MOVFF  34A,356
05AC8:  MOVFF  354,359
05ACC:  MOVFF  353,358
05AD0:  MOVWF  x5A
05AD2:  MOVLB  0
05AD4:  BRA    592E
....................       } 
05AD6:  BRA    5AE0
05AD8:  MOVLB  3
....................       else 
....................          str++; 
05ADA:  INCF   x4A,F
05ADC:  BTFSC  FD8.2
05ADE:  INCF   x4B,F
05AE0:  MOVLB  3
05AE2:  BRA    5A10
....................    } 
....................  
....................    return(ostr); 
05AE4:  MOVFF  34C,01
05AE8:  MOVFF  34D,02
05AEC:  MOVLB  0
05AEE:  RETURN 0
.................... } 
....................  
.................... void http_parse_cgi_string(int32 file, char *ptr) 
.................... { 
....................    char *pKey, *pValue, c; 
....................  
....................    pKey=ptr; 
*
05C50:  MOVFF  344,346
05C54:  MOVFF  343,345
....................    pValue=0; 
05C58:  MOVLB  3
05C5A:  CLRF   x48
05C5C:  CLRF   x47
....................  
....................    while(TRUE) 
....................    { 
....................       c = *ptr; 
05C5E:  MOVFF  343,FE9
05C62:  MOVFF  344,FEA
05C66:  MOVFF  FEF,349
....................       if ((c=='&') || (c==0)) 
05C6A:  MOVF   x49,W
05C6C:  SUBLW  26
05C6E:  BZ    5C74
05C70:  MOVF   x49,F
05C72:  BNZ   5CD0
....................       { 
....................          *ptr=0; 
05C74:  MOVFF  343,FE9
05C78:  MOVFF  344,FEA
05C7C:  CLRF   FEF
....................          http_escape_chars(pKey); 
05C7E:  MOVFF  346,34B
05C82:  MOVFF  345,34A
05C86:  MOVLB  0
05C88:  RCALL  5A04
....................          http_escape_chars(pValue); 
05C8A:  MOVFF  348,34B
05C8E:  MOVFF  347,34A
05C92:  RCALL  5A04
....................          http_exec_cgi(file, pKey, pValue); 
05C94:  MOVFF  342,34D
05C98:  MOVFF  341,34C
05C9C:  MOVFF  340,34B
05CA0:  MOVFF  33F,34A
05CA4:  MOVFF  346,34F
05CA8:  MOVFF  345,34E
05CAC:  MOVFF  348,351
05CB0:  MOVFF  347,350
05CB4:  BRA    5C4C
....................          pKey=ptr+1; 
05CB6:  MOVLW  01
05CB8:  MOVLB  3
05CBA:  ADDWF  x43,W
05CBC:  MOVWF  x45
05CBE:  MOVLW  00
05CC0:  ADDWFC x44,W
05CC2:  MOVWF  x46
....................          pValue=0; 
05CC4:  CLRF   x48
05CC6:  CLRF   x47
....................          if (c==0) 
05CC8:  MOVF   x49,F
05CCA:  BNZ   5CCE
....................             break; 
05CCC:  BRA    5CF4
....................       } 
05CCE:  BRA    5CEC
....................       else if (c=='=') 
05CD0:  MOVF   x49,W
05CD2:  SUBLW  3D
05CD4:  BNZ   5CEC
....................       { 
....................          *ptr=0; 
05CD6:  MOVFF  343,FE9
05CDA:  MOVFF  344,FEA
05CDE:  CLRF   FEF
....................          pValue=ptr+1; 
05CE0:  MOVLW  01
05CE2:  ADDWF  x43,W
05CE4:  MOVWF  x47
05CE6:  MOVLW  00
05CE8:  ADDWFC x44,W
05CEA:  MOVWF  x48
....................       } 
....................       ptr++; 
05CEC:  INCF   x43,F
05CEE:  BTFSC  FD8.2
05CF0:  INCF   x44,F
05CF2:  BRA    5C5E
....................    } 
05CF4:  MOVLB  0
05CF6:  RETURN 0
.................... } 
....................  
.................... int8 _httpPutcSocket; 
....................  
.................... #define tcp_http_tx_left()  TCPPutAvailable(_httpPutcSocket) 
....................  
.................... void set_tcp_http_putc(int8 newSocket) 
.................... { 
....................    _httpPutcSocket=newSocket; 
*
05FDA:  MOVFF  347,123
05FDE:  GOTO   6BAA (RETURN)
.................... } 
....................  
.................... int tcp_http_putc(char c) 
.................... { 
....................    return(TCPPut(_httpPutcSocket,c)); 
*
062F2:  MOVFF  123,366
062F6:  MOVFF  365,367
062FA:  BRA    61AC
062FC:  MOVF   01,W
062FE:  RETURN 0
.................... } 
....................  
.................... int32 lastHTTPPutConstPos[HTTP_NUM_SOCKETS]; 
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS]; 
....................  
.................... #if HTTP_USE_CHUNKS 
.................... void TCPPutFileChunkStart(int16 count) 
.................... { 
....................    printf(tcp_http_putc, "%04LX\r\n", count); 
.................... } 
....................  
.................... void TCPPutFileChunkStop(void) 
.................... { 
....................    tcp_http_putc('\r'); 
....................    tcp_http_putc('\n'); 
.................... } 
.................... #else 
....................  #define TCPPutFileChunkStart(x) 
....................  #define TCPPutFileChunkStop() 
.................... #endif 
....................  
.................... typedef enum 
.................... { 
....................    TCP_PUT_CONST_EC_FINISH = 0, 
....................    TCP_PUT_CONST_EC_CONTINUE, 
....................    TCP_PUT_CONST_EC_ESCAPE 
.................... } TCP_PUT_CONST_EC; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileVarChunk(ptr) 
.................... // 
.................... // send a chunked response from ram 
.................... // 
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated 
.................... //          with the continue position before exit. 
.................... // 
.................... // Returns a status code: 
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed 
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr) 
.................... //because of a compiler error i had to make this double pointer an int16, when 
.................... //it should be a char. 
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(int16 **retPtr) 
.................... { 
....................    int16 txLeft, n; 
....................    char *ptr, ec; 
....................  
....................    ptr=*retPtr; 
*
06540:  MOVLB  3
06542:  MOVFF  349,FE9
06546:  MOVFF  34A,FEA
0654A:  MOVFF  FEC,03
0654E:  MOVF   FED,F
06550:  MOVFF  FEF,34F
06554:  MOVFF  03,350
....................  
....................    n=strlen(ptr); 
06558:  MOVFF  350,38E
0655C:  MOVFF  34F,38D
06560:  MOVLB  0
06562:  CALL   58F4
06566:  MOVLB  3
06568:  CLRF   x4E
0656A:  MOVFF  01,34D
....................  
....................    if (!n) 
0656E:  MOVF   x4D,W
06570:  IORWF  x4E,W
06572:  BNZ   657A
....................       return(TCP_PUT_CONST_EC_FINISH); 
06574:  MOVLW  00
06576:  MOVWF  01
06578:  BRA    65FE
....................  
....................    txLeft = tcp_http_tx_left(); 
0657A:  MOVFF  123,355
0657E:  MOVLB  0
06580:  RCALL  6448
06582:  MOVFF  02,34C
06586:  MOVFF  01,34B
....................  
....................   #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................   #else 
....................    if (!txLeft) 
0658A:  MOVLB  3
0658C:  MOVF   x4B,W
0658E:  IORWF  x4C,W
06590:  BNZ   6598
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
06592:  MOVLW  01
06594:  MOVWF  01
06596:  BRA    65FE
....................   #endif 
....................  
....................    if (n > txLeft) 
06598:  MOVF   x4C,W
0659A:  SUBWF  x4E,W
0659C:  BNC   65AC
0659E:  BNZ   65A6
065A0:  MOVF   x4D,W
065A2:  SUBWF  x4B,W
065A4:  BC    65AC
....................    { 
....................       ec = TCP_PUT_CONST_EC_CONTINUE; 
065A6:  MOVLW  01
065A8:  MOVWF  x51
....................    } 
065AA:  BRA    65B6
....................    else 
....................    { 
....................       txLeft = n; 
065AC:  MOVFF  34E,34C
065B0:  MOVFF  34D,34B
....................       ec = TCP_PUT_CONST_EC_FINISH; 
065B4:  CLRF   x51
....................    } 
....................  
....................    TCPPutFileChunkStart(txLeft); 
....................  
....................    while (txLeft--) 
065B6:  MOVFF  34C,03
065BA:  MOVF   x4B,W
065BC:  BTFSC  FD8.2
065BE:  DECF   x4C,F
065C0:  DECF   x4B,F
065C2:  IORWF  03,W
065C4:  BZ    65E8
....................    { 
....................       tcp_http_putc(*ptr++); 
065C6:  MOVFF  350,03
065CA:  MOVF   x4F,W
065CC:  INCF   x4F,F
065CE:  BTFSC  FD8.2
065D0:  INCF   x50,F
065D2:  MOVWF  FE9
065D4:  MOVFF  03,FEA
065D8:  MOVFF  FEF,352
065DC:  MOVFF  352,365
065E0:  MOVLB  0
065E2:  RCALL  62F2
065E4:  MOVLB  3
065E6:  BRA    65B6
....................    } 
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    *retPtr=ptr; 
065E8:  MOVFF  349,FE9
065EC:  MOVFF  34A,FEA
065F0:  MOVFF  350,FEC
065F4:  MOVF   FED,F
065F6:  MOVFF  34F,FEF
....................  
....................    return(ec); 
065FA:  MOVFF  351,01
065FE:  MOVLB  0
06600:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileParseConst(addy, n, doSend) 
.................... // 
.................... // Reads file from Const memory.  Stops when it reaches an escape sequence, 
.................... // n chars or an end of file 
.................... // 
.................... // addy - data to read (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // n - max number of chars to read from file.  will save the total number 
.................... //    of chars passed to this pointer. 
.................... // 
.................... // doSend - if TRUE, then send data to TCP socket 
.................... // 
.................... // returns the last char read 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... char TCPPutFileParseConst(int32 *retAddy, int16 *n, int8 doSend) 
*
06620:  MOVLB  3
06622:  CLRF   x5D
06624:  CLRF   x5C
06626:  BSF    x64.0
.................... { 
....................    char stopC, checkC; 
....................    int16 fileSize = 0, max; 
....................    int32 addy; 
....................    int1 premature = TRUE; 
....................  
....................    max = *n; 
06628:  MOVFF  357,FE9
0662C:  MOVFF  358,FEA
06630:  MOVFF  FEC,35F
06634:  MOVF   FED,F
06636:  MOVFF  FEF,35E
....................    addy = *retAddy; 
0663A:  MOVFF  355,FE9
0663E:  MOVFF  356,FEA
06642:  MOVFF  FEF,360
06646:  MOVFF  FEC,361
0664A:  MOVFF  FEC,362
0664E:  MOVFF  FEC,363
....................  
....................    while (TRUE) 
....................    { 
....................       read_program_memory(addy++, &stopC, 1); 
06652:  MOVFF  363,03
06656:  MOVFF  362,02
0665A:  MOVFF  361,01
0665E:  MOVFF  360,00
06662:  MOVLW  01
06664:  ADDWF  x60,F
06666:  BTFSC  FD8.0
06668:  INCF   x61,F
0666A:  BTFSC  FD8.2
0666C:  INCF   x62,F
0666E:  BTFSC  FD8.2
06670:  INCF   x63,F
06672:  MOVFF  03,368
06676:  MOVFF  02,367
0667A:  MOVFF  01,366
0667E:  MOVFF  00,365
06682:  MOVFF  02,FF8
06686:  MOVFF  01,FF7
0668A:  MOVFF  00,FF6
0668E:  MOVLW  03
06690:  MOVWF  FEA
06692:  MOVLW  5A
06694:  MOVWF  FE9
06696:  CLRF   x6A
06698:  MOVLW  01
0669A:  MOVWF  x69
0669C:  MOVLB  0
0669E:  RCALL  6602
....................       if (stopC == '%') 
066A0:  MOVLB  3
066A2:  MOVF   x5A,W
066A4:  SUBLW  25
066A6:  BNZ   672A
....................       { 
....................          read_program_memory(addy++, &checkC, 1); 
066A8:  MOVFF  363,03
066AC:  MOVFF  362,02
066B0:  MOVFF  361,01
066B4:  MOVFF  360,00
066B8:  MOVLW  01
066BA:  ADDWF  x60,F
066BC:  BTFSC  FD8.0
066BE:  INCF   x61,F
066C0:  BTFSC  FD8.2
066C2:  INCF   x62,F
066C4:  BTFSC  FD8.2
066C6:  INCF   x63,F
066C8:  MOVFF  03,368
066CC:  MOVFF  02,367
066D0:  MOVFF  01,366
066D4:  MOVFF  00,365
066D8:  MOVFF  02,FF8
066DC:  MOVFF  01,FF7
066E0:  MOVFF  00,FF6
066E4:  MOVLW  03
066E6:  MOVWF  FEA
066E8:  MOVLW  5B
066EA:  MOVWF  FE9
066EC:  CLRF   x6A
066EE:  MOVLW  01
066F0:  MOVWF  x69
066F2:  MOVLB  0
066F4:  RCALL  6602
....................          if (checkC == '%') 
066F6:  MOVLB  3
066F8:  MOVF   x5B,W
066FA:  SUBLW  25
066FC:  BNZ   6726
....................          { 
....................             if (fileSize < max) 
066FE:  MOVF   x5D,W
06700:  SUBWF  x5F,W
06702:  BNC   6722
06704:  BNZ   670C
06706:  MOVF   x5E,W
06708:  SUBWF  x5C,W
0670A:  BC    6722
....................             { 
....................                if (doSend) 
0670C:  MOVF   x59,F
0670E:  BZ    671A
....................                   tcp_http_putc('%'); 
06710:  MOVLW  25
06712:  MOVWF  x65
06714:  MOVLB  0
06716:  RCALL  62F2
06718:  MOVLB  3
....................                fileSize++; 
0671A:  INCF   x5C,F
0671C:  BTFSC  FD8.2
0671E:  INCF   x5D,F
....................             } 
06720:  BRA    6724
....................             else 
....................                break; 
06722:  BRA    675C
....................          } 
06724:  BRA    6728
....................          else 
....................             break;   //ESCAPE 
06726:  BRA    675C
....................       } 
06728:  BRA    675A
....................       else if (stopC) 
0672A:  MOVF   x5A,F
0672C:  BZ    6756
....................       { 
....................          if (fileSize < max) 
0672E:  MOVF   x5D,W
06730:  SUBWF  x5F,W
06732:  BNC   6752
06734:  BNZ   673C
06736:  MOVF   x5E,W
06738:  SUBWF  x5C,W
0673A:  BC    6752
....................          { 
....................             if (doSend) 
0673C:  MOVF   x59,F
0673E:  BZ    674A
....................                tcp_http_putc(stopC); 
06740:  MOVFF  35A,365
06744:  MOVLB  0
06746:  RCALL  62F2
06748:  MOVLB  3
....................             fileSize++; 
0674A:  INCF   x5C,F
0674C:  BTFSC  FD8.2
0674E:  INCF   x5D,F
....................          } 
06750:  BRA    6754
....................          else 
....................             break; 
06752:  BRA    675C
....................       } 
06754:  BRA    675A
....................       else 
....................       { 
....................          premature = FALSE; 
06756:  BCF    x64.0
....................          break;   //EOF (stopC == 0) 
06758:  BRA    675C
....................       } 
0675A:  BRA    6652
....................    } 
....................  
....................    if (premature) 
0675C:  BTFSS  x64.0
0675E:  BRA    6770
....................       addy--; 
06760:  MOVLW  FF
06762:  ADDWF  x60,F
06764:  BTFSS  FD8.0
06766:  ADDWF  x61,F
06768:  BTFSS  FD8.0
0676A:  ADDWF  x62,F
0676C:  BTFSS  FD8.0
0676E:  ADDWF  x63,F
....................  
....................    *n = fileSize; 
06770:  MOVFF  357,FE9
06774:  MOVFF  358,FEA
06778:  MOVFF  35D,FEC
0677C:  MOVF   FED,F
0677E:  MOVFF  35C,FEF
....................    *retAddy = addy; 
06782:  MOVFF  355,FE9
06786:  MOVFF  356,FEA
0678A:  MOVFF  360,FEF
0678E:  MOVFF  361,FEC
06792:  MOVFF  362,FEC
06796:  MOVFF  363,FEC
....................  
....................    return(stopC); 
0679A:  MOVFF  35A,01
0679E:  MOVLB  0
067A0:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileConstChunk(*addy) 
.................... // 
.................... // send a chunked response from constant memory 
.................... // 
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // returns a response: 
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue 
.................... //                            from this position on next call. 
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character 
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(int32 *retAddy) 
067A2:  MOVLB  3
067A4:  CLRF   x51
067A6:  CLRF   x50
.................... { 
....................    char stopC; 
....................    int32 addy; 
....................    int16 fileSize = 0, txLeft; 
....................    TCP_PUT_CONST_EC ec; 
....................  
....................    txLeft = tcp_http_tx_left(); 
067A8:  MOVFF  123,355
067AC:  MOVLB  0
067AE:  RCALL  6448
067B0:  MOVFF  02,353
067B4:  MOVFF  01,352
....................  
....................  #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................  #else 
....................    if (!txLeft) 
067B8:  MOVLB  3
067BA:  MOVF   x52,W
067BC:  IORWF  x53,W
067BE:  BNZ   67C6
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
067C0:  MOVLW  01
067C2:  MOVWF  01
067C4:  BRA    6862
....................  #endif 
....................  
....................    addy = *retAddy; 
067C6:  MOVFF  349,FE9
067CA:  MOVFF  34A,FEA
067CE:  MOVFF  FEF,34C
067D2:  MOVFF  FEC,34D
067D6:  MOVFF  FEC,34E
067DA:  MOVFF  FEC,34F
....................  
....................    fileSize = 0xFFFF; 
067DE:  SETF   x51
067E0:  SETF   x50
....................    stopC = TCPPutFileParseConst(&addy, &fileSize, FALSE); 
067E2:  MOVLW  03
067E4:  MOVWF  x56
067E6:  MOVLW  4C
067E8:  MOVWF  x55
067EA:  MOVLW  03
067EC:  MOVWF  x58
067EE:  MOVLW  50
067F0:  MOVWF  x57
067F2:  CLRF   x59
067F4:  MOVLB  0
067F6:  RCALL  6620
067F8:  MOVFF  01,34B
....................  
....................    if (!fileSize && (stopC!='%')) 
067FC:  MOVLB  3
067FE:  MOVF   x50,W
06800:  IORWF  x51,W
06802:  BNZ   6810
06804:  MOVF   x4B,W
06806:  SUBLW  25
06808:  BZ    6810
....................       return(TCP_PUT_CONST_EC_FINISH); 
0680A:  MOVLW  00
0680C:  MOVWF  01
0680E:  BRA    6862
....................  
....................    //TODO: optimize 
....................    if (fileSize > txLeft) 
06810:  MOVF   x53,W
06812:  SUBWF  x51,W
06814:  BNC   682C
06816:  BNZ   681E
06818:  MOVF   x50,W
0681A:  SUBWF  x52,W
0681C:  BC    682C
....................    { 
....................       fileSize = txLeft; 
0681E:  MOVFF  353,351
06822:  MOVFF  352,350
.................... //      if (stopC == '%') 
.................... //         ec = TCP_PUT_CONST_EC_ESCAPE; 
.................... //      else 
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
06826:  MOVLW  01
06828:  MOVWF  x54
....................    } 
0682A:  BRA    6844
....................    else 
....................    { 
....................       if (stopC == '%') 
0682C:  MOVF   x4B,W
0682E:  SUBLW  25
06830:  BNZ   6838
....................          ec = TCP_PUT_CONST_EC_ESCAPE; 
06832:  MOVLW  02
06834:  MOVWF  x54
06836:  BRA    6844
....................       else if (stopC) 
06838:  MOVF   x4B,F
0683A:  BZ    6842
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
0683C:  MOVLW  01
0683E:  MOVWF  x54
06840:  BRA    6844
....................       else 
....................          ec = TCP_PUT_CONST_EC_FINISH; 
06842:  CLRF   x54
....................    } 
....................  
....................    TCPPutFileChunkStart(fileSize); 
....................  
....................    TCPPutFileParseConst(retAddy, &fileSize, TRUE); 
06844:  MOVFF  34A,356
06848:  MOVFF  349,355
0684C:  MOVLW  03
0684E:  MOVWF  x58
06850:  MOVLW  50
06852:  MOVWF  x57
06854:  MOVLW  01
06856:  MOVWF  x59
06858:  MOVLB  0
0685A:  RCALL  6620
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    return(ec); 
0685C:  MOVLB  3
0685E:  MOVFF  354,01
06862:  MOVLB  0
06864:  GOTO   6DA0 (RETURN)
.................... } 
....................  
.................... int TCPPutFileConstGetEscape(int32 addy) 
.................... { 
.................... #if HTTP_USE_DOUBLE_ESCAPE 
....................    char str[3]; 
....................    int ret; 
....................  
....................    read_program_memory(addy, &str[0], 2); 
....................    str[2] = 0; 
....................    ret = strtol(str, 0, 16); 
.................... #else 
....................    char ret; 
....................    read_program_memory(addy, &ret, 1); 
06868:  MOVFF  34D,FF8
0686C:  MOVFF  34C,FF7
06870:  MOVFF  34B,FF6
06874:  MOVLW  03
06876:  MOVWF  FEA
06878:  MOVLW  4F
0687A:  MOVWF  FE9
0687C:  MOVLB  3
0687E:  CLRF   x6A
06880:  MOVLW  01
06882:  MOVWF  x69
06884:  MOVLB  0
06886:  RCALL  6602
.................... #endif 
....................  
....................    return(ret); 
06888:  MOVLB  3
0688A:  MOVFF  34F,01
0688E:  MOVLB  0
06890:  GOTO   6DE4 (RETURN)
.................... } 
....................  
.................... int1 tcp_http_put_file(int8 which, int16 errorCode, int32 file, char *contentType) 
.................... { 
....................    static char str[40]; 
....................    int8 socket; 
....................    char ec; 
....................    int escaped; 
....................  
....................    static enum 
....................    { 
....................       HTTP_PUT_FILE_INIT = 0, 
....................       HTTP_PUT_FILE_CONTINUE, 
....................       HTTP_PUT_FILE_CHUNK_END, 
....................       HTTP_PUT_FILE_DONE 
....................    } status; 
....................  
....................    socket=http_socket[which]; 
*
06B8C:  CLRF   03
06B8E:  MOVLB  3
06B90:  MOVF   x3B,W
06B92:  ADDLW  20
06B94:  MOVWF  FE9
06B96:  MOVLW  01
06B98:  ADDWFC 03,W
06B9A:  MOVWF  FEA
06B9C:  MOVFF  FEF,344
....................  
....................    set_tcp_http_putc(socket); 
06BA0:  MOVFF  344,347
06BA4:  MOVLB  0
06BA6:  GOTO   5FDA
....................  
....................    if (lastHTTPPutConstPos[which] == 0) 
06BAA:  MOVLB  3
06BAC:  MOVF   x3B,W
06BAE:  MULLW  04
06BB0:  MOVF   FF3,W
06BB2:  CLRF   03
06BB4:  ADDLW  24
06BB6:  MOVWF  FE9
06BB8:  MOVLW  01
06BBA:  ADDWFC 03,W
06BBC:  MOVWF  FEA
06BBE:  MOVFF  FEF,347
06BC2:  MOVFF  FEC,348
06BC6:  MOVFF  FEC,349
06BCA:  MOVFF  FEC,34A
06BCE:  MOVF   x47,F
06BD0:  BTFSS  FD8.2
06BD2:  BRA    6D24
06BD4:  MOVF   x48,F
06BD6:  BTFSS  FD8.2
06BD8:  BRA    6D24
06BDA:  MOVF   x49,F
06BDC:  BTFSS  FD8.2
06BDE:  BRA    6D24
06BE0:  MOVF   x4A,F
06BE2:  BTFSS  FD8.2
06BE4:  BRA    6D24
....................    { 
....................       lastHTTPPutVarPos[which] = 0; 
06BE6:  BCF    FD8.0
06BE8:  RLCF   x3B,W
06BEA:  CLRF   03
06BEC:  ADDLW  28
06BEE:  MOVWF  FE9
06BF0:  MOVLW  01
06BF2:  ADDWFC 03,W
06BF4:  MOVWF  FEA
06BF6:  CLRF   FEC
06BF8:  MOVF   FED,F
06BFA:  CLRF   FEF
....................       lastHTTPPutConstPos[which] = file; 
06BFC:  MOVF   x3B,W
06BFE:  MULLW  04
06C00:  MOVF   FF3,W
06C02:  CLRF   03
06C04:  ADDLW  24
06C06:  MOVWF  FE9
06C08:  MOVLW  01
06C0A:  ADDWFC 03,W
06C0C:  MOVWF  FEA
06C0E:  MOVFF  33E,FEF
06C12:  MOVFF  33F,FEC
06C16:  MOVFF  340,FEC
06C1A:  MOVFF  341,FEC
....................       status = HTTP_PUT_FILE_CONTINUE; 
06C1E:  MOVLW  01
06C20:  MOVLB  1
06C22:  MOVWF  x52
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
....................     #else 
....................       printf(tcp_http_putc,"HTTP/1.0 %LU ", errorCode); 
06C24:  MOVLW  68
06C26:  MOVWF  FF6
06C28:  MOVLW  01
06C2A:  MOVWF  FF7
06C2C:  MOVLW  00
06C2E:  MOVWF  FF8
06C30:  MOVLW  09
06C32:  MOVLB  3
06C34:  MOVWF  x47
06C36:  MOVLB  0
06C38:  GOTO   6300
06C3C:  MOVLW  10
06C3E:  MOVWF  FE9
06C40:  MOVFF  33D,348
06C44:  MOVFF  33C,347
06C48:  GOTO   6332
06C4C:  MOVLW  20
06C4E:  MOVLB  3
06C50:  MOVWF  x65
06C52:  MOVLB  0
06C54:  CALL   62F2
....................     #endif 
....................  
....................       switch(errorCode) 
06C58:  MOVLB  3
06C5A:  MOVF   x3C,W
06C5C:  MOVWF  00
06C5E:  MOVF   x3D,W
06C60:  MOVWF  03
06C62:  MOVF   03,W
06C64:  BNZ   6C70
06C66:  MOVLW  C8
06C68:  SUBWF  00,W
06C6A:  MOVLB  0
06C6C:  BZ    6C92
06C6E:  MOVLB  3
06C70:  MOVLW  01
06C72:  SUBWF  03,W
06C74:  BNZ   6C80
06C76:  MOVLW  94
06C78:  SUBWF  00,W
06C7A:  MOVLB  0
06C7C:  BZ    6CAC
06C7E:  MOVLB  3
06C80:  MOVLW  01
06C82:  SUBWF  03,W
06C84:  BNZ   6C90
06C86:  MOVLW  F4
06C88:  SUBWF  00,W
06C8A:  MOVLB  0
06C8C:  BZ    6CBE
06C8E:  MOVLB  3
06C90:  BRA    6CD2
....................       { 
....................          case 200: 
....................             printf(tcp_http_putc,"OK"); 
06C92:  MOVLW  4F
06C94:  MOVLB  3
06C96:  MOVWF  x65
06C98:  MOVLB  0
06C9A:  CALL   62F2
06C9E:  MOVLW  4B
06CA0:  MOVLB  3
06CA2:  MOVWF  x65
06CA4:  MOVLB  0
06CA6:  CALL   62F2
....................             break; 
06CAA:  BRA    6CD4
....................          case 404: 
....................             printf(tcp_http_putc,"Not found"); 
06CAC:  MOVLW  76
06CAE:  MOVWF  FF6
06CB0:  MOVLW  01
06CB2:  MOVWF  FF7
06CB4:  MOVLW  00
06CB6:  MOVWF  FF8
06CB8:  CALL   63FA
....................             break; 
06CBC:  BRA    6CD4
....................          case 500: 
....................             printf(tcp_http_putc,"Server Error"); 
06CBE:  MOVLW  80
06CC0:  MOVWF  FF6
06CC2:  MOVLW  01
06CC4:  MOVWF  FF7
06CC6:  MOVLW  00
06CC8:  MOVWF  FF8
06CCA:  CALL   63FA
....................             break; 
06CCE:  BRA    6CD4
06CD0:  MOVLB  3
....................          default: 
....................             break; 
06CD2:  MOVLB  0
....................       } 
....................  
....................       printf(tcp_http_putc, "\r\nContent-Type: "); 
06CD4:  MOVLW  8E
06CD6:  MOVWF  FF6
06CD8:  MOVLW  01
06CDA:  MOVWF  FF7
06CDC:  MOVLW  00
06CDE:  MOVWF  FF8
06CE0:  CALL   63FA
....................       if (contentType) 
06CE4:  MOVLB  3
06CE6:  MOVF   x42,W
06CE8:  IORWF  x43,W
06CEA:  BZ    6D00
....................          printf(tcp_http_putc, "%s", contentType); 
06CEC:  MOVFF  343,FEA
06CF0:  MOVFF  342,FE9
06CF4:  MOVLB  0
06CF6:  GOTO   6422
06CFA:  MOVLB  0
06CFC:  BRA    6D12
06CFE:  MOVLB  3
....................       else 
....................          printf(tcp_http_putc,"text/html"); 
06D00:  MOVLW  A0
06D02:  MOVWF  FF6
06D04:  MOVLW  01
06D06:  MOVWF  FF7
06D08:  MOVLW  00
06D0A:  MOVWF  FF8
06D0C:  MOVLB  0
06D0E:  CALL   63FA
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc, "\r\nConnection: close"); 
....................       printf(tcp_http_putc, "\r\nTransfer-Encoding: chunked"); 
....................     #endif 
....................  
....................       printf(tcp_http_putc, "\r\n\r\n"); 
06D12:  MOVLW  AA
06D14:  MOVWF  FF6
06D16:  MOVLW  01
06D18:  MOVWF  FF7
06D1A:  MOVLW  00
06D1C:  MOVWF  FF8
06D1E:  CALL   63FA
06D22:  MOVLB  3
....................    } 
....................  
....................    if (lastHTTPPutVarPos[which]) 
06D24:  BCF    FD8.0
06D26:  RLCF   x3B,W
06D28:  CLRF   03
06D2A:  ADDLW  28
06D2C:  MOVWF  FE9
06D2E:  MOVLW  01
06D30:  ADDWFC 03,W
06D32:  MOVWF  FEA
06D34:  MOVF   FEF,F
06D36:  BZ    6D74
....................    { 
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
06D38:  BCF    FD8.0
06D3A:  RLCF   x3B,W
06D3C:  CLRF   03
06D3E:  ADDLW  28
06D40:  MOVWF  01
06D42:  MOVLW  01
06D44:  ADDWFC 03,F
06D46:  MOVFF  01,347
06D4A:  MOVFF  03,348
06D4E:  MOVFF  03,34A
06D52:  MOVFF  01,349
06D56:  MOVLB  0
06D58:  CALL   6540
....................       lastHTTPPutVarPos[which] = 0; 
06D5C:  BCF    FD8.0
06D5E:  MOVLB  3
06D60:  RLCF   x3B,W
06D62:  CLRF   03
06D64:  ADDLW  28
06D66:  MOVWF  FE9
06D68:  MOVLW  01
06D6A:  ADDWFC 03,W
06D6C:  MOVWF  FEA
06D6E:  CLRF   FEC
06D70:  MOVF   FED,F
06D72:  CLRF   FEF
....................    } 
....................  
....................    if (status == HTTP_PUT_FILE_CONTINUE) 
06D74:  MOVLB  1
06D76:  DECFSZ x52,W
06D78:  BRA    6EC2
....................    { 
....................       do { 
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[which]); 
06D7A:  MOVLB  3
06D7C:  MOVF   x3B,W
06D7E:  MULLW  04
06D80:  MOVF   FF3,W
06D82:  CLRF   03
06D84:  ADDLW  24
06D86:  MOVWF  01
06D88:  MOVLW  01
06D8A:  ADDWFC 03,F
06D8C:  MOVFF  01,347
06D90:  MOVFF  03,348
06D94:  MOVFF  03,34A
06D98:  MOVFF  01,349
06D9C:  MOVLB  0
06D9E:  BRA    67A2
06DA0:  MOVFF  01,345
....................  
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE) 
06DA4:  MOVLB  3
06DA6:  MOVF   x45,W
06DA8:  SUBLW  02
06DAA:  BTFSS  FD8.2
06DAC:  BRA    6EB0
....................          { 
....................             escaped = TCPPutFileConstGetEscape(lastHTTPPutConstPos[which]); 
06DAE:  MOVF   x3B,W
06DB0:  MULLW  04
06DB2:  MOVF   FF3,W
06DB4:  CLRF   03
06DB6:  ADDLW  24
06DB8:  MOVWF  FE9
06DBA:  MOVLW  01
06DBC:  ADDWFC 03,W
06DBE:  MOVWF  FEA
06DC0:  MOVFF  FEF,347
06DC4:  MOVFF  FEC,348
06DC8:  MOVFF  FEC,349
06DCC:  MOVFF  FEC,34A
06DD0:  MOVFF  34A,34E
06DD4:  MOVFF  349,34D
06DD8:  MOVFF  348,34C
06DDC:  MOVFF  347,34B
06DE0:  MOVLB  0
06DE2:  BRA    6868
06DE4:  MOVFF  01,346
....................            #if HTTP_USE_DOUBLE_ESCAPE 
....................             lastHTTPPutConstPos[which] += 2; 
....................            #else 
....................             lastHTTPPutConstPos[which] += 1; 
06DE8:  MOVLB  3
06DEA:  MOVF   x3B,W
06DEC:  MULLW  04
06DEE:  MOVF   FF3,W
06DF0:  CLRF   03
06DF2:  ADDLW  24
06DF4:  MOVWF  FE9
06DF6:  MOVLW  01
06DF8:  ADDWFC 03,W
06DFA:  MOVWF  FEA
06DFC:  MOVLW  01
06DFE:  ADDWF  FEF,W
06E00:  MOVWF  00
06E02:  MOVLW  00
06E04:  ADDWFC FEC,W
06E06:  MOVWF  01
06E08:  MOVLW  00
06E0A:  ADDWFC FEC,W
06E0C:  MOVWF  02
06E0E:  MOVLW  00
06E10:  ADDWFC FEC,W
06E12:  MOVF   FED,F
06E14:  MOVF   FED,F
06E16:  MOVF   FED,F
06E18:  MOVFF  00,FEF
06E1C:  MOVFF  01,FEC
06E20:  MOVFF  02,FEC
06E24:  MOVWF  FEC
....................            #endif 
....................             http_format_char(file, escaped, &str[0], sizeof(str)-1); 
06E26:  MOVFF  33F,348
06E2A:  MOVFF  33E,347
06E2E:  MOVFF  33F,34A
06E32:  MOVFF  33E,349
06E36:  MOVFF  346,34B
06E3A:  MOVLW  01
06E3C:  MOVWF  x4D
06E3E:  MOVLW  2A
06E40:  MOVWF  x4C
06E42:  MOVLW  27
06E44:  MOVWF  x4E
06E46:  MOVLB  0
06E48:  BRA    69DA
....................             lastHTTPPutVarPos[which] = &str[0]; 
06E4A:  BCF    FD8.0
06E4C:  MOVLB  3
06E4E:  RLCF   x3B,W
06E50:  CLRF   03
06E52:  ADDLW  28
06E54:  MOVWF  FE9
06E56:  MOVLW  01
06E58:  ADDWFC 03,W
06E5A:  MOVWF  FEA
06E5C:  MOVLW  01
06E5E:  MOVWF  FEC
06E60:  MOVF   FED,F
06E62:  MOVLW  2A
06E64:  MOVWF  FEF
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
06E66:  BCF    FD8.0
06E68:  RLCF   x3B,W
06E6A:  CLRF   03
06E6C:  ADDLW  28
06E6E:  MOVWF  01
06E70:  MOVLW  01
06E72:  ADDWFC 03,F
06E74:  MOVFF  01,347
06E78:  MOVFF  03,348
06E7C:  MOVFF  03,34A
06E80:  MOVFF  01,349
06E84:  MOVLB  0
06E86:  CALL   6540
06E8A:  MOVFF  01,345
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
06E8E:  MOVLB  3
06E90:  MOVF   x45,F
06E92:  BNZ   6EAC
....................                lastHTTPPutVarPos[which] = 0; 
06E94:  BCF    FD8.0
06E96:  RLCF   x3B,W
06E98:  CLRF   03
06E9A:  ADDLW  28
06E9C:  MOVWF  FE9
06E9E:  MOVLW  01
06EA0:  ADDWFC 03,W
06EA2:  MOVWF  FEA
06EA4:  CLRF   FEC
06EA6:  MOVF   FED,F
06EA8:  CLRF   FEF
06EAA:  BRA    6EAE
....................             else 
....................                break; 
06EAC:  BRA    6EC0
....................          } 
06EAE:  BRA    6EBE
....................          else 
....................          { 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
06EB0:  MOVF   x45,F
06EB2:  BNZ   6EBC
....................                status = HTTP_PUT_FILE_CHUNK_END; 
06EB4:  MOVLW  02
06EB6:  MOVLB  1
06EB8:  MOVWF  x52
06EBA:  MOVLB  3
....................             break; 
06EBC:  BRA    6EC0
....................          } 
....................       } while (TRUE); 
06EBE:  BRA    6D7C
06EC0:  MOVLB  1
....................    } 
....................  
....................    if (status == HTTP_PUT_FILE_CHUNK_END) 
06EC2:  MOVF   x52,W
06EC4:  SUBLW  02
06EC6:  BNZ   6ECC
....................    { 
....................      #if HTTP_USE_CHUNKS 
....................       if (tcp_http_tx_left() > 8) 
....................       { 
....................          TCPPutFileChunkStart(0); 
....................          TCPPutFileChunkStop(); 
....................          status = HTTP_PUT_FILE_DONE; 
....................       } 
....................      #else 
....................       status = HTTP_PUT_FILE_DONE; 
06EC8:  MOVLW  03
06ECA:  MOVWF  x52
....................      #endif 
....................    } 
....................  
....................  
....................    TCPFlush(socket); 
06ECC:  MOVFF  344,36C
06ED0:  MOVLB  0
06ED2:  CALL   5FE2
....................  
....................    return(status == HTTP_PUT_FILE_DONE); 
06ED6:  MOVLB  1
06ED8:  MOVF   x52,W
06EDA:  SUBLW  03
06EDC:  BZ    6EE2
06EDE:  MOVLW  00
06EE0:  BRA    6EE4
06EE2:  MOVLW  01
06EE4:  MOVWF  01
06EE6:  MOVLB  0
06EE8:  RETURN 0
.................... } 
....................  
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack 
.................... void HTTP_Init(void) { 
....................    int8 i; 
....................    debug_http("\r\nHTTP OPENING"); 
....................    if (HTTP_PORT != 0) 
....................    { 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
*
022F0:  MOVLB  3
022F2:  CLRF   x29
022F4:  MOVF   x29,F
022F6:  BNZ   2354
....................       { 
....................          http_socket[i]=TCPListen(HTTP_PORT); 
022F8:  CLRF   03
022FA:  MOVF   x29,W
022FC:  ADDLW  20
022FE:  MOVWF  01
02300:  MOVLW  01
02302:  ADDWFC 03,F
02304:  MOVFF  01,32A
02308:  MOVFF  03,32B
0230C:  CLRF   x2D
0230E:  MOVLW  50
02310:  MOVWF  x2C
02312:  MOVLB  0
02314:  BRA    21F6
02316:  MOVFF  32B,FEA
0231A:  MOVFF  32A,FE9
0231E:  MOVFF  01,FEF
....................          debug_http("\r\nHTTP SOCKET=%X", http_socket[i]); 
....................          if (http_socket[i]!=INVALID_SOCKET) 
02322:  CLRF   03
02324:  MOVLB  3
02326:  MOVF   x29,W
02328:  ADDLW  20
0232A:  MOVWF  FE9
0232C:  MOVLW  01
0232E:  ADDWFC 03,W
02330:  MOVWF  FEA
02332:  MOVF   FEF,W
02334:  SUBLW  FE
02336:  BZ    2350
....................          { 
....................             http_state[i]=HTTP_LISTEN_WAIT; 
02338:  BCF    FD8.0
0233A:  RLCF   x29,W
0233C:  CLRF   03
0233E:  ADDLW  21
02340:  MOVWF  FE9
02342:  MOVLW  01
02344:  ADDWFC 03,W
02346:  MOVWF  FEA
02348:  MOVLW  01
0234A:  MOVWF  FEC
0234C:  MOVF   FED,F
0234E:  MOVWF  FEF
....................          } 
02350:  INCF   x29,F
02352:  BRA    22F4
....................       } 
....................    } 
....................    else 
....................    { 
....................       debug_http("\r\nHTTP DISABLED"); 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
....................       { 
....................             http_state[i]=HTTP_DISABLED; 
....................       } 
....................    } 
02354:  MOVLB  0
02356:  GOTO   236C (RETURN)
.................... } 
....................  
.................... void HTTP_Task(void) { 
....................    static char tokens_header[]=" "; 
....................    static char tokens_get[]="?"; 
....................    static char http_get_str[]="GET"; 
....................    static char http_post_str[]="POST"; 
....................    static char http_len_str[]="Content-Length:"; 
....................    //static char http_keepalive_str[]="keep-alive"; 
....................    //static char http_connection_str[]="Connection"; 
....................  
....................    static char buffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
....................  
....................    static int8 i[HTTP_NUM_SOCKETS]; 
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]={0}; 
....................    static int32 http_page_req[HTTP_NUM_SOCKETS]; 
....................    static int16 http_post_len[HTTP_NUM_SOCKETS]={0}; 
....................    static int16 http_timer[HTTP_NUM_SOCKETS]; 
....................  #if HTTP_USE_CONTENT_TYPE 
....................    static char contentType[HTTP_NUM_SOCKETS][12]; 
....................  #endif 
....................  
....................    int1 doneSend, postContinue; 
....................  
....................    char c, *pKey, *pValue; 
....................    int8 hs, currSocket; 
....................  
....................    for (hs=0; hs<HTTP_NUM_SOCKETS; hs++) 
*
07028:  MOVLB  3
0702A:  CLRF   x35
0702C:  MOVF   x35,F
0702E:  BTFSS  FD8.2
07030:  GOTO   7CB8
....................    { 
....................       if (http_state[hs]==HTTP_DISABLED) 
07034:  BCF    FD8.0
07036:  RLCF   x35,W
07038:  CLRF   03
0703A:  ADDLW  21
0703C:  MOVWF  FE9
0703E:  MOVLW  01
07040:  ADDWFC 03,W
07042:  MOVWF  FEA
07044:  MOVFF  FEC,338
07048:  MOVF   FED,F
0704A:  MOVFF  FEF,337
0704E:  INCFSZ x37,W
07050:  BRA    705A
07052:  MOVF   x38,F
07054:  BNZ   705A
....................          return; 
07056:  GOTO   7CB8
....................  
....................       currSocket=http_socket[hs]; 
0705A:  CLRF   03
0705C:  MOVF   x35,W
0705E:  ADDLW  20
07060:  MOVWF  FE9
07062:  MOVLW  01
07064:  ADDWFC 03,W
07066:  MOVWF  FEA
07068:  MOVFF  FEF,336
....................  
....................       if (!TCPIsConnected(currSocket)) 
0706C:  MOVFF  336,337
07070:  MOVLB  0
07072:  CALL   5194
07076:  MOVF   01,F
07078:  BNZ   7096
....................          http_state[hs]=HTTP_LISTEN_WAIT; 
0707A:  BCF    FD8.0
0707C:  MOVLB  3
0707E:  RLCF   x35,W
07080:  CLRF   03
07082:  ADDLW  21
07084:  MOVWF  FE9
07086:  MOVLW  01
07088:  ADDWFC 03,W
0708A:  MOVWF  FEA
0708C:  MOVLW  01
0708E:  MOVWF  FEC
07090:  MOVF   FED,F
07092:  MOVWF  FEF
07094:  MOVLB  0
....................  
....................       switch(http_state[hs]) 
07096:  BCF    FD8.0
07098:  MOVLB  3
0709A:  RLCF   x35,W
0709C:  CLRF   03
0709E:  ADDLW  21
070A0:  MOVWF  FE9
070A2:  MOVLW  01
070A4:  ADDWFC 03,W
070A6:  MOVWF  FEA
070A8:  MOVF   FEF,W
070AA:  MOVWF  00
070AC:  INCF   FE9,F
070AE:  MOVF   FEF,W
070B0:  DECF   FE9,F
070B2:  MOVWF  03
070B4:  MOVLW  01
070B6:  SUBWF  03,W
070B8:  BNZ   70C4
070BA:  MOVLW  01
070BC:  SUBWF  00,W
070BE:  MOVLB  0
070C0:  BZ    7172
070C2:  MOVLB  3
070C4:  MOVLW  01
070C6:  SUBWF  03,W
070C8:  BNZ   70D4
070CA:  MOVLW  02
070CC:  SUBWF  00,W
070CE:  MOVLB  0
070D0:  BZ    7182
070D2:  MOVLB  3
070D4:  MOVLW  01
070D6:  SUBWF  03,W
070D8:  BNZ   70E6
070DA:  MOVLW  03
070DC:  SUBWF  00,W
070DE:  MOVLB  0
070E0:  BTFSC  FD8.2
070E2:  BRA    7232
070E4:  MOVLB  3
070E6:  MOVLW  01
070E8:  SUBWF  03,W
070EA:  BNZ   70F8
070EC:  MOVLW  04
070EE:  SUBWF  00,W
070F0:  MOVLB  0
070F2:  BTFSC  FD8.2
070F4:  BRA    7694
070F6:  MOVLB  3
070F8:  MOVLW  01
070FA:  SUBWF  03,W
070FC:  BNZ   710A
070FE:  MOVLW  05
07100:  SUBWF  00,W
07102:  MOVLB  0
07104:  BTFSC  FD8.2
07106:  BRA    76F2
07108:  MOVLB  3
0710A:  MOVLW  01
0710C:  SUBWF  03,W
0710E:  BNZ   711E
07110:  MOVLW  06
07112:  SUBWF  00,W
07114:  MOVLB  0
07116:  BTFSC  FD8.2
07118:  GOTO   79B2
0711C:  MOVLB  3
0711E:  MOVLW  01
07120:  SUBWF  03,W
07122:  BNZ   7132
07124:  MOVLW  07
07126:  SUBWF  00,W
07128:  MOVLB  0
0712A:  BTFSC  FD8.2
0712C:  GOTO   79F4
07130:  MOVLB  3
07132:  MOVLW  01
07134:  SUBWF  03,W
07136:  BNZ   7146
07138:  MOVLW  08
0713A:  SUBWF  00,W
0713C:  MOVLB  0
0713E:  BTFSC  FD8.2
07140:  GOTO   7B68
07144:  MOVLB  3
07146:  MOVLW  01
07148:  SUBWF  03,W
0714A:  BNZ   715A
0714C:  MOVLW  09
0714E:  SUBWF  00,W
07150:  MOVLB  0
07152:  BTFSC  FD8.2
07154:  GOTO   7BB2
07158:  MOVLB  3
0715A:  MOVLW  01
0715C:  SUBWF  03,W
0715E:  BNZ   716E
07160:  MOVLW  0A
07162:  SUBWF  00,W
07164:  MOVLB  0
07166:  BTFSC  FD8.2
07168:  GOTO   7CAC
0716C:  MOVLB  3
0716E:  GOTO   7CAE
....................       { 
....................          case HTTP_LISTEN_WAIT: 
....................             if (!TCPIsConnected(currSocket)) 
07172:  MOVFF  336,337
07176:  CALL   5194
0717A:  MOVF   01,F
0717C:  BNZ   7182
....................                break; 
0717E:  GOTO   7CB0
....................             debug_http("HTTP %U CONNECTED\r\n", hs); 
....................  
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header 
....................          case HTTP_CONNECTED: 
....................             debug_http("HTTP %U LISTENING\r\n", hs); 
....................             buffer[hs][0]=0; 
07182:  MOVLB  3
07184:  MOVF   x35,W
07186:  MULLW  FE
07188:  MOVF   FF3,W
0718A:  CLRF   x38
0718C:  MOVWF  x37
0718E:  MOVLW  70
07190:  ADDWF  x37,W
07192:  MOVWF  FE9
07194:  MOVLW  01
07196:  ADDWFC x38,W
07198:  MOVWF  FEA
0719A:  CLRF   FEF
....................             i[hs]=0; 
0719C:  CLRF   03
0719E:  MOVF   x35,W
071A0:  ADDLW  6E
071A2:  MOVWF  FE9
071A4:  MOVLW  02
071A6:  ADDWFC 03,W
071A8:  MOVWF  FEA
071AA:  CLRF   FEF
....................             http_state[hs]=HTTP_GET_HEADERS; 
071AC:  BCF    FD8.0
071AE:  RLCF   x35,W
071B0:  CLRF   03
071B2:  ADDLW  21
071B4:  MOVWF  FE9
071B6:  MOVLW  01
071B8:  ADDWFC 03,W
071BA:  MOVWF  FEA
071BC:  MOVLW  01
071BE:  MOVWF  FEC
071C0:  MOVF   FED,F
071C2:  MOVLW  03
071C4:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
071C6:  BCF    FD8.0
071C8:  RLCF   x35,W
071CA:  CLRF   03
071CC:  ADDLW  76
071CE:  MOVWF  01
071D0:  MOVLW  02
071D2:  ADDWFC 03,F
071D4:  MOVFF  01,337
071D8:  MOVFF  03,338
071DC:  MOVLB  0
071DE:  CALL   379E
071E2:  MOVFF  338,FEA
071E6:  MOVFF  337,FE9
071EA:  MOVFF  02,FEC
071EE:  MOVF   FED,F
071F0:  MOVFF  01,FEF
....................             http_page_req[hs]=0; 
071F4:  MOVLB  3
071F6:  MOVF   x35,W
071F8:  MULLW  04
071FA:  MOVF   FF3,W
071FC:  CLRF   03
071FE:  ADDLW  70
07200:  MOVWF  FE9
07202:  MOVLW  02
07204:  ADDWFC 03,W
07206:  MOVWF  FEA
07208:  MOVF   FEE,F
0720A:  MOVF   FEE,F
0720C:  CLRF   FEC
0720E:  MOVF   FED,F
07210:  CLRF   FEF
07212:  MOVF   FED,F
07214:  CLRF   FEF
07216:  MOVF   FED,F
07218:  CLRF   FEF
....................             http_post_len[hs]=0; 
0721A:  BCF    FD8.0
0721C:  RLCF   x35,W
0721E:  CLRF   03
07220:  ADDLW  74
07222:  MOVWF  FE9
07224:  MOVLW  02
07226:  ADDWFC 03,W
07228:  MOVWF  FEA
0722A:  CLRF   FEC
0722C:  MOVF   FED,F
0722E:  CLRF   FEF
07230:  MOVLB  0
....................             //http_got_headers[hs]=FALSE; 
....................             //http_isKeepAlive[hs]=FALSE; 
....................  
....................          case HTTP_GET_HEADERS: 
....................             postContinue=FALSE; 
07232:  MOVLB  3
07234:  BCF    x2F.1
....................             while (TCPIsGetReady(currSocket) && TCPGet(currSocket, &c)) 
07236:  MOVFF  336,337
0723A:  MOVLB  0
0723C:  CALL   51BE
07240:  MOVF   01,F
07242:  BTFSC  FD8.2
07244:  BRA    7598
07246:  MOVFF  336,337
0724A:  MOVLW  03
0724C:  MOVLB  3
0724E:  MOVWF  x39
07250:  MOVLW  30
07252:  MOVWF  x38
07254:  MOVLB  0
07256:  CALL   51EA
0725A:  MOVF   01,F
0725C:  BTFSC  FD8.2
0725E:  BRA    7598
....................             { 
....................                //http_got_headers[hs]=TRUE; 
....................                if ( (c >= 0x20) && (i[hs] < HTTP_GET_PARAM_MAX_SIZE - 2) ) 
07260:  MOVLB  3
07262:  MOVF   x30,W
07264:  SUBLW  1F
07266:  BC    72B2
07268:  CLRF   03
0726A:  MOVF   x35,W
0726C:  ADDLW  6E
0726E:  MOVWF  FE9
07270:  MOVLW  02
07272:  ADDWFC 03,W
07274:  MOVWF  FEA
07276:  MOVF   FEF,W
07278:  SUBLW  FB
0727A:  BNC   72B2
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
0727C:  MOVF   x35,W
0727E:  MULLW  FE
07280:  MOVF   FF3,W
07282:  CLRF   x38
07284:  MOVWF  x37
07286:  CLRF   03
07288:  MOVF   x35,W
0728A:  ADDLW  6E
0728C:  MOVWF  FE9
0728E:  MOVLW  02
07290:  ADDWFC 03,W
07292:  MOVWF  FEA
07294:  MOVF   FEF,W
07296:  INCF   FEF,F
07298:  CLRF   03
0729A:  ADDWF  x37,W
0729C:  MOVWF  01
0729E:  MOVF   x38,W
072A0:  ADDWFC 03,F
072A2:  MOVF   01,W
072A4:  ADDLW  70
072A6:  MOVWF  FE9
072A8:  MOVLW  01
072AA:  ADDWFC 03,W
072AC:  MOVWF  FEA
072AE:  MOVFF  330,FEF
....................                } 
....................                if (c=='\n') 
072B2:  MOVF   x30,W
072B4:  SUBLW  0A
072B6:  BTFSS  FD8.2
072B8:  BRA    7594
....................                { 
....................                   buffer[hs][i[hs]]=0; 
072BA:  MOVF   x35,W
072BC:  MULLW  FE
072BE:  MOVF   FF3,W
072C0:  CLRF   x38
072C2:  MOVWF  x37
072C4:  CLRF   03
072C6:  MOVF   x35,W
072C8:  ADDLW  6E
072CA:  MOVWF  FE9
072CC:  MOVLW  02
072CE:  ADDWFC 03,W
072D0:  MOVWF  FEA
072D2:  CLRF   03
072D4:  MOVF   FEF,W
072D6:  ADDWF  x37,W
072D8:  MOVWF  01
072DA:  MOVF   x38,W
072DC:  ADDWFC 03,F
072DE:  MOVF   01,W
072E0:  ADDLW  70
072E2:  MOVWF  FE9
072E4:  MOVLW  01
072E6:  ADDWFC 03,W
072E8:  MOVWF  FEA
072EA:  CLRF   FEF
....................                   if ( 
....................                        ( ( pKey = strtok(&buffer[hs][0], tokens_header) ) !=0 ) && 
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 ) 
072EC:  MOVF   x35,W
072EE:  MULLW  FE
072F0:  MOVF   FF3,W
072F2:  CLRF   x38
072F4:  MOVWF  x37
072F6:  MOVLW  70
072F8:  ADDWF  x37,W
072FA:  MOVWF  01
072FC:  MOVLW  01
072FE:  ADDWFC x38,W
07300:  MOVWF  03
07302:  MOVFF  01,339
07306:  MOVWF  x3A
07308:  MOVWF  x3C
0730A:  MOVFF  01,33B
0730E:  MOVLW  01
07310:  MOVWF  x3E
07312:  MOVLW  53
07314:  MOVWF  x3D
07316:  MOVLB  0
07318:  CALL   53C8
0731C:  MOVFF  02,332
07320:  MOVFF  01,331
07324:  MOVLB  3
07326:  MOVF   x31,F
07328:  BNZ   7330
0732A:  MOVF   x32,F
0732C:  BTFSC  FD8.2
0732E:  BRA    7514
07330:  CLRF   x3C
07332:  CLRF   x3B
07334:  MOVLW  01
07336:  MOVWF  x3E
07338:  MOVLW  53
0733A:  MOVWF  x3D
0733C:  MOVLB  0
0733E:  CALL   53C8
07342:  MOVFF  02,334
07346:  MOVFF  01,333
0734A:  MOVLB  3
0734C:  MOVF   x33,F
0734E:  BNZ   7356
07350:  MOVF   x34,F
07352:  BTFSC  FD8.2
07354:  BRA    7514
....................                      ) 
....................                   { 
....................                      debug_http("HTTP %U PAIR %s = %s\r\n", hs, pKey, pValue); 
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) ) 
07356:  MOVFF  332,338
0735A:  MOVFF  331,337
0735E:  MOVLW  01
07360:  MOVWF  x3A
07362:  MOVLW  57
07364:  MOVWF  x39
07366:  MOVLB  0
07368:  CALL   5478
0736C:  MOVF   01,F
0736E:  BZ    738E
07370:  MOVFF  332,338
07374:  MOVFF  331,337
07378:  MOVLW  01
0737A:  MOVLB  3
0737C:  MOVWF  x3A
0737E:  MOVLW  5B
07380:  MOVWF  x39
07382:  MOVLB  0
07384:  CALL   5478
07388:  MOVF   01,F
0738A:  BTFSS  FD8.2
0738C:  BRA    74AA
....................                      { 
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ? 
0738E:  MOVFF  334,33C
07392:  MOVFF  333,33B
07396:  MOVLW  01
07398:  MOVLB  3
0739A:  MOVWF  x3E
0739C:  MOVLW  55
0739E:  MOVWF  x3D
073A0:  MOVLB  0
073A2:  CALL   53C8
073A6:  MOVFF  02,334
073AA:  MOVFF  01,333
....................                         http_escape_chars(pValue); 
073AE:  MOVFF  334,34B
073B2:  MOVFF  333,34A
073B6:  CALL   5A04
....................                        #if HTTP_USE_CONTENT_TYPE 
....................                         http_get_page(pValue, &http_page_req[hs], &contentType[hs][0]); 
....................                        #else 
....................                         http_page_req[hs] = http_get_page(pValue); 
073BA:  MOVLB  3
073BC:  MOVF   x35,W
073BE:  MULLW  04
073C0:  MOVF   FF3,W
073C2:  CLRF   03
073C4:  ADDLW  70
073C6:  MOVWF  01
073C8:  MOVLW  02
073CA:  ADDWFC 03,F
073CC:  MOVFF  01,337
073D0:  MOVFF  03,338
073D4:  MOVFF  334,33A
073D8:  MOVFF  333,339
073DC:  MOVLB  0
073DE:  GOTO   5BFA
073E2:  MOVFF  338,FEA
073E6:  MOVFF  337,FE9
073EA:  MOVFF  00,FEF
073EE:  MOVFF  01,FEC
073F2:  MOVFF  02,FEC
073F6:  MOVFF  03,FEC
....................                        #endif 
....................                         debug_http("HTTP %U FILE %s = %lx\r\n", hs, pValue, http_page_req[hs]); 
....................                         pValue=strtok(0, tokens_get); 
073FA:  MOVLB  3
073FC:  CLRF   x3C
073FE:  CLRF   x3B
07400:  MOVLW  01
07402:  MOVWF  x3E
07404:  MOVLW  55
07406:  MOVWF  x3D
07408:  MOVLB  0
0740A:  CALL   53C8
0740E:  MOVFF  02,334
07412:  MOVFF  01,333
....................                         if (pValue) 
07416:  MOVLB  3
07418:  MOVF   x33,W
0741A:  IORWF  x34,W
0741C:  BZ    7460
....................                            http_parse_cgi_string(http_page_req[hs], pValue); 
0741E:  MOVF   x35,W
07420:  MULLW  04
07422:  MOVF   FF3,W
07424:  CLRF   03
07426:  ADDLW  70
07428:  MOVWF  FE9
0742A:  MOVLW  02
0742C:  ADDWFC 03,W
0742E:  MOVWF  FEA
07430:  MOVFF  FEF,337
07434:  MOVFF  FEC,338
07438:  MOVFF  FEC,339
0743C:  MOVFF  FEC,33A
07440:  MOVFF  33A,342
07444:  MOVFF  339,341
07448:  MOVFF  338,340
0744C:  MOVFF  337,33F
07450:  MOVFF  334,344
07454:  MOVFF  333,343
07458:  MOVLB  0
0745A:  CALL   5C50
0745E:  MOVLB  3
....................  
....................                         if (strcmp(pKey, http_get_str)==0) 
07460:  MOVFF  332,338
07464:  MOVFF  331,337
07468:  MOVLW  01
0746A:  MOVWF  x3A
0746C:  MOVLW  57
0746E:  MOVWF  x39
07470:  MOVLB  0
07472:  CALL   5478
07476:  MOVF   01,F
07478:  BNZ   7492
....................                            http_cmd[hs]=HTTP_REQ_GET; 
0747A:  CLRF   03
0747C:  MOVLB  3
0747E:  MOVF   x35,W
07480:  ADDLW  6F
07482:  MOVWF  FE9
07484:  MOVLW  02
07486:  ADDWFC 03,W
07488:  MOVWF  FEA
0748A:  MOVLW  01
0748C:  MOVWF  FEF
0748E:  BRA    74A6
07490:  MOVLB  0
....................                         else 
....................                            http_cmd[hs]=HTTP_REQ_POST; 
07492:  CLRF   03
07494:  MOVLB  3
07496:  MOVF   x35,W
07498:  ADDLW  6F
0749A:  MOVWF  FE9
0749C:  MOVLW  02
0749E:  ADDWFC 03,W
074A0:  MOVWF  FEA
074A2:  MOVLW  02
074A4:  MOVWF  FEF
....................                      } 
074A6:  BRA    7512
074A8:  MOVLB  0
....................                      else if (http_cmd[hs] != HTTP_REQ_UNKOWN)   //we processed a GET or POST 
074AA:  CLRF   03
074AC:  MOVLB  3
074AE:  MOVF   x35,W
074B0:  ADDLW  6F
074B2:  MOVWF  FE9
074B4:  MOVLW  02
074B6:  ADDWFC 03,W
074B8:  MOVWF  FEA
074BA:  MOVF   FEF,F
074BC:  BZ    7512
....................                      { 
....................                         //if you want to parse HTTP headers, do it here. 
....................                         //pKey and pVal hold the individual headers. 
....................  
....................                         //this driver only parses the Content-Length header. 
....................                         if (strcmp(pKey, http_len_str)==0) 
074BE:  MOVFF  332,338
074C2:  MOVFF  331,337
074C6:  MOVLW  01
074C8:  MOVWF  x3A
074CA:  MOVLW  60
074CC:  MOVWF  x39
074CE:  MOVLB  0
074D0:  CALL   5478
074D4:  MOVF   01,F
074D6:  BNZ   7510
....................                         { 
....................                            http_post_len[hs]=atol(pValue); 
074D8:  BCF    FD8.0
074DA:  MOVLB  3
074DC:  RLCF   x35,W
074DE:  CLRF   03
074E0:  ADDLW  74
074E2:  MOVWF  01
074E4:  MOVLW  02
074E6:  ADDWFC 03,F
074E8:  MOVFF  01,337
074EC:  MOVFF  03,338
074F0:  MOVFF  334,33A
074F4:  MOVFF  333,339
074F8:  MOVLB  0
074FA:  GOTO   5CF8
074FE:  MOVFF  338,FEA
07502:  MOVFF  337,FE9
07506:  MOVFF  02,FEC
0750A:  MOVF   FED,F
0750C:  MOVFF  01,FEF
07510:  MOVLB  3
....................                         } 
....................                      } 
....................                   } 
07512:  BRA    7584
....................                   else if (i[hs] == 0) 
07514:  CLRF   03
07516:  MOVF   x35,W
07518:  ADDLW  6E
0751A:  MOVWF  FE9
0751C:  MOVLW  02
0751E:  ADDWFC 03,W
07520:  MOVWF  FEA
07522:  MOVF   FEF,F
07524:  BNZ   7584
....................                   { 
....................                      //got a double \r\n 
....................                      debug_http("HTTP %U GET HEADER DONE\r\n", hs); 
....................                      if (http_cmd[hs] == HTTP_REQ_POST) 
07526:  CLRF   03
07528:  MOVF   x35,W
0752A:  ADDLW  6F
0752C:  MOVWF  FE9
0752E:  MOVLW  02
07530:  ADDWFC 03,W
07532:  MOVWF  FEA
07534:  MOVF   FEF,W
07536:  SUBLW  02
07538:  BNZ   7558
....................                      { 
....................                         http_state[hs]=HTTP_GET_POST; 
0753A:  BCF    FD8.0
0753C:  RLCF   x35,W
0753E:  CLRF   03
07540:  ADDLW  21
07542:  MOVWF  FE9
07544:  MOVLW  01
07546:  ADDWFC 03,W
07548:  MOVWF  FEA
0754A:  MOVLW  01
0754C:  MOVWF  FEC
0754E:  MOVF   FED,F
07550:  MOVLW  04
07552:  MOVWF  FEF
....................                         postContinue=TRUE; 
07554:  BSF    x2F.1
....................                      } 
07556:  BRA    757E
....................                      else 
....................                      { 
....................                         http_state[hs]=HTTP_SEND_RESPONSE; 
07558:  BCF    FD8.0
0755A:  RLCF   x35,W
0755C:  CLRF   03
0755E:  ADDLW  21
07560:  MOVWF  FE9
07562:  MOVLW  01
07564:  ADDWFC 03,W
07566:  MOVWF  FEA
07568:  MOVLW  01
0756A:  MOVWF  FEC
0756C:  MOVF   FED,F
0756E:  MOVLW  06
07570:  MOVWF  FEF
....................                         TCPDiscard(currSocket); 
07572:  MOVFF  336,33A
07576:  MOVLB  0
07578:  CALL   5EF0
0757C:  MOVLB  3
....................                      } 
....................                      break;   //break out of read from ethernet loop 
0757E:  MOVLB  0
07580:  BRA    7598
07582:  MOVLB  3
....................                   } 
....................                   i[hs]=0; 
07584:  CLRF   03
07586:  MOVF   x35,W
07588:  ADDLW  6E
0758A:  MOVWF  FE9
0758C:  MOVLW  02
0758E:  ADDWFC 03,W
07590:  MOVWF  FEA
07592:  CLRF   FEF
....................                } 
07594:  BRA    7236
07596:  MOVLB  0
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
07598:  CALL   379E
0759C:  MOVFF  02,338
075A0:  MOVFF  01,337
075A4:  BCF    FD8.0
075A6:  MOVLB  3
075A8:  RLCF   x35,W
075AA:  CLRF   03
075AC:  ADDLW  76
075AE:  MOVWF  FE9
075B0:  MOVLW  02
075B2:  ADDWFC 03,W
075B4:  MOVWF  FEA
075B6:  MOVFF  FEC,03
075BA:  MOVF   FED,F
075BC:  MOVFF  FEF,01
075C0:  MOVF   02,W
075C2:  SUBWF  03,W
075C4:  BNC   75CE
075C6:  BNZ   75D2
075C8:  MOVF   01,W
075CA:  SUBWF  x37,W
075CC:  BNC   75D2
075CE:  MOVLW  00
075D0:  BRA    75D4
075D2:  MOVLW  01
075D4:  CLRF   03
075D6:  IORWF  03,W
075D8:  BZ    761C
075DA:  BCF    FD8.0
075DC:  RLCF   x35,W
075DE:  CLRF   03
075E0:  ADDLW  76
075E2:  MOVWF  FE9
075E4:  MOVLW  02
075E6:  ADDWFC 03,W
075E8:  MOVWF  FEA
075EA:  MOVFF  FEC,03
075EE:  MOVF   FED,F
075F0:  MOVF   FEF,W
075F2:  SUBLW  FF
075F4:  MOVWF  x37
075F6:  MOVLW  FF
075F8:  SUBFWB 03,W
075FA:  MOVWF  x38
075FC:  MOVLB  0
075FE:  CALL   379E
07602:  MOVF   01,W
07604:  MOVLB  3
07606:  ADDWF  x37,F
07608:  MOVF   02,W
0760A:  ADDWFC x38,F
0760C:  MOVLW  01
0760E:  ADDWF  x37,W
07610:  MOVWF  01
07612:  MOVLW  00
07614:  ADDWFC x38,W
07616:  MOVWF  03
07618:  MOVF   01,W
0761A:  BRA    7650
0761C:  MOVLB  0
0761E:  CALL   379E
07622:  MOVFF  02,338
07626:  MOVFF  01,337
0762A:  BCF    FD8.0
0762C:  MOVLB  3
0762E:  RLCF   x35,W
07630:  CLRF   03
07632:  ADDLW  76
07634:  MOVWF  FE9
07636:  MOVLW  02
07638:  ADDWFC 03,W
0763A:  MOVWF  FEA
0763C:  MOVFF  FEC,03
07640:  MOVF   FED,F
07642:  MOVF   FEF,W
07644:  SUBWF  01,W
07646:  MOVWF  00
07648:  MOVF   03,W
0764A:  SUBWFB 02,W
0764C:  MOVWF  03
0764E:  MOVF   00,W
07650:  SUBLW  C8
07652:  BC    7688
....................             { 
....................                //if (http_got_headers[hs]) 
....................                //{ 
....................                   debug_http("HTTP %U GET HEADER TIMEOUT\r\n", hs); 
....................                   http_page_req[hs]=0xFFFFFFFF; 
07654:  MOVF   x35,W
07656:  MULLW  04
07658:  MOVF   FF3,W
0765A:  CLRF   03
0765C:  ADDLW  70
0765E:  MOVWF  FE9
07660:  MOVLW  02
07662:  ADDWFC 03,W
07664:  MOVWF  FEA
07666:  SETF   FEF
07668:  SETF   FEC
0766A:  SETF   FEC
0766C:  SETF   FEC
....................                   http_state[hs]=HTTP_SEND_RESPONSE; 
0766E:  BCF    FD8.0
07670:  RLCF   x35,W
07672:  CLRF   03
07674:  ADDLW  21
07676:  MOVWF  FE9
07678:  MOVLW  01
0767A:  ADDWFC 03,W
0767C:  MOVWF  FEA
0767E:  MOVLW  01
07680:  MOVWF  FEC
07682:  MOVF   FED,F
07684:  MOVLW  06
07686:  MOVWF  FEF
....................                //} 
....................                //else 
....................                //{ 
....................                //   http_state[hs]=HTTP_CLOSE; 
....................                //} 
....................             } 
....................             if (!postContinue) 
07688:  BTFSC  x2F.1
0768A:  BRA    7692
....................                break; 
0768C:  MOVLB  0
0768E:  BRA    7CB0
07690:  MOVLB  3
07692:  MOVLB  0
....................  
....................          case HTTP_GET_POST: 
....................             debug_http("HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]); 
....................             http_state[hs]=HTTP_GET_POST_CONTINUE; 
07694:  BCF    FD8.0
07696:  MOVLB  3
07698:  RLCF   x35,W
0769A:  CLRF   03
0769C:  ADDLW  21
0769E:  MOVWF  FE9
076A0:  MOVLW  01
076A2:  ADDWFC 03,W
076A4:  MOVWF  FEA
076A6:  MOVLW  01
076A8:  MOVWF  FEC
076AA:  MOVF   FED,F
076AC:  MOVLW  05
076AE:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
076B0:  BCF    FD8.0
076B2:  RLCF   x35,W
076B4:  CLRF   03
076B6:  ADDLW  76
076B8:  MOVWF  01
076BA:  MOVLW  02
076BC:  ADDWFC 03,F
076BE:  MOVFF  01,337
076C2:  MOVFF  03,338
076C6:  MOVLB  0
076C8:  CALL   379E
076CC:  MOVFF  338,FEA
076D0:  MOVFF  337,FE9
076D4:  MOVFF  02,FEC
076D8:  MOVF   FED,F
076DA:  MOVFF  01,FEF
....................             i[hs]=0; 
076DE:  CLRF   03
076E0:  MOVLB  3
076E2:  MOVF   x35,W
076E4:  ADDLW  6E
076E6:  MOVWF  FE9
076E8:  MOVLW  02
076EA:  ADDWFC 03,W
076EC:  MOVWF  FEA
076EE:  CLRF   FEF
076F0:  MOVLB  0
....................  
....................          case HTTP_GET_POST_CONTINUE: 
....................             while ( 
....................                      TCPIsGetReady(currSocket) && 
....................                      TCPGet(currSocket, &c) && 
....................                      (http_post_len[hs] != 0) 
....................                   ) 
076F2:  MOVFF  336,337
076F6:  CALL   51BE
076FA:  MOVF   01,F
076FC:  BTFSC  FD8.2
076FE:  BRA    78BE
07700:  MOVFF  336,337
07704:  MOVLW  03
07706:  MOVLB  3
07708:  MOVWF  x39
0770A:  MOVLW  30
0770C:  MOVWF  x38
0770E:  MOVLB  0
07710:  CALL   51EA
07714:  MOVF   01,F
07716:  BTFSC  FD8.2
07718:  BRA    78BE
0771A:  BCF    FD8.0
0771C:  MOVLB  3
0771E:  RLCF   x35,W
07720:  CLRF   03
07722:  ADDLW  74
07724:  MOVWF  FE9
07726:  MOVLW  02
07728:  ADDWFC 03,W
0772A:  MOVWF  FEA
0772C:  MOVFF  FEC,338
07730:  MOVF   FED,F
07732:  MOVFF  FEF,337
07736:  MOVF   x37,F
07738:  BNZ   7744
0773A:  MOVF   x38,F
0773C:  BTFSS  FD8.2
0773E:  BRA    7744
07740:  MOVLB  0
07742:  BRA    78BE
....................             { 
....................                http_post_len[hs] -= 1; 
07744:  BCF    FD8.0
07746:  RLCF   x35,W
07748:  CLRF   03
0774A:  ADDLW  74
0774C:  MOVWF  FE9
0774E:  MOVLW  02
07750:  ADDWFC 03,W
07752:  MOVWF  FEA
07754:  MOVLW  01
07756:  SUBWF  FEF,W
07758:  MOVWF  00
0775A:  MOVLW  00
0775C:  SUBWFB FEC,W
0775E:  MOVWF  03
07760:  MOVF   00,W
07762:  MOVF   FED,F
07764:  MOVWF  FEF
07766:  MOVFF  03,FEC
....................  
....................                if (c!='&') 
0776A:  MOVF   x30,W
0776C:  SUBLW  26
0776E:  BZ    77A6
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
07770:  MOVF   x35,W
07772:  MULLW  FE
07774:  MOVF   FF3,W
07776:  CLRF   x38
07778:  MOVWF  x37
0777A:  CLRF   03
0777C:  MOVF   x35,W
0777E:  ADDLW  6E
07780:  MOVWF  FE9
07782:  MOVLW  02
07784:  ADDWFC 03,W
07786:  MOVWF  FEA
07788:  MOVF   FEF,W
0778A:  INCF   FEF,F
0778C:  CLRF   03
0778E:  ADDWF  x37,W
07790:  MOVWF  01
07792:  MOVF   x38,W
07794:  ADDWFC 03,F
07796:  MOVF   01,W
07798:  ADDLW  70
0779A:  MOVWF  FE9
0779C:  MOVLW  01
0779E:  ADDWFC 03,W
077A0:  MOVWF  FEA
077A2:  MOVFF  330,FEF
....................                } 
....................  
....................                if ( (c=='&') || (http_post_len[hs] == 0) ) 
077A6:  MOVF   x30,W
077A8:  SUBLW  26
077AA:  BZ    77D0
077AC:  BCF    FD8.0
077AE:  RLCF   x35,W
077B0:  CLRF   03
077B2:  ADDLW  74
077B4:  MOVWF  FE9
077B6:  MOVLW  02
077B8:  ADDWFC 03,W
077BA:  MOVWF  FEA
077BC:  MOVFF  FEC,338
077C0:  MOVF   FED,F
077C2:  MOVFF  FEF,337
077C6:  MOVF   x37,F
077C8:  BTFSS  FD8.2
077CA:  BRA    78BA
077CC:  MOVF   x38,F
077CE:  BNZ   78BA
....................                { 
....................                   buffer[hs][i[hs]]=0; 
077D0:  MOVF   x35,W
077D2:  MULLW  FE
077D4:  MOVF   FF3,W
077D6:  CLRF   x38
077D8:  MOVWF  x37
077DA:  CLRF   03
077DC:  MOVF   x35,W
077DE:  ADDLW  6E
077E0:  MOVWF  FE9
077E2:  MOVLW  02
077E4:  ADDWFC 03,W
077E6:  MOVWF  FEA
077E8:  CLRF   03
077EA:  MOVF   FEF,W
077EC:  ADDWF  x37,W
077EE:  MOVWF  01
077F0:  MOVF   x38,W
077F2:  ADDWFC 03,F
077F4:  MOVF   01,W
077F6:  ADDLW  70
077F8:  MOVWF  FE9
077FA:  MOVLW  01
077FC:  ADDWFC 03,W
077FE:  MOVWF  FEA
07800:  CLRF   FEF
....................  
....................                   debug_http("%lu - %s\r\n", http_post_len[hs], &buffer[hs][0]); 
....................  
....................                   http_parse_cgi_string(http_page_req[hs], &buffer[hs][0]); 
07802:  MOVF   x35,W
07804:  MULLW  04
07806:  MOVF   FF3,W
07808:  CLRF   03
0780A:  ADDLW  70
0780C:  MOVWF  FE9
0780E:  MOVLW  02
07810:  ADDWFC 03,W
07812:  MOVWF  FEA
07814:  MOVFF  FEF,337
07818:  MOVFF  FEC,338
0781C:  MOVFF  FEC,339
07820:  MOVFF  FEC,33A
07824:  MOVF   x35,W
07826:  MULLW  FE
07828:  MOVF   FF3,W
0782A:  CLRF   x3C
0782C:  MOVWF  x3B
0782E:  MOVLW  70
07830:  ADDWF  x3B,W
07832:  MOVWF  01
07834:  MOVLW  01
07836:  ADDWFC x3C,W
07838:  MOVWF  03
0783A:  MOVFF  01,33D
0783E:  MOVWF  x3E
07840:  MOVFF  33A,342
07844:  MOVFF  339,341
07848:  MOVFF  338,340
0784C:  MOVFF  337,33F
07850:  MOVWF  x44
07852:  MOVFF  01,343
07856:  MOVLB  0
07858:  CALL   5C50
....................                   if (http_post_len[hs] == 0) 
0785C:  BCF    FD8.0
0785E:  MOVLB  3
07860:  RLCF   x35,W
07862:  CLRF   03
07864:  ADDLW  74
07866:  MOVWF  FE9
07868:  MOVLW  02
0786A:  ADDWFC 03,W
0786C:  MOVWF  FEA
0786E:  MOVFF  FEC,338
07872:  MOVF   FED,F
07874:  MOVFF  FEF,337
07878:  MOVF   x37,F
0787A:  BNZ   78AA
0787C:  MOVF   x38,F
0787E:  BNZ   78AA
....................                   { 
....................                      http_state[hs]=HTTP_SEND_RESPONSE; 
07880:  BCF    FD8.0
07882:  RLCF   x35,W
07884:  CLRF   03
07886:  ADDLW  21
07888:  MOVWF  FE9
0788A:  MOVLW  01
0788C:  ADDWFC 03,W
0788E:  MOVWF  FEA
07890:  MOVLW  01
07892:  MOVWF  FEC
07894:  MOVF   FED,F
07896:  MOVLW  06
07898:  MOVWF  FEF
....................                      TCPDiscard(currSocket); 
0789A:  MOVFF  336,33A
0789E:  MOVLB  0
078A0:  CALL   5EF0
....................                      break; 
078A4:  BRA    78BE
....................                   } 
078A6:  BRA    78BC
078A8:  MOVLB  3
....................                   else 
....................                      i[hs]=0; 
078AA:  CLRF   03
078AC:  MOVF   x35,W
078AE:  ADDLW  6E
078B0:  MOVWF  FE9
078B2:  MOVLW  02
078B4:  ADDWFC 03,W
078B6:  MOVWF  FEA
078B8:  CLRF   FEF
078BA:  MOVLB  0
....................                } 
078BC:  BRA    76F2
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
078BE:  CALL   379E
078C2:  MOVFF  02,338
078C6:  MOVFF  01,337
078CA:  BCF    FD8.0
078CC:  MOVLB  3
078CE:  RLCF   x35,W
078D0:  CLRF   03
078D2:  ADDLW  76
078D4:  MOVWF  FE9
078D6:  MOVLW  02
078D8:  ADDWFC 03,W
078DA:  MOVWF  FEA
078DC:  MOVFF  FEC,03
078E0:  MOVF   FED,F
078E2:  MOVFF  FEF,01
078E6:  MOVF   02,W
078E8:  SUBWF  03,W
078EA:  BNC   78F4
078EC:  BNZ   78F8
078EE:  MOVF   01,W
078F0:  SUBWF  x37,W
078F2:  BNC   78F8
078F4:  MOVLW  00
078F6:  BRA    78FA
078F8:  MOVLW  01
078FA:  CLRF   03
078FC:  IORWF  03,W
078FE:  BZ    7942
07900:  BCF    FD8.0
07902:  RLCF   x35,W
07904:  CLRF   03
07906:  ADDLW  76
07908:  MOVWF  FE9
0790A:  MOVLW  02
0790C:  ADDWFC 03,W
0790E:  MOVWF  FEA
07910:  MOVFF  FEC,03
07914:  MOVF   FED,F
07916:  MOVF   FEF,W
07918:  SUBLW  FF
0791A:  MOVWF  x37
0791C:  MOVLW  FF
0791E:  SUBFWB 03,W
07920:  MOVWF  x38
07922:  MOVLB  0
07924:  CALL   379E
07928:  MOVF   01,W
0792A:  MOVLB  3
0792C:  ADDWF  x37,F
0792E:  MOVF   02,W
07930:  ADDWFC x38,F
07932:  MOVLW  01
07934:  ADDWF  x37,W
07936:  MOVWF  01
07938:  MOVLW  00
0793A:  ADDWFC x38,W
0793C:  MOVWF  03
0793E:  MOVF   01,W
07940:  BRA    7976
07942:  MOVLB  0
07944:  CALL   379E
07948:  MOVFF  02,338
0794C:  MOVFF  01,337
07950:  BCF    FD8.0
07952:  MOVLB  3
07954:  RLCF   x35,W
07956:  CLRF   03
07958:  ADDLW  76
0795A:  MOVWF  FE9
0795C:  MOVLW  02
0795E:  ADDWFC 03,W
07960:  MOVWF  FEA
07962:  MOVFF  FEC,03
07966:  MOVF   FED,F
07968:  MOVF   FEF,W
0796A:  SUBWF  01,W
0796C:  MOVWF  00
0796E:  MOVF   03,W
07970:  SUBWFB 02,W
07972:  MOVWF  03
07974:  MOVF   00,W
07976:  SUBLW  C8
07978:  BC    79AE
....................             { 
....................                debug_http("HTTP %U GET POST TIMEOUT\r\n", hs); 
....................                http_page_req[hs]=0xFFFFFFFF; 
0797A:  MOVF   x35,W
0797C:  MULLW  04
0797E:  MOVF   FF3,W
07980:  CLRF   03
07982:  ADDLW  70
07984:  MOVWF  FE9
07986:  MOVLW  02
07988:  ADDWFC 03,W
0798A:  MOVWF  FEA
0798C:  SETF   FEF
0798E:  SETF   FEC
07990:  SETF   FEC
07992:  SETF   FEC
....................                http_state[hs]=HTTP_SEND_RESPONSE; 
07994:  BCF    FD8.0
07996:  RLCF   x35,W
07998:  CLRF   03
0799A:  ADDLW  21
0799C:  MOVWF  FE9
0799E:  MOVLW  01
079A0:  ADDWFC 03,W
079A2:  MOVWF  FEA
079A4:  MOVLW  01
079A6:  MOVWF  FEC
079A8:  MOVF   FED,F
079AA:  MOVLW  06
079AC:  MOVWF  FEF
....................             } 
....................             break; 
079AE:  MOVLB  0
079B0:  BRA    7CB0
....................  
....................          case HTTP_SEND_RESPONSE: 
....................             debug_http("HTTP %U SEND RESPONSE\r\n", hs); 
....................             lastHTTPPutConstPos[hs]=0; 
079B2:  MOVLB  3
079B4:  MOVF   x35,W
079B6:  MULLW  04
079B8:  MOVF   FF3,W
079BA:  CLRF   03
079BC:  ADDLW  24
079BE:  MOVWF  FE9
079C0:  MOVLW  01
079C2:  ADDWFC 03,W
079C4:  MOVWF  FEA
079C6:  MOVF   FEE,F
079C8:  MOVF   FEE,F
079CA:  CLRF   FEC
079CC:  MOVF   FED,F
079CE:  CLRF   FEF
079D0:  MOVF   FED,F
079D2:  CLRF   FEF
079D4:  MOVF   FED,F
079D6:  CLRF   FEF
....................             http_state[hs]=HTTP_SEND_RESPONSE_CONTINUE; 
079D8:  BCF    FD8.0
079DA:  RLCF   x35,W
079DC:  CLRF   03
079DE:  ADDLW  21
079E0:  MOVWF  FE9
079E2:  MOVLW  01
079E4:  ADDWFC 03,W
079E6:  MOVWF  FEA
079E8:  MOVLW  01
079EA:  MOVWF  FEC
079EC:  MOVF   FED,F
079EE:  MOVLW  07
079F0:  MOVWF  FEF
079F2:  MOVLB  0
....................  
....................          case HTTP_SEND_RESPONSE_CONTINUE: 
....................             TCPDiscard(currSocket); 
079F4:  MOVFF  336,33A
079F8:  CALL   5EF0
....................             if (TCPIsPutReady(currSocket)) 
079FC:  MOVFF  336,35A
07A00:  CALL   5F3E
07A04:  MOVF   01,F
07A06:  BTFSC  FD8.2
07A08:  BRA    7B66
....................             { 
....................                debug_http("\r\nPUTTING HTTP SEG\r\n"); 
....................                if (http_page_req[hs]==0xFFFFFFFF) 
07A0A:  MOVLB  3
07A0C:  MOVF   x35,W
07A0E:  MULLW  04
07A10:  MOVF   FF3,W
07A12:  CLRF   03
07A14:  ADDLW  70
07A16:  MOVWF  FE9
07A18:  MOVLW  02
07A1A:  ADDWFC 03,W
07A1C:  MOVWF  FEA
07A1E:  MOVFF  FEF,337
07A22:  MOVFF  FEC,338
07A26:  MOVFF  FEC,339
07A2A:  MOVFF  FEC,33A
07A2E:  INCFSZ x37,W
07A30:  BRA    7A8A
07A32:  INCFSZ x38,W
07A34:  BRA    7A8A
07A36:  INCFSZ x39,W
07A38:  BRA    7A8A
07A3A:  INCFSZ x3A,W
07A3C:  BRA    7A8A
....................                   doneSend=tcp_http_put_file(hs, 500, label_address(http_500_error), 0); 
07A3E:  MOVLW  00
07A40:  MOVWF  02
07A42:  MOVLW  01
07A44:  MOVWF  01
07A46:  MOVLW  1E
07A48:  MOVWF  00
07A4A:  CLRF   03
07A4C:  MOVFF  03,33A
07A50:  MOVFF  02,339
07A54:  MOVFF  01,338
07A58:  MOVWF  x37
07A5A:  MOVFF  335,33B
07A5E:  MOVLW  01
07A60:  MOVWF  x3D
07A62:  MOVLW  F4
07A64:  MOVWF  x3C
07A66:  MOVFF  03,341
07A6A:  MOVFF  02,340
07A6E:  MOVFF  01,33F
07A72:  MOVFF  00,33E
07A76:  CLRF   x43
07A78:  CLRF   x42
07A7A:  MOVLB  0
07A7C:  CALL   6B8C
07A80:  MOVLB  3
07A82:  BCF    x2F.0
07A84:  BTFSC  01.0
07A86:  BSF    x2F.0
07A88:  BRA    7B46
....................                else if (http_page_req[hs]) 
....................                 #if HTTP_USE_CONTENT_TYPE 
07A8A:  MOVF   x35,W
07A8C:  MULLW  04
07A8E:  MOVF   FF3,W
07A90:  CLRF   03
07A92:  ADDLW  70
07A94:  MOVWF  FE9
07A96:  MOVLW  02
07A98:  ADDWFC 03,W
07A9A:  MOVWF  FEA
07A9C:  MOVF   FEF,F
07A9E:  BNZ   7AAC
07AA0:  MOVF   FEC,F
07AA2:  BNZ   7AAC
07AA4:  MOVF   FEC,F
07AA6:  BNZ   7AAC
07AA8:  MOVF   FEC,F
07AAA:  BZ    7AFC
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], &contentType[hs][0]); 
....................                 #else 
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], 0); 
07AAC:  MOVF   x35,W
07AAE:  MULLW  04
07AB0:  MOVF   FF3,W
07AB2:  CLRF   03
07AB4:  ADDLW  70
07AB6:  MOVWF  FE9
07AB8:  MOVLW  02
07ABA:  ADDWFC 03,W
07ABC:  MOVWF  FEA
07ABE:  MOVFF  FEF,337
07AC2:  MOVFF  FEC,338
07AC6:  MOVFF  FEC,339
07ACA:  MOVFF  FEC,33A
07ACE:  MOVFF  335,33B
07AD2:  CLRF   x3D
07AD4:  MOVLW  C8
07AD6:  MOVWF  x3C
07AD8:  MOVFF  33A,341
07ADC:  MOVFF  339,340
07AE0:  MOVFF  338,33F
07AE4:  MOVFF  337,33E
07AE8:  CLRF   x43
07AEA:  CLRF   x42
07AEC:  MOVLB  0
07AEE:  CALL   6B8C
07AF2:  MOVLB  3
07AF4:  BCF    x2F.0
07AF6:  BTFSC  01.0
07AF8:  BSF    x2F.0
....................                 #endif 
07AFA:  BRA    7B46
....................                else 
....................                   doneSend=tcp_http_put_file(hs, 404, label_address(http_404_error), 0); 
07AFC:  MOVLW  00
07AFE:  MOVWF  02
07B00:  MOVLW  00
07B02:  MOVWF  01
07B04:  MOVLW  DA
07B06:  MOVWF  00
07B08:  CLRF   03
07B0A:  MOVFF  03,33A
07B0E:  MOVFF  02,339
07B12:  MOVFF  01,338
07B16:  MOVWF  x37
07B18:  MOVFF  335,33B
07B1C:  MOVLW  01
07B1E:  MOVWF  x3D
07B20:  MOVLW  94
07B22:  MOVWF  x3C
07B24:  MOVFF  03,341
07B28:  MOVFF  02,340
07B2C:  MOVFF  01,33F
07B30:  MOVFF  00,33E
07B34:  CLRF   x43
07B36:  CLRF   x42
07B38:  MOVLB  0
07B3A:  CALL   6B8C
07B3E:  MOVLB  3
07B40:  BCF    x2F.0
07B42:  BTFSC  01.0
07B44:  BSF    x2F.0
....................  
....................                if (doneSend) 
07B46:  BTFSS  x2F.0
07B48:  BRA    7B64
....................                { 
....................                   //if (http_isKeepAlive[hs]) 
....................                   //   http_state[hs]=HTTP_CONNECTED; 
....................                   //else 
....................                   //   http_state[hs]=HTTP_CLOSE; 
....................                   http_state[hs] = HTTP_CLOSE; 
07B4A:  BCF    FD8.0
07B4C:  RLCF   x35,W
07B4E:  CLRF   03
07B50:  ADDLW  21
07B52:  MOVWF  FE9
07B54:  MOVLW  01
07B56:  ADDWFC 03,W
07B58:  MOVWF  FEA
07B5A:  MOVLW  01
07B5C:  MOVWF  FEC
07B5E:  MOVF   FED,F
07B60:  MOVLW  08
07B62:  MOVWF  FEF
07B64:  MOVLB  0
....................                   debug_http("HTTP %U RESPONSE SENT\r\n", hs); 
....................                } 
....................             } 
....................             /*else 
....................             { 
....................                debug_http("\r\nNR => RW=%LX B=%X IS=%U\r\n", 
....................                      TCB[currSocket].RemoteWindow, 
....................                      TCB[currSocket].TxBuffer, 
....................                      TCB[currSocket].Flags.bIsPutReady 
....................                   ); 
....................                delay_ms(100); 
....................             }*/ 
....................             break; 
07B66:  BRA    7CB0
....................  
....................          case HTTP_CLOSE: 
....................             //since we set connection: close in the header, the client 
....................             //should automatically close.  but after so many seconds we 
....................             //shall kill the connection 
....................             http_state[hs]=HTTP_CLOSE_WAITING; 
07B68:  BCF    FD8.0
07B6A:  MOVLB  3
07B6C:  RLCF   x35,W
07B6E:  CLRF   03
07B70:  ADDLW  21
07B72:  MOVWF  FE9
07B74:  MOVLW  01
07B76:  ADDWFC 03,W
07B78:  MOVWF  FEA
07B7A:  MOVLW  01
07B7C:  MOVWF  FEC
07B7E:  MOVF   FED,F
07B80:  MOVLW  09
07B82:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
07B84:  BCF    FD8.0
07B86:  RLCF   x35,W
07B88:  CLRF   03
07B8A:  ADDLW  76
07B8C:  MOVWF  01
07B8E:  MOVLW  02
07B90:  ADDWFC 03,F
07B92:  MOVFF  01,337
07B96:  MOVFF  03,338
07B9A:  MOVLB  0
07B9C:  CALL   379E
07BA0:  MOVFF  338,FEA
07BA4:  MOVFF  337,FE9
07BA8:  MOVFF  02,FEC
07BAC:  MOVF   FED,F
07BAE:  MOVFF  01,FEF
....................  
....................          case HTTP_CLOSE_WAITING: 
....................             TCPDiscard(currSocket); 
07BB2:  MOVFF  336,33A
07BB6:  CALL   5EF0
....................             if (  TCPIsPutReady(currSocket) || 
....................                   (TickGetDiff(TickGet(),http_timer[hs]) > (TICKS_PER_SECOND*5)) 
07BBA:  MOVFF  336,35A
07BBE:  CALL   5F3E
07BC2:  MOVF   01,F
07BC4:  BNZ   7C84
07BC6:  CALL   379E
07BCA:  MOVFF  02,338
07BCE:  MOVFF  01,337
07BD2:  BCF    FD8.0
07BD4:  MOVLB  3
07BD6:  RLCF   x35,W
07BD8:  CLRF   03
07BDA:  ADDLW  76
07BDC:  MOVWF  FE9
07BDE:  MOVLW  02
07BE0:  ADDWFC 03,W
07BE2:  MOVWF  FEA
07BE4:  MOVFF  FEC,03
07BE8:  MOVF   FED,F
07BEA:  MOVFF  FEF,01
07BEE:  MOVF   02,W
07BF0:  SUBWF  03,W
07BF2:  BNC   7BFC
07BF4:  BNZ   7C00
07BF6:  MOVF   01,W
07BF8:  SUBWF  x37,W
07BFA:  BNC   7C00
07BFC:  MOVLW  00
07BFE:  BRA    7C02
07C00:  MOVLW  01
07C02:  CLRF   03
07C04:  IORWF  03,W
07C06:  BZ    7C4A
07C08:  BCF    FD8.0
07C0A:  RLCF   x35,W
07C0C:  CLRF   03
07C0E:  ADDLW  76
07C10:  MOVWF  FE9
07C12:  MOVLW  02
07C14:  ADDWFC 03,W
07C16:  MOVWF  FEA
07C18:  MOVFF  FEC,03
07C1C:  MOVF   FED,F
07C1E:  MOVF   FEF,W
07C20:  SUBLW  FF
07C22:  MOVWF  x37
07C24:  MOVLW  FF
07C26:  SUBFWB 03,W
07C28:  MOVWF  x38
07C2A:  MOVLB  0
07C2C:  CALL   379E
07C30:  MOVF   01,W
07C32:  MOVLB  3
07C34:  ADDWF  x37,F
07C36:  MOVF   02,W
07C38:  ADDWFC x38,F
07C3A:  MOVLW  01
07C3C:  ADDWF  x37,W
07C3E:  MOVWF  01
07C40:  MOVLW  00
07C42:  ADDWFC x38,W
07C44:  MOVWF  03
07C46:  MOVF   01,W
07C48:  BRA    7C7E
07C4A:  MOVLB  0
07C4C:  CALL   379E
07C50:  MOVFF  02,338
07C54:  MOVFF  01,337
07C58:  BCF    FD8.0
07C5A:  MOVLB  3
07C5C:  RLCF   x35,W
07C5E:  CLRF   03
07C60:  ADDLW  76
07C62:  MOVWF  FE9
07C64:  MOVLW  02
07C66:  ADDWFC 03,W
07C68:  MOVWF  FEA
07C6A:  MOVFF  FEC,03
07C6E:  MOVF   FED,F
07C70:  MOVF   FEF,W
07C72:  SUBWF  01,W
07C74:  MOVWF  00
07C76:  MOVF   03,W
07C78:  SUBWFB 02,W
07C7A:  MOVWF  03
07C7C:  MOVF   00,W
07C7E:  SUBLW  32
07C80:  BC    7CA8
07C82:  MOVLB  0
....................                ) 
....................             { 
....................                debug_http("HTTP %U FORCE CLOSED\r\n", hs); 
....................                TCPDisconnect(currSocket); 
07C84:  MOVFF  336,337
07C88:  GOTO   6EEA
....................                http_state[hs]=HTTP_CLOSED; 
07C8C:  BCF    FD8.0
07C8E:  MOVLB  3
07C90:  RLCF   x35,W
07C92:  CLRF   03
07C94:  ADDLW  21
07C96:  MOVWF  FE9
07C98:  MOVLW  01
07C9A:  ADDWFC 03,W
07C9C:  MOVWF  FEA
07C9E:  MOVLW  01
07CA0:  MOVWF  FEC
07CA2:  MOVF   FED,F
07CA4:  MOVLW  0A
07CA6:  MOVWF  FEF
....................             } 
....................             break; 
07CA8:  MOVLB  0
07CAA:  BRA    7CB0
07CAC:  MOVLB  3
....................  
....................          case HTTP_CLOSED: //do nothing until socket actually closes 
....................          default: 
....................             break; 
07CAE:  MOVLB  0
....................       } 
07CB0:  MOVLB  3
07CB2:  INCF   x35,F
07CB4:  GOTO   702C
....................    } 
07CB8:  MOVLB  0
07CBA:  GOTO   7E8C (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
0235A:  MOVLB  2
0235C:  CLRF   x78
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
0235E:  MOVLB  0
02360:  GOTO   1A8C
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
02364:  BRA    1D9A
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
02366:  BRA    1F68
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
02368:  BRA    20B2
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Init(); 
0236A:  BRA    22F0
.................... #endif 
0236C:  GOTO   8036 (RETURN)
.................... } 
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
*
07CBE:  MOVLB  3
07CC0:  BCF    x2E.0
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
07CC2:  BCF    x2E.0
....................         switch(smStack) 
07CC4:  MOVLB  2
07CC6:  MOVF   x78,W
07CC8:  ADDLW  F9
07CCA:  BTFSC  FD8.0
07CCC:  BRA    7E7C
07CCE:  ADDLW  07
07CD0:  MOVLB  0
07CD2:  GOTO   7E90
....................         { 
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
07CD6:  MOVLW  02
07CD8:  MOVLB  3
07CDA:  MOVWF  x30
07CDC:  MOVLW  79
07CDE:  MOVWF  x2F
07CE0:  MOVLW  03
07CE2:  MOVWF  x32
07CE4:  MOVLW  2D
07CE6:  MOVWF  x31
07CE8:  MOVLB  0
07CEA:  GOTO   2456
07CEE:  MOVF   01,F
07CF0:  BNZ   7CF8
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
....................                     { 
....................                         if ( !MACIsLinked() ) 
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
....................                             DHCPReset(); 
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
07CF2:  MOVLB  2
07CF4:  BRA    7E7C
07CF6:  MOVLB  0
....................             } 
....................  
.................... //            debug_stack("\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
07CF8:  MOVLB  3
07CFA:  BSF    x2E.0
....................             if ( type.MACFrameType == MAC_IP ) { 
07CFC:  MOVF   x2D,F
07CFE:  BNZ   7D0A
....................                 smStack = SM_STACK_IP; 
07D00:  MOVLW  02
07D02:  MOVLB  2
07D04:  MOVWF  x78
.................... //                debug_stack("IP "); 
....................             } 
07D06:  BRA    7D22
07D08:  MOVLB  3
....................             else if ( type.MACFrameType == MAC_ARP ) { 
07D0A:  MOVF   x2D,W
07D0C:  SUBLW  06
07D0E:  BNZ   7D1A
....................                 smStack = SM_STACK_ARP; 
07D10:  MOVLW  05
07D12:  MOVLB  2
07D14:  MOVWF  x78
.................... //                debug_stack("ARP "); 
....................             } 
07D16:  BRA    7D22
07D18:  MOVLB  3
....................             else { 
....................                 MACDiscardRx(); 
07D1A:  MOVLB  0
07D1C:  CALL   2370
07D20:  MOVLB  2
.................... //                debug_stack("DISCARD"); 
....................             } 
....................             break; 
07D22:  BRA    7E7C
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
07D24:  GOTO   2D12
07D28:  MOVF   01,F
07D2A:  BZ    7D32
....................                 smStack = SM_STACK_IDLE; 
07D2C:  MOVLB  2
07D2E:  CLRF   x78
07D30:  MOVLB  0
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
07D32:  MOVLB  2
07D34:  BRA    7E7C
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
07D36:  MOVLW  03
07D38:  MOVLB  3
07D3A:  MOVWF  x30
07D3C:  MOVLW  29
07D3E:  MOVWF  x2F
07D40:  MOVLW  02
07D42:  MOVWF  x32
07D44:  MOVLW  79
07D46:  MOVWF  x31
07D48:  MOVLW  03
07D4A:  MOVWF  x34
07D4C:  MOVLW  2D
07D4E:  MOVWF  x33
07D50:  MOVLW  02
07D52:  MOVWF  x36
07D54:  MOVLW  83
07D56:  MOVWF  x35
07D58:  MOVLB  0
07D5A:  GOTO   3006
07D5E:  MOVF   01,F
07D60:  BZ    7D94
....................             { 
....................                 lbContinue = TRUE; 
07D62:  MOVLB  3
07D64:  BSF    x2E.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
07D66:  DECFSZ x2D,W
07D68:  BRA    7D74
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
07D6A:  MOVLW  03
07D6C:  MOVLB  2
07D6E:  MOVWF  x78
.................... //                    debug_stack("ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
07D70:  BRA    7D90
07D72:  MOVLB  3
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
07D74:  MOVF   x2D,W
07D76:  SUBLW  06
07D78:  BNZ   7D84
....................                     smStack = SM_STACK_TCP; 
07D7A:  MOVLW  06
07D7C:  MOVLB  2
07D7E:  MOVWF  x78
....................                     debug_stack("TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
07D80:  BRA    7D90
07D82:  MOVLB  3
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                     smStack = SM_STACK_UDP; 
.................... //                    debug_stack("UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
....................                 { 
....................                     lbContinue = FALSE; 
07D84:  BCF    x2E.0
....................                     MACDiscardRx(); 
07D86:  MOVLB  0
07D88:  CALL   2370
....................  
....................                     smStack = SM_STACK_IDLE; 
07D8C:  MOVLB  2
07D8E:  CLRF   x78
.................... //                    debug_stack("UNKOWN-IP1 "); 
....................                 } 
....................             } 
07D90:  BRA    7D9C
07D92:  MOVLB  0
....................             else 
....................             { 
....................                 MACDiscardRx(); 
07D94:  CALL   2370
....................                 smStack = SM_STACK_IDLE; 
07D98:  MOVLB  2
07D9A:  CLRF   x78
.................... //                debug_stack("UNKOWN-IP2 "); 
....................             } 
....................             break; 
07D9C:  BRA    7E7C
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
.................... //                debug_stack("\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
07D9E:  MOVLW  02
07DA0:  MOVLB  3
07DA2:  MOVWF  x30
07DA4:  MOVLW  79
07DA6:  MOVWF  x2F
07DA8:  MOVLW  03
07DAA:  MOVWF  x32
07DAC:  MOVLW  29
07DAE:  MOVWF  x31
07DB0:  MOVFF  284,334
07DB4:  MOVFF  283,333
07DB8:  MOVLB  0
07DBA:  GOTO   4856
07DBE:  MOVF   01,F
07DC0:  BZ    7DC8
....................             { 
....................                 debug_stack("\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
07DC2:  MOVLB  2
07DC4:  CLRF   x78
07DC6:  MOVLB  0
....................             } 
....................             break; 
07DC8:  MOVLB  2
07DCA:  BRA    7E7C
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
07DCC:  MOVLB  2
07DCE:  CLRF   x78
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
07DD0:  MOVF   x84,F
07DD2:  BNZ   7E26
07DD4:  MOVF   x83,W
07DD6:  SUBLW  48
07DD8:  BNC   7E26
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
07DDA:  MOVLW  02
07DDC:  MOVLB  3
07DDE:  MOVWF  x30
07DE0:  MOVLW  83
07DE2:  MOVWF  x2F
07DE4:  MOVLW  03
07DE6:  MOVWF  x32
07DE8:  MOVLW  2D
07DEA:  MOVWF  x31
07DEC:  MOVLW  02
07DEE:  MOVWF  x34
07DF0:  MOVLW  85
07DF2:  MOVWF  x33
07DF4:  MOVFF  330,336
07DF8:  MOVFF  32F,335
07DFC:  MOVLW  02
07DFE:  MOVWF  x38
07E00:  MOVLW  C5
07E02:  MOVWF  x37
07E04:  MOVLW  02
07E06:  MOVWF  x3A
07E08:  MOVLW  C7
07E0A:  MOVWF  x39
07E0C:  MOVLB  0
07E0E:  GOTO   4AE4
07E12:  MOVF   01,F
07E14:  BZ    7E2A
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
07E16:  MOVLB  3
07E18:  MOVF   x2D,W
07E1A:  SUBLW  08
07E1C:  BNZ   7E28
....................                     { 
.................... //                        debug_stack("\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
07E1E:  BSF    x2E.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
07E20:  MOVLW  04
07E22:  MOVLB  2
07E24:  MOVWF  x78
07E26:  MOVLB  3
07E28:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
07E2A:  CALL   2370
....................             break; 
07E2E:  MOVLB  2
07E30:  BRA    7E7C
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
07E32:  MOVLW  01
07E34:  MOVLB  3
07E36:  MOVWF  xB8
07E38:  MOVLB  0
07E3A:  CALL   38BA
07E3E:  MOVF   01,F
07E40:  BZ    7E76
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
07E42:  MOVLW  02
07E44:  MOVLB  3
07E46:  MOVWF  x30
07E48:  MOVLW  79
07E4A:  MOVWF  x2F
07E4C:  CLRF   x31
07E4E:  MOVLW  02
07E50:  MOVWF  x33
07E52:  MOVLW  85
07E54:  MOVWF  x32
07E56:  MOVFF  283,334
07E5A:  MOVFF  2C6,336
07E5E:  MOVFF  2C5,335
07E62:  MOVFF  2C8,338
07E66:  MOVFF  2C7,337
07E6A:  MOVLB  0
07E6C:  GOTO   4BBE
....................  
.................... //                debug_stack("\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
07E70:  MOVLB  2
07E72:  CLRF   x78
07E74:  MOVLB  0
....................             } 
....................             break; 
07E76:  MOVLB  2
07E78:  BRA    7E7C
07E7A:  MOVLB  2
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
07E7C:  MOVLB  3
07E7E:  BTFSC  x2E.0
07E80:  BRA    7CC2
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
07E82:  MOVLB  0
07E84:  GOTO   4CD4
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
07E88:  GOTO   7028
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
07E8C:  GOTO   8046 (RETURN)
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
....................  
....................     if ( DHCPIsBound() ) 
....................         AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
....................  
....................  
.................... } 
....................  
.................... #if defined(__PCH__) 
....................    #define GetSystemClock()       getenv("CLOCK") 
....................    #define GetInstructionClock()  (GetSystemClock()/4) 
....................    #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... #else 
....................    #define GetSystemClock()       getenv("CLOCK") 
....................    #define GetInstructionClock()  (GetSystemClock()/2) 
....................    #define GetPeripheralClock()   (GetSystemClock()/2) 
.................... #endif 
....................  
.................... #define MIN(a,b)  ((a > b) ? b : a) 
....................  
.................... #define RX_BUFFER_SIZE  27 
.................... char Rx_Buffer[RX_BUFFER_SIZE+1]; 
.................... char Rx_Buffer2[RX_BUFFER_SIZE+1]; 
.................... int8 RX_Wr_Index=0; 
.................... int8 Dato2=0,Inicio=0,Dato_Exitoso=0,i=0,z=0,cont=0,n=0; 
.................... int8 IP[4]={0,0,0,0}; 
.................... int8 Gateway[4]={0,0,0,0}; 
.................... int8 Subnet[4]={0,0,0,0}; 
.................... int8 MAC[6]={0,0x04,0xA3,0x06,0x07,0}; 
....................  
.................... #include "pages.h" 
.................... /*********************  PAGINA WEB A MOSTRAR **********************************/ 
.................... /* Pgina principal INDEX (/) */ 
.................... const char  HTML_INDEX_PAGE[]=" 
....................    <html> 
.................... <head> 
.................... <meta http-equiv=\"refresh\"content=\"20;url=\"> 
.................... <title>JPInglobal Datos Ethernet</title> 
.................... </head> 
....................  
.................... <body style=\"background:#ffffff\">  
....................  
.................... <div style=\"background:#4383d3\" align=\"center\"> 
....................  
....................    <img src=\"https://jpinglobal.com/images/ando_sistema/Logo-JP_2019-05.png\" alt=\"Logo JPInglobal\" align=\"center\" width=\"567\" height=\"189\"> 
.................... </div> 
....................  
.................... <hr size=\"8px\" color=\"#4383d3\"> 
....................  
.................... <div style=\"background:#E1F6FF\" align=\"center\"> 
....................  
....................    <h2 align=\"center\"> Visualizacin de datos</h2> 
....................    <TABLE BORDER=0> 
....................       <TR> 
....................     <TD> <img src=\"https://w7.pngwing.com/pngs/2/237/png-transparent-computer-icons-thermometer-temperature-business-celsius-themometer-measurement-business-temperature-measurement.png\" alt=\"Temperatura\" align=\"center\" width=\"92\" height=\"51\"> </TD> 
....................          <TH>Temperatura:</TH> 
....................          <TD id=\"dyn0\">%0</TD>          
....................       </TR> 
....................       <TR> 
....................     <TD> <img src=\"https://w7.pngwing.com/pngs/2/237/png-transparent-computer-icons-thermometer-temperature-business-celsius-themometer-measurement-business-temperature-measurement.png\" alt=\"Temperatura\" align=\"center\" width=\"92\" height=\"51\"> </TD> 
....................          <TH>Temperatura2:</TH> 
....................          <TD id=\"dyn1\">%1</TD>          
....................       </TR> 
....................       <TR>  
....................     <TD> <img src=\"https://w7.pngwing.com/pngs/762/351/png-transparent-humidity-computer-icons-climate-moisture-humid-angle-cloud-meteorology.png\" alt=\"Humedad\" align=\"center\" width=\"92\" height=\"51\"></TD> 
....................          <TH>Humedad:</TH> 
....................          <TD id=\"dyn2\">%2</TD> 
....................       </TR>       
....................       <TR> 
....................     <TD> <img src=\"https://w7.pngwing.com/pngs/493/958/png-transparent-symbol-logo-computer-icons-time-symbol-miscellaneous-angle-logo.png\" alt=\"Tiempo\" align=\"center\" width=\"92\" height=\"51\"> </TD> 
....................     <TH> Fecha: </TH> 
....................     <TD id=\"HoraActual\"> </TD> 
....................       </TR> 
....................    </TABLE> 
....................  
....................  
....................    <BR/> 
.................... </div> 
....................  
....................  
.................... </body> 
....................  
.................... <script type=\"text/javascript\"> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  AJAX routines for rx/tx of data without having to reload page. //// 
.................... ////                                                                 //// 
.................... ////  Written by CCS, Inc.                    http://www.ccsinfo.com //// 
.................... ////                                                                 //// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.                                                     //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... var ajaxGet; 
.................... var t; 
.................... var waiting = 0; 
.................... var tValid = 0; 
.................... var nextCgi = \"\"; 
.................... var lastCgi = \"\"; 
.................... var ios6workaround = 0; 
....................  
.................... function setStartTime() 
.................... { 
....................    tValid = 1; 
....................    t = setTimeout(\'ajax()\', 500); 
.................... } 
....................  
.................... function ajax() 
.................... { 
....................    if (waiting) 
....................    { 
....................       waiting--; 
....................       if (waiting == 0) 
....................       { 
....................          if (lastCgi != \"\") 
....................          { 
....................             if (nextCgi == \"\") 
....................                nextCgi = lastCgi; 
....................             else 
....................                nextCgi = lastCgi + \"&\" + nextCgi; 
....................          } 
....................       } 
....................    } 
....................  
....................    if (!waiting) 
....................    { 
....................       ajaxGet=GetXmlHttpObject(); 
....................  
....................       if (ajaxGet==null) 
....................       { 
....................          alert (\"Your browser does not support AJAX!\"); 
....................          return; 
....................       } 
....................  
....................       waiting = 5;  //wait 2.5 seconds for a response 
....................  
....................       ajaxGet.open(\"POST\", \"index.xml\", true); 
....................  
....................       ajaxGet.onreadystatechange = stateChanged; 
....................  
....................       if (nextCgi != \"\") 
....................       { 
....................          ajaxGet.send(nextCgi); 
....................          lastCgi = nextCgi; 
....................          nextCgi = \"\"; 
....................       } 
....................       else 
....................       { 
....................          ajaxGet.send(\"IGNOREDTAG=\"+ios6workaround); 
....................  
....................          if (++ios6workaround > 255) 
....................             ios6workaround = 0; 
....................       } 
....................    } 
....................  
....................    setStartTime(); 
.................... } 
....................  
.................... function sendCgi(cmd, value) 
.................... { 
....................    if (nextCgi != \"\") 
....................       nextCgi += \"&\"; 
....................  
....................    nextCgi += cmd + \"=\" + value; 
.................... } 
....................  
.................... function GetElementNodeValue(xmlDoc, id) 
.................... { 
....................    return xmlDoc.getElementsByTagName(id)[0].childNodes[0].nodeValue; 
.................... } 
....................  
.................... function GetElementAttributeValue(xmlDoc, element, attribute) 
.................... { 
....................    var n; 
....................    var i; 
....................  
....................    n = xmlDoc.getElementsByTagName(element)[0].attributes.length; 
....................  
....................    for (i=0; i<n; i++) 
....................    { 
....................       if (xmlDoc.getElementsByTagName(element)[0].attributes[i].name == attribute) 
....................       { 
....................          return xmlDoc.getElementsByTagName(element)[0].attributes[i].value; 
....................       } 
....................    } 
....................  
....................    return ""; 
.................... } 
....................  
.................... function UpdateExistingTable(xmlDoc) 
.................... { 
....................    var i = 0; 
....................  
....................    for(;;) 
....................    { 
....................       var id = \"dyn\"+i; 
....................       i++; 
....................       if (document.getElementById(id)) 
....................       {          
....................          document.getElementById(id).innerHTML = GetElementNodeValue(xmlDoc, id); 
....................       } 
....................       else{ 
....................          break; 
....................       } 
....................    } 
.................... } 
....................  
.................... function stateChanged() 
.................... { 
....................    if (ajaxGet.readyState==4) 
....................    { 
....................       UpdateExistingTable(ajaxGet.responseXML.documentElement); 
....................  
....................       waiting = 0; 
....................   } 
.................... } 
....................  
.................... function GetXmlHttpObject() 
.................... { 
....................    if (window.XMLHttpRequest) 
....................    { 
....................       // code for IE7+, Firefox, Chrome, Opera, Safari 
....................       return new XMLHttpRequest(); 
....................    } 
....................    if (window.ActiveXObject) 
....................    { 
....................       // code for IE6, IE5 
....................       return new ActiveXObject(\"Microsoft.XMLHTTP\"); 
....................    } 
....................    return null; 
.................... } 
....................  
.................... showTime(); 
....................  
.................... function showTime(){ 
....................    myDate = new Date(); 
....................    //document.write(myDate); 
....................    //myDate.toUTCString(); 
....................    //document.getElementById(\"HoraActual\").innerHTML = myDate.toUTCString(); 
....................    hours = myDate.getHours(); 
....................    minutes = myDate.getMinutes(); 
....................    seconds = myDate.getSeconds(); 
....................    if (hours < 10) hours = 0 + hours; 
....................    if (minutes < 10) minutes = \"0\" + minutes; 
....................    if (seconds < 10) seconds = \"0\" + seconds; 
....................    //$(\"#HoraActual\").text(hours+ \":\" +minutes+ \":\" +seconds); 
....................    document.getElementById(\"HoraActual\").innerHTML=myDate.toUTCString(); 
....................    setTimeout(\"showTime()\", 1000);    
....................    setTimeout(\"UpdateExistingTable()\", 1000);   
....................  
.................... } 
....................  
.................... </script> 
....................  
.................... </html> 
.................... "; 
....................  
....................  
.................... #int_rda 
.................... void serial_rx_isr(){ 
....................  
....................    Dato2=fgetc(); 
*
019BC:  BRA    19A4
019BE:  MOVFF  01,302
....................    if(Dato2==0x65){//Inicio Comunicacion 
019C2:  MOVLB  3
019C4:  MOVF   x02,W
019C6:  SUBLW  65
019C8:  BNZ   19D0
....................       Inicio=1; 
019CA:  MOVLW  01
019CC:  MOVWF  x03
....................       RX_Wr_Index =0; 
019CE:  CLRF   x01
....................    } 
....................    //Inicio=1; 
....................    if(Inicio==1){ 
019D0:  DECFSZ x03,W
019D2:  BRA    19E8
....................       Rx_Buffer2[RX_Wr_Index] = Dato2; 
019D4:  CLRF   03
019D6:  MOVF   x01,W
019D8:  ADDLW  E5
019DA:  MOVWF  FE9
019DC:  MOVLW  02
019DE:  ADDWFC 03,W
019E0:  MOVWF  FEA
019E2:  MOVFF  302,FEF
....................       RX_Wr_Index++; 
019E6:  INCF   x01,F
....................    } 
....................    if(RX_Wr_Index >= RX_BUFFER_SIZE){ 
019E8:  MOVF   x01,W
019EA:  SUBLW  1A
019EC:  BC    19F2
....................       RX_Wr_Index =0; 
019EE:  CLRF   x01
....................       Inicio=0; 
019F0:  CLRF   x03
....................    } 
....................  
....................    if(RX_Wr_Index==0){ 
019F2:  MOVF   x01,F
019F4:  BNZ   1A1A
....................       if(Rx_Buffer2[0]==0x65 && Rx_Buffer2[1]==0xff && Rx_Buffer2[9]==0x00 && Rx_Buffer2[10]==0xff ){ 
019F6:  MOVLB  2
019F8:  MOVF   xE5,W
019FA:  SUBLW  65
019FC:  BNZ   1A14
019FE:  INCFSZ xE6,W
01A00:  BRA    1A14
01A02:  MOVF   xEE,F
01A04:  BNZ   1A14
01A06:  INCFSZ xEF,W
01A08:  BRA    1A14
....................          Dato_Exitoso=5; 
01A0A:  MOVLW  05
01A0C:  MOVLB  3
01A0E:  MOVWF  x04
....................       }else{ 
01A10:  BRA    1A1A
01A12:  MOVLB  2
....................          Dato_Exitoso=10; 
01A14:  MOVLW  0A
01A16:  MOVLB  3
01A18:  MOVWF  x04
....................       } 
....................    } 
....................    //output_toggle(PIN_C0); 
01A1A:  BCF    F9E.5
01A1C:  MOVLB  0
01A1E:  GOTO   0074
.................... } 
....................  
.................... void LeeDisplay(void){     
....................     if(Dato_Exitoso==5){ 
*
07ECE:  MOVLB  3
07ED0:  MOVF   x04,W
07ED2:  SUBLW  05
07ED4:  BNZ   7F1A
....................       for(i=0;i<27;i++){ 
07ED6:  CLRF   x05
07ED8:  MOVF   x05,W
07EDA:  SUBLW  1A
07EDC:  BNC   7F10
....................          Rx_Buffer[i]=Rx_Buffer2[i]; 
07EDE:  CLRF   03
07EE0:  MOVF   x05,W
07EE2:  ADDLW  C9
07EE4:  MOVWF  01
07EE6:  MOVLW  02
07EE8:  ADDWFC 03,F
07EEA:  MOVFF  03,32A
07EEE:  CLRF   03
07EF0:  MOVF   x05,W
07EF2:  ADDLW  E5
07EF4:  MOVWF  FE9
07EF6:  MOVLW  02
07EF8:  ADDWFC 03,W
07EFA:  MOVWF  FEA
07EFC:  MOVFF  FEF,32B
07F00:  MOVFF  32A,FEA
07F04:  MOVFF  01,FE9
07F08:  MOVFF  32B,FEF
07F0C:  INCF   x05,F
07F0E:  BRA    7ED8
....................       } 
....................           
....................       if(Rx_Buffer[3]==0x01){// Pregunta por la pagina en la que esta el display,01 es Contrasea de Acceso 
07F10:  MOVLB  2
07F12:  DECFSZ xCC,W
07F14:  BRA    7F16
....................       } 
....................    }else{ 
07F16:  BRA    7F28
07F18:  MOVLB  3
....................       for(z=0;z<RX_BUFFER_SIZE;z++){ 
07F1A:  CLRF   x06
07F1C:  MOVF   x06,W
07F1E:  SUBLW  1A
07F20:  BNC   7F26
07F22:  INCF   x06,F
07F24:  BRA    7F1C
07F26:  MOVLB  2
....................             //Rx_Buffer[z]=0; 
....................             //Rx_Buffer2[z]=0; 
....................          } 
....................    } 
07F28:  MOVLB  0
07F2A:  GOTO   8048 (RETURN)
.................... } 
....................  
.................... void MACAddrInit(void) { 
....................    MY_MAC_BYTE1=0; 
*
01A4A:  CLRF   23
....................    MY_MAC_BYTE2=0x04; 
01A4C:  MOVLW  04
01A4E:  MOVWF  24
....................    MY_MAC_BYTE3=0xA3; 
01A50:  MOVLW  A3
01A52:  MOVWF  25
....................    MY_MAC_BYTE4=0x06; 
01A54:  MOVLW  06
01A56:  MOVWF  26
....................    MY_MAC_BYTE5=0x07; 
01A58:  MOVLW  07
01A5A:  MOVWF  27
....................    MY_MAC_BYTE6=0x08; 
01A5C:  MOVLW  08
01A5E:  MOVWF  28
01A60:  GOTO   802E (RETURN)
.................... } 
....................  
.................... void IPAddrInit(void) { 
....................    //Eleccin de la direccin IP.  
....................    MY_IP_BYTE1=192; 
01A64:  MOVLW  C0
01A66:  MOVWF  1F
....................    MY_IP_BYTE2=168; 
01A68:  MOVLW  A8
01A6A:  MOVWF  20
....................    MY_IP_BYTE3=0; 
01A6C:  CLRF   21
....................    MY_IP_BYTE4=118; 
01A6E:  MOVLW  76
01A70:  MOVWF  22
....................  
....................    //Eleccin de la direccin de puerta de enlace.  
....................    MY_GATE_BYTE1=192; 
01A72:  MOVLW  C0
01A74:  MOVWF  2D
....................    MY_GATE_BYTE2=168; 
01A76:  MOVLW  A8
01A78:  MOVWF  2E
....................    MY_GATE_BYTE3=0; 
01A7A:  CLRF   2F
....................    MY_GATE_BYTE4=1; 
01A7C:  MOVLW  01
01A7E:  MOVWF  30
....................  
....................    //Eleccin de la mscara de red.Si no se indica nada se tomar 255.255.255.0 
....................    MY_MASK_BYTE1=255; 
01A80:  SETF   29
....................    MY_MASK_BYTE2=255; 
01A82:  SETF   2A
....................    MY_MASK_BYTE3=255; 
01A84:  SETF   2B
....................    MY_MASK_BYTE4=0; 
01A86:  CLRF   2C
01A88:  GOTO   8032 (RETURN)
.................... } 
....................  
.................... /* 
.................... void MACAddrInit(void) { 
....................    MY_MAC_BYTE1=MAC[0]; 
....................    MY_MAC_BYTE2=MAC[1]; 
....................    MY_MAC_BYTE3=MAC[2]; 
....................    MY_MAC_BYTE4=MAC[3]; 
....................    MY_MAC_BYTE5=MAC[4]; 
....................    MY_MAC_BYTE6=MAC[5]; 
.................... } 
....................  
.................... void IPAddrInit(void) { 
....................    //Eleccin de la direccin IP.  
....................    MY_IP_BYTE1=IP[0]; 
....................    MY_IP_BYTE2=IP[1]; 
....................    MY_IP_BYTE3=IP[2]; 
....................    MY_IP_BYTE4=IP[3]; 
....................  
....................    //Eleccin de la direccin de puerta de enlace.  
....................    MY_GATE_BYTE1=IP[0]; 
....................    MY_GATE_BYTE2=IP[1]; 
....................    MY_GATE_BYTE3=IP[2]; 
....................    MY_GATE_BYTE4=Gateway[0]; 
....................  
....................    //Eleccin de la mscara de red.Si no se indica nada se tomar 255.255.255.0 
....................    MY_MASK_BYTE1=Subnet[0]; 
....................    MY_MASK_BYTE2=Subnet[1]; 
....................    MY_MASK_BYTE3=Subnet[2]; 
....................    MY_MASK_BYTE4=Subnet[3]; 
.................... } 
.................... */ 
....................  
.................... /***************************  FUNCIN GET PAGE   ******************************/ 
.................... /* Esta funcin devuelve la posicin de memoria donde se encuentra la pgina web  
.................... a mostrar. En este caso se trata de una web con 2 pginas. Una principal index(/)  
.................... y una secundaria(/lecturas)                                                   */ 
....................  
.................... int32 http_get_page(char *file_str) { 
*
05BFA:  MOVLB  3
05BFC:  CLRF   x3E
05BFE:  CLRF   x3D
05C00:  CLRF   x3C
05C02:  CLRF   x3B
....................    int32 file_loc=0; 
....................    static char index[]="/"; 
....................    static char lecturas[]="/lecturas"; 
....................  
....................    /* Busca la posicin de memoria donde se encuentra la pgina solicitada */ 
....................    if (stricmp(file_str,index)==0)                 //Si es la principal... 
05C04:  MOVFF  33A,340
05C08:  MOVFF  339,33F
05C0C:  MOVLW  03
05C0E:  MOVWF  x42
05C10:  MOVLW  1B
05C12:  MOVWF  x41
05C14:  MOVLB  0
05C16:  BRA    5AF0
05C18:  MOVF   01,F
05C1A:  BNZ   5C38
....................       file_loc=label_address(HTML_INDEX_PAGE);     //...toma su posicin en la memoria 
05C1C:  MOVLW  00
05C1E:  MOVWF  02
05C20:  MOVLW  01
05C22:  MOVWF  01
05C24:  MOVLW  B0
05C26:  CLRF   03
05C28:  MOVFF  03,33E
05C2C:  MOVFF  02,33D
05C30:  MOVFF  01,33C
05C34:  MOVFF  FE8,33B
....................    //else if (stricmp(file_str,lecturas)==0)            //O si es la secundaria... 
....................      // file_loc=label_address(HTML_LECTURAS_PAGE);    //...toma su posicin en la memoria 
....................  
....................     
....................    /* Devuelve la posicin en la memoria donde se encuentra la pgina a mostrar */ 
....................    return(file_loc);                            
05C38:  MOVFF  33B,00
05C3C:  MOVFF  33C,01
05C40:  MOVFF  33D,02
05C44:  MOVFF  33E,03
05C48:  GOTO   73E2 (RETURN)
.................... } 
....................  
.................... /**************************  FUNCIN FORMAT CHAR  *****************************/ 
.................... /* Con  la funcin http_format_char  interconectamos las variables virtuales de  
.................... la pgina web con las variables del programa del PIC. Se encarga de enviar los  
.................... cambios producidos en la aplicacin del PIC y reflejarlos en la aplicacin web.  
.................... Muestra,por tanto, las lectura obtenidas por el PIC y las representa en la  
.................... aplicacin de la pgina web       
....................  
.................... %0 es la variable virtual para representar el valor de la lectura del canal  
.................... analgico 
.................... %1 es la variable virtual para representar el valor de la lectura del bit 0 del  
.................... puerto E. 
.................... */ 
.................... int8 http_format_char(char* file, char id, char *str, int8 max_ret) { 
*
069DA:  MOVLB  3
069DC:  CLRF   x8B
....................    char new_str[60]; 
....................    int8 len=0; 
....................     
....................    int8 RE0; 
....................  
....................    *str=0; 
069DE:  MOVFF  34C,FE9
069E2:  MOVFF  34D,FEA
069E6:  CLRF   FEF
....................  
....................    switch(id) { 
069E8:  MOVF   x4B,W
069EA:  XORLW  30
069EC:  MOVLB  0
069EE:  BZ    69FC
069F0:  XORLW  01
069F2:  BZ    6A6E
069F4:  XORLW  03
069F6:  BTFSC  FD8.2
069F8:  BRA    6AE0
069FA:  BRA    6B48
....................       case '0': 
....................          sprintf(new_str,"%02u.%01uC",Rx_Buffer[3],Rx_Buffer[4]); 
069FC:  MOVLW  03
069FE:  MOVLB  3
06A00:  MOVWF  x28
06A02:  MOVLW  4F
06A04:  MOVWF  x27
06A06:  MOVFF  2CC,38D
06A0A:  MOVLW  01
06A0C:  MOVWF  x8E
06A0E:  MOVLB  0
06A10:  RCALL  68E0
06A12:  MOVLW  2E
06A14:  MOVLB  3
06A16:  MOVWF  x8F
06A18:  MOVLB  0
06A1A:  RCALL  68C0
06A1C:  MOVFF  2CD,38D
06A20:  MOVLW  08
06A22:  MOVLB  3
06A24:  MOVWF  x8E
06A26:  MOVLB  0
06A28:  RCALL  68E0
06A2A:  MOVLW  B0
06A2C:  MOVLB  3
06A2E:  MOVWF  x8F
06A30:  MOVLB  0
06A32:  RCALL  68C0
06A34:  MOVLW  43
06A36:  MOVLB  3
06A38:  MOVWF  x8F
06A3A:  MOVLB  0
06A3C:  RCALL  68C0
....................          len=strlen(new_str); 
06A3E:  MOVLW  03
06A40:  MOVLB  3
06A42:  MOVWF  x8E
06A44:  MOVLW  4F
06A46:  MOVWF  x8D
06A48:  MOVLB  0
06A4A:  CALL   58F4
06A4E:  MOVFF  01,38B
....................          strncpy(str, new_str, max_ret); 
06A52:  MOVFF  34D,38E
06A56:  MOVFF  34C,38D
06A5A:  MOVLW  03
06A5C:  MOVLB  3
06A5E:  MOVWF  x90
06A60:  MOVLW  4F
06A62:  MOVWF  x8F
06A64:  MOVFF  34E,391
06A68:  MOVLB  0
06A6A:  RCALL  695C
....................       break; 
06A6C:  BRA    6B4E
....................       case '1': 
....................          sprintf(new_str,"%02u.%01uC",Rx_Buffer[5],Rx_Buffer[6]); 
06A6E:  MOVLW  03
06A70:  MOVLB  3
06A72:  MOVWF  x28
06A74:  MOVLW  4F
06A76:  MOVWF  x27
06A78:  MOVFF  2CE,38D
06A7C:  MOVLW  01
06A7E:  MOVWF  x8E
06A80:  MOVLB  0
06A82:  RCALL  68E0
06A84:  MOVLW  2E
06A86:  MOVLB  3
06A88:  MOVWF  x8F
06A8A:  MOVLB  0
06A8C:  RCALL  68C0
06A8E:  MOVFF  2CF,38D
06A92:  MOVLW  08
06A94:  MOVLB  3
06A96:  MOVWF  x8E
06A98:  MOVLB  0
06A9A:  RCALL  68E0
06A9C:  MOVLW  B0
06A9E:  MOVLB  3
06AA0:  MOVWF  x8F
06AA2:  MOVLB  0
06AA4:  RCALL  68C0
06AA6:  MOVLW  43
06AA8:  MOVLB  3
06AAA:  MOVWF  x8F
06AAC:  MOVLB  0
06AAE:  RCALL  68C0
....................          len=strlen(new_str); 
06AB0:  MOVLW  03
06AB2:  MOVLB  3
06AB4:  MOVWF  x8E
06AB6:  MOVLW  4F
06AB8:  MOVWF  x8D
06ABA:  MOVLB  0
06ABC:  CALL   58F4
06AC0:  MOVFF  01,38B
....................          strncpy(str, new_str, max_ret); 
06AC4:  MOVFF  34D,38E
06AC8:  MOVFF  34C,38D
06ACC:  MOVLW  03
06ACE:  MOVLB  3
06AD0:  MOVWF  x90
06AD2:  MOVLW  4F
06AD4:  MOVWF  x8F
06AD6:  MOVFF  34E,391
06ADA:  MOVLB  0
06ADC:  RCALL  695C
....................       break;   
06ADE:  BRA    6B4E
....................       case '2': 
....................          sprintf(new_str,"%02u.%01u%%",Rx_Buffer[7],Rx_Buffer[8]); 
06AE0:  MOVLW  03
06AE2:  MOVLB  3
06AE4:  MOVWF  x28
06AE6:  MOVLW  4F
06AE8:  MOVWF  x27
06AEA:  MOVFF  2D0,38D
06AEE:  MOVLW  01
06AF0:  MOVWF  x8E
06AF2:  MOVLB  0
06AF4:  RCALL  68E0
06AF6:  MOVLW  2E
06AF8:  MOVLB  3
06AFA:  MOVWF  x8F
06AFC:  MOVLB  0
06AFE:  RCALL  68C0
06B00:  MOVFF  2D1,38D
06B04:  MOVLW  08
06B06:  MOVLB  3
06B08:  MOVWF  x8E
06B0A:  MOVLB  0
06B0C:  RCALL  68E0
06B0E:  MOVLW  25
06B10:  MOVLB  3
06B12:  MOVWF  x8F
06B14:  MOVLB  0
06B16:  RCALL  68C0
....................          len=strlen(new_str); 
06B18:  MOVLW  03
06B1A:  MOVLB  3
06B1C:  MOVWF  x8E
06B1E:  MOVLW  4F
06B20:  MOVWF  x8D
06B22:  MOVLB  0
06B24:  CALL   58F4
06B28:  MOVFF  01,38B
....................          strncpy(str, new_str, max_ret); 
06B2C:  MOVFF  34D,38E
06B30:  MOVFF  34C,38D
06B34:  MOVLW  03
06B36:  MOVLB  3
06B38:  MOVWF  x90
06B3A:  MOVLW  4F
06B3C:  MOVWF  x8F
06B3E:  MOVFF  34E,391
06B42:  MOVLB  0
06B44:  RCALL  695C
....................       break;  /* 
06B46:  BRA    6B4E
....................       case '3': 
....................          sprintf(new_str,"%u.%u.%u.%u-%u.%u.%u.%u- %02u",Rx_Buffer[11],Rx_Buffer[12],Rx_Buffer[13],Rx_Buffer[14],Rx_Buffer[15],Rx_Buffer[16],Rx_Buffer[17],Rx_Buffer[18],n); 
....................          len=strlen(new_str); 
....................          strncpy(str, new_str, max_ret); 
....................       break;   
....................       case '4': 
....................          sprintf(new_str,"%02X.%02X.%02X.%02X.%02X.%02X",Rx_Buffer[20],Rx_Buffer[21],Rx_Buffer[22],Rx_Buffer[23],Rx_Buffer[24],Rx_Buffer[25]); 
....................          len=strlen(new_str); 
....................          strncpy(str, new_str, max_ret); 
....................       break;   
....................       */ 
....................       default: 
....................       len=0; 
06B48:  MOVLB  3
06B4A:  CLRF   x8B
06B4C:  MOVLB  0
....................    } 
....................  
....................    if (len)strncpy(str, new_str, max_ret); 
06B4E:  MOVLB  3
06B50:  MOVF   x8B,F
06B52:  BZ    6B70
06B54:  MOVFF  34D,38E
06B58:  MOVFF  34C,38D
06B5C:  MOVLW  03
06B5E:  MOVWF  x90
06B60:  MOVLW  4F
06B62:  MOVWF  x8F
06B64:  MOVFF  34E,391
06B68:  MOVLB  0
06B6A:  RCALL  695C
06B6C:  BRA    6B80
06B6E:  MOVLB  3
....................    else  *str=0; 
06B70:  MOVFF  34D,03
06B74:  MOVFF  34C,FE9
06B78:  MOVFF  34D,FEA
06B7C:  CLRF   FEF
06B7E:  MOVLB  0
....................     
....................    return(len); 
06B80:  MOVLB  3
06B82:  MOVFF  38B,01
06B86:  MOVLB  0
06B88:  GOTO   6E4A (RETURN)
.................... } 
....................  
.................... /***************************  FUNCIN EXEC CGI   ******************************/ 
.................... /* Con la funcin http_exec_cgi interconectamos las variables virtuales de la  
.................... pgina web con las variables del programa del PIC. Se encarga de recibir  
.................... los cambios producidos en la aplicacin web y reflejarlos en el hardware del PIC.  
.................... Ejecuta, por tanto, la accin elegida segn el valor de la variable virtual recibida  
.................... de la pgina web 
....................  
.................... key es la variable virtual que viene de la pagina web 
.................... val es el valor de una variable virtual de la pgina web 
.................... file es la direccin de la pgina web devuelta por http_get_page () 
....................  
.................... */ 
....................  
.................... void http_exec_cgi(int32 file, char *key, char *val) { 
*
05C4C:  GOTO   5CB6 (RETURN)
....................     
.................... } 
....................  
.................... /************************** FUNCIN PRINCIPAL *********************************/ 
.................... void main(void) { 
*
07F2E:  CLRF   FF8
07F30:  BCF    FF1.2
07F32:  BCF    F9F.5
07F34:  BSF    FD0.7
07F36:  BSF    07.7
07F38:  CLRF   17
07F3A:  BSF    FB8.3
07F3C:  MOVLW  08
07F3E:  MOVWF  FAF
07F40:  MOVLW  02
07F42:  MOVWF  FB0
07F44:  MOVLW  A6
07F46:  MOVWF  FAC
07F48:  MOVLW  90
07F4A:  MOVWF  FAB
07F4C:  CLRF   52
07F4E:  CLRF   51
07F50:  CLRF   53
07F52:  CLRF   54
07F54:  CLRF   5C
07F56:  CLRF   5B
07F58:  MOVLW  04
07F5A:  MOVWF  5F
07F5C:  CLRF   5E
07F5E:  MOVLB  3
07F60:  CLRF   x01
07F62:  CLRF   x02
07F64:  CLRF   x03
07F66:  CLRF   x04
07F68:  CLRF   x05
07F6A:  CLRF   x06
07F6C:  CLRF   x07
07F6E:  CLRF   x08
07F70:  CLRF   x28
07F72:  CLRF   x27
07F74:  MOVF   FC1,W
07F76:  ANDLW  C0
07F78:  IORLW  0F
07F7A:  MOVWF  FC1
07F7C:  MOVLW  07
07F7E:  MOVWF  FB4
07F80:  BCF    59.1
07F82:  BRA    7FDA
07F84:  DATA 02,00
07F86:  DATA 18,00
07F88:  DATA 00,01
07F8A:  DATA 00,5D
07F8C:  DATA 00,0A
07F8E:  DATA 41,16
07F90:  DATA 00,03
07F92:  DATA 80,FE
07F94:  DATA 00,01
07F96:  DATA 29,41
07F98:  DATA 2A,00
07F9A:  DATA 1C,80
07F9C:  DATA 20,00
07F9E:  DATA 3F,00
07FA0:  DATA 47,45
07FA2:  DATA 54,00
07FA4:  DATA 50,4F
07FA6:  DATA 53,54
07FA8:  DATA 00,43
07FAA:  DATA 6F,6E
07FAC:  DATA 74,65
07FAE:  DATA 6E,74
07FB0:  DATA 2D,4C
07FB2:  DATA 65,6E
07FB4:  DATA 67,74
07FB6:  DATA 68,3A
07FB8:  DATA FF,C0
07FBA:  DATA 00,0B
07FBC:  DATA C0,00
07FBE:  DATA 46,42
07FC0:  DATA 83,00
07FC2:  DATA 0D,43
07FC4:  DATA 09,00
07FC6:  DATA 11,80
07FC8:  DATA 04,A3
07FCA:  DATA 06,07
07FCC:  DATA 00,2F
07FCE:  DATA 00,2F
07FD0:  DATA 6C,65
07FD2:  DATA 63,74
07FD4:  DATA 75,72
07FD6:  DATA 61,73
07FD8:  DATA 00,00
07FDA:  MOVLW  00
07FDC:  MOVWF  FF8
07FDE:  MOVLW  7F
07FE0:  MOVWF  FF7
07FE2:  MOVLW  84
07FE4:  MOVWF  FF6
07FE6:  TBLRD*+
07FE8:  MOVF   FF5,W
07FEA:  MOVWF  00
07FEC:  XORLW  00
07FEE:  BZ    8016
07FF0:  TBLRD*+
07FF2:  MOVF   FF5,W
07FF4:  MOVWF  01
07FF6:  BTFSC  FE8.7
07FF8:  BRA    8004
07FFA:  ANDLW  0F
07FFC:  MOVWF  FEA
07FFE:  TBLRD*+
08000:  MOVFF  FF5,FE9
08004:  BTFSC  01.6
08006:  TBLRD*+
08008:  BTFSS  01.6
0800A:  TBLRD*+
0800C:  MOVFF  FF5,FEE
08010:  DCFSNZ 00,F
08012:  BRA    7FE6
08014:  BRA    8008
08016:  CLRF   FF8
....................    setup_wdt(WDT_ON); 
08018:  BSF    FD1.0
....................    enable_interrupts(INT_RDA); 
0801A:  BSF    F9D.5
....................    enable_interrupts(GLOBAL); 
0801C:  MOVLW  C0
0801E:  IORWF  FF2,F
....................    delay_ms(100); 
08020:  MOVLW  64
08022:  MOVWF  x2A
08024:  MOVLB  0
08026:  CALL   1A22
....................    /* Inicializacin del Stack */ 
....................    MACAddrInit(); //Se asigna la direccin MAC elegida  
0802A:  GOTO   1A4A
....................    IPAddrInit();  //Se asigna IP, mascara de red y puerta de enlace elegidos 
0802E:  GOTO   1A64
....................    StackInit();   //Inicializa el stack    
08032:  GOTO   235A
....................    delay_ms(10); 
08036:  MOVLW  0A
08038:  MOVLB  3
0803A:  MOVWF  x2A
0803C:  MOVLB  0
0803E:  CALL   1A22
....................  
....................    while(TRUE) { 
....................       restart_wdt(); 
08042:  CLRWDT
....................       StackTask(); 
08044:  BRA    7CBE
....................       LeeDisplay(); 
08046:  BRA    7ECE
....................  
....................       MY_IP_BYTE1=Rx_Buffer[11]; 
08048:  MOVFF  2D4,1F
....................       MY_IP_BYTE2=Rx_Buffer[12]; 
0804C:  MOVFF  2D5,20
....................       MY_IP_BYTE3=Rx_Buffer[13]; 
08050:  MOVFF  2D6,21
....................       MY_IP_BYTE4=Rx_Buffer[14]; 
08054:  MOVFF  2D7,22
....................  
....................       //Eleccin de la direccin de puerta de enlace.  
....................       MY_GATE_BYTE1=Rx_Buffer[11]; 
08058:  MOVFF  2D4,2D
....................       MY_GATE_BYTE2=Rx_Buffer[12]; 
0805C:  MOVFF  2D5,2E
....................       MY_GATE_BYTE3=Rx_Buffer[13]; 
08060:  MOVFF  2D6,2F
....................       MY_GATE_BYTE4=Rx_Buffer[19]; 
08064:  MOVFF  2DC,30
....................     
....................       //Eleccin de la mscara de red.Si no se indica nada se tomar 255.255.255.0 
....................       MY_MASK_BYTE1=Rx_Buffer[15]; 
08068:  MOVFF  2D8,29
....................       MY_MASK_BYTE2=Rx_Buffer[16]; 
0806C:  MOVFF  2D9,2A
....................       MY_MASK_BYTE3=Rx_Buffer[17]; 
08070:  MOVFF  2DA,2B
....................       MY_MASK_BYTE4=Rx_Buffer[18]; 
08074:  MOVFF  2DB,2C
08078:  BRA    8042
....................        
....................       //MY_MAC_BYTE1=Rx_Buffer[20]; 
....................       //MY_MAC_BYTE2=Rx_Buffer[21]; 
....................       //MY_MAC_BYTE3=Rx_Buffer[22]; 
....................       //MY_MAC_BYTE4=Rx_Buffer[23]; 
....................       //MY_MAC_BYTE5=Rx_Buffer[24]; 
....................       //MY_MAC_BYTE6=Rx_Buffer[25]; 
....................     } 
.................... } 
....................  
0807A:  SLEEP 

Configuration Fuses:
   Word  1: 0200   HS NOFCMEN NOIESO
   Word  2: 1908   PUT NOBROWNOUT BORV43 WDT WDT4096
   Word  3: 0000   NOPBADEN NOLPT1OSC NOMCLR
   Word  4: 00B0   NOSTVREN NOLVP NOXINST NODEBUG
   Word  5: C03F   NOPROTECT NOCPB NOCPD
   Word  6: E03F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 403F   NOEBTR NOEBTRB
