CCS PCH C Compiler, Version 5.015, 5967               27-jul.-22 09:57

               Filename:   D:\Laboratorio\Camara Climatica\2022\JPCCR108 Avantika #0045890XX OP2022177\Firmware Servidor V1.0.1\main.lst

               ROM used:   49836 bytes (51%)
                           Largest free fragment is 26196
               RAM used:   960 (29%) at main() level
                           1133 (34%) worst case
               Stack used: 15 locations (13 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   A7B8
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FFB,15
0003C:  MOVFF  00,0E
00040:  MOVFF  01,0F
00044:  MOVFF  02,10
00048:  MOVFF  03,11
0004C:  BTFSS  FF2.5
0004E:  GOTO   0058
00052:  BTFSC  FF2.2
00054:  GOTO   00C8
00058:  BTFSS  F9D.5
0005A:  GOTO   0064
0005E:  BTFSC  F9E.5
00060:  GOTO   0234
00064:  MOVFF  0E,00
00068:  MOVFF  0F,01
0006C:  MOVFF  10,02
00070:  MOVFF  11,03
00074:  MOVFF  0C,FE9
00078:  MOVFF  07,FEA
0007C:  BSF    07.7
0007E:  MOVFF  08,FE1
00082:  MOVFF  09,FE2
00086:  MOVFF  0A,FD9
0008A:  MOVFF  0B,FDA
0008E:  MOVFF  12,FF3
00092:  MOVFF  13,FF4
00096:  MOVFF  14,FFA
0009A:  MOVFF  15,FFB
0009E:  MOVF   04,W
000A0:  MOVFF  06,FE0
000A4:  MOVFF  05,FD8
000A8:  RETFIE 0
.................... #include <main.h> 
.................... #include <18F4685.h> 
.................... //////////// Standard Header file for the PIC18F4685 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4685 
*
000CE:  DATA 48,54
000D0:  DATA 54,50
000D2:  DATA 2F,31
000D4:  DATA 2E,31
000D6:  DATA 20,25
000D8:  DATA 4C,55
000DA:  DATA 20,00
000DC:  DATA 41,75
000DE:  DATA 74,68
000E0:  DATA 6F,72
000E2:  DATA 69,7A
000E4:  DATA 61,74
000E6:  DATA 69,6F
000E8:  DATA 6E,20
000EA:  DATA 52,65
000EC:  DATA 71,75
000EE:  DATA 69,72
000F0:  DATA 65,64
000F2:  DATA 00,00
000F4:  DATA 4E,6F
000F6:  DATA 74,20
000F8:  DATA 46,6F
000FA:  DATA 75,6E
000FC:  DATA 64,00
000FE:  DATA 53,65
00100:  DATA 72,76
00102:  DATA 65,72
00104:  DATA 20,45
00106:  DATA 72,72
00108:  DATA 6F,72
0010A:  DATA 00,00
0010C:  DATA 43,6F
0010E:  DATA 6E,74
00110:  DATA 65,6E
00112:  DATA 74,2D
00114:  DATA 54,79
00116:  DATA 70,65
00118:  DATA 3A,20
0011A:  DATA 00,00
0011C:  DATA 4C,61
0011E:  DATA 73,74
00120:  DATA 2D,4D
00122:  DATA 6F,64
00124:  DATA 69,66
00126:  DATA 69,65
00128:  DATA 64,3A
0012A:  DATA 20,54
0012C:  DATA 75,65
0012E:  DATA 2C,20
00130:  DATA 31,35
00132:  DATA 20,4E
00134:  DATA 6F,76
00136:  DATA 20,31
00138:  DATA 39,39
0013A:  DATA 34,20
0013C:  DATA 31,32
0013E:  DATA 3A,34
00140:  DATA 35,3A
00142:  DATA 32,36
00144:  DATA 20,47
00146:  DATA 4D,54
00148:  DATA 0D,0A
0014A:  DATA 00,00
0014C:  DATA 43,61
0014E:  DATA 63,68
00150:  DATA 65,2D
00152:  DATA 43,6F
00154:  DATA 6E,74
00156:  DATA 72,6F
00158:  DATA 6C,3A
0015A:  DATA 20,6E
0015C:  DATA 6F,2D
0015E:  DATA 63,61
00160:  DATA 63,68
00162:  DATA 65,0D
00164:  DATA 0A,00
00166:  DATA 43,6F
00168:  DATA 6E,6E
0016A:  DATA 65,63
0016C:  DATA 74,69
0016E:  DATA 6F,6E
00170:  DATA 3A,20
00172:  DATA 63,6C
00174:  DATA 6F,73
00176:  DATA 65,0D
00178:  DATA 0A,00
0017A:  DATA 65,72
0017C:  DATA 72,6F
0017E:  DATA 72,35
00180:  DATA 30,30
00182:  DATA 2E,68
00184:  DATA 74,6D
00186:  DATA 00,00
00188:  DATA 3C,68
0018A:  DATA 74,6D
0018C:  DATA 6C,3E
0018E:  DATA 3C,62
00190:  DATA 6F,64
00192:  DATA 79,3E
00194:  DATA 3C,68
00196:  DATA 31,3E
00198:  DATA 35,30
0019A:  DATA 30,20
0019C:  DATA 45,72
0019E:  DATA 72,6F
001A0:  DATA 72,3C
001A2:  DATA 2F,68
001A4:  DATA 31,3E
001A6:  DATA 3C,68
001A8:  DATA 72,3E
001AA:  DATA 3C,70
001AC:  DATA 3E,49
001AE:  DATA 6E,74
001B0:  DATA 65,72
001B2:  DATA 6E,61
001B4:  DATA 6C,20
001B6:  DATA 73,65
001B8:  DATA 72,76
001BA:  DATA 65,72
001BC:  DATA 20,65
001BE:  DATA 72,72
001C0:  DATA 6F,72
001C2:  DATA 2E,3C
001C4:  DATA 2F,70
001C6:  DATA 3E,3C
001C8:  DATA 2F,62
001CA:  DATA 6F,64
001CC:  DATA 79,3E
001CE:  DATA 3C,2F
001D0:  DATA 68,74
001D2:  DATA 6D,6C
001D4:  DATA 3E,00
001D6:  DATA 69,6E
001D8:  DATA 64,65
001DA:  DATA 78,2E
001DC:  DATA 68,74
001DE:  DATA 6D,00
001E0:  DATA 65,72
001E2:  DATA 72,6F
001E4:  DATA 72,34
001E6:  DATA 30,34
001E8:  DATA 2E,68
001EA:  DATA 74,6D
001EC:  DATA 00,00
001EE:  DATA 65,72
001F0:  DATA 72,6F
001F2:  DATA 72,35
001F4:  DATA 30,30
001F6:  DATA 2E,68
001F8:  DATA 74,6D
001FA:  DATA 00,00
001FC:  DATA 65,72
001FE:  DATA 72,6F
00200:  DATA 72,35
00202:  DATA 30,30
00204:  DATA 2E,68
00206:  DATA 74,6D
00208:  DATA 00,00
0020A:  DATA 65,72
0020C:  DATA 72,6F
0020E:  DATA 72,35
00210:  DATA 30,30
00212:  DATA 2E,68
00214:  DATA 74,6D
00216:  DATA 00,00
*
00A30:  TSTFSZ 01
00A32:  BRA    0A3A
00A34:  TSTFSZ 02
00A36:  BRA    0A3C
00A38:  BRA    0A48
00A3A:  INCF   02,F
00A3C:  MOVFF  00,FEE
00A40:  DECFSZ 01,F
00A42:  BRA    0A3C
00A44:  DECFSZ 02,F
00A46:  BRA    0A3C
00A48:  RETURN 0
*
01838:  MOVLB  4
0183A:  CLRF   x2C
0183C:  CLRF   x2D
0183E:  MOVLW  01
01840:  MOVWF  x2E
01842:  CLRF   FDA
01844:  CLRF   FD9
01846:  MOVLW  04
01848:  MOVWF  x31
0184A:  MOVLW  24
0184C:  MOVWF  x30
0184E:  MOVLW  04
01850:  MOVWF  FEA
01852:  MOVLW  28
01854:  MOVWF  FE9
01856:  MOVFF  431,FE2
0185A:  MOVFF  430,FE1
0185E:  MOVFF  42E,42F
01862:  BCF    FD8.0
01864:  MOVF   FE5,W
01866:  MULWF  FEE
01868:  MOVF   FF3,W
0186A:  ADDWFC x2C,F
0186C:  MOVF   FF4,W
0186E:  ADDWFC x2D,F
01870:  DECFSZ x2F,F
01872:  BRA    1862
01874:  MOVFF  42C,FDE
01878:  MOVFF  42D,42C
0187C:  CLRF   x2D
0187E:  BTFSC  FD8.0
01880:  INCF   x2D,F
01882:  INCF   x30,F
01884:  BTFSC  FD8.2
01886:  INCF   x31,F
01888:  INCF   x2E,F
0188A:  MOVF   x2E,W
0188C:  SUBLW  05
0188E:  BNZ   184E
01890:  MOVLB  0
01892:  RETURN 0
01894:  CLRF   01
01896:  CLRF   02
01898:  CLRF   00
0189A:  CLRF   03
0189C:  MOVLB  3
0189E:  MOVF   xD9,W
018A0:  BNZ   18A6
018A2:  MOVF   xD8,W
018A4:  BZ    18D6
018A6:  MOVLW  10
018A8:  MOVWF  xDA
018AA:  BCF    FD8.0
018AC:  RLCF   xD6,F
018AE:  RLCF   xD7,F
018B0:  RLCF   00,F
018B2:  RLCF   03,F
018B4:  MOVF   xD9,W
018B6:  SUBWF  03,W
018B8:  BNZ   18BE
018BA:  MOVF   xD8,W
018BC:  SUBWF  00,W
018BE:  BNC   18CE
018C0:  MOVF   xD8,W
018C2:  SUBWF  00,F
018C4:  BTFSS  FD8.0
018C6:  DECF   03,F
018C8:  MOVF   xD9,W
018CA:  SUBWF  03,F
018CC:  BSF    FD8.0
018CE:  RLCF   01,F
018D0:  RLCF   02,F
018D2:  DECFSZ xDA,F
018D4:  BRA    18AA
018D6:  MOVLB  0
018D8:  GOTO   1942 (RETURN)
*
02F82:  MOVFF  FF2,0D
02F86:  BCF    FF2.7
02F88:  ADDWF  FE8,W
02F8A:  CLRF   FF7
02F8C:  RLCF   FF7,F
02F8E:  ADDLW  AD
02F90:  MOVWF  FF6
02F92:  MOVLW  2F
02F94:  ADDWFC FF7,F
02F96:  MOVLW  00
02F98:  MOVWF  FF8
02F9A:  MOVWF  FFB
02F9C:  TBLRD*-
02F9E:  MOVF   FF5,W
02FA0:  MOVWF  FFA
02FA2:  TBLRD*
02FA4:  MOVF   FF5,W
02FA6:  BTFSC  0D.7
02FA8:  BSF    FF2.7
02FAA:  MOVWF  FF9
02FAC:  DATA 9C,2A
02FAE:  DATA A0,2A
02FB0:  DATA D0,2A
02FB2:  DATA 84,2B
02FB4:  DATA 18,2C
02FB6:  DATA 9C,2C
02FB8:  DATA 9E,2D
02FBA:  DATA 50,2E
02FBC:  DATA A4,2E
02FBE:  DATA 50,2E
02FC0:  DATA A4,2E
02FC2:  DATA 50,2E
02FC4:  DATA A4,2E
*
02FFC:  MOVLB  3
02FFE:  MOVF   xFE,W
03000:  MOVLB  4
03002:  MULWF  x00
03004:  MOVFF  FF3,01
03008:  MOVFF  FF4,00
0300C:  MULWF  x01
0300E:  MOVF   FF3,W
03010:  ADDWF  00,F
03012:  MOVLB  3
03014:  MOVF   xFF,W
03016:  MOVLB  4
03018:  MULWF  x00
0301A:  MOVF   FF3,W
0301C:  ADDWFC 00,W
0301E:  MOVWF  02
03020:  MOVLB  0
03022:  RETURN 0
*
078E4:  MOVFF  345,FEA
078E8:  MOVFF  344,FE9
078EC:  MOVLB  4
078EE:  MOVFF  403,FEF
078F2:  INCF   FE9,F
078F4:  BTFSC  FD8.2
078F6:  INCF   FEA,F
078F8:  CLRF   FEF
078FA:  MOVLB  3
078FC:  INCF   x44,F
078FE:  BTFSC  FD8.2
07900:  INCF   x45,F
07902:  MOVLB  0
07904:  RETURN 0
07906:  TBLRD*+
07908:  MOVF   FF5,F
0790A:  BZ    792C
0790C:  MOVFF  FF6,3E2
07910:  MOVFF  FF7,3E3
07914:  MOVFF  FF8,3E4
07918:  MOVFF  FF5,403
0791C:  RCALL  78E4
0791E:  MOVFF  3E2,FF6
07922:  MOVFF  3E3,FF7
07926:  MOVFF  3E4,FF8
0792A:  BRA    7906
0792C:  RETURN 0
*
079B2:  MOVFF  40F,01
079B6:  MOVFF  40E,00
079BA:  TSTFSZ 00
079BC:  INCF   01,F
079BE:  TBLRD*+
079C0:  MOVFF  FF5,FEE
079C4:  DECFSZ 00,F
079C6:  BRA    79BE
079C8:  DECFSZ 01,F
079CA:  BRA    79BE
079CC:  CLRF   FF8
079CE:  GOTO   79F6 (RETURN)
*
08518:  TBLRD*+
0851A:  MOVFF  FF6,3E3
0851E:  MOVFF  FF7,3E4
08522:  MOVFF  FF8,3E5
08526:  MOVFF  FF5,3F7
0852A:  RCALL  8506
0852C:  MOVFF  3E3,FF6
08530:  MOVFF  3E4,FF7
08534:  MOVFF  3E5,FF8
08538:  MOVLB  3
0853A:  DECFSZ xE2,F
0853C:  BRA    8540
0853E:  BRA    8544
08540:  MOVLB  0
08542:  BRA    8518
08544:  MOVLB  0
08546:  GOTO   9414 (RETURN)
0854A:  MOVFF  FEA,3EA
0854E:  MOVFF  FE9,3E9
08552:  MOVLB  3
08554:  SWAPF  xE3,W
08556:  IORLW  F0
08558:  MOVWF  xE5
0855A:  ADDWF  xE5,F
0855C:  ADDLW  E2
0855E:  MOVWF  xE6
08560:  ADDLW  32
08562:  MOVWF  xE8
08564:  MOVF   xE3,W
08566:  ANDLW  0F
08568:  ADDWF  xE6,F
0856A:  ADDWF  xE6,F
0856C:  ADDWF  xE8,F
0856E:  ADDLW  E9
08570:  MOVWF  xE7
08572:  ADDWF  xE7,F
08574:  ADDWF  xE7,F
08576:  SWAPF  xE2,W
08578:  ANDLW  0F
0857A:  ADDWF  xE7,F
0857C:  ADDWF  xE8,F
0857E:  RLCF   xE7,F
08580:  RLCF   xE8,F
08582:  COMF   xE8,F
08584:  RLCF   xE8,F
08586:  MOVF   xE2,W
08588:  ANDLW  0F
0858A:  ADDWF  xE8,F
0858C:  RLCF   xE5,F
0858E:  MOVLW  07
08590:  MOVWF  xE4
08592:  MOVLW  0A
08594:  DECF   xE7,F
08596:  ADDWF  xE8,F
08598:  BNC   8594
0859A:  DECF   xE6,F
0859C:  ADDWF  xE7,F
0859E:  BNC   859A
085A0:  DECF   xE5,F
085A2:  ADDWF  xE6,F
085A4:  BNC   85A0
085A6:  DECF   xE4,F
085A8:  ADDWF  xE5,F
085AA:  BNC   85A6
085AC:  MOVLW  03
085AE:  MOVWF  FEA
085B0:  MOVLW  E4
085B2:  MOVWF  FE9
085B4:  MOVLW  07
085B6:  ANDWF  xE9,W
085B8:  BCF    xE9.6
085BA:  ADDWF  FE9,F
085BC:  MOVLW  00
085BE:  ADDWFC FEA,F
085C0:  MOVF   FE9,W
085C2:  SUBLW  E8
085C4:  BNZ   85CE
085C6:  MOVF   FEA,W
085C8:  SUBLW  03
085CA:  BNZ   85CE
085CC:  BSF    xE9.6
085CE:  MOVF   FEF,W
085D0:  MOVWF  00
085D2:  BNZ   85E4
085D4:  BTFSC  xE9.6
085D6:  BRA    85E4
085D8:  BTFSC  xE9.4
085DA:  BRA    8606
085DC:  BTFSC  xE9.3
085DE:  BRA    85E4
085E0:  MOVLW  20
085E2:  BRA    85EA
085E4:  BSF    xE9.3
085E6:  BCF    xE9.4
085E8:  MOVLW  30
085EA:  ADDWF  00,F
085EC:  MOVFF  FEA,3E3
085F0:  MOVFF  FE9,3E2
085F4:  MOVFF  00,3F7
085F8:  MOVLB  0
085FA:  RCALL  8506
085FC:  MOVFF  3E3,FEA
08600:  MOVFF  3E2,FE9
08604:  MOVLB  3
08606:  MOVF   FEE,W
08608:  BTFSS  xE9.6
0860A:  BRA    85C0
0860C:  MOVLB  0
0860E:  GOTO   9424 (RETURN)
08612:  TBLRD*+
08614:  MOVF   FF5,F
08616:  BZ    8638
08618:  MOVFF  FF6,3E2
0861C:  MOVFF  FF7,3E3
08620:  MOVFF  FF8,3E4
08624:  MOVFF  FF5,3F7
08628:  RCALL  8506
0862A:  MOVFF  3E2,FF6
0862E:  MOVFF  3E3,FF7
08632:  MOVFF  3E4,FF8
08636:  BRA    8612
08638:  RETURN 0
0863A:  MOVF   FEF,F
0863C:  BZ    865C
0863E:  MOVFF  FEA,3E5
08642:  MOVFF  FE9,3E4
08646:  MOVFF  FEF,3F7
0864A:  RCALL  8506
0864C:  MOVFF  3E5,FEA
08650:  MOVFF  3E4,FE9
08654:  INCF   FE9,F
08656:  BTFSC  FD8.2
08658:  INCF   FEA,F
0865A:  BRA    863A
0865C:  GOTO   9590 (RETURN)
*
09120:  MOVLB  4
09122:  MOVF   x04,W
09124:  CLRF   01
09126:  SUBWF  x03,W
09128:  BC    9130
0912A:  MOVFF  403,00
0912E:  BRA    9148
09130:  CLRF   00
09132:  MOVLW  08
09134:  MOVWF  x05
09136:  RLCF   x03,F
09138:  RLCF   00,F
0913A:  MOVF   x04,W
0913C:  SUBWF  00,W
0913E:  BTFSC  FD8.0
09140:  MOVWF  00
09142:  RLCF   01,F
09144:  DECFSZ x05,F
09146:  BRA    9136
09148:  MOVLB  0
0914A:  RETURN 0
0914C:  MOVF   01,W
0914E:  MOVFF  401,403
09152:  MOVLW  64
09154:  MOVLB  4
09156:  MOVWF  x04
09158:  MOVLB  0
0915A:  RCALL  9120
0915C:  MOVFF  00,401
09160:  MOVF   01,W
09162:  MOVLW  30
09164:  BNZ   9176
09166:  MOVLB  4
09168:  BTFSS  x02.1
0916A:  BRA    918C
0916C:  BTFSC  x02.3
0916E:  BRA    918C
09170:  BTFSC  x02.4
09172:  MOVLW  20
09174:  BRA    917E
09176:  MOVLB  4
09178:  BCF    x02.3
0917A:  BCF    x02.4
0917C:  BSF    x02.0
0917E:  ADDWF  01,F
09180:  MOVFF  01,403
09184:  MOVLB  0
09186:  CALL   78E4
0918A:  MOVLB  4
0918C:  MOVFF  401,403
09190:  MOVLW  0A
09192:  MOVWF  x04
09194:  MOVLB  0
09196:  RCALL  9120
09198:  MOVFF  00,401
0919C:  MOVF   01,W
0919E:  MOVLW  30
091A0:  BNZ   91B2
091A2:  MOVLB  4
091A4:  BTFSC  x02.3
091A6:  BRA    91BE
091A8:  BTFSS  x02.0
091AA:  BRA    91BE
091AC:  BTFSC  x02.4
091AE:  MOVLW  20
091B0:  MOVLB  0
091B2:  ADDWF  01,F
091B4:  MOVFF  01,403
091B8:  CALL   78E4
091BC:  MOVLB  4
091BE:  MOVLW  30
091C0:  ADDWF  x01,F
091C2:  MOVFF  401,403
091C6:  MOVLB  0
091C8:  CALL   78E4
091CC:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... /* 
.................... TCP/IP Stack enabled. 
.................... Many TCP/IP configuration settings (servers enabled, ports used, 
.................... etc) are defined in TCPIPConfig.h. 
.................... Many hardware configuration settings (SPI port and GPIO pins used) 
.................... are defined in HardwareProfile.h. 
.................... */ 
....................  
.................... #include "tcpip/p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................  #include "PIC18F4620_registers.h" 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFD 
.................... #byte TOSH = 0xFFE 
.................... #byte TOSL = 0xFFD 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int STKPTR0:5; 
....................          unsigned int :1; 
....................          unsigned int STKUNF:1; 
....................          unsigned int STKFUL:1; 
....................       }; 
....................       struct { 
....................          unsigned int STKPTR:5; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int STKOVF:1; 
....................       }; 
....................    }; 
.................... } STKPTRBITS; 
.................... STKPTRBITS STKPTRbits; 
.................... #byte STKPTRbits = 0xFFC 
.................... #byte STKPTR = 0xFFC 
....................  
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int TBLPTRU0:5; 
....................          unsigned int ACSS:1; 
....................       }; 
....................       struct { 
....................          unsigned int TBLPTRU:5; 
....................       }; 
.................... } TBLPTRUBITS; 
.................... TBLPTRUBITS TBLPTRUbits; 
.................... #byte TBLPTRUbits = 0xFF8 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF6 
.................... #byte TBLPTRH = 0xFF7 
.................... #byte TBLPTRL = 0xFF6 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF3 
.................... #byte PRODH = 0xFF4 
.................... #byte PRODL = 0xFF3 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int RBIF:1; 
....................          unsigned int INT0IF:1; 
....................          unsigned int TMR0IF:1; 
....................          unsigned int RBIE:1; 
....................          unsigned int INT0IE:1; 
....................          unsigned int TMR0IE:1; 
....................          unsigned int PEIE_GIEL:1; 
....................          unsigned int GIE_GIEH:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int INT0F:1; 
....................          unsigned int T0IF:1; 
....................          unsigned int :1; 
....................          unsigned int INT0E:1; 
....................          unsigned int T0IE:1; 
....................          unsigned int GIEL:1; 
....................          unsigned int GIEH:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int :6; 
....................          unsigned int PEIE:1; 
....................          unsigned int GIE:1; 
....................       }; 
....................    }; 
.................... } INTCONBITS; 
.................... INTCONBITS INTCONbits; 
.................... #byte INTCONbits = 0xFF2 
.................... #byte INTCON = 0xFF2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RBIP:1; 
....................          unsigned int :1; 
....................          unsigned int TMR0IP:1; 
....................          unsigned int :1; 
....................          unsigned int INTEDG2:1; 
....................          unsigned int INTEDG1:1; 
....................          unsigned int INTEDG0:1; 
....................          unsigned int RBPU:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int INTEDG:3; 
....................       }; 
.................... } INTCON2BITS; 
.................... INTCON2BITS INTCON2bits; 
.................... #byte INTCON2bits = 0xFF1 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int INT1F:1; 
....................          unsigned int INT2F:1; 
....................          unsigned int :1; 
....................          unsigned int INT1E:1; 
....................          unsigned int INT2E:1; 
....................          unsigned int :1; 
....................          unsigned int INT1P:1; 
....................          unsigned int INT2P:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int INT1IF:1; 
....................          unsigned int INT2IF:1; 
....................          unsigned int :1; 
....................          unsigned int INT1IE:1; 
....................          unsigned int INT2IE:1; 
....................          unsigned int :1; 
....................          unsigned int INT1IP:1; 
....................          unsigned int INT2IP:1; 
....................       }; 
....................    }; 
.................... } INTCON3BITS; 
.................... INTCON3BITS INTCON3bits; 
.................... #byte INTCON3bits = 0xFF0 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... #word FSR0 = 0xFE9 
.................... #byte FSR0H = 0xFEA 
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... #word FSR1 = 0xFE1 
.................... #byte FSR1H = 0xFE2 
.................... #byte FSR1L = 0xFE1 
....................  
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... #word FSR2 = 0xFD9 
.................... #byte FSR2H = 0xFDA 
.................... #byte FSR2L = 0xFD9 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUSBITS; 
.................... STATUSBITS STATUSbits; 
.................... #byte STATUSbits = 0xFD8 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD6 
.................... #byte TMR0H = 0xFD7 
.................... #byte TMR0L = 0xFD6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :6; 
....................          unsigned int T016BIT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int T0PS0:3; 
....................          unsigned int PSA:1; 
....................          unsigned int T0SE:1; 
....................          unsigned int T0CS:1; 
....................          unsigned int T08BIT:1; 
....................          unsigned int TMR0ON:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int T0PS:3; 
....................       }; 
.................... } T0CONBITS; 
.................... T0CONBITS T0CONbits; 
.................... #byte T0CONbits = 0xFD5 
.................... #byte T0CON = 0xFD5 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SCS0:2; 
....................          unsigned int IOFS:1; 
....................          unsigned int OSTS:1; 
....................          unsigned int IRCF0:3; 
....................          unsigned int IDLEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int SCS:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int IRCF:3; 
....................       }; 
.................... } OSCCONBITS; 
.................... OSCCONBITS OSCCONbits; 
.................... #byte OSCCONbits = 0xFD3 
.................... #byte OSCCON = 0xFD3 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int LVDL0:4; 
....................          unsigned int LVDEN:1; 
....................          unsigned int IRVST:1; 
....................       }; 
....................       struct { 
....................          unsigned int LVDL:4; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int HLVDL0:4; 
....................          unsigned int HLVDEN:1; 
....................          unsigned int IVRST:1; 
....................          unsigned int :1; 
....................          unsigned int VDIRMAG:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int HLVDL:4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int LVV0:4; 
....................          unsigned int :1; 
....................          unsigned int BGST:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int LVV:4; 
....................       }; 
.................... } HLVDCONBITS; 
.................... HLVDCONBITS HLVDCONbits; 
.................... #byte HLVDCONbits = 0xFD2 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SWDTE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SWDTEN:1; 
....................       }; 
....................    }; 
.................... } WDTCONBITS; 
.................... WDTCONBITS WDTCONbits; 
.................... #byte WDTCONbits = 0xFD1 
.................... #byte WDTCON = 0xFD1 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCONBITS; 
.................... RCONBITS RCONbits; 
.................... #byte RCONbits = 0xFD0 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCE 
.................... #byte TMR1H = 0xFCF 
.................... #byte TMR1L = 0xFCE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int TMR1ON:1; 
....................          unsigned int TMR1CS:1; 
....................          unsigned int T1SYNC:1; 
....................          unsigned int T1OSCEN:1; 
....................          unsigned int T1CKPS0:2; 
....................          unsigned int T1RUN:1; 
....................          unsigned int RD16:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int T1CKPS:2; 
....................       }; 
.................... } T1CONBITS; 
.................... T1CONBITS T1CONbits; 
.................... #byte T1CONbits = 0xFCD 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int T2OUTPS0:4; 
....................       }; 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int T2OUTPS:4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int T2CKPS0:2; 
....................          unsigned int TMR2ON:1; 
....................          unsigned int TOUTPS0:4; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int T2CKPS:2; 
....................          unsigned int :1; 
....................          unsigned int TOUTPS:4; 
....................       }; 
.................... } T2CONBITS; 
.................... T2CONBITS T2CONbits; 
.................... #byte T2CONbits = 0xFCA 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int WRITE:1; 
....................          unsigned int :2; 
....................          unsigned int ADDRESS:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................    }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int BF:1; 
....................          unsigned int UA:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int W:1; 
....................          unsigned int :2; 
....................          unsigned int A:1; 
....................       }; 
....................    }; 
.................... } SSPSTATBITS; 
.................... SSPSTATBITS SSPSTATbits; 
.................... #byte SSPSTATbits = 0xFC7 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SSPM0:4; 
....................          unsigned int CKP:1; 
....................          unsigned int SSPEN:1; 
....................          unsigned int SSPOV:1; 
....................          unsigned int WCOL:1; 
....................       }; 
....................       struct { 
....................          unsigned int SSPM:4; 
....................       }; 
.................... } SSPCON1BITS; 
.................... SSPCON1BITS SSPCON1bits; 
.................... #byte SSPCON1bits = 0xFC6 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2BITS; 
.................... SSPCON2BITS SSPCON2bits; 
.................... #byte SSPCON2bits = 0xFC5 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC3 
.................... #byte ADRESH = 0xFC4 
.................... #byte ADRESL = 0xFC3 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int DONE:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int GO_DONE:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int ADON:1; 
....................          unsigned int GO:1; 
....................          unsigned int CHS0:4; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int CHS:4; 
....................       }; 
.................... } ADCON0BITS; 
.................... ADCON0BITS ADCON0bits; 
.................... #byte ADCON0bits = 0xFC2 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PCFG0:4; 
....................          unsigned int VCFG0:2; 
....................       }; 
....................       struct { 
....................          unsigned int PCFG:4; 
....................          unsigned int VCFG:2; 
....................       }; 
.................... } ADCON1BITS; 
.................... ADCON1BITS ADCON1bits; 
.................... #byte ADCON1bits = 0xFC1 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ADCS0:3; 
....................          unsigned int ACQT0:3; 
....................          unsigned int :1; 
....................          unsigned int ADFM:1; 
....................       }; 
....................       struct { 
....................          unsigned int ADCS:3; 
....................          unsigned int ACQT:3; 
....................       }; 
.................... } ADCON2BITS; 
.................... ADCON2BITS ADCON2bits; 
.................... #byte ADCON2bits = 0xFC0 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #word CCPR1 = 0xFBE 
.................... #byte CCPR1H = 0xFBF 
.................... #byte CCPR1L = 0xFBE 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int CCP1Y:1; 
....................          unsigned int CCP1X:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int CCP1M0:4; 
....................          unsigned int DC1B0:2; 
....................          unsigned int P1M0:2; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int CCP1M:4; 
....................          unsigned int DC1B:2; 
....................          unsigned int P1M:2; 
....................       }; 
.................... } CCP1CONBITS; 
.................... CCP1CONBITS CCP1CONbits; 
.................... #byte CCP1CONbits = 0xFBD 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #word CCPR2 = 0xFBB 
.................... #byte CCPR2H = 0xFBC 
.................... #byte CCPR2L = 0xFBB 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int CCP2Y:1; 
....................          unsigned int CCP2X:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int CCP2M0:4; 
....................          unsigned int DC2B0:2; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int CCP2M:4; 
....................          unsigned int DC2B:2; 
....................       }; 
.................... } CCP2CONBITS; 
.................... CCP2CONBITS CCP2CONbits; 
.................... #byte CCP2CONbits = 0xFBA 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SCKP:1; 
....................          unsigned int RXCKP:1; 
....................          unsigned int RCMT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int ABDEN:1; 
....................          unsigned int WUE:1; 
....................          unsigned int :1; 
....................          unsigned int BRG16:1; 
....................          unsigned int TXCKP:1; 
....................          unsigned int RXDTP:1; 
....................          unsigned int RCIDL:1; 
....................          unsigned int ABDOVF:1; 
....................       }; 
....................    }; 
.................... } BAUDCONBITS; 
.................... BAUDCONBITS BAUDCONbits; 
.................... #byte BAUDCONbits = 0xFB8 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PDC0:7; 
....................          unsigned int PRSEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int PDC:7; 
....................       }; 
.................... } PWM1CONBITS; 
.................... PWM1CONBITS PWM1CONbits; 
.................... #byte PWM1CONbits = 0xFB7 
.................... #byte PWM1CON = 0xFB7 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PSSBD0:2; 
....................          unsigned int PSSAC0:2; 
....................          unsigned int ECCPAS0:3; 
....................          unsigned int ECCPASE:1; 
....................       }; 
....................       struct { 
....................          unsigned int PSSBD:2; 
....................          unsigned int PSSAC:2; 
....................          unsigned int ECCPAS:3; 
....................       }; 
.................... } ECCP1ASBITS; 
.................... ECCP1ASBITS ECCP1ASbits; 
.................... #byte ECCP1ASbits = 0xFB6 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CVR0:4; 
....................          unsigned int CVRSS:1; 
....................          unsigned int CVRR:1; 
....................          unsigned int CVROE:1; 
....................          unsigned int CVREN:1; 
....................       }; 
....................       struct { 
....................          unsigned int CVR:4; 
....................       }; 
.................... } CVRCONBITS; 
.................... CVRCONBITS CVRCONbits; 
.................... #byte CVRCONbits = 0xFB5 
.................... #byte CVRCON = 0xFB5 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CM0:3; 
....................          unsigned int CIS:1; 
....................          unsigned int C1INV:1; 
....................          unsigned int C2INV:1; 
....................          unsigned int C1OUT:1; 
....................          unsigned int C2OUT:1; 
....................       }; 
....................       struct { 
....................          unsigned int CM:3; 
....................       }; 
.................... } CMCONBITS; 
.................... CMCONBITS CMCONbits; 
.................... #byte CMCONbits = 0xFB4 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB2 
.................... #byte TMR3H = 0xFB3 
.................... #byte TMR3L = 0xFB2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int TMR3ON:1; 
....................          unsigned int TMR3CS:1; 
....................          unsigned int T3SYNC:1; 
....................          unsigned int T3CCP1:1; 
....................          unsigned int T3CKPS0:2; 
....................          unsigned int T3CCP2:1; 
....................          unsigned int RD16:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int T3CKPS:2; 
....................       }; 
.................... } T3CONBITS; 
.................... T3CONBITS T3CONbits; 
.................... #byte T3CONbits = 0xFB1 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX9:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTABITS; 
.................... TXSTABITS TXSTAbits; 
.................... #byte TXSTAbits = 0xFAC 
.................... #byte TXSTA = 0xFAC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int ADEN:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int RX9D:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int CREN:1; 
....................          unsigned int SREN:1; 
....................          unsigned int RX9:1; 
....................          unsigned int SPEN:1; 
....................       }; 
....................    }; 
.................... } RCSTABITS; 
.................... RCSTABITS RCSTAbits; 
.................... #byte RCSTAbits = 0xFAB 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1BITS; 
.................... EECON1BITS EECON1bits; 
.................... #byte EECON1bits = 0xFA6 
.................... #byte EECON1 = 0xFA6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCP2IP:1; 
....................          unsigned int TMR3IP:1; 
....................          unsigned int HLVDIP:1; 
....................          unsigned int BCLIP:1; 
....................          unsigned int EEIP:1; 
....................          unsigned int :1; 
....................          unsigned int CMIP:1; 
....................          unsigned int OSCFIP:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int LVDIP:1; 
....................       }; 
....................    }; 
.................... } IPR2BITS; 
.................... IPR2BITS IPR2bits; 
.................... #byte IPR2bits = 0xFA2 
.................... #byte IPR2 = 0xFA2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCP2IF:1; 
....................          unsigned int TMR3IF:1; 
....................          unsigned int HLVDIF:1; 
....................          unsigned int BCLIF:1; 
....................          unsigned int EEIF:1; 
....................          unsigned int :1; 
....................          unsigned int CMIF:1; 
....................          unsigned int OSCFIF:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int LVDIF:1; 
....................       }; 
....................    }; 
.................... } PIR2BITS; 
.................... PIR2BITS PIR2bits; 
.................... #byte PIR2bits = 0xFA1 
.................... #byte PIR2 = 0xFA1 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCP2IE:1; 
....................          unsigned int TMR3IE:1; 
....................          unsigned int HLVDIE:1; 
....................          unsigned int BCLIE:1; 
....................          unsigned int EEIE:1; 
....................          unsigned int :1; 
....................          unsigned int CMIE:1; 
....................          unsigned int OSCFIE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int LVDIE:1; 
....................       }; 
....................    }; 
.................... } PIE2BITS; 
.................... PIE2BITS PIE2bits; 
.................... #byte PIE2bits = 0xFA0 
.................... #byte PIE2 = 0xFA0 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int PSPIP:1; 
.................... } IPR1BITS; 
.................... IPR1BITS IPR1bits; 
.................... #byte IPR1bits = 0xF9F 
.................... #byte IPR1 = 0xF9F 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1BITS; 
.................... PIR1BITS PIR1bits; 
.................... #byte PIR1bits = 0xF9E 
.................... #byte PIR1 = 0xF9E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1BITS; 
.................... PIE1BITS PIE1bits; 
.................... #byte PIE1bits = 0xF9D 
.................... #byte PIE1 = 0xF9D 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int TUN0:5; 
....................          unsigned int :1; 
....................          unsigned int PLLEN:1; 
....................          unsigned int INTSRC:1; 
....................       }; 
....................       struct { 
....................          unsigned int TUN:5; 
....................       }; 
.................... } OSCTUNEBITS; 
.................... OSCTUNEBITS OSCTUNEbits; 
.................... #byte OSCTUNEbits = 0xF9B 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISEBITS; 
.................... TRISEBITS TRISEbits; 
.................... #byte TRISEbits = 0xF96 
.................... #byte TRISE = 0xF96 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISDBITS; 
.................... TRISDBITS TRISDbits; 
.................... #byte TRISDbits = 0xF95 
.................... #byte TRISD = 0xF95 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISCBITS; 
.................... TRISCBITS TRISCbits; 
.................... #byte TRISCbits = 0xF94 
.................... #byte TRISC = 0xF94 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISBBITS; 
.................... TRISBBITS TRISBbits; 
.................... #byte TRISBbits = 0xF93 
.................... #byte TRISB = 0xF93 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISABITS; 
.................... TRISABITS TRISAbits; 
.................... #byte TRISAbits = 0xF92 
.................... #byte TRISA = 0xF92 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATEBITS; 
.................... LATEBITS LATEbits; 
.................... #byte LATEbits = 0xF8D 
.................... #byte LATE = 0xF8D 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATDBITS; 
.................... LATDBITS LATDbits; 
.................... #byte LATDbits = 0xF8C 
.................... #byte LATD = 0xF8C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATCBITS; 
.................... LATCBITS LATCbits; 
.................... #byte LATCbits = 0xF8B 
.................... #byte LATC = 0xF8B 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATBBITS; 
.................... LATBBITS LATBbits; 
.................... #byte LATBbits = 0xF8A 
.................... #byte LATB = 0xF8A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATABITS; 
.................... LATABITS LATAbits; 
.................... #byte LATAbits = 0xF89 
.................... #byte LATA = 0xF89 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTEBITS; 
.................... PORTEBITS PORTEbits; 
.................... #byte PORTEbits = 0xF84 
.................... #byte PORTE = 0xF84 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTDBITS; 
.................... PORTDBITS PORTDbits; 
.................... #byte PORTDbits = 0xF83 
.................... #byte PORTD = 0xF83 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTCBITS; 
.................... PORTCBITS PORTCbits; 
.................... #byte PORTCbits = 0xF82 
.................... #byte PORTC = 0xF82 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTBBITS; 
.................... PORTBBITS PORTBbits; 
.................... #byte PORTBbits = 0xF81 
.................... #byte PORTB = 0xF81 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTABITS; 
.................... PORTABITS PORTAbits; 
.................... #byte PORTAbits = 0xF80 
.................... #byte PORTA = 0xF80 
....................  
....................  
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1) 
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(rom char *s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
....................  
.................... #fuses HS,WDT4096,NOPROTECT,NOLVP,NODEBUG,NOSTVREN,PUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOLPT1OSC,NOMCLR,NOBROWNOUT,BORV43 
....................  
.................... #use delay(crystal=20000000) 
*
00296:  MOVLW  03
00298:  MOVWF  FEA
0029A:  MOVLW  C2
0029C:  MOVWF  FE9
0029E:  MOVF   FEF,W
002A0:  BZ    02BC
002A2:  MOVLW  06
002A4:  MOVWF  01
002A6:  CLRF   00
002A8:  DECFSZ 00,F
002AA:  BRA    02A8
002AC:  DECFSZ 01,F
002AE:  BRA    02A6
002B0:  MOVLW  7B
002B2:  MOVWF  00
002B4:  DECFSZ 00,F
002B6:  BRA    02B4
002B8:  DECFSZ FEF,F
002BA:  BRA    02A2
002BC:  RETURN 0
....................  
....................  
.................... #if defined(__PCH__) 
....................    #define GetSystemClock()       getenv("CLOCK") 
....................    #define GetInstructionClock()  (GetSystemClock()/4) 
....................    #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... #else 
....................    #define GetSystemClock()       getenv("CLOCK") 
....................    #define GetInstructionClock()  (GetSystemClock()/2) 
....................    #define GetPeripheralClock()   (GetSystemClock()/2) 
.................... #endif 
....................  
.................... #define MIN(a,b)  ((a > b) ? b : a) 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk2.h" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
....................  
.................... #ifndef __CCS_STACKTSK2_H__ 
.................... #define __CCS_STACKTSK2_H__ 
....................  
.................... #if !defined(debug_mpfs2) 
....................  #define debug_mpfs2(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) 
.................... #else 
....................  #define __DO_DEBUG_MPFS2 
.................... #endif 
....................  
.................... #if defined(__PCH__) && !defined(__18CXX) 
....................  #define __18CXX 
.................... #endif 
....................  
.................... #define SIZEOF_MAC_HEADER 14 
....................  
.................... // override delay.c/delay.h with CCS compatible code 
.................... #define __DELAY_H 
.................... #define Delay10us(x) delay_us((uint16_t)10*(uint16_t)x) 
.................... #define DelayMs(x)   delay_ms(x) 
....................  
.................... #define __WF_DEBUG_STRINGS_H  //don't include this file 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
*
075E8:  MOVFF  405,40B
075EC:  MOVFF  404,40A
....................    sc2=s2; 
075F0:  MOVFF  407,40D
075F4:  MOVFF  406,40C
....................    if(sc2<sc1 && sc1 <sc2 +n) 
075F8:  MOVLB  4
075FA:  MOVF   x0D,W
075FC:  SUBWF  x0B,W
075FE:  BNC   767C
07600:  BNZ   7608
07602:  MOVF   x0A,W
07604:  SUBWF  x0C,W
07606:  BC    767C
07608:  MOVF   x08,W
0760A:  ADDWF  x0C,W
0760C:  MOVWF  01
0760E:  MOVF   x09,W
07610:  ADDWFC x0D,W
07612:  MOVWF  03
07614:  MOVF   x0B,W
07616:  SUBWF  03,W
07618:  BNC   767C
0761A:  BNZ   7622
0761C:  MOVF   01,W
0761E:  SUBWF  x0A,W
07620:  BC    767C
....................       for(sc1+=n,sc2+=n;0<n;--n) 
07622:  MOVF   x08,W
07624:  ADDWF  x0A,F
07626:  MOVF   x09,W
07628:  ADDWFC x0B,F
0762A:  MOVF   x08,W
0762C:  ADDWF  x0C,F
0762E:  MOVF   x09,W
07630:  ADDWFC x0D,F
07632:  MOVF   x09,F
07634:  BNZ   763C
07636:  MOVF   x08,W
07638:  SUBLW  00
0763A:  BC    767A
....................          *--sc1=*--sc2; 
0763C:  MOVF   x0A,W
0763E:  BTFSC  FD8.2
07640:  DECF   x0B,F
07642:  DECF   x0A,F
07644:  MOVFF  40A,40E
07648:  MOVFF  40B,40F
0764C:  MOVF   x0C,W
0764E:  BTFSC  FD8.2
07650:  DECF   x0D,F
07652:  DECF   x0C,F
07654:  MOVFF  40D,03
07658:  MOVFF  40C,FE9
0765C:  MOVFF  40D,FEA
07660:  MOVFF  FEF,410
07664:  MOVFF  40B,FEA
07668:  MOVFF  40A,FE9
0766C:  MOVFF  410,FEF
07670:  MOVF   x08,W
07672:  BTFSC  FD8.2
07674:  DECF   x09,F
07676:  DECF   x08,F
07678:  BRA    7632
0767A:  BRA    76C4
....................    else 
....................       for(;0<n;--n) 
0767C:  MOVF   x09,F
0767E:  BNZ   7686
07680:  MOVF   x08,W
07682:  SUBLW  00
07684:  BC    76C4
....................          *sc1++=*sc2++; 
07686:  MOVFF  40B,03
0768A:  MOVF   x0A,W
0768C:  INCF   x0A,F
0768E:  BTFSC  FD8.2
07690:  INCF   x0B,F
07692:  MOVWF  x0E
07694:  MOVFF  03,40F
07698:  MOVFF  40D,03
0769C:  MOVF   x0C,W
0769E:  INCF   x0C,F
076A0:  BTFSC  FD8.2
076A2:  INCF   x0D,F
076A4:  MOVWF  FE9
076A6:  MOVFF  03,FEA
076AA:  MOVFF  FEF,410
076AE:  MOVFF  40F,FEA
076B2:  MOVFF  40E,FE9
076B6:  MOVFF  410,FEF
076BA:  MOVF   x08,W
076BC:  BTFSC  FD8.2
076BE:  DECF   x09,F
076C0:  DECF   x08,F
076C2:  BRA    767C
....................   return s1; 
076C4:  MOVFF  404,01
076C8:  MOVFF  405,02
076CC:  MOVLB  0
076CE:  RETURN 0
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
07C54:  MOVFF  402,408
07C58:  MOVFF  401,407
07C5C:  MOVLB  4
07C5E:  MOVF   x05,F
07C60:  BNZ   7C66
07C62:  MOVF   x06,F
07C64:  BZ    7CB4
07C66:  MOVFF  404,03
07C6A:  MOVFF  403,FE9
07C6E:  MOVFF  404,FEA
07C72:  MOVF   FEF,F
07C74:  BZ    7CB4
....................      *s++ = *s2++; 
07C76:  MOVFF  408,03
07C7A:  MOVF   x07,W
07C7C:  INCF   x07,F
07C7E:  BTFSC  FD8.2
07C80:  INCF   x08,F
07C82:  MOVWF  x09
07C84:  MOVFF  03,40A
07C88:  MOVFF  404,03
07C8C:  MOVF   x03,W
07C8E:  INCF   x03,F
07C90:  BTFSC  FD8.2
07C92:  INCF   x04,F
07C94:  MOVWF  FE9
07C96:  MOVFF  03,FEA
07C9A:  MOVFF  FEF,40B
07C9E:  MOVFF  40A,FEA
07CA2:  MOVFF  409,FE9
07CA6:  MOVFF  40B,FEF
07CAA:  MOVF   x05,W
07CAC:  BTFSC  FD8.2
07CAE:  DECF   x06,F
07CB0:  DECF   x05,F
07CB2:  BRA    7C5E
....................   for (; n > 0; n--) 
07CB4:  MOVF   x05,F
07CB6:  BNZ   7CBC
07CB8:  MOVF   x06,F
07CBA:  BZ    7CDA
....................      *s++ = '\0'; 
07CBC:  MOVFF  408,03
07CC0:  MOVF   x07,W
07CC2:  INCF   x07,F
07CC4:  BTFSC  FD8.2
07CC6:  INCF   x08,F
07CC8:  MOVWF  FE9
07CCA:  MOVFF  03,FEA
07CCE:  CLRF   FEF
07CD0:  MOVF   x05,W
07CD2:  BTFSC  FD8.2
07CD4:  DECF   x06,F
07CD6:  DECF   x05,F
07CD8:  BRA    7CB4
....................  
....................   return(s1); 
07CDA:  MOVFF  401,01
07CDE:  MOVFF  402,02
07CE2:  MOVLB  0
07CE4:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
079F8:  MOVFF  409,40F
079FC:  MOVFF  408,40E
07A00:  MOVFF  40B,411
07A04:  MOVFF  40A,410
07A08:  MOVLB  4
07A0A:  MOVF   x0D,F
07A0C:  BNZ   7A14
07A0E:  MOVF   x0C,W
07A10:  SUBLW  00
07A12:  BC    7A7E
.................... { 
....................    if(*su1!=*su2) 
07A14:  MOVFF  40E,FE9
07A18:  MOVFF  40F,FEA
07A1C:  MOVFF  FEF,412
07A20:  MOVFF  411,03
07A24:  MOVFF  410,FE9
07A28:  MOVFF  411,FEA
07A2C:  MOVF   FEF,W
07A2E:  SUBWF  x12,W
07A30:  BZ    7A68
....................       return ((*su1<*su2)?-1:+1); 
07A32:  MOVFF  40F,03
07A36:  MOVFF  40E,FE9
07A3A:  MOVFF  03,FEA
07A3E:  MOVFF  FEF,412
07A42:  MOVFF  411,03
07A46:  MOVFF  410,FE9
07A4A:  MOVFF  411,FEA
07A4E:  MOVF   FEF,W
07A50:  XORLW  80
07A52:  MOVWF  00
07A54:  MOVF   x12,W
07A56:  XORLW  80
07A58:  SUBWF  00,W
07A5A:  BZ    7A62
07A5C:  BNC   7A62
07A5E:  MOVLW  FF
07A60:  BRA    7A64
07A62:  MOVLW  01
07A64:  MOVWF  01
07A66:  BRA    7A82
07A68:  INCF   x0E,F
07A6A:  BTFSC  FD8.2
07A6C:  INCF   x0F,F
07A6E:  INCF   x10,F
07A70:  BTFSC  FD8.2
07A72:  INCF   x11,F
07A74:  MOVF   x0C,W
07A76:  BTFSC  FD8.2
07A78:  DECF   x0D,F
07A7A:  DECF   x0C,F
07A7C:  BRA    7A0A
.................... } 
.................... return 0; 
07A7E:  MOVLW  00
07A80:  MOVWF  01
07A82:  MOVLB  0
07A84:  GOTO   7B42 (RETURN)
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
070CA:  MOVLB  3
070CC:  MOVFF  3CE,FE9
070D0:  MOVFF  3CF,FEA
070D4:  MOVFF  FEF,3D2
070D8:  MOVFF  3D1,03
070DC:  MOVFF  3D0,FE9
070E0:  MOVFF  3D1,FEA
070E4:  MOVF   FEF,W
070E6:  SUBWF  xD2,W
070E8:  BNZ   7114
....................       if (*s1 == '\0') 
070EA:  MOVFF  3CF,03
070EE:  MOVFF  3CE,FE9
070F2:  MOVFF  03,FEA
070F6:  MOVF   FEF,F
070F8:  BNZ   7100
....................          return(0); 
070FA:  MOVLW  00
070FC:  MOVWF  01
070FE:  BRA    7148
07100:  MOVFF  3CF,03
07104:  MOVF   xCE,W
07106:  INCF   xCE,F
07108:  BTFSC  FD8.2
0710A:  INCF   xCF,F
0710C:  INCF   xD0,F
0710E:  BTFSC  FD8.2
07110:  INCF   xD1,F
07112:  BRA    70CC
....................    return((*s1 < *s2) ? -1: 1); 
07114:  MOVFF  3CF,03
07118:  MOVFF  3CE,FE9
0711C:  MOVFF  3CF,FEA
07120:  MOVFF  FEF,3D2
07124:  MOVFF  3D1,03
07128:  MOVFF  3D0,FE9
0712C:  MOVFF  3D1,FEA
07130:  MOVF   FEF,W
07132:  XORLW  80
07134:  MOVWF  00
07136:  MOVF   xD2,W
07138:  XORLW  80
0713A:  SUBWF  00,W
0713C:  BZ    7144
0713E:  BNC   7144
07140:  MOVLW  FF
07142:  BRA    7146
07144:  MOVLW  01
07146:  MOVWF  01
07148:  MOVLB  0
0714A:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
0714C:  MOVFF  423,426
....................    for(su=s;0<n;++su,--n) 
07150:  MOVFF  422,428
07154:  MOVFF  421,427
07158:  MOVLB  4
0715A:  MOVF   x25,F
0715C:  BNZ   7164
0715E:  MOVF   x24,W
07160:  SUBLW  00
07162:  BC    7190
....................       if(*su==uc) 
07164:  MOVFF  428,03
07168:  MOVFF  427,FE9
0716C:  MOVFF  428,FEA
07170:  MOVF   x26,W
07172:  SUBWF  FEF,W
07174:  BNZ   7180
....................       return su; 
07176:  MOVFF  427,01
0717A:  MOVFF  428,02
0717E:  BRA    7196
07180:  INCF   x27,F
07182:  BTFSC  FD8.2
07184:  INCF   x28,F
07186:  MOVF   x24,W
07188:  BTFSC  FD8.2
0718A:  DECF   x25,F
0718C:  DECF   x24,F
0718E:  BRA    715A
....................    return NULL; 
07190:  MOVLW  00
07192:  MOVWF  01
07194:  MOVWF  02
07196:  MOVLB  0
07198:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
08148:  MOVFF  3E2,03
0814C:  MOVLB  3
0814E:  MOVFF  3E1,FE9
08152:  MOVFF  3E2,FEA
08156:  MOVF   xE3,W
08158:  SUBWF  FEF,W
0815A:  BZ    8180
....................       if (*s == '\0') 
0815C:  MOVFF  3E2,03
08160:  MOVFF  3E1,FE9
08164:  MOVFF  3E2,FEA
08168:  MOVF   FEF,F
0816A:  BNZ   8174
....................          return(0); 
0816C:  MOVLW  00
0816E:  MOVWF  01
08170:  MOVWF  02
08172:  BRA    8188
08174:  INCF   xE1,F
08176:  BTFSC  FD8.2
08178:  INCF   xE2,F
0817A:  MOVLB  0
0817C:  BRA    8148
0817E:  MOVLB  3
....................    return(s); 
08180:  MOVFF  3E1,01
08184:  MOVFF  3E2,02
08188:  MOVLB  0
0818A:  RETURN 0
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
06FA0:  MOVFF  3DB,3DF
06FA4:  MOVFF  3DA,3DE
06FA8:  MOVFF  3DF,03
06FAC:  MOVLB  3
06FAE:  MOVFF  3DE,FE9
06FB2:  MOVFF  3DF,FEA
06FB6:  MOVF   FEF,F
06FB8:  BZ    700E
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
06FBA:  MOVFF  3DD,3E1
06FBE:  MOVFF  3DC,3E0
06FC2:  MOVFF  3E1,03
06FC6:  MOVFF  3E0,FE9
06FCA:  MOVFF  3E1,FEA
06FCE:  MOVF   FEF,F
06FD0:  BZ    7002
....................          if (*sc1 == *sc2) 
06FD2:  MOVFF  3DE,FE9
06FD6:  MOVFF  3DF,FEA
06FDA:  MOVFF  FEF,3E2
06FDE:  MOVFF  3E1,03
06FE2:  MOVFF  3E0,FE9
06FE6:  MOVFF  3E1,FEA
06FEA:  MOVF   FEF,W
06FEC:  SUBWF  xE2,W
06FEE:  BNZ   6FFA
....................             return(sc1); 
06FF0:  MOVFF  3DE,01
06FF4:  MOVFF  3DF,02
06FF8:  BRA    7014
06FFA:  INCF   xE0,F
06FFC:  BTFSC  FD8.2
06FFE:  INCF   xE1,F
07000:  BRA    6FC2
07002:  INCF   xDE,F
07004:  BTFSC  FD8.2
07006:  INCF   xDF,F
07008:  MOVLB  0
0700A:  BRA    6FA8
0700C:  MOVLB  3
....................    return(0); 
0700E:  MOVLW  00
07010:  MOVWF  01
07012:  MOVWF  02
07014:  MOVLB  0
07016:  GOTO   708C (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
06F10:  MOVFF  3DB,3DF
06F14:  MOVFF  3DA,3DE
06F18:  MOVFF  3DF,03
06F1C:  MOVLB  3
06F1E:  MOVFF  3DE,FE9
06F22:  MOVFF  3DF,FEA
06F26:  MOVF   FEF,F
06F28:  BZ    6F8A
....................       for (sc2 = s2; ; sc2++) 
06F2A:  MOVFF  3DD,3E1
06F2E:  MOVFF  3DC,3E0
....................     if (*sc2 == '\0') 
06F32:  MOVFF  3E1,03
06F36:  MOVFF  3E0,FE9
06F3A:  MOVFF  3E1,FEA
06F3E:  MOVF   FEF,F
06F40:  BNZ   6F56
....................        return(sc1 - s1); 
06F42:  MOVF   xDA,W
06F44:  SUBWF  xDE,W
06F46:  MOVWF  00
06F48:  MOVF   xDB,W
06F4A:  SUBWFB xDF,W
06F4C:  MOVWF  03
06F4E:  MOVFF  00,01
06F52:  BRA    6F9A
06F54:  BRA    6F76
....................          else if (*sc1 == *sc2) 
06F56:  MOVFF  3DE,FE9
06F5A:  MOVFF  3DF,FEA
06F5E:  MOVFF  FEF,3E2
06F62:  MOVFF  3E1,03
06F66:  MOVFF  3E0,FE9
06F6A:  MOVFF  3E1,FEA
06F6E:  MOVF   FEF,W
06F70:  SUBWF  xE2,W
06F72:  BNZ   6F76
....................             break; 
06F74:  BRA    6F7E
06F76:  INCF   xE0,F
06F78:  BTFSC  FD8.2
06F7A:  INCF   xE1,F
06F7C:  BRA    6F32
06F7E:  INCF   xDE,F
06F80:  BTFSC  FD8.2
06F82:  INCF   xDF,F
06F84:  MOVLB  0
06F86:  BRA    6F18
06F88:  MOVLB  3
....................    return(sc1 - s1); 
06F8A:  MOVF   xDA,W
06F8C:  SUBWF  xDE,W
06F8E:  MOVWF  00
06F90:  MOVF   xDB,W
06F92:  SUBWFB xDF,W
06F94:  MOVWF  03
06F96:  MOVFF  00,01
06F9A:  MOVLB  0
06F9C:  GOTO   704A (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
0701A:  MOVLB  3
0701C:  MOVF   xD2,W
0701E:  IORWF  xD3,W
07020:  BZ    702A
07022:  MOVFF  3D3,03
07026:  MOVF   xD2,W
07028:  BRA    7030
0702A:  MOVFF  18,03
0702E:  MOVF   17,W
07030:  MOVWF  xD6
07032:  MOVFF  03,3D7
....................    beg += strspn(beg, s2); 
07036:  MOVFF  3D7,3DB
0703A:  MOVFF  3D6,3DA
0703E:  MOVFF  3D5,3DD
07042:  MOVFF  3D4,3DC
07046:  MOVLB  0
07048:  BRA    6F10
0704A:  MOVF   01,W
0704C:  MOVLB  3
0704E:  ADDWF  xD6,F
07050:  MOVLW  00
07052:  ADDWFC xD7,F
....................    if (*beg == '\0') 
07054:  MOVFF  3D7,03
07058:  MOVFF  3D6,FE9
0705C:  MOVFF  3D7,FEA
07060:  MOVF   FEF,F
07062:  BNZ   7078
....................    { 
....................       *save = ' '; 
07064:  MOVFF  17,FE9
07068:  MOVFF  18,FEA
0706C:  MOVLW  20
0706E:  MOVWF  FEF
....................       return(0); 
07070:  MOVLW  00
07072:  MOVWF  01
07074:  MOVWF  02
07076:  BRA    70C6
....................    } 
....................    end = strpbrk(beg, s2); 
07078:  MOVFF  3D7,3DB
0707C:  MOVFF  3D6,3DA
07080:  MOVFF  3D5,3DD
07084:  MOVFF  3D4,3DC
07088:  MOVLB  0
0708A:  BRA    6FA0
0708C:  MOVFF  02,3D9
07090:  MOVFF  01,3D8
....................    if (*end != '\0') 
07094:  MOVFF  3D9,03
07098:  MOVLB  3
0709A:  MOVFF  3D8,FE9
0709E:  MOVFF  3D9,FEA
070A2:  MOVF   FEF,F
070A4:  BZ    70B6
....................    { 
....................       *end = '\0'; 
070A6:  MOVFF  3D8,FE9
070AA:  MOVFF  3D9,FEA
070AE:  CLRF   FEF
....................       end++; 
070B0:  INCF   xD8,F
070B2:  BTFSC  FD8.2
070B4:  INCF   xD9,F
....................    } 
....................    save = end; 
070B6:  MOVFF  3D9,18
070BA:  MOVFF  3D8,17
....................    return(beg); 
070BE:  MOVFF  3D6,01
070C2:  MOVFF  3D7,02
070C6:  MOVLB  0
070C8:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
075AE:  MOVFF  407,409
075B2:  MOVFF  406,408
075B6:  MOVFF  409,03
075BA:  MOVLB  4
075BC:  MOVFF  408,FE9
075C0:  MOVFF  409,FEA
075C4:  MOVF   FEF,F
075C6:  BZ    75D4
075C8:  INCF   x08,F
075CA:  BTFSC  FD8.2
075CC:  INCF   x09,F
075CE:  MOVLB  0
075D0:  BRA    75B6
075D2:  MOVLB  4
....................    return(sc - s); 
075D4:  MOVF   x06,W
075D6:  SUBWF  x08,W
075D8:  MOVWF  00
075DA:  MOVF   x07,W
075DC:  SUBWFB x09,W
075DE:  MOVWF  03
075E0:  MOVFF  00,01
075E4:  MOVLB  0
075E6:  RETURN 0
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
077B2:  MOVLB  3
077B4:  MOVFF  3E1,FE9
077B8:  MOVFF  3E2,FEA
077BC:  MOVFF  FEF,3E5
077C0:  MOVFF  3E4,03
077C4:  MOVFF  3E3,FE9
077C8:  MOVFF  3E4,FEA
077CC:  MOVF   FEF,W
077CE:  SUBWF  xE5,W
077D0:  BZ    7882
077D2:  MOVFF  3E2,03
077D6:  MOVFF  3E1,FE9
077DA:  MOVFF  3E2,FEA
077DE:  MOVFF  FEF,3E5
077E2:  BTFSC  xE5.7
077E4:  BRA    77F6
077E6:  MOVF   xE5,W
077E8:  SUBLW  40
077EA:  BC    77F6
077EC:  BTFSC  xE5.7
077EE:  BRA    780A
077F0:  MOVF   xE5,W
077F2:  SUBLW  5A
077F4:  BC    780A
077F6:  BTFSC  xE5.7
077F8:  BRA    78AC
077FA:  MOVF   xE5,W
077FC:  SUBLW  60
077FE:  BC    78AC
07800:  BTFSC  xE5.7
07802:  BRA    780A
07804:  MOVF   xE5,W
07806:  SUBLW  7A
07808:  BNC   78AC
0780A:  MOVFF  3E4,03
0780E:  MOVFF  3E3,FE9
07812:  MOVFF  3E4,FEA
07816:  MOVFF  FEF,3E5
0781A:  BTFSC  xE5.7
0781C:  BRA    782E
0781E:  MOVF   xE5,W
07820:  SUBLW  40
07822:  BC    782E
07824:  BTFSC  xE5.7
07826:  BRA    7842
07828:  MOVF   xE5,W
0782A:  SUBLW  5A
0782C:  BC    7842
0782E:  BTFSC  xE5.7
07830:  BRA    78AC
07832:  MOVF   xE5,W
07834:  SUBLW  60
07836:  BC    78AC
07838:  BTFSC  xE5.7
0783A:  BRA    7842
0783C:  MOVF   xE5,W
0783E:  SUBLW  7A
07840:  BNC   78AC
07842:  MOVFF  3E1,FE9
07846:  MOVFF  3E2,FEA
0784A:  MOVFF  FEF,3E5
0784E:  MOVFF  3E4,03
07852:  MOVFF  3E3,FE9
07856:  MOVFF  3E4,FEA
0785A:  MOVLW  20
0785C:  ADDWF  FEF,W
0785E:  SUBWF  xE5,W
07860:  BZ    7882
07862:  MOVFF  3E3,FE9
07866:  MOVFF  3E4,FEA
0786A:  MOVFF  FEF,3E5
0786E:  MOVFF  3E2,03
07872:  MOVFF  3E1,FE9
07876:  MOVFF  3E2,FEA
0787A:  MOVLW  20
0787C:  ADDWF  FEF,W
0787E:  SUBWF  xE5,W
07880:  BNZ   78AC
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
07882:  MOVFF  3E2,03
07886:  MOVFF  3E1,FE9
0788A:  MOVFF  3E2,FEA
0788E:  MOVF   FEF,F
07890:  BNZ   7898
....................        return(0); 
07892:  MOVLW  00
07894:  MOVWF  01
07896:  BRA    78E0
07898:  MOVFF  3E2,03
0789C:  MOVF   xE1,W
0789E:  INCF   xE1,F
078A0:  BTFSC  FD8.2
078A2:  INCF   xE2,F
078A4:  INCF   xE3,F
078A6:  BTFSC  FD8.2
078A8:  INCF   xE4,F
078AA:  BRA    77B4
....................  return((*s1 < *s2) ? -1: 1); 
078AC:  MOVFF  3E2,03
078B0:  MOVFF  3E1,FE9
078B4:  MOVFF  3E2,FEA
078B8:  MOVFF  FEF,3E5
078BC:  MOVFF  3E4,03
078C0:  MOVFF  3E3,FE9
078C4:  MOVFF  3E4,FEA
078C8:  MOVF   FEF,W
078CA:  XORLW  80
078CC:  MOVWF  00
078CE:  MOVF   xE5,W
078D0:  XORLW  80
078D2:  SUBWF  00,W
078D4:  BZ    78DC
078D6:  BNC   78DC
078D8:  MOVLW  FF
078DA:  BRA    78DE
078DC:  MOVLW  01
078DE:  MOVWF  01
078E0:  MOVLB  0
078E2:  RETURN 0
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
*
07940:  MOVFF  407,409
07944:  MOVFF  406,408
07948:  MOVFF  409,03
0794C:  MOVLB  4
0794E:  MOVFF  408,FE9
07952:  MOVFF  409,FEA
07956:  MOVF   FEF,F
07958:  BZ    79A4
....................       if (*p >= 'a' && *p <='z') 
0795A:  MOVFF  409,03
0795E:  MOVFF  408,FE9
07962:  MOVFF  409,FEA
07966:  BTFSC  FEF.7
07968:  BRA    7998
0796A:  MOVF   FEF,W
0796C:  SUBLW  60
0796E:  BC    7998
07970:  MOVFF  409,03
07974:  MOVFF  408,FE9
07978:  MOVFF  409,FEA
0797C:  BTFSC  FEF.7
0797E:  BRA    7986
07980:  MOVF   FEF,W
07982:  SUBLW  7A
07984:  BNC   7998
....................          *p -= 'a' - 'A'; 
07986:  MOVFF  409,03
0798A:  MOVFF  408,FE9
0798E:  MOVFF  409,FEA
07992:  MOVLW  20
07994:  SUBWF  FEF,W
07996:  MOVWF  FEF
07998:  INCF   x08,F
0799A:  BTFSC  FD8.2
0799C:  INCF   x09,F
0799E:  MOVLB  0
079A0:  BRA    7948
079A2:  MOVLB  4
....................    return(s); 
079A4:  MOVFF  406,01
079A8:  MOVFF  407,02
079AC:  MOVLB  0
079AE:  GOTO   7AD4 (RETURN)
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
07DCC:  MOVLB  3
07DCE:  CLRF   xDB
07DD0:  CLRF   xDA
....................    sign = 0; 
07DD2:  CLRF   xD7
07DD4:  CLRF   xD6
....................    base = 10; 
07DD6:  CLRF   xD9
07DD8:  MOVLW  0A
07DDA:  MOVWF  xD8
....................    result = 0; 
07DDC:  CLRF   xD5
07DDE:  CLRF   xD4
07DE0:  CLRF   xD3
07DE2:  CLRF   xD2
....................  
....................    if (!s) 
07DE4:  MOVF   xD0,W
07DE6:  IORWF  xD1,W
07DE8:  BNZ   7DF4
....................       return 0; 
07DEA:  CLRF   00
07DEC:  CLRF   01
07DEE:  CLRF   02
07DF0:  CLRF   03
07DF2:  BRA    8112
....................    c = s[index++]; 
07DF4:  MOVFF  3DB,03
07DF8:  MOVF   xDA,W
07DFA:  INCF   xDA,F
07DFC:  BTFSC  FD8.2
07DFE:  INCF   xDB,F
07E00:  MOVWF  xDD
07E02:  MOVF   xD0,W
07E04:  ADDWF  xDD,W
07E06:  MOVWF  FE9
07E08:  MOVF   xD1,W
07E0A:  ADDWFC 03,W
07E0C:  MOVWF  FEA
07E0E:  MOVFF  FEF,3DC
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
07E12:  MOVF   xDC,W
07E14:  SUBLW  2D
07E16:  BNZ   7E3E
....................    { 
....................       sign = 1;         // Set the sign to negative 
07E18:  CLRF   xD7
07E1A:  MOVLW  01
07E1C:  MOVWF  xD6
....................       c = s[index++]; 
07E1E:  MOVFF  3DB,03
07E22:  MOVF   xDA,W
07E24:  INCF   xDA,F
07E26:  BTFSC  FD8.2
07E28:  INCF   xDB,F
07E2A:  MOVWF  xDD
07E2C:  MOVF   xD0,W
07E2E:  ADDWF  xDD,W
07E30:  MOVWF  FE9
07E32:  MOVF   xD1,W
07E34:  ADDWFC 03,W
07E36:  MOVWF  FEA
07E38:  MOVFF  FEF,3DC
....................    } 
07E3C:  BRA    7E62
....................    else if (c == '+') 
07E3E:  MOVF   xDC,W
07E40:  SUBLW  2B
07E42:  BNZ   7E62
....................    { 
....................       c = s[index++]; 
07E44:  MOVFF  3DB,03
07E48:  MOVF   xDA,W
07E4A:  INCF   xDA,F
07E4C:  BTFSC  FD8.2
07E4E:  INCF   xDB,F
07E50:  MOVWF  xDD
07E52:  MOVF   xD0,W
07E54:  ADDWF  xDD,W
07E56:  MOVWF  FE9
07E58:  MOVF   xD1,W
07E5A:  ADDWFC 03,W
07E5C:  MOVWF  FEA
07E5E:  MOVFF  FEF,3DC
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
07E62:  BTFSC  xDC.7
07E64:  BRA    80DA
07E66:  MOVF   xDC,W
07E68:  SUBLW  2F
07E6A:  BTFSC  FD8.0
07E6C:  BRA    80DA
07E6E:  BTFSC  xDC.7
07E70:  BRA    7E7A
07E72:  MOVF   xDC,W
07E74:  SUBLW  39
07E76:  BTFSS  FD8.0
07E78:  BRA    80DA
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
07E7A:  MOVF   xDC,W
07E7C:  SUBLW  30
07E7E:  BNZ   7ECE
07E80:  MOVF   xD0,W
07E82:  ADDWF  xDA,W
07E84:  MOVWF  FE9
07E86:  MOVF   xD1,W
07E88:  ADDWFC xDB,W
07E8A:  MOVWF  FEA
07E8C:  MOVF   FEF,W
07E8E:  SUBLW  78
07E90:  BZ    7EA4
07E92:  MOVF   xD0,W
07E94:  ADDWF  xDA,W
07E96:  MOVWF  FE9
07E98:  MOVF   xD1,W
07E9A:  ADDWFC xDB,W
07E9C:  MOVWF  FEA
07E9E:  MOVF   FEF,W
07EA0:  SUBLW  58
07EA2:  BNZ   7ECE
....................       { 
....................          base = 16; 
07EA4:  CLRF   xD9
07EA6:  MOVLW  10
07EA8:  MOVWF  xD8
....................          index++; 
07EAA:  INCF   xDA,F
07EAC:  BTFSC  FD8.2
07EAE:  INCF   xDB,F
....................          c = s[index++]; 
07EB0:  MOVFF  3DB,03
07EB4:  MOVF   xDA,W
07EB6:  INCF   xDA,F
07EB8:  BTFSC  FD8.2
07EBA:  INCF   xDB,F
07EBC:  MOVWF  xDD
07EBE:  MOVF   xD0,W
07EC0:  ADDWF  xDD,W
07EC2:  MOVWF  FE9
07EC4:  MOVF   xD1,W
07EC6:  ADDWFC 03,W
07EC8:  MOVWF  FEA
07ECA:  MOVFF  FEF,3DC
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
07ECE:  MOVF   xD8,W
07ED0:  SUBLW  0A
07ED2:  BNZ   7F74
07ED4:  MOVF   xD9,F
07ED6:  BNZ   7F74
....................       { 
....................          while (c >= '0' && c <= '9') 
07ED8:  BTFSC  xDC.7
07EDA:  BRA    7F72
07EDC:  MOVF   xDC,W
07EDE:  SUBLW  2F
07EE0:  BC    7F72
07EE2:  BTFSC  xDC.7
07EE4:  BRA    7EEC
07EE6:  MOVF   xDC,W
07EE8:  SUBLW  39
07EEA:  BNC   7F72
....................          { 
....................             result = 10*result + (c - '0'); 
07EEC:  MOVLB  4
07EEE:  CLRF   x27
07EF0:  CLRF   x26
07EF2:  CLRF   x25
07EF4:  MOVLW  0A
07EF6:  MOVWF  x24
07EF8:  MOVFF  3D5,42B
07EFC:  MOVFF  3D4,42A
07F00:  MOVFF  3D3,429
07F04:  MOVFF  3D2,428
07F08:  MOVLB  0
07F0A:  CALL   1838
07F0E:  MOVFF  03,3E0
07F12:  MOVFF  02,3DF
07F16:  MOVFF  01,3DE
07F1A:  MOVFF  00,3DD
07F1E:  MOVLW  30
07F20:  MOVLB  3
07F22:  SUBWF  xDC,W
07F24:  MOVWF  00
07F26:  CLRF   01
07F28:  CLRF   02
07F2A:  CLRF   03
07F2C:  BTFSS  FE8.7
07F2E:  BRA    7F36
07F30:  DECF   01,F
07F32:  DECF   02,F
07F34:  DECF   03,F
07F36:  MOVF   00,W
07F38:  ADDWF  xDD,W
07F3A:  MOVWF  xD2
07F3C:  MOVF   01,W
07F3E:  ADDWFC xDE,W
07F40:  MOVWF  xD3
07F42:  MOVF   02,W
07F44:  ADDWFC xDF,W
07F46:  MOVWF  xD4
07F48:  MOVF   03,W
07F4A:  ADDWFC xE0,W
07F4C:  MOVWF  xD5
....................             c = s[index++]; 
07F4E:  MOVFF  3DB,03
07F52:  MOVF   xDA,W
07F54:  INCF   xDA,F
07F56:  BTFSC  FD8.2
07F58:  INCF   xDB,F
07F5A:  MOVWF  xDD
07F5C:  MOVFF  03,3DE
07F60:  MOVF   xD0,W
07F62:  ADDWF  xDD,W
07F64:  MOVWF  FE9
07F66:  MOVF   xD1,W
07F68:  ADDWFC 03,W
07F6A:  MOVWF  FEA
07F6C:  MOVFF  FEF,3DC
07F70:  BRA    7ED8
....................          } 
....................       } 
07F72:  BRA    80DA
....................       else if (base == 16)    // The number is a hexa number 
07F74:  MOVF   xD8,W
07F76:  SUBLW  10
07F78:  BTFSS  FD8.2
07F7A:  BRA    80DA
07F7C:  MOVF   xD9,F
07F7E:  BTFSS  FD8.2
07F80:  BRA    80DA
....................       { 
....................          c = toupper(c); 
07F82:  BTFSC  xDC.7
07F84:  BRA    7F9C
07F86:  MOVF   xDC,W
07F88:  SUBLW  60
07F8A:  BC    7F9C
07F8C:  BTFSC  xDC.7
07F8E:  BRA    7F96
07F90:  MOVF   xDC,W
07F92:  SUBLW  7A
07F94:  BNC   7F9C
07F96:  MOVF   xDC,W
07F98:  ANDLW  DF
07F9A:  BRA    7F9E
07F9C:  MOVF   xDC,W
07F9E:  MOVWF  xDC
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
07FA0:  BTFSC  xDC.7
07FA2:  BRA    7FB4
07FA4:  MOVF   xDC,W
07FA6:  SUBLW  2F
07FA8:  BC    7FB4
07FAA:  BTFSC  xDC.7
07FAC:  BRA    7FCC
07FAE:  MOVF   xDC,W
07FB0:  SUBLW  39
07FB2:  BC    7FCC
07FB4:  BTFSC  xDC.7
07FB6:  BRA    80DA
07FB8:  MOVF   xDC,W
07FBA:  SUBLW  40
07FBC:  BTFSC  FD8.0
07FBE:  BRA    80DA
07FC0:  BTFSC  xDC.7
07FC2:  BRA    7FCC
07FC4:  MOVF   xDC,W
07FC6:  SUBLW  46
07FC8:  BTFSS  FD8.0
07FCA:  BRA    80DA
....................          { 
....................             if (c >= '0' && c <= '9') 
07FCC:  BTFSC  xDC.7
07FCE:  BRA    803C
07FD0:  MOVF   xDC,W
07FD2:  SUBLW  2F
07FD4:  BC    803C
07FD6:  BTFSC  xDC.7
07FD8:  BRA    7FE0
07FDA:  MOVF   xDC,W
07FDC:  SUBLW  39
07FDE:  BNC   803C
....................                result = (result << 4) + (c - '0'); 
07FE0:  RLCF   xD2,W
07FE2:  MOVWF  xDE
07FE4:  RLCF   xD3,W
07FE6:  MOVWF  xDF
07FE8:  RLCF   xD4,W
07FEA:  MOVWF  xE0
07FEC:  RLCF   xD5,W
07FEE:  MOVWF  xE1
07FF0:  RLCF   xDE,F
07FF2:  RLCF   xDF,F
07FF4:  RLCF   xE0,F
07FF6:  RLCF   xE1,F
07FF8:  RLCF   xDE,F
07FFA:  RLCF   xDF,F
07FFC:  RLCF   xE0,F
07FFE:  RLCF   xE1,F
08000:  RLCF   xDE,F
08002:  RLCF   xDF,F
08004:  RLCF   xE0,F
08006:  RLCF   xE1,F
08008:  MOVLW  F0
0800A:  ANDWF  xDE,F
0800C:  MOVLW  30
0800E:  SUBWF  xDC,W
08010:  MOVWF  00
08012:  CLRF   01
08014:  CLRF   02
08016:  CLRF   03
08018:  BTFSS  FE8.7
0801A:  BRA    8022
0801C:  DECF   01,F
0801E:  DECF   02,F
08020:  DECF   03,F
08022:  MOVF   00,W
08024:  ADDWF  xDE,W
08026:  MOVWF  xD2
08028:  MOVF   01,W
0802A:  ADDWFC xDF,W
0802C:  MOVWF  xD3
0802E:  MOVF   02,W
08030:  ADDWFC xE0,W
08032:  MOVWF  xD4
08034:  MOVF   03,W
08036:  ADDWFC xE1,W
08038:  MOVWF  xD5
0803A:  BRA    8098
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0803C:  RLCF   xD2,W
0803E:  MOVWF  xDE
08040:  RLCF   xD3,W
08042:  MOVWF  xDF
08044:  RLCF   xD4,W
08046:  MOVWF  xE0
08048:  RLCF   xD5,W
0804A:  MOVWF  xE1
0804C:  RLCF   xDE,F
0804E:  RLCF   xDF,F
08050:  RLCF   xE0,F
08052:  RLCF   xE1,F
08054:  RLCF   xDE,F
08056:  RLCF   xDF,F
08058:  RLCF   xE0,F
0805A:  RLCF   xE1,F
0805C:  RLCF   xDE,F
0805E:  RLCF   xDF,F
08060:  RLCF   xE0,F
08062:  RLCF   xE1,F
08064:  MOVLW  F0
08066:  ANDWF  xDE,F
08068:  MOVLW  41
0806A:  SUBWF  xDC,W
0806C:  ADDLW  0A
0806E:  MOVWF  00
08070:  CLRF   01
08072:  CLRF   02
08074:  CLRF   03
08076:  BTFSS  FE8.7
08078:  BRA    8080
0807A:  DECF   01,F
0807C:  DECF   02,F
0807E:  DECF   03,F
08080:  MOVF   00,W
08082:  ADDWF  xDE,W
08084:  MOVWF  xD2
08086:  MOVF   01,W
08088:  ADDWFC xDF,W
0808A:  MOVWF  xD3
0808C:  MOVF   02,W
0808E:  ADDWFC xE0,W
08090:  MOVWF  xD4
08092:  MOVF   03,W
08094:  ADDWFC xE1,W
08096:  MOVWF  xD5
....................  
....................             c = s[index++];c = toupper(c); 
08098:  MOVFF  3DB,03
0809C:  MOVF   xDA,W
0809E:  INCF   xDA,F
080A0:  BTFSC  FD8.2
080A2:  INCF   xDB,F
080A4:  MOVWF  xDD
080A6:  MOVFF  03,3DE
080AA:  MOVF   xD0,W
080AC:  ADDWF  xDD,W
080AE:  MOVWF  FE9
080B0:  MOVF   xD1,W
080B2:  ADDWFC 03,W
080B4:  MOVWF  FEA
080B6:  MOVFF  FEF,3DC
080BA:  BTFSC  xDC.7
080BC:  BRA    80D4
080BE:  MOVF   xDC,W
080C0:  SUBLW  60
080C2:  BC    80D4
080C4:  BTFSC  xDC.7
080C6:  BRA    80CE
080C8:  MOVF   xDC,W
080CA:  SUBLW  7A
080CC:  BNC   80D4
080CE:  MOVF   xDC,W
080D0:  ANDLW  DF
080D2:  BRA    80D6
080D4:  MOVF   xDC,W
080D6:  MOVWF  xDC
080D8:  BRA    7FA0
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
080DA:  MOVF   xD8,W
080DC:  SUBLW  0A
080DE:  BNZ   8102
080E0:  MOVF   xD9,F
080E2:  BNZ   8102
080E4:  DECFSZ xD6,W
080E6:  BRA    8102
080E8:  MOVF   xD7,F
080EA:  BNZ   8102
....................       result = -result; 
080EC:  COMF   xD2,F
080EE:  COMF   xD3,F
080F0:  COMF   xD4,F
080F2:  COMF   xD5,F
080F4:  INCF   xD2,F
080F6:  BTFSC  FD8.2
080F8:  INCF   xD3,F
080FA:  BTFSC  FD8.2
080FC:  INCF   xD4,F
080FE:  BTFSC  FD8.2
08100:  INCF   xD5,F
....................  
....................    return(result); 
08102:  MOVFF  3D2,00
08106:  MOVFF  3D3,01
0810A:  MOVFF  3D4,02
0810E:  MOVFF  3D5,03
08112:  MOVLB  0
08114:  GOTO   9EDA (RETURN)
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
0719A:  MOVLB  3
0719C:  CLRF   xF5
0719E:  CLRF   xF4
071A0:  CLRF   xF3
071A2:  CLRF   xF2
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
071A4:  MOVLW  30
071A6:  MOVWF  xF7
071A8:  MOVLW  31
071AA:  MOVWF  xF8
071AC:  MOVLW  32
071AE:  MOVWF  xF9
071B0:  MOVLW  33
071B2:  MOVWF  xFA
071B4:  MOVLW  34
071B6:  MOVWF  xFB
071B8:  MOVLW  35
071BA:  MOVWF  xFC
071BC:  MOVLW  36
071BE:  MOVWF  xFD
071C0:  MOVLW  37
071C2:  MOVWF  xFE
071C4:  MOVLW  38
071C6:  MOVWF  xFF
071C8:  MOVLW  39
071CA:  MOVLB  4
071CC:  MOVWF  x00
071CE:  MOVLW  61
071D0:  MOVWF  x01
071D2:  MOVLW  62
071D4:  MOVWF  x02
071D6:  MOVLW  63
071D8:  MOVWF  x03
071DA:  MOVLW  64
071DC:  MOVWF  x04
071DE:  MOVLW  65
071E0:  MOVWF  x05
071E2:  MOVLW  66
071E4:  MOVWF  x06
071E6:  MOVLW  67
071E8:  MOVWF  x07
071EA:  MOVLW  68
071EC:  MOVWF  x08
071EE:  MOVLW  69
071F0:  MOVWF  x09
071F2:  MOVLW  6A
071F4:  MOVWF  x0A
071F6:  MOVLW  6B
071F8:  MOVWF  x0B
071FA:  MOVLW  6C
071FC:  MOVWF  x0C
071FE:  MOVLW  6D
07200:  MOVWF  x0D
07202:  MOVLW  6E
07204:  MOVWF  x0E
07206:  MOVLW  6F
07208:  MOVWF  x0F
0720A:  MOVLW  70
0720C:  MOVWF  x10
0720E:  MOVLW  71
07210:  MOVWF  x11
07212:  MOVLW  73
07214:  MOVWF  x12
07216:  MOVLW  74
07218:  MOVWF  x13
0721A:  MOVLW  75
0721C:  MOVWF  x14
0721E:  MOVLW  76
07220:  MOVWF  x15
07222:  MOVLW  77
07224:  MOVWF  x16
07226:  MOVLW  78
07228:  MOVWF  x17
0722A:  MOVLW  79
0722C:  MOVWF  x18
0722E:  MOVLW  7A
07230:  MOVWF  x19
07232:  CLRF   x1A
....................    for(sc=s;isspace(*sc);++sc); 
07234:  MOVFF  3E7,3ED
07238:  MOVFF  3E6,3EC
0723C:  MOVFF  3ED,03
07240:  MOVLB  3
07242:  MOVFF  3EC,FE9
07246:  MOVFF  3ED,FEA
0724A:  MOVF   FEF,W
0724C:  SUBLW  20
0724E:  BNZ   725C
07250:  INCF   xEC,F
07252:  BTFSC  FD8.2
07254:  INCF   xED,F
07256:  MOVLB  4
07258:  BRA    723C
0725A:  MOVLB  3
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
0725C:  MOVFF  3ED,03
07260:  MOVFF  3EC,FE9
07264:  MOVFF  3ED,FEA
07268:  MOVF   FEF,W
0726A:  SUBLW  2D
0726C:  BZ    7280
0726E:  MOVFF  3ED,03
07272:  MOVFF  3EC,FE9
07276:  MOVFF  3ED,FEA
0727A:  MOVF   FEF,W
0727C:  SUBLW  2B
0727E:  BNZ   7296
07280:  MOVFF  3ED,03
07284:  MOVF   xEC,W
07286:  INCF   xEC,F
07288:  BTFSC  FD8.2
0728A:  INCF   xED,F
0728C:  MOVWF  FE9
0728E:  MOVFF  03,FEA
07292:  MOVF   FEF,W
07294:  BRA    7298
07296:  MOVLW  2B
07298:  MOVWF  xF6
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
0729A:  MOVF   xF6,W
0729C:  SUBLW  2D
0729E:  BZ    72BA
072A0:  BTFSC  xEB.7
072A2:  BRA    72BA
072A4:  DECFSZ xEA,W
072A6:  BRA    72AC
072A8:  MOVF   xEB,F
072AA:  BZ    72BA
072AC:  BTFSC  xEB.7
072AE:  BRA    72BE
072B0:  MOVF   xEB,F
072B2:  BNZ   72BA
072B4:  MOVF   xEA,W
072B6:  SUBLW  24
072B8:  BC    72BE
....................    goto StrtoulGO; 
072BA:  BRA    755E
072BC:  BRA    73DC
....................  
....................    else if (base) 
072BE:  MOVF   xEA,W
072C0:  IORWF  xEB,W
072C2:  BZ    7368
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
072C4:  MOVF   xEA,W
072C6:  SUBLW  10
072C8:  BNZ   730C
072CA:  MOVF   xEB,F
072CC:  BNZ   730C
072CE:  MOVFF  3ED,03
072D2:  MOVFF  3EC,FE9
072D6:  MOVFF  3ED,FEA
072DA:  MOVF   FEF,W
072DC:  SUBLW  30
072DE:  BNZ   730C
072E0:  MOVLW  01
072E2:  ADDWF  xEC,W
072E4:  MOVWF  FE9
072E6:  MOVLW  00
072E8:  ADDWFC xED,W
072EA:  MOVWF  FEA
072EC:  MOVF   FEF,W
072EE:  SUBLW  78
072F0:  BZ    7304
072F2:  MOVLW  01
072F4:  ADDWF  xEC,W
072F6:  MOVWF  FE9
072F8:  MOVLW  00
072FA:  ADDWFC xED,W
072FC:  MOVWF  FEA
072FE:  MOVF   FEF,W
07300:  SUBLW  58
07302:  BNZ   730C
....................          sc+=2; 
07304:  MOVLW  02
07306:  ADDWF  xEC,F
07308:  MOVLW  00
0730A:  ADDWFC xED,F
....................       if(base==8 && *sc =='0') 
0730C:  MOVF   xEA,W
0730E:  SUBLW  08
07310:  BNZ   7330
07312:  MOVF   xEB,F
07314:  BNZ   7330
07316:  MOVFF  3ED,03
0731A:  MOVFF  3EC,FE9
0731E:  MOVFF  3ED,FEA
07322:  MOVF   FEF,W
07324:  SUBLW  30
07326:  BNZ   7330
....................          sc+=1; 
07328:  MOVLW  01
0732A:  ADDWF  xEC,F
0732C:  MOVLW  00
0732E:  ADDWFC xED,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
07330:  MOVF   xEA,W
07332:  SUBLW  02
07334:  BNZ   7366
07336:  MOVF   xEB,F
07338:  BNZ   7366
0733A:  MOVFF  3ED,03
0733E:  MOVFF  3EC,FE9
07342:  MOVFF  3ED,FEA
07346:  MOVF   FEF,W
07348:  SUBLW  30
0734A:  BNZ   7366
0734C:  MOVLW  01
0734E:  ADDWF  xEC,W
07350:  MOVWF  FE9
07352:  MOVLW  00
07354:  ADDWFC xED,W
07356:  MOVWF  FEA
07358:  MOVF   FEF,W
0735A:  SUBLW  62
0735C:  BNZ   7366
....................          sc+=2; 
0735E:  MOVLW  02
07360:  ADDWF  xEC,F
07362:  MOVLW  00
07364:  ADDWFC xED,F
....................  
....................    } 
07366:  BRA    73DC
....................    else if(*sc!='0') // base is 0, find base 
07368:  MOVFF  3ED,03
0736C:  MOVFF  3EC,FE9
07370:  MOVFF  3ED,FEA
07374:  MOVF   FEF,W
07376:  SUBLW  30
07378:  BZ    7382
....................       base=10; 
0737A:  CLRF   xEB
0737C:  MOVLW  0A
0737E:  MOVWF  xEA
07380:  BRA    73DC
....................    else if (sc[1]=='x' || sc[1]=='X') 
07382:  MOVLW  01
07384:  ADDWF  xEC,W
07386:  MOVWF  FE9
07388:  MOVLW  00
0738A:  ADDWFC xED,W
0738C:  MOVWF  FEA
0738E:  MOVF   FEF,W
07390:  SUBLW  78
07392:  BZ    73A6
07394:  MOVLW  01
07396:  ADDWF  xEC,W
07398:  MOVWF  FE9
0739A:  MOVLW  00
0739C:  ADDWFC xED,W
0739E:  MOVWF  FEA
073A0:  MOVF   FEF,W
073A2:  SUBLW  58
073A4:  BNZ   73B6
....................       base =16,sc+=2; 
073A6:  CLRF   xEB
073A8:  MOVLW  10
073AA:  MOVWF  xEA
073AC:  MOVLW  02
073AE:  ADDWF  xEC,F
073B0:  MOVLW  00
073B2:  ADDWFC xED,F
073B4:  BRA    73DC
....................    else if(sc[1]=='b') 
073B6:  MOVLW  01
073B8:  ADDWF  xEC,W
073BA:  MOVWF  FE9
073BC:  MOVLW  00
073BE:  ADDWFC xED,W
073C0:  MOVWF  FEA
073C2:  MOVF   FEF,W
073C4:  SUBLW  62
073C6:  BNZ   73D6
....................       base=2,sc+=2; 
073C8:  CLRF   xEB
073CA:  MOVLW  02
073CC:  MOVWF  xEA
073CE:  ADDWF  xEC,F
073D0:  MOVLW  00
073D2:  ADDWFC xED,F
073D4:  BRA    73DC
....................    else 
....................       base=8; 
073D6:  CLRF   xEB
073D8:  MOVLW  08
073DA:  MOVWF  xEA
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
073DC:  MOVFF  3ED,3EF
073E0:  MOVFF  3EC,3EE
073E4:  MOVFF  3ED,03
073E8:  MOVFF  3EC,FE9
073EC:  MOVFF  3ED,FEA
073F0:  MOVF   FEF,W
073F2:  SUBLW  30
073F4:  BNZ   73FE
073F6:  INCF   xEC,F
073F8:  BTFSC  FD8.2
073FA:  INCF   xED,F
073FC:  BRA    73E4
....................    sd=memchr(digits,tolower(*sc),base); 
073FE:  MOVFF  3ED,03
07402:  MOVFF  3EC,FE9
07406:  MOVFF  3ED,FEA
0740A:  MOVFF  FEF,41B
0740E:  MOVLB  4
07410:  BTFSC  x1B.7
07412:  BRA    742A
07414:  MOVF   x1B,W
07416:  SUBLW  40
07418:  BC    742A
0741A:  BTFSC  x1B.7
0741C:  BRA    7424
0741E:  MOVF   x1B,W
07420:  SUBLW  5A
07422:  BNC   742A
07424:  MOVF   x1B,W
07426:  IORLW  20
07428:  BRA    742C
0742A:  MOVF   x1B,W
0742C:  MOVWF  x1B
0742E:  MOVLW  03
07430:  MOVWF  x22
07432:  MOVLW  F7
07434:  MOVWF  x21
07436:  MOVFF  41B,423
0743A:  MOVFF  3EB,425
0743E:  MOVFF  3EA,424
07442:  MOVLB  0
07444:  RCALL  714C
07446:  MOVFF  02,3F1
0744A:  MOVFF  01,3F0
....................    for(; sd!=0; ) 
0744E:  MOVLB  3
07450:  MOVF   xF0,F
07452:  BNZ   745A
07454:  MOVF   xF1,F
07456:  BTFSC  FD8.2
07458:  BRA    7552
....................    { 
....................       x=x*base+(int16)(sd-digits); 
0745A:  MOVFF  3EA,00
0745E:  MOVFF  3EB,01
07462:  CLRF   02
07464:  CLRF   03
07466:  BTFSS  xEB.7
07468:  BRA    746E
0746A:  DECF   02,F
0746C:  DECF   03,F
0746E:  MOVFF  03,41E
07472:  MOVFF  02,41D
07476:  MOVFF  01,41C
0747A:  MOVFF  00,41B
0747E:  MOVFF  3F5,427
07482:  MOVFF  3F4,426
07486:  MOVFF  3F3,425
0748A:  MOVFF  3F2,424
0748E:  MOVFF  03,42B
07492:  MOVFF  02,42A
07496:  MOVFF  01,429
0749A:  MOVFF  00,428
0749E:  MOVLB  0
074A0:  CALL   1838
074A4:  MOVFF  03,41E
074A8:  MOVFF  02,41D
074AC:  MOVFF  01,41C
074B0:  MOVFF  00,41B
074B4:  MOVLW  F7
074B6:  MOVLB  3
074B8:  SUBWF  xF0,W
074BA:  MOVWF  00
074BC:  MOVLW  03
074BE:  SUBWFB xF1,W
074C0:  MOVWF  03
074C2:  MOVF   00,W
074C4:  MOVFF  03,01
074C8:  CLRF   02
074CA:  CLRF   03
074CC:  BTFSS  01.7
074CE:  BRA    74D4
074D0:  DECF   02,F
074D2:  DECF   03,F
074D4:  MOVLB  4
074D6:  MOVF   x1B,W
074D8:  ADDWF  00,F
074DA:  MOVF   x1C,W
074DC:  ADDWFC 01,F
074DE:  MOVF   x1D,W
074E0:  ADDWFC 02,F
074E2:  MOVF   x1E,W
074E4:  ADDWFC 03,F
074E6:  MOVFF  03,3F5
074EA:  MOVFF  02,3F4
074EE:  MOVFF  01,3F3
074F2:  MOVFF  00,3F2
....................       ++sc; 
074F6:  MOVLB  3
074F8:  INCF   xEC,F
074FA:  BTFSC  FD8.2
074FC:  INCF   xED,F
....................       sd=memchr(digits,tolower(*sc),base); 
074FE:  MOVFF  3ED,03
07502:  MOVFF  3EC,FE9
07506:  MOVFF  3ED,FEA
0750A:  MOVFF  FEF,41B
0750E:  MOVLB  4
07510:  BTFSC  x1B.7
07512:  BRA    752A
07514:  MOVF   x1B,W
07516:  SUBLW  40
07518:  BC    752A
0751A:  BTFSC  x1B.7
0751C:  BRA    7524
0751E:  MOVF   x1B,W
07520:  SUBLW  5A
07522:  BNC   752A
07524:  MOVF   x1B,W
07526:  IORLW  20
07528:  BRA    752C
0752A:  MOVF   x1B,W
0752C:  MOVWF  x1B
0752E:  MOVLW  03
07530:  MOVWF  x22
07532:  MOVLW  F7
07534:  MOVWF  x21
07536:  MOVFF  41B,423
0753A:  MOVFF  3EB,425
0753E:  MOVFF  3EA,424
07542:  MOVLB  0
07544:  RCALL  714C
07546:  MOVFF  02,3F1
0754A:  MOVFF  01,3F0
0754E:  BRA    744E
07550:  MOVLB  3
....................    } 
....................    if(s1==sc) 
07552:  MOVF   xEC,W
07554:  SUBWF  xEE,W
07556:  BNZ   7580
07558:  MOVF   xED,W
0755A:  SUBWF  xEF,W
0755C:  BNZ   7580
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
0755E:  MOVF   xE8,W
07560:  IORWF  xE9,W
07562:  BZ    7576
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
07564:  MOVFF  3E8,FE9
07568:  MOVFF  3E9,FEA
0756C:  MOVFF  3E7,FEC
07570:  MOVF   FED,F
07572:  MOVFF  3E6,FEF
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
07576:  CLRF   00
07578:  CLRF   01
0757A:  CLRF   02
0757C:  CLRF   03
0757E:  BRA    75A8
....................    } 
....................    if (endptr) 
07580:  MOVF   xE8,W
07582:  IORWF  xE9,W
07584:  BZ    7598
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
07586:  MOVFF  3E8,FE9
0758A:  MOVFF  3E9,FEA
0758E:  MOVFF  3ED,FEC
07592:  MOVF   FED,F
07594:  MOVFF  3EC,FEF
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
07598:  MOVFF  3F2,00
0759C:  MOVFF  3F3,01
075A0:  MOVFF  3F4,02
075A4:  MOVFF  3F5,03
075A8:  MOVLB  0
075AA:  GOTO   774A (RETURN)
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
*
08C7C:  MOVLB  3
08C7E:  CLRF   xFA
08C80:  CLRF   xF9
08C82:  CLRF   xF8
08C84:  CLRF   xF7
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
08C86:  MOVLW  30
08C88:  MOVWF  xFC
08C8A:  MOVLW  31
08C8C:  MOVWF  xFD
08C8E:  MOVLW  32
08C90:  MOVWF  xFE
08C92:  MOVLW  33
08C94:  MOVWF  xFF
08C96:  MOVLW  34
08C98:  MOVLB  4
08C9A:  MOVWF  x00
08C9C:  MOVLW  35
08C9E:  MOVWF  x01
08CA0:  MOVLW  36
08CA2:  MOVWF  x02
08CA4:  MOVLW  37
08CA6:  MOVWF  x03
08CA8:  MOVLW  38
08CAA:  MOVWF  x04
08CAC:  MOVLW  39
08CAE:  MOVWF  x05
08CB0:  MOVLW  61
08CB2:  MOVWF  x06
08CB4:  MOVLW  62
08CB6:  MOVWF  x07
08CB8:  MOVLW  63
08CBA:  MOVWF  x08
08CBC:  MOVLW  64
08CBE:  MOVWF  x09
08CC0:  MOVLW  65
08CC2:  MOVWF  x0A
08CC4:  MOVLW  66
08CC6:  MOVWF  x0B
08CC8:  MOVLW  67
08CCA:  MOVWF  x0C
08CCC:  MOVLW  68
08CCE:  MOVWF  x0D
08CD0:  MOVLW  69
08CD2:  MOVWF  x0E
08CD4:  MOVLW  6A
08CD6:  MOVWF  x0F
08CD8:  MOVLW  6B
08CDA:  MOVWF  x10
08CDC:  MOVLW  6C
08CDE:  MOVWF  x11
08CE0:  MOVLW  6D
08CE2:  MOVWF  x12
08CE4:  MOVLW  6E
08CE6:  MOVWF  x13
08CE8:  MOVLW  6F
08CEA:  MOVWF  x14
08CEC:  MOVLW  70
08CEE:  MOVWF  x15
08CF0:  MOVLW  71
08CF2:  MOVWF  x16
08CF4:  MOVLW  73
08CF6:  MOVWF  x17
08CF8:  MOVLW  74
08CFA:  MOVWF  x18
08CFC:  MOVLW  75
08CFE:  MOVWF  x19
08D00:  MOVLW  76
08D02:  MOVWF  x1A
08D04:  MOVLW  77
08D06:  MOVWF  x1B
08D08:  MOVLW  78
08D0A:  MOVWF  x1C
08D0C:  MOVLW  79
08D0E:  MOVWF  x1D
08D10:  MOVLW  7A
08D12:  MOVWF  x1E
08D14:  CLRF   x1F
....................    for(sc=s;isspace(*sc);++sc); 
08D16:  MOVFF  3EC,3F2
08D1A:  MOVFF  3EB,3F1
08D1E:  MOVFF  3F2,03
08D22:  MOVLB  3
08D24:  MOVFF  3F1,FE9
08D28:  MOVFF  3F2,FEA
08D2C:  MOVF   FEF,W
08D2E:  SUBLW  20
08D30:  BNZ   8D3E
08D32:  INCF   xF1,F
08D34:  BTFSC  FD8.2
08D36:  INCF   xF2,F
08D38:  MOVLB  4
08D3A:  BRA    8D1E
08D3C:  MOVLB  3
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
08D3E:  MOVFF  3F2,03
08D42:  MOVFF  3F1,FE9
08D46:  MOVFF  3F2,FEA
08D4A:  MOVF   FEF,W
08D4C:  SUBLW  2D
08D4E:  BZ    8D62
08D50:  MOVFF  3F2,03
08D54:  MOVFF  3F1,FE9
08D58:  MOVFF  3F2,FEA
08D5C:  MOVF   FEF,W
08D5E:  SUBLW  2B
08D60:  BNZ   8D78
08D62:  MOVFF  3F2,03
08D66:  MOVF   xF1,W
08D68:  INCF   xF1,F
08D6A:  BTFSC  FD8.2
08D6C:  INCF   xF2,F
08D6E:  MOVWF  FE9
08D70:  MOVFF  03,FEA
08D74:  MOVF   FEF,W
08D76:  BRA    8D7A
08D78:  MOVLW  2B
08D7A:  MOVWF  xFB
....................    if (base <0 || base ==1|| base >36) // invalid base 
08D7C:  BTFSC  xF0.7
08D7E:  BRA    8D96
08D80:  DECFSZ xEF,W
08D82:  BRA    8D88
08D84:  MOVF   xF0,F
08D86:  BZ    8D96
08D88:  BTFSC  xF0.7
08D8A:  BRA    8D9A
08D8C:  MOVF   xF0,F
08D8E:  BNZ   8D96
08D90:  MOVF   xEF,W
08D92:  SUBLW  24
08D94:  BC    8D9A
....................    goto StrtolGO; 
08D96:  BRA    9042
08D98:  BRA    8EB8
....................    else if (base) 
08D9A:  MOVF   xEF,W
08D9C:  IORWF  xF0,W
08D9E:  BZ    8E44
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
08DA0:  MOVF   xEF,W
08DA2:  SUBLW  10
08DA4:  BNZ   8DE8
08DA6:  MOVF   xF0,F
08DA8:  BNZ   8DE8
08DAA:  MOVFF  3F2,03
08DAE:  MOVFF  3F1,FE9
08DB2:  MOVFF  3F2,FEA
08DB6:  MOVF   FEF,W
08DB8:  SUBLW  30
08DBA:  BNZ   8DE8
08DBC:  MOVLW  01
08DBE:  ADDWF  xF1,W
08DC0:  MOVWF  FE9
08DC2:  MOVLW  00
08DC4:  ADDWFC xF2,W
08DC6:  MOVWF  FEA
08DC8:  MOVF   FEF,W
08DCA:  SUBLW  78
08DCC:  BZ    8DE0
08DCE:  MOVLW  01
08DD0:  ADDWF  xF1,W
08DD2:  MOVWF  FE9
08DD4:  MOVLW  00
08DD6:  ADDWFC xF2,W
08DD8:  MOVWF  FEA
08DDA:  MOVF   FEF,W
08DDC:  SUBLW  58
08DDE:  BNZ   8DE8
....................          sc+=2; 
08DE0:  MOVLW  02
08DE2:  ADDWF  xF1,F
08DE4:  MOVLW  00
08DE6:  ADDWFC xF2,F
....................       if(base==8 && *sc =='0') 
08DE8:  MOVF   xEF,W
08DEA:  SUBLW  08
08DEC:  BNZ   8E0C
08DEE:  MOVF   xF0,F
08DF0:  BNZ   8E0C
08DF2:  MOVFF  3F2,03
08DF6:  MOVFF  3F1,FE9
08DFA:  MOVFF  3F2,FEA
08DFE:  MOVF   FEF,W
08E00:  SUBLW  30
08E02:  BNZ   8E0C
....................          sc+=1; 
08E04:  MOVLW  01
08E06:  ADDWF  xF1,F
08E08:  MOVLW  00
08E0A:  ADDWFC xF2,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
08E0C:  MOVF   xEF,W
08E0E:  SUBLW  02
08E10:  BNZ   8E42
08E12:  MOVF   xF0,F
08E14:  BNZ   8E42
08E16:  MOVFF  3F2,03
08E1A:  MOVFF  3F1,FE9
08E1E:  MOVFF  3F2,FEA
08E22:  MOVF   FEF,W
08E24:  SUBLW  30
08E26:  BNZ   8E42
08E28:  MOVLW  01
08E2A:  ADDWF  xF1,W
08E2C:  MOVWF  FE9
08E2E:  MOVLW  00
08E30:  ADDWFC xF2,W
08E32:  MOVWF  FEA
08E34:  MOVF   FEF,W
08E36:  SUBLW  62
08E38:  BNZ   8E42
....................          sc+=2; 
08E3A:  MOVLW  02
08E3C:  ADDWF  xF1,F
08E3E:  MOVLW  00
08E40:  ADDWFC xF2,F
....................  
....................    } 
08E42:  BRA    8EB8
....................    else if(*sc!='0') // base is 0, find base 
08E44:  MOVFF  3F2,03
08E48:  MOVFF  3F1,FE9
08E4C:  MOVFF  3F2,FEA
08E50:  MOVF   FEF,W
08E52:  SUBLW  30
08E54:  BZ    8E5E
....................       base=10; 
08E56:  CLRF   xF0
08E58:  MOVLW  0A
08E5A:  MOVWF  xEF
08E5C:  BRA    8EB8
....................    else if (sc[1]=='x' || sc[1]=='X') 
08E5E:  MOVLW  01
08E60:  ADDWF  xF1,W
08E62:  MOVWF  FE9
08E64:  MOVLW  00
08E66:  ADDWFC xF2,W
08E68:  MOVWF  FEA
08E6A:  MOVF   FEF,W
08E6C:  SUBLW  78
08E6E:  BZ    8E82
08E70:  MOVLW  01
08E72:  ADDWF  xF1,W
08E74:  MOVWF  FE9
08E76:  MOVLW  00
08E78:  ADDWFC xF2,W
08E7A:  MOVWF  FEA
08E7C:  MOVF   FEF,W
08E7E:  SUBLW  58
08E80:  BNZ   8E92
....................       base =16,sc+=2; 
08E82:  CLRF   xF0
08E84:  MOVLW  10
08E86:  MOVWF  xEF
08E88:  MOVLW  02
08E8A:  ADDWF  xF1,F
08E8C:  MOVLW  00
08E8E:  ADDWFC xF2,F
08E90:  BRA    8EB8
....................    else if(sc[1]=='b') 
08E92:  MOVLW  01
08E94:  ADDWF  xF1,W
08E96:  MOVWF  FE9
08E98:  MOVLW  00
08E9A:  ADDWFC xF2,W
08E9C:  MOVWF  FEA
08E9E:  MOVF   FEF,W
08EA0:  SUBLW  62
08EA2:  BNZ   8EB2
....................       base=2,sc+=2; 
08EA4:  CLRF   xF0
08EA6:  MOVLW  02
08EA8:  MOVWF  xEF
08EAA:  ADDWF  xF1,F
08EAC:  MOVLW  00
08EAE:  ADDWFC xF2,F
08EB0:  BRA    8EB8
....................    else 
....................       base=8; 
08EB2:  CLRF   xF0
08EB4:  MOVLW  08
08EB6:  MOVWF  xEF
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
08EB8:  MOVFF  3F2,3F4
08EBC:  MOVFF  3F1,3F3
08EC0:  MOVFF  3F2,03
08EC4:  MOVFF  3F1,FE9
08EC8:  MOVFF  3F2,FEA
08ECC:  MOVF   FEF,W
08ECE:  SUBLW  30
08ED0:  BNZ   8EDA
08ED2:  INCF   xF1,F
08ED4:  BTFSC  FD8.2
08ED6:  INCF   xF2,F
08ED8:  BRA    8EC0
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
08EDA:  MOVFF  3F2,03
08EDE:  MOVFF  3F1,FE9
08EE2:  MOVFF  3F2,FEA
08EE6:  MOVFF  FEF,420
08EEA:  MOVLB  4
08EEC:  BTFSC  x20.7
08EEE:  BRA    8F06
08EF0:  MOVF   x20,W
08EF2:  SUBLW  40
08EF4:  BC    8F06
08EF6:  BTFSC  x20.7
08EF8:  BRA    8F00
08EFA:  MOVF   x20,W
08EFC:  SUBLW  5A
08EFE:  BNC   8F06
08F00:  MOVF   x20,W
08F02:  IORLW  20
08F04:  BRA    8F08
08F06:  MOVF   x20,W
08F08:  MOVWF  x20
08F0A:  MOVLW  03
08F0C:  MOVWF  x22
08F0E:  MOVLW  FC
08F10:  MOVWF  x21
08F12:  MOVFF  420,423
08F16:  MOVFF  3F0,425
08F1A:  MOVFF  3EF,424
08F1E:  MOVLB  0
08F20:  CALL   714C
08F24:  MOVFF  02,3F6
08F28:  MOVFF  01,3F5
....................    for(;sd!=0;) 
08F2C:  MOVLB  3
08F2E:  MOVF   xF5,F
08F30:  BNZ   8F38
08F32:  MOVF   xF6,F
08F34:  BTFSC  FD8.2
08F36:  BRA    9036
....................    { 
....................       x=x*base+(int16)(sd-digits); 
08F38:  MOVFF  3EF,00
08F3C:  MOVFF  3F0,01
08F40:  CLRF   02
08F42:  CLRF   03
08F44:  BTFSS  xF0.7
08F46:  BRA    8F4C
08F48:  DECF   02,F
08F4A:  DECF   03,F
08F4C:  MOVFF  03,423
08F50:  MOVFF  02,422
08F54:  MOVFF  01,421
08F58:  MOVFF  00,420
08F5C:  MOVFF  3FA,427
08F60:  MOVFF  3F9,426
08F64:  MOVFF  3F8,425
08F68:  MOVFF  3F7,424
08F6C:  MOVFF  03,42B
08F70:  MOVFF  02,42A
08F74:  MOVFF  01,429
08F78:  MOVFF  00,428
08F7C:  MOVLB  0
08F7E:  CALL   1838
08F82:  MOVFF  03,423
08F86:  MOVFF  02,422
08F8A:  MOVFF  01,421
08F8E:  MOVFF  00,420
08F92:  MOVLW  FC
08F94:  MOVLB  3
08F96:  SUBWF  xF5,W
08F98:  MOVWF  00
08F9A:  MOVLW  03
08F9C:  SUBWFB xF6,W
08F9E:  MOVWF  03
08FA0:  MOVF   00,W
08FA2:  MOVFF  03,01
08FA6:  CLRF   02
08FA8:  CLRF   03
08FAA:  BTFSS  01.7
08FAC:  BRA    8FB2
08FAE:  DECF   02,F
08FB0:  DECF   03,F
08FB2:  MOVF   00,W
08FB4:  MOVLB  4
08FB6:  ADDWF  x20,W
08FB8:  MOVLB  3
08FBA:  MOVWF  xF7
08FBC:  MOVF   01,W
08FBE:  MOVLB  4
08FC0:  ADDWFC x21,W
08FC2:  MOVLB  3
08FC4:  MOVWF  xF8
08FC6:  MOVF   02,W
08FC8:  MOVLB  4
08FCA:  ADDWFC x22,W
08FCC:  MOVLB  3
08FCE:  MOVWF  xF9
08FD0:  MOVF   03,W
08FD2:  MOVLB  4
08FD4:  ADDWFC x23,W
08FD6:  MOVLB  3
08FD8:  MOVWF  xFA
....................       ++sc; 
08FDA:  INCF   xF1,F
08FDC:  BTFSC  FD8.2
08FDE:  INCF   xF2,F
....................       sd=memchr(digits,tolower(*sc),base); 
08FE0:  MOVFF  3F2,03
08FE4:  MOVFF  3F1,FE9
08FE8:  MOVFF  3F2,FEA
08FEC:  MOVFF  FEF,420
08FF0:  MOVLB  4
08FF2:  BTFSC  x20.7
08FF4:  BRA    900C
08FF6:  MOVF   x20,W
08FF8:  SUBLW  40
08FFA:  BC    900C
08FFC:  BTFSC  x20.7
08FFE:  BRA    9006
09000:  MOVF   x20,W
09002:  SUBLW  5A
09004:  BNC   900C
09006:  MOVF   x20,W
09008:  IORLW  20
0900A:  BRA    900E
0900C:  MOVF   x20,W
0900E:  MOVWF  x20
09010:  MOVLW  03
09012:  MOVWF  x22
09014:  MOVLW  FC
09016:  MOVWF  x21
09018:  MOVFF  420,423
0901C:  MOVFF  3F0,425
09020:  MOVFF  3EF,424
09024:  MOVLB  0
09026:  CALL   714C
0902A:  MOVFF  02,3F6
0902E:  MOVFF  01,3F5
09032:  BRA    8F2C
09034:  MOVLB  3
....................    } 
....................    if(s1==sc) 
09036:  MOVF   xF1,W
09038:  SUBWF  xF3,W
0903A:  BNZ   9064
0903C:  MOVF   xF2,W
0903E:  SUBWF  xF4,W
09040:  BNZ   9064
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
09042:  MOVF   xED,W
09044:  IORWF  xEE,W
09046:  BZ    905A
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
09048:  MOVFF  3ED,FE9
0904C:  MOVFF  3EE,FEA
09050:  MOVFF  3EC,FEC
09054:  MOVF   FED,F
09056:  MOVFF  3EB,FEF
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
0905A:  CLRF   00
0905C:  CLRF   01
0905E:  CLRF   02
09060:  CLRF   03
09062:  BRA    90A8
....................    } 
....................    if(sign=='-') 
09064:  MOVF   xFB,W
09066:  SUBLW  2D
09068:  BNZ   9080
....................       x  =-x; 
0906A:  COMF   xF7,F
0906C:  COMF   xF8,F
0906E:  COMF   xF9,F
09070:  COMF   xFA,F
09072:  INCF   xF7,F
09074:  BTFSC  FD8.2
09076:  INCF   xF8,F
09078:  BTFSC  FD8.2
0907A:  INCF   xF9,F
0907C:  BTFSC  FD8.2
0907E:  INCF   xFA,F
....................    if (endptr) 
09080:  MOVF   xED,W
09082:  IORWF  xEE,W
09084:  BZ    9098
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
09086:  MOVFF  3ED,FE9
0908A:  MOVFF  3EE,FEA
0908E:  MOVFF  3F2,FEC
09092:  MOVF   FED,F
09094:  MOVFF  3F1,FEF
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
09098:  MOVFF  3F7,00
0909C:  MOVFF  3F8,01
090A0:  MOVFF  3F9,02
090A4:  MOVFF  3FA,03
090A8:  MOVLB  0
090AA:  GOTO   90F4 (RETURN)
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
018DC:  MOVFF  1C,427
018E0:  MOVFF  1B,426
018E4:  MOVFF  1A,425
018E8:  MOVFF  19,424
018EC:  MOVLW  41
018EE:  MOVLB  4
018F0:  MOVWF  x2B
018F2:  MOVLW  C6
018F4:  MOVWF  x2A
018F6:  MOVLW  4E
018F8:  MOVWF  x29
018FA:  MOVLW  6D
018FC:  MOVWF  x28
018FE:  MOVLB  0
01900:  RCALL  1838
01902:  MOVLW  39
01904:  MOVLB  3
01906:  ADDWF  00,W
01908:  MOVWF  19
0190A:  MOVLW  30
0190C:  ADDWFC 01,W
0190E:  MOVWF  1A
01910:  MOVLW  00
01912:  ADDWFC 02,W
01914:  MOVWF  1B
01916:  MOVLW  00
01918:  ADDWFC 03,W
0191A:  MOVWF  1C
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0191C:  MOVFF  1B,00
01920:  MOVFF  1C,01
01924:  CLRF   02
01926:  CLRF   03
01928:  MOVFF  1C,3D5
0192C:  MOVFF  1B,3D4
01930:  MOVFF  1C,3D7
01934:  MOVFF  1B,3D6
01938:  MOVLW  7F
0193A:  MOVWF  xD9
0193C:  SETF   xD8
0193E:  MOVLB  0
01940:  BRA    1894
01942:  MOVFF  00,01
01946:  MOVFF  03,02
0194A:  RETURN 0
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................  #include "PIC18F4620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1) 
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(rom char *s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
.................... #include <string.h> 
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define STACK_USE_ICMP_SERVER    1 
.................... #define STACK_USE_TCP            1 
.................... #define STACK_USE_DHCP_CLIENT    1 
....................  
.................... #define STACK_CCS_SMTP_TX_SIZE    0 
.................... #define STACK_CCS_SMTP_RX_SIZE    0 
....................  
.................... #define STACK_USE_CCS_HTTP2_SERVER 
.................... #define STACK_CCS_HTTP2_SERVER_TX_SIZE    1500 
.................... #define STACK_CCS_HTTP2_SERVER_RX_SIZE    500 
.................... #define HTTP_NUM_SOCKETS                  1 
.................... #define HTTP_PORT                         (80u) 
.................... #define HTTP_USE_DOUBLE_ESCAPE            1 
.................... #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................  
.................... #define STACK_MY_TELNET_SERVER_TX_SIZE    0 
.................... #define STACK_MY_TELNET_SERVER_RX_SIZE    0 
....................  
.................... #define MY_DEFAULT_HOST_NAME      "CCS_EXAMPLES" 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1      (0x0) 
.................... #define MY_DEFAULT_MAC_BYTE2      (0x20) 
.................... #define MY_DEFAULT_MAC_BYTE3      (0x30) 
.................... #define MY_DEFAULT_MAC_BYTE4      (0x40) 
.................... #define MY_DEFAULT_MAC_BYTE5      (0x50) 
.................... #define MY_DEFAULT_MAC_BYTE6      (0x60) 
....................  
.................... #define MY_DEFAULT_IP_ADDR_BYTE1  (192ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2  (168ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3  (1ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4  (118ul) 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1     (192ul) 
.................... #define MY_DEFAULT_GATE_BYTE2     (168ul) 
.................... #define MY_DEFAULT_GATE_BYTE3     (1ul) 
.................... #define MY_DEFAULT_GATE_BYTE4     (1ul) 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE2     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE3     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE4     (0ul) 
....................  
.................... #define TCP_CONFIGURATION      1 
....................  
.................... #define TCP_ETH_RAM_SIZE (STACK_CCS_SMTP_TX_SIZE + \ 
....................                           STACK_CCS_SMTP_RX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_TX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_RX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_TX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_RX_SIZE + \ 
....................                           100*TCP_CONFIGURATION) 
....................  
.................... // Define names of socket types 
.................... #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
.................... #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
.................... #define TCP_PURPOSE_TELNET             2 
.................... #define TCP_PURPOSE_FTP_COMMAND        3 
.................... #define TCP_PURPOSE_FTP_DATA           4 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
.................... #define TCP_PURPOSE_UART_2_TCP_BRIDGE  7 
.................... #define TCP_PURPOSE_HTTP_SERVER        8 
.................... #define TCP_PURPOSE_DEFAULT            9 
.................... #define TCP_PURPOSE_BERKELEY_SERVER    10 
.................... #define TCP_PURPOSE_BERKELEY_CLIENT    11 
.................... #define TCP_PURPOSE_CCS_SMTP           0x40 
....................  
.................... typedef struct 
.................... { 
....................    BYTE vSocketPurpose; 
....................    BYTE vMemoryMedium; 
....................    WORD wTXBufferSize; 
....................    WORD wRXBufferSize; 
.................... } TCPSocketInitializer_t; 
....................  
.................... #if TCP_CONFIGURATION > 0 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................          {TCP_PURPOSE_HTTP_SERVER, TCP_ETH_RAM, STACK_CCS_HTTP2_SERVER_TX_SIZE, STACK_CCS_HTTP2_SERVER_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_SMTP_CLIENT) 
....................          {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, STACK_CCS_SMTP_TX_SIZE, STACK_CCS_SMTP_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_MY_TELNET_SERVER) 
....................          {TCP_PURPOSE_TELNET, TCP_ETH_RAM, STACK_MY_TELNET_SERVER_TX_SIZE, STACK_MY_TELNET_SERVER_RX_SIZE}, 
....................       #endif 
....................    }; 
.................... #else 
....................    #undef TCP_CONFIGURATION 
....................    #define TCP_CONFIGURATION 1 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 250, 250} 
....................    }; 
.................... #endif 
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,  
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,  
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook/CCS      WIFI networkType added to AppConfig, hopefully 
....................  *                         this doesn't conflict with EZ_CONFIG_STORE.  
....................  *                      WIFI adhocBehavior added to AppConfig. 
....................  ********************************************************************/ 
.................... #ifndef __STACK_TSK_H 
.................... #define __STACK_TSK_H 
....................  
.................... #if defined (WF_CS_TRIS) 
....................     #include "WF_Config.h"      
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 ) 
.................... #error Invalid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_HTTP_CONNECTIONS <= 0 || MAX_HTTP_CONNECTIONS > 255 ) 
.................... #error Invalid MAX_HTTP_CONNECTIONS value specified. 
.................... #endif 
....................  
.................... // Structure to contain a MAC address 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... // Definition to represent an IP address 
.................... #define IP_ADDR      DWORD_VAL 
....................  
.................... // Address structure for a node 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     IP_ADDR     IPAddr; 
....................     MAC_ADDR    MACAddr; 
.................... } NODE_INFO; 
....................  
.................... // Application-dependent structure used to contain address information 
.................... typedef struct __attribute__((__packed__)) appConfigStruct  
.................... { 
....................    IP_ADDR      MyIPAddr;               // IP address 
....................    IP_ADDR      MyMask;                 // Subnet mask 
....................    IP_ADDR      MyGateway;              // Default Gateway 
....................    IP_ADDR      PrimaryDNSServer;       // Primary DNS Server 
....................    IP_ADDR      SecondaryDNSServer;     // Secondary DNS Server 
....................    IP_ADDR      DefaultIPAddr;          // Default IP address 
....................    IP_ADDR      DefaultMask;            // Default subnet mask 
....................    BYTE      NetBIOSName[16];        // NetBIOS name 
....................    struct 
....................    { 
....................       unsigned char : 6; 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    } Flags;                            // Flag structure 
....................    MAC_ADDR   MyMACAddr;              // Application MAC address 
....................  
.................... #if defined(WF_CS_TRIS) 
....................    BYTE      MySSID[32];             // Wireless SSID (if using MRF24W) 
....................    BYTE        SsidLength;             // number of bytes in SSID 
....................    BYTE        SecurityMode;           // WF_SECURITY_OPEN or one of the other security modes 
....................    BYTE        SecurityKey[64];        // WiFi Security key, or passphrase.    
....................    BYTE        SecurityKeyLength;      // number of bytes in security key (can be 0) 
....................    BYTE        WepKeyIndex;            // WEP key index (only valid for WEP) 
....................    BYTE        networkType; 
....................    BYTE        adhocBehavior; 
....................     #if defined(EZ_CONFIG_STORE) // WLAN configuration data stored to NVM 
....................     BYTE        dataValid; 
....................     //BYTE        networkType; 
....................     BYTE        saveSecurityInfo;       // Save 32-byte PSK 
....................     #endif 
.................... #endif 
....................     
.................... #if defined(STACK_USE_SNMP_SERVER) || defined(STACK_USE_SNMPV3_SERVER) 
....................    // SNMPv2C Read community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE readCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1];  
....................  
....................    // SNMPv2C Write community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE writeCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1]; 
....................  
....................    UINT32 SnmpEngineBootRcrd; 
.................... #endif 
....................  
.................... } APP_CONFIG; 
....................  
.................... #ifndef THIS_IS_STACK_APPLICATION 
....................     extern APP_CONFIG AppConfig; 
.................... #endif 
....................  
....................  
.................... void StackInit(void); 
.................... void StackTask(void); 
.................... void StackApplications(void); 
.................... #endif 
....................  
.................... #include "TCPIP Stack/Helpers.h" 
.................... /********************************************************************* 
....................  Header file for Helpers.c 
....................   
....................  FileName:      Helpers.h 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
.................... 		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
.................... 		used in conjunction with a Microchip ethernet controller for 
.................... 		the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release 
....................   5.36        Updated compile time check for ultoa(); 
....................  ********************************************************************/ 
.................... #ifndef __HELPERS_H 
.................... #define __HELPERS_H 
....................  
....................  
.................... #if !defined(__18CXX) || defined(HI_TECH_C) 
.................... 	char *strupr(char* s); 
.................... #endif 
....................  
.................... // Implement consistent ultoa() function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... 	// C32 < 1.12 and C30 < v3.25 need this 2 parameter stack implemented function 
.................... 	void ultoa(DWORD Value, BYTE* Buffer); 
.................... #elif defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	// C18 already has a 2 parameter ultoa() function 
.................... 	#include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #else 
.................... 	// HI-TECH PICC-18 PRO 9.63, C30 v3.25+, and C32 v1.12+ already have a ultoa() stdlib  
.................... 	// library function, but it requires 3 parameters.  The TCP/IP Stack  
.................... 	// assumes the C18 style 2 parameter ultoa() function, so we shall  
.................... 	// create a macro to automatically convert the code. 
.................... 	#include <stdlib.h> 
.................... 	#define ultoa(val,buf)	ultoa((char*)(buf),(val),10) 
.................... #endif 
....................  
.................... #if defined(DEBUG) 
.................... 	#define DebugPrint(a)	{putrsUART(a);} 
.................... #else 
.................... 	#define DebugPrint(a) 
.................... #endif 
....................  
.................... DWORD	LFSRSeedRand(DWORD dwSeed); 
.................... WORD	LFSRRand(void); 
.................... DWORD	GenerateRandomDWORD(void); 
.................... void 	uitoa(WORD Value, BYTE* Buffer); 
.................... void 	UnencodeURL(BYTE* URL); 
.................... WORD 	Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... WORD	Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... BOOL	StringToIPAddress(BYTE* str, IP_ADDR* IPAddress); 
.................... BYTE 	ReadStringUART(BYTE* Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b); 
.................... char * 	strnchr(const char *searchString, size_t count, char c); 
.................... size_t  strncpy_m(char* destStr, size_t destSize, int nStrings, ...); 
....................  
.................... #if defined(__18CXX) 
.................... 	BOOL	ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress); 
.................... #else 
.................... 	// Non-ROM variant for C30 and C32 
.................... 	#define ROMStringToIPAddress(a,b)	StringToIPAddress((BYTE*)a,b) 
.................... #endif 
....................  
....................  
.................... WORD    swaps(WORD v); 
....................  
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v); 
.................... #else 
.................... DWORD   swapl(DWORD v); 
.................... #endif 
....................  
.................... WORD    CalcIPChecksum(BYTE* buffer, WORD len); 
....................  
....................  
.................... #if defined(__18CXX) 
.................... 	DWORD leftRotateDWORD(DWORD val, BYTE bits); 
.................... #else 
.................... 	// Rotations are more efficient in C30 and C32 
.................... 	#define leftRotateDWORD(x, n) (((x) << (n)) | ((x) >> (32-(n)))) 
.................... #endif 
....................  
.................... void FormatNetBIOSName(BYTE Name[16]); 
....................  
....................  
.................... // Protocols understood by the ExtractURLFields() function.  IMPORTANT: If you  
.................... // need to reorder these (change their constant values), you must also reorder  
.................... // the constant arrays in ExtractURLFields(). 
.................... typedef enum 
.................... { 
.................... 	PROTOCOL_HTTP = 0u, 
.................... 	PROTOCOL_HTTPS, 
.................... 	PROTOCOL_MMS, 
.................... 	PROTOCOL_RTSP 
.................... } PROTOCOLS; 
....................  
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen); 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Delay.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  General Delay rouines 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Delay.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/9/02  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     6/10/02 Fixed C18 ms and us routines 
....................  * Howard Schlunder		4/04/06	Changed for C30 
....................  ********************************************************************/ 
.................... #ifndef __DELAY_H 
.................... #define __DELAY_H 
....................  
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#include <delays.h> 
.................... #endif 
....................  
.................... #if !defined(GetInstructionClock) 
.................... 	#error GetInstructionClock() must be defined. 
.................... #endif 
....................  
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#define Delay10us(us)		Delay10TCYx(((GetInstructionClock()/1000000)*(us))) 
.................... 	#define DelayMs(ms)												\ 
.................... 	do																\ 
.................... 	{																\ 
.................... 		unsigned int _iTemp = (ms); 								\ 
.................... 		while(_iTemp--)												\ 
.................... 			Delay1KTCYx((GetInstructionClock()+999999)/1000000);	\ 
.................... 	} while(0) 
....................  
.................... #elif defined(__C30__) || defined(__C32__) 
.................... 	void Delay10us(DWORD dwCount); 
.................... 	void DelayMs(WORD ms); 
....................  
.................... #else 
.................... 	#define Delay10us(x)			\ 
.................... 	do 								\ 
.................... 	{								\ 
.................... 		unsigned long _dcnt;		\ 
.................... 		_dcnt=x*((unsigned long)(0.00001/(1.0/GetInstructionClock())/6));	\ 
.................... 		while(_dcnt--);				\ 
.................... 	} while(0) 
.................... 	void DelayMs(WORD ms); 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __TICK_H 
.................... #define __TICK_H 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // All TICKS are stored as 32-bit unsigned integers. 
.................... // This is deprecated since it conflicts with other TICK definitions used in  
.................... // other Microchip software libraries and therefore poses a merge and maintence  
.................... // problem.  Instead of using the TICK data type, just use the base DWORD data  
.................... // type instead. 
.................... typedef __attribute__((__deprecated__)) DWORD TICK; 
....................  
.................... // This value is used by TCP and other modules to implement timeout actions. 
.................... // For this definition, the Timer must be initialized to use a 1:256 prescalar  
.................... // in Tick.c.  If using a 32kHz watch crystal as the time base, modify the  
.................... // Tick.c file to use no prescalar. 
.................... #define TICKS_PER_SECOND		((GetPeripheralClock()+128ull)/256ull)	// Internal core clock drives timer with 1:256 prescaler 
.................... //#define TICKS_PER_SECOND		(32768ul)								// 32kHz crystal drives timer with no scalar 
....................  
.................... // Represents one second in Ticks 
.................... #define TICK_SECOND				((QWORD)TICKS_PER_SECOND) 
.................... // Represents one minute in Ticks 
.................... #define TICK_MINUTE				((QWORD)TICKS_PER_SECOND*60ull) 
.................... // Represents one hour in Ticks 
.................... #define TICK_HOUR				((QWORD)TICKS_PER_SECOND*3600ull) 
....................  
....................  
.................... void TickInit(void); 
.................... DWORD TickGet(void); 
.................... DWORD TickGetDiv256(void); 
.................... DWORD TickGetDiv64K(void); 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue); 
.................... void TickUpdate(void); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  ********************************************************************/ 
.................... #ifndef __MAC_H 
.................... #define __MAC_H 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(WF_CS_TRIS) 
....................    // Do not use the DMA and other goodies that Microchip Ethernet modules have 
....................    #define NON_MCHP_MAC 
.................... #endif 
....................  
.................... #if defined(ENC_CS_TRIS) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the MRF24WB10 but not both ENC_CS_TRIS and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENCX24J600 or the MRF24WB10 but not both ENC100_INTERFACE_MODE and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(ENC_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the ENCX24J600 but not both ENC_CS_TRIS and ENC100_INTERFACE_MODE." 
.................... #endif 
....................  
....................  
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "TCPIP Stack/ETH97J60.h" 
.................... #elif defined(ENC_CS_TRIS) || defined(WF_CS_TRIS) 
....................    #include "TCPIP Stack/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  ********************************************************************/ 
....................  
.................... #ifndef __ENC28J60_H 
.................... #define __ENC28J60_H 
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	CollisionCount:4; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	Done:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	PacketDefer:1; 
.................... 		unsigned char	ExcessiveDefer:1; 
.................... 		unsigned char	MaximumCollisions:1; 
.................... 		unsigned char	LateCollision:1; 
.................... 		unsigned char	Giant:1; 
.................... 		unsigned char	Underrun:1; 
.................... 		WORD 	 		BytesTransmittedOnWire; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PAUSEControlFrame:1; 
.................... 		unsigned char	BackpressureApplied:1; 
.................... 		unsigned char	VLANTaggedFrame:1; 
.................... 		unsigned char	Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	BYTE v[4]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	PreviouslyIgnored:1; 
.................... 		unsigned char	RXDCPreviouslySeen:1; 
.................... 		unsigned char	CarrierPreviouslySeen:1; 
.................... 		unsigned char	CodeViolation:1; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	ReceiveOk:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	DribbleNibble:1; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PauseControlFrame:1; 
.................... 		unsigned char	UnsupportedOpcode:1; 
.................... 		unsigned char	VLANType:1; 
.................... 		unsigned char	Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG  
.................... { 
.................... 	BYTE Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char :1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char BUFER:1; 
.................... 		unsigned char INT:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char :3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
.................... 		 
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
.................... 		 
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
.................... 		 
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
.................... 		 
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
.................... 		 
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char :1; 
.................... 	} MACON4bits; 
.................... 		 
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char :6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
.................... 		 
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char :5; 
.................... 	} MISTATbits; 
.................... 		 
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits2; 
.................... 		 
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	WORD Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned PDPXMD:1; 
.................... 		unsigned :2; 
.................... 		unsigned PPWRSV:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLOOPBK:1; 
.................... 		unsigned PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned JBSTAT:1; 
.................... 		unsigned LLSTAT:1; 
.................... 		unsigned :5; 
.................... 		unsigned :3; 
.................... 		unsigned PHDPX:1; 
.................... 		unsigned PFDPX:1; 
.................... 		unsigned :3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		unsigned PREV0:1; 
.................... 		unsigned PREV1:1; 
.................... 		unsigned PREV2:1; 
.................... 		unsigned PREV3:1; 
.................... 		unsigned PPN0:1; 
.................... 		unsigned PPN1:1; 
.................... 		unsigned PPN2:1; 
.................... 		unsigned PPN3:1; 
.................... 		unsigned PPN4:1; 
.................... 		unsigned PPN5:1; 
.................... 		unsigned PID19:1; 
.................... 		unsigned PID20:1; 
.................... 		unsigned PID21:1; 
.................... 		unsigned PID22:1; 
.................... 		unsigned PID23:1; 
.................... 		unsigned PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		unsigned PREV:4; 
.................... 		unsigned PPNL:4; 
.................... 		unsigned PPNH:2; 
.................... 		unsigned PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned HDLDIS:1; 
.................... 		unsigned :1; 
.................... 		unsigned JABBER:1; 
.................... 		unsigned :2; 
.................... 		unsigned TXDIS:1; 
.................... 		unsigned FRCLNK:1; 
.................... 		unsigned :1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		unsigned :5; 
.................... 		unsigned PLRITY:1; 
.................... 		unsigned :2; 
.................... 		unsigned :1; 
.................... 		unsigned DPXSTAT:1; 
.................... 		unsigned LSTAT:1; 
.................... 		unsigned COLSTAT:1; 
.................... 		unsigned RXSTAT:1; 
.................... 		unsigned TXSTAT:1; 
.................... 		unsigned :2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned PGEIE:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLNKIE:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		unsigned :2; 
.................... 		unsigned PGIF:1; 
.................... 		unsigned :1; 
.................... 		unsigned PLNKIF:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ0:1; 
.................... 		unsigned LFRQ1:1; 
.................... 		unsigned LBCFG0:1; 
.................... 		unsigned LBCFG1:1; 
.................... 		unsigned LBCFG2:1; 
.................... 		unsigned LBCFG3:1; 
.................... 		unsigned LACFG0:1; 
.................... 		unsigned LACFG1:1; 
.................... 		unsigned LACFG2:1; 
.................... 		unsigned LACFG3:1; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ:2; 
.................... 		unsigned LBCFG:4; 
.................... 		unsigned LACFG:4; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
.................... 	 
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFER		(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
.................... 	 
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
.................... 	 
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
.................... 	 
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
.................... 	 
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
.................... 	 
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDREN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
.................... 	 
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
.................... 	 
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
.................... 	 
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
.................... 	 
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "TCPIP Stack/ENCX24J600.h" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or WiFi MRF24WB10 must be present. 
.................... #endif 
....................  
....................  
.................... #define MAC_TX_BUFFER_SIZE         (1500ul) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct   
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................    MAC_ADDR        DestMACAddr; 
....................    MAC_ADDR        SourceMACAddr; 
....................    WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
....................  
.................... #define MAC_IP         (0x00u) 
.................... #define MAC_ARP        (0x06u) 
.................... #define MAC_UNKNOWN    (0xFFu) 
....................  
....................  
.................... #if !defined(STACK_USE_HTTP2_SERVER) 
....................    #define RESERVED_HTTP_MEMORY 0ul 
.................... #endif 
....................  
.................... #if !defined(STACK_USE_SSL) 
....................    #define RESERVED_SSL_MEMORY 0ul 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #define MAX_PACKET_SIZE     (1514ul) 
.................... #endif 
....................  
.................... // MAC RAM definitions 
.................... #if defined(ENC100_INTERFACE_MODE) 
....................    #define RESERVED_CRYPTO_MEMORY   (128ul) 
....................    #define RAMSIZE         (24*1024ul) 
....................    #define TXSTART       (0x0000ul) 
....................    #define RXSTART       ((TXSTART + 1518ul + TCP_ETH_RAM_SIZE + RESERVED_HTTP_MEMORY + RESERVED_SSL_MEMORY + RESERVED_CRYPTO_MEMORY + 1ul) & 0xFFFE) 
....................    #define   RXSTOP         (RAMSIZE-1ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + 1518ul) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_CRYPTOB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(WF_CS_TRIS) 
....................    #define RAMSIZE       (14170ul - 8192ul - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define TXSTART       (RAMSIZE - (4ul + MAX_PACKET_SIZE + 4ul)) 
....................    #define RXSTART       (0ul) 
....................    #define RXSTOP         ((TXSTART-2ul) | 0x0001ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 4ul) 
....................    #define BASE_SCRATCH_ADDR (BASE_TX_ADDR + (MAX_PACKET_SIZE + 4ul)) 
....................    #define BASE_HTTPB_ADDR  (BASE_SCRATCH_ADDR) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_TCB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(__PIC32MX__) && defined(_ETH) && !defined(ENC_CS_TRIS) 
....................    #define BASE_TX_ADDR   (MACGetTxBaseAddr()) 
....................    #define BASE_HTTPB_ADDR   (MACGetHttpBaseAddr()) 
....................    #define BASE_SSLB_ADDR   (MACGetSslBaseAddr()) 
....................    #define RXSIZE         (EMAC_RX_BUFF_SIZE) 
....................    #define RAMSIZE         (2*RXSIZE)   // not used but silences the compiler 
.................... #else   // ENC28J60 or PIC18F97J60 family internal Ethernet controller 
....................    #define RAMSIZE         (8*1024ul) 
....................    #define TXSTART       (RAMSIZE - (1ul+1518ul+7ul) - TCP_ETH_RAM_SIZE - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define RXSTART         (0ul)                  // Should be an even memory address; must be 0 for errata 
....................    #define   RXSTOP         ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 1ul) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + (1514ul+7ul)) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
.................... #endif 
....................  
.................... #if (RXSIZE < 1400) || (RXSIZE > RAMSIZE) 
....................    #error Warning, Ethernet RX buffer is tiny.  Reduce TCP socket count, the size of each TCP socket, or move sockets to a different RAM 
.................... #endif 
....................  
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void   MACEDPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... #if defined(ENC_CS_TRIS) || defined(ENC100_INTERFACE_MODE) || \ 
....................    (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... #endif 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
.................... // ENC28J60 specific 
.................... void   SetCLKOUT(BYTE NewConfig); 
.................... BYTE   GetCLKOUT(void); 
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
....................  
.................... void MACInit(void); 
.................... void MACProcess(void); 
.................... BOOL MACIsLinked(void); 
....................  
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void MACSetReadPtrInRx(WORD offset); 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address); 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address); 
.................... BYTE MACGet(void); 
.................... WORD MACGetArray(BYTE *val, WORD len); 
.................... void MACDiscardRx(void); 
.................... WORD MACGetFreeRxSize(void); 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len); 
.................... BOOL MACIsMemCopyDone(void); 
....................  
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen); 
.................... BOOL MACIsTxReady(void); 
.................... void MACPut(BYTE val); 
.................... void MACPutArray(BYTE *val, WORD len); 
.................... void MACFlush(void); 
....................  
....................  
.................... // ROM function variants for PIC18 
.................... #if defined(__18CXX) 
....................    void MACPutROMArray(ROM BYTE *val, WORD len); 
.................... #else 
....................    #define MACPutROMArray(a,b)   MACPutArray((BYTE*)a,b) 
.................... #endif 
....................  
.................... // PIC32MX with embedded ETHC functions 
.................... #if defined(__PIC32MX__) && defined(_ETH) 
....................    PTR_BASE MACGetTxBaseAddr(void); 
....................    PTR_BASE MACGetHttpBaseAddr(void); 
....................    PTR_BASE MACGetSslBaseAddr(void); 
.................... #endif 
....................  
....................     
.................... #endif 
....................  
.................... #include "TCPIP Stack/IP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __IP_H 
.................... #define __IP_H 
....................  
....................  
.................... #define IP_PROT_ICMP    (1u) 
.................... #define IP_PROT_TCP     (6u) 
.................... #define IP_PROT_UDP     (17u) 
....................  
....................  
.................... // IP packet header definition 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
.................... } IP_HEADER; 
....................  
.................... // IP Pseudo header as defined by RFC 793 (needed for TCP and UDP  
.................... // checksum calculations/verification) 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD Length; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define SwapPseudoHeader(h)  (h.Length = swaps(h.Length)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady()       MACIsTxReady() 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(b) MACSetWritePtr(b + BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "TCPIP Stack/ARP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.h and ARPTsk.h into ARP.h 
....................  ********************************************************************/ 
.................... #ifndef __ARP_H 
.................... #define __ARP_H 
....................  
.................... #ifdef STACK_CLIENT_MODE 
....................    void ARPInit(void); 
.................... #else 
....................    #define ARPInit() 
.................... #endif 
....................  
.................... #define ARP_OPERATION_REQ       0x0001u      // Operation code indicating an ARP Request 
.................... #define ARP_OPERATION_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
....................  
....................  
.................... // ARP packet structure 
.................... typedef struct  
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD        HardwareType;   // Link-layer protocol type (Ethernet is 1). 
....................     WORD        Protocol;       // The upper-layer protocol issuing an ARP request (0x0800 for IPv4).. 
....................     BYTE        MACAddrLen;     // MAC address length (6). 
....................     BYTE        ProtocolLen;    // Length of addresses used in the upper-layer protocol (4). 
....................     WORD        Operation;      // The operation the sender is performing (ARP_REQ or ARP_RESP). 
....................     MAC_ADDR    SenderMACAddr;  // The sender's hardware (MAC) address. 
....................     IP_ADDR     SenderIPAddr;   // The sender's IP address. 
....................     MAC_ADDR    TargetMACAddr;  // The target node's hardware (MAC) address. 
....................     IP_ADDR     TargetIPAddr;   // The target node's IP address. 
.................... } ARP_PACKET; 
....................  
.................... BOOL ARPProcess(void); 
.................... void ARPResolve(IP_ADDR* IPAddr); 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr); 
.................... void SwapARPPacket(ARP_PACKET* p); 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    /* API specific Definitions */ 
....................    #define ARP_REQ       0x0001u      // Operation code indicating an ARP Request 
....................    #define ARP_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
....................    struct arp_app_callbacks { 
....................        BOOL used; 
....................        void (*ARPPkt_notify)(DWORD SenderIPAddr, DWORD TargetIPAddr,  
....................                              MAC_ADDR* SenderMACAddr, MAC_ADDR* TargetMACAddr, BYTE op_req); 
....................    }; 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app); 
....................    BOOL ARPDeRegisterCallbacks(CHAR id); 
.................... #endif 
....................    BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ); 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... /********************************************************************* 
....................  * 
....................  *               External serial data EEPROM Access Defs. 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        XEEPROM.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/20/02     Original (Rev. 1.0) 
.................... ********************************************************************/ 
.................... #ifndef __XEEPROM_H 
.................... #define __XEEPROM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BOOL XEE_RESULT; 
.................... #define XEE_SUCCESS FALSE 
....................  
.................... #if defined(EEPROM_CS_TRIS)	 
.................... 	void XEEInit(void); 
.................... 	XEE_RESULT XEEBeginWrite(DWORD address); 
.................... 	XEE_RESULT XEEWrite(BYTE val); 
.................... 	void XEEWriteArray(BYTE *val, WORD wLen); 
.................... 	XEE_RESULT XEEEndWrite(void); 
.................... 	XEE_RESULT XEEBeginRead(DWORD address); 
.................... 	BYTE XEERead(void); 
.................... 	XEE_RESULT XEEReadArray(DWORD address, BYTE *buffer, WORD length); 
.................... 	XEE_RESULT XEEEndRead(void); 
.................... 	BOOL XEEIsBusy(void); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI EEPROM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI EERPOM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI EEPROM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void 		You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void 		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BYTE 		You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BOOL 		You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define XEEInit()				You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginWrite(a) 		You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWrite(a)				You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWriteArray(a,b)		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndWrite()			You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginRead(a)			You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEERead(a)				You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEReadArray(a, b, c)	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndRead()			You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEIsBusy()				You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... /********************************************************************* 
....................  * 
....................  *  SPI Flash Memory Driver Header 
....................  *	- Tested to be compatible with SST25VF016B 
....................  *  - Expected compatibility with other SST (Microchip) SST25 series  
....................  *    devices 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIFlash.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * E. Wood				3/20/08	Original 
.................... ********************************************************************/ 
.................... #ifndef __SPIFLASH_H 
.................... #define __SPIFLASH_H 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define SPI_FLASH_SECTOR_SIZE		(4096ul) 
.................... #define SPI_FLASH_PAGE_SIZE			(0ul)		// SST has no page boundary requirements 
....................  
.................... #define SPI_FLASH_SECTOR_MASK		(SPI_FLASH_SECTOR_SIZE - 1) 
....................  
....................  
.................... #if defined(SPIFLASH_CS_TRIS) 
.................... 	void SPIFlashInit(void);		 
.................... 	void SPIFlashReadArray(DWORD dwAddress, BYTE *vData, WORD wLen); 
.................... 	void SPIFlashBeginWrite(DWORD dwAddr); 
.................... 	void SPIFlashWrite(BYTE vData); 
.................... 	void SPIFlashWriteArray(BYTE *vData, WORD wLen); 
.................... 	void SPIFlashEraseSector(DWORD dwAddr); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI Flash chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI Flash chip, it  
.................... 	// means you have enabled a stack feature that requires SPI Flash hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIFlashInit()				You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashReadArray(a,b,c)	You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashBeginWrite(a)		You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWrite(a)			You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWriteArray(a,b)		You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashEraseSector(a)		You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIRAM.h" 
.................... /********************************************************************* 
....................  * 
....................  * Data SPI RAM Access Routines 
....................  *  -Tested with AMI Semiconductor N256S0830HDA 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIRAM.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * \file SPIRAM.h 
....................  * \author Howard Henry Schlunder 
....................  * \date 25 July 2007 
.................... ********************************************************************/ 
.................... #ifndef __SPIRAM_H 
.................... #define __SPIRAM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(SPIRAM_CS_TRIS) 
.................... 	void SPIRAMInit(void); 
.................... 	void SPIRAMGetArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	void SPIRAMPutArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	 
.................... 	#define SPIRAMPutString(a,b)			SPIRAMPutArray(a, strlen((char*)b)) 
.................... 	 
.................... 	#if defined(__18CXX) 
.................... 		void SPIRAMPutROMArray(WORD wAddress, ROM BYTE *vData, WORD wLength); 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutROMArray(a, strlenpgm((ROM char*)b)) 
.................... 	#else 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutArray(a, strlen((char*)b)) 
.................... 		#define SPIRAMPutROMArray(a,b,c)	SPIRAMPutROMArray(a, b, c) 
.................... 	#endif 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI SRAM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI SRAM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI SRAM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIRAMInit()				You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMGetArray(a,b,c)		You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutArray(a,b,c)		You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutString(a,b)		You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMArray(a,b,c)	You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMString(a,b)		You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  ********************************************************************/ 
.................... #ifndef __UDP_H 
.................... #define __UDP_H 
....................  
.................... // Stores a UDP Port Number 
.................... typedef WORD UDP_PORT; 
....................  
.................... // Provides a handle to a UDP Socket 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... // UDP States  
.................... typedef enum 
.................... { 
.................... 	UDP_DNS_IS_RESOLVED,		// Special state for UDP client mode sockets 
.................... 	UDP_DNS_RESOLVE,		// Special state for UDP client mode sockets 
.................... 	UDP_GATEWAY_SEND_ARP,	// Special state for UDP client mode sockets 
.................... 	UDP_GATEWAY_GET_ARP,		// Special state for UDP client mode sockets	 
....................     UDP_CLOSED,				// Socket is idle and unallocated 
.................... 	UDP_OPENED 
.................... } UDP_STATE; 
....................  
....................  
.................... // Stores information about a current UDP socket 
.................... typedef struct 
.................... { 
.................... 	union 
.................... 	{ 
.................... 		NODE_INFO	remoteNode;		// 10 bytes for MAC and IP address 
.................... 		DWORD		remoteHost;		// RAM or ROM pointer to a hostname string (ex: "www.microchip.com") 
.................... 	} remote; 
....................     //NODE_INFO   remoteNode;		// IP and MAC of remote node 
....................     UDP_PORT    remotePort;		// Remote node's UDP port number 
....................     UDP_PORT    localPort;		// Local UDP port number, or INVALID_UDP_PORT when free 
....................     UDP_STATE smState;			// State of this socket 
....................     DWORD retryInterval; 
.................... 	BYTE retryCount; 
.................... 	struct 
.................... 	{ 
.................... 		unsigned char bRemoteHostIsROM : 1;	// Remote host is stored in ROM 
.................... 	}flags; 
.................... 	WORD eventTime; 
.................... } UDP_SOCKET_INFO; 
....................  
....................  
.................... #define INVALID_UDP_SOCKET      (0xffu)		// Indicates a UDP socket that is not valid 
.................... #define INVALID_UDP_PORT        (0ul)		// Indicates a UDP port that is not valid 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	External Global Variables 
....................   ***************************************************************************/ 
.................... #if !defined(__UDP_C) 
....................     extern UDP_SOCKET activeUDPSocket; 
....................     extern UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
.................... 	extern WORD UDPTxCount; 
.................... 	extern WORD UDPRxCount; 
.................... #endif 
....................  
.................... // Stores the header of a UDP packet 
.................... typedef struct 
.................... { 
....................     UDP_PORT    SourcePort;				// Source UDP port 
....................     UDP_PORT    DestinationPort;		// Destination UDP port 
....................     WORD        Length;					// Length of data 
....................     WORD        Checksum;				// UDP checksum of the data 
.................... } UDP_HEADER; 
....................  
....................  
.................... // Create a server socket and ignore dwRemoteHost. 
.................... #define UDP_OPEN_SERVER		0u 
.................... #if defined(STACK_CLIENT_MODE) 
.................... 	#if defined(STACK_USE_DNS) 
.................... 		// Create a client socket and use dwRemoteHost as a RAM pointer to a hostname string. 
.................... 		#define UDP_OPEN_RAM_HOST	1u 
.................... 		// Create a client socket and use dwRemoteHost as a ROM pointer to a hostname string. 
.................... 		#define UDP_OPEN_ROM_HOST	2u 
.................... 	#else 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use UDP_OPEN_RAM_HOST while the DNS client module is not enabled.  
.................... 		#define UDP_OPEN_RAM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_UDP_OPEN_RAM_HOST 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use UDP_OPEN_ROM_HOST while the DNS client module is not enabled.  
.................... 		#define UDP_OPEN_ROM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_UDP_OPEN_ROM_HOST 
.................... 	#endif 
.................... 	// Create a client socket and use dwRemoteHost as a literal IP address. 
.................... 	#define UDP_OPEN_IP_ADDRESS	3u 
.................... #endif 
....................  
.................... // Create a client socket and use dwRemoteHost as a pointer to a NODE_INFO structure containing the exact remote IP address and MAC address to use. 
.................... #define UDP_OPEN_NODE_INFO	4u 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Prototypes 
....................   ***************************************************************************/ 
.................... void UDPInit(void); 
.................... void UDPTask(void); 
.................... UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort,UDP_PORT remotePort); 
....................  
.................... //UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO *remoteNode, UDP_PORT remotePort); 
.................... void UDPClose(UDP_SOCKET s); 
.................... BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len); 
....................  
.................... void UDPSetTxBuffer(WORD wOffset); 
.................... void UDPSetRxBuffer(WORD wOffset); 
.................... WORD UDPIsPutReady(UDP_SOCKET s); 
.................... BOOL UDPPut(BYTE v); 
.................... WORD UDPPutArray(BYTE *cData, WORD wDataLen); 
.................... BYTE* UDPPutString(BYTE *strData); 
.................... void UDPFlush(void); 
....................  
.................... // ROM function variants for PIC18 
.................... #if defined(__18CXX) 
.................... 	WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen); 
.................... 	ROM BYTE* UDPPutROMString(ROM BYTE *strData); 
.................... #else 
.................... 	#define UDPPutROMArray(a,b)	UDPPutArray((BYTE*)a,b) 
.................... 	#define UDPPutROMString(a)	UDPPutString((BYTE*)a) 
.................... #endif 
....................  
.................... WORD UDPIsGetReady(UDP_SOCKET s); 
.................... BOOL UDPGet(BYTE *v); 
.................... WORD UDPGetArray(BYTE *cData, WORD wDataLen); 
.................... void UDPDiscard(void); 
.................... BOOL UDPIsOpened(UDP_SOCKET socket); 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO* remoteNode,  
....................                         UDP_PORT remotePort) 
....................  
....................   Summary: 
....................     Macro of the legacy version of UDPOpen. 
....................      
....................   Description: 
....................     UDPOpen is a macro replacement of the legacy implementation of UDPOpen. 
....................     Creates a UDP socket handle for transmiting or receiving UDP packets.   
....................     Call this function to obtain a handle required by other UDP function. 
....................  
....................   Precondition: 
....................     UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................     localPort - UDP port number to listen on.  If 0, stack will dynamically  
....................         assign a unique port number to use. 
....................     remoteNode - Pointer to remote node info (MAC and IP address) for this 
....................         connection.  If this is a server socket (receives the first packet)  
....................         or the destination is the broadcast address, then this parameter 
....................         should be NULL. 
....................     remotePort - For client sockets, the remote port number. 
....................  
....................   Return Values: 
....................     Success - 
....................         A UDP socket handle that can be used for subsequent UDP API calls. 
....................     Failure - 
....................         INVALID_UDP_SOCKET.  This function fails when no more UDP socket  
....................         handles are available.  Increase MAX_UDP_SOCKETS to make more sockets  
....................         available. 
....................      
....................   Remarks: 
....................     When finished using the UDP socket handle, call the UDPClose() function  
....................     to free the socket and delete the handle. 
....................   ***************************************************************************/ 
.................... #define UDPOpen(localPort,remoteNode,remotePort)  UDPOpenEx((DWORD)remoteNode,UDP_OPEN_NODE_INFO,localPort,remotePort) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01  	Original        (Rev 1.0) 
....................  * Howard Schlunder		11/30/06	See "TCPIP Stack Version.txt" file 
....................  ********************************************************************/ 
.................... #ifndef __TCP_HITECH_WORKAROUND_H 
.................... #define __TCP_HITECH_WORKAROUND_H 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Type Definitions 
....................   ***************************************************************************/ 
....................  
.................... // A TCP_SOCKET is stored as a single BYTE 
.................... typedef BYTE TCP_SOCKET; 
....................  
.................... #define INVALID_SOCKET      (0xFE)	// The socket is invalid or could not be opened 
.................... #define UNKNOWN_SOCKET      (0xFF)	// The socket is not known 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	State Machine Variables 
....................   ***************************************************************************/ 
....................  
.................... // TCP States as defined by RFC 793 
.................... typedef enum 
.................... { 
.................... 	TCP_GET_DNS_MODULE,		// Special state for TCP client mode sockets 
.................... 	TCP_DNS_RESOLVE,		// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_SEND_ARP,	// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_GET_ARP,	// Special state for TCP client mode sockets 
....................  
....................     TCP_LISTEN,				// Socket is listening for connections 
....................     TCP_SYN_SENT,			// A SYN has been sent, awaiting an SYN+ACK 
....................     TCP_SYN_RECEIVED,		// A SYN has been received, awaiting an ACK 
....................     TCP_ESTABLISHED,		// Socket is connected and connection is established 
....................     TCP_FIN_WAIT_1,			// FIN WAIT state 1 
....................     TCP_FIN_WAIT_2,			// FIN WAIT state 2 
....................     TCP_CLOSING,			// Socket is closing 
.................... //	TCP_TIME_WAIT, state is not implemented 
.................... 	TCP_CLOSE_WAIT,			// Waiting to close the socket 
....................     TCP_LAST_ACK,			// The final ACK has been sent 
....................     TCP_CLOSED,				// Socket is idle and unallocated 
....................  
....................     TCP_CLOSED_BUT_RESERVED	// Special state for TCP client mode sockets.  Socket is idle, but still allocated pending application closure of the handle. 
.................... } TCP_STATE; 
....................  
.................... typedef enum 
.................... { 
.................... 	SSL_NONE = 0,			// No security is enabled 
.................... 	SSL_HANDSHAKING,		// Handshake is progressing (no application data allowed) 
.................... 	SSL_ESTABLISHED,		// Connection is established and secured 
.................... 	SSL_CLOSED				// Connection has been closed (no applicaiton data is allowed) 
.................... } SSL_STATE; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // TCP Control Block (TCB) stub data storage.  Stubs are stored in local PIC RAM for speed. 
.................... // Current size is 34 bytes (PIC18), 36 bytes (PIC24/dsPIC), or 56 (PIC32) 
.................... typedef struct 
.................... { 
.................... 	PTR_BASE bufferTxStart;		// First byte of TX buffer 
.................... 	PTR_BASE bufferRxStart;		// First byte of RX buffer.  TX buffer ends 1 byte prior 
.................... 	PTR_BASE bufferEnd;			// Last byte of RX buffer 
.................... 	PTR_BASE txHead;			// Head pointer for TX 
.................... 	PTR_BASE txTail;			// Tail pointer for TX 
.................... 	PTR_BASE rxHead;			// Head pointer for RX 
.................... 	PTR_BASE rxTail;			// Tail pointer for RX 
....................     DWORD eventTime;			// Packet retransmissions, state changes 
.................... 	WORD eventTime2;			// Window updates, automatic transmission 
.................... 	union 
.................... 	{ 
.................... 		WORD delayedACKTime;	// Delayed Acknowledgement timer 
.................... 		WORD closeWaitTime;		// TCP_CLOSE_WAIT timeout timer 
.................... 	} OverlappedTimers; 
....................     TCP_STATE smState;			// State of this socket 
....................     struct 
....................     { 
.................... 	    unsigned char vUnackedKeepalives : 3;		// Count of how many keepalives have been sent with no response 
....................         unsigned char bServer : 1;					// Socket should return to listening state when closed 
.................... 		unsigned char bTimerEnabled	: 1;			// Timer is enabled 
.................... 		unsigned char bTimer2Enabled : 1;			// Second timer is enabled 
.................... 		unsigned char bDelayedACKTimerEnabled : 1;	// DelayedACK timer is enabled 
.................... 		unsigned char bOneSegmentReceived : 1;		// A segment has been received 
.................... 		unsigned char bHalfFullFlush : 1;			// Flush is for being half full 
.................... 		unsigned char bTXASAP : 1;					// Transmit as soon as possible (for Flush) 
.................... 		unsigned char bTXASAPWithoutTimerReset : 1;	// Transmit as soon as possible (for Flush), but do not reset retransmission timers 
.................... 		unsigned char bTXFIN : 1;					// FIN needs to be transmitted 
.................... 		unsigned char bSocketReset : 1;				// Socket has been reset (self-clearing semaphore) 
.................... 		unsigned char bSSLHandshaking : 1;			// Socket is in an SSL handshake 
.................... 		unsigned char filler : 2;					// Future expansion 
....................     } Flags; 
.................... 	WORD_VAL remoteHash;	// Consists of remoteIP, remotePort, localPort for connected sockets.  It is a localPort number only for listening server sockets. 
....................  
....................     #if defined(STACK_USE_SSL) 
....................     PTR_BASE sslTxHead;		// Position of data being written in next SSL application record 
....................     						//   Also serves as cache of localSSLPort when smState = TCP_LISTENING 
....................     PTR_BASE sslRxHead;		// Position of incoming data not yet handled by SSL 
....................     BYTE sslStubID;			// Which sslStub is associated with this connection 
....................     BYTE sslReqMessage;		// Currently requested SSL message 
....................     #endif 
....................  
.................... 	BYTE vMemoryMedium;		// Which memory medium the TCB is actually stored 
.................... 	 
.................... } TCB_STUB; 
....................  
.................... // Remainder of TCP Control Block data. 
.................... // The rest of the TCB is stored in Ethernet buffer RAM or elsewhere as defined by vMemoryMedium. 
.................... // Current size is 41 (PIC18), 42 (PIC24/dsPIC), or 48 bytes (PIC32) 
.................... typedef struct 
.................... { 
.................... 	DWORD		retryInterval;			// How long to wait before retrying transmission 
.................... 	DWORD		MySEQ;					// Local sequence number 
.................... 	DWORD		RemoteSEQ;				// Remote sequence number 
.................... 	PTR_BASE	txUnackedTail;			// TX tail pointer for data that is not yet acked 
....................     WORD_VAL	remotePort;				// Remote port number 
....................     WORD_VAL	localPort;				// Local port number 
.................... 	WORD		remoteWindow;			// Remote window size 
.................... 	WORD		wFutureDataSize;		// How much out-of-order data has been received 
.................... 	union 
.................... 	{ 
.................... 		NODE_INFO	niRemoteMACIP;		// 10 bytes for MAC and IP address 
.................... 		DWORD		dwRemoteHost;		// RAM or ROM pointer to a hostname string (ex: "www.microchip.com") 
.................... 	} remote; 
.................... 	SHORT		sHoleSize;				// Size of the hole, or -1 for none exists.  (0 indicates hole has just been filled) 
....................     struct 
....................     { 
....................         unsigned char bFINSent : 1;		// A FIN has been sent 
.................... 		unsigned char bSYNSent : 1;		// A SYN has been sent 
.................... 		unsigned char bRemoteHostIsROM : 1;	// Remote host is stored in ROM 
.................... 		unsigned char bRXNoneACKed1 : 1;	// A duplicate ACK was likely received 
.................... 		unsigned char bRXNoneACKed2 : 1;	// A second duplicate ACK was likely received 
.................... 		unsigned char filler : 3;		// future use 
....................     } flags; 
.................... 	WORD		wRemoteMSS;				// Maximum Segment Size option advirtised by the remote node during initial handshaking 
....................     #if defined(STACK_USE_SSL) 
....................     WORD_VAL	localSSLPort;			// Local SSL port number (for listening sockets) 
....................     #endif 
.................... 	BYTE		retryCount;				// Counter for transmission retries 
.................... 	BYTE		vSocketPurpose;			// Purpose of socket (as defined in TCPIPConfig.h) 
.................... } TCB; 
....................  
.................... // Information about a socket 
.................... typedef struct 
.................... { 
.................... 	NODE_INFO remote;		// NODE_INFO structure for remote node 
.................... 	WORD_VAL remotePort;	// Port number associated with remote node 
.................... } SOCKET_INFO; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Declarations 
....................   ***************************************************************************/ 
....................  
.................... void TCPInit(void); 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP); 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP); 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP); 
.................... void TCPDisconnect(TCP_SOCKET hTCP); 
.................... void TCPClose(TCP_SOCKET hTCP); 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP); 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte); 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* Data, WORD Len); 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* Data); 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP); 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP); 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte); 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD count); 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart); 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart); 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... void TCPDiscard(TCP_SOCKET hTCP); 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len); 
.................... void TCPTick(void); 
.................... void TCPFlush(TCP_SOCKET hTCP); 
....................  
.................... // Create a server socket and ignore dwRemoteHost. 
.................... #define TCP_OPEN_SERVER		0u 
.................... #if defined(STACK_CLIENT_MODE) 
.................... 	#if defined(STACK_USE_DNS) 
.................... 		// Create a client socket and use dwRemoteHost as a RAM pointer to a hostname string. 
.................... 		#define TCP_OPEN_RAM_HOST	1u 
.................... 		// Create a client socket and use dwRemoteHost as a ROM pointer to a hostname string. 
.................... 		#define TCP_OPEN_ROM_HOST	2u 
.................... 	#else 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_RAM_HOST 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_ROM_HOST 
.................... 	#endif 
.................... 	// Create a client socket and use dwRemoteHost as a literal IP address. 
.................... 	#define TCP_OPEN_IP_ADDRESS	3u 
.................... 	// Create a client socket and use dwRemoteHost as a pointer to a NODE_INFO structure containing the exact remote IP address and MAC address to use. 
.................... 	#define TCP_OPEN_NODE_INFO	4u 
.................... #else 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_RAM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_ROM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_IP_ADDRESS while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_IP_ADDRESS	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_IP_ADDRESS 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_NODE_INFO while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_NODE_INFO	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_NODE_INFO 
.................... #endif 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose); 
....................  
.................... #if defined(__18CXX) 
.................... 	WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
....................  
.................... 	/***************************************************************************** 
.................... 	  Summary: 
.................... 		Alias to TCPFindROMArrayEx with no length parameter. 
.................... 	 
.................... 	  Description: 
.................... 		This function is an alias to TCPFindROMArrayEx with no length parameter.   
.................... 		It is provided for backwards compatibility with an older API. 
.................... 	  ***************************************************************************/ 
.................... 	#define TCPFindROMArray(a,b,c,d,e)		TCPFindROMArrayEx(a,b,c,d,0,e) 
.................... 	 
.................... 	WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* Data, WORD Len); 
.................... 	ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* Data); 
.................... #else 
.................... 	#define TCPFindROMArray(a,b,c,d,e) 		TCPFindArray(a,(BYTE*)b,c,d,e) 
.................... 	#define TCPFindROMArrayEx(a,b,c,d,e,f) 	TCPFindArrayEx(a,(BYTE*)b,c,d,e,f) 
.................... 	#define TCPPutROMArray(a,b,c)			TCPPutArray(a,(BYTE*)b,c) 
.................... 	#define TCPPutROMString(a,b)			TCPPutString(a,(BYTE*)b) 
.................... #endif 
....................  
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP); 
.................... // Alias to TCPIsGetReady provided for API completeness 
.................... #define TCPGetRxFIFOFull(a)					TCPIsGetReady(a) 
.................... // Alias to TCPIsPutReady provided for API completeness 
.................... #define TCPGetTxFIFOFree(a) 				TCPIsPutReady(a) 
....................  
.................... #define TCP_ADJUST_GIVE_REST_TO_RX	0x01u	// Resize flag: extra bytes go to RX  
.................... #define TCP_ADJUST_GIVE_REST_TO_TX	0x02u	// Resize flag: extra bytes go to TX 
.................... #define TCP_ADJUST_PRESERVE_RX		0x04u	// Resize flag: attempt to preserve RX buffer 
.................... #define TCP_ADJUST_PRESERVE_TX		0x08u	// Resize flag: attempt to preserve TX buffer 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags); 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host); 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType); 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP); 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port); 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg); 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP); 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP); 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP); 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len); 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len); 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone); 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP); 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP); 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFind(a,b,c,d)					TCPFindEx(a,b,c,0,d) 
....................  
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindArrayEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindArrayEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFindArray(a,b,c,d,e)				TCPFindArrayEx(a,b,c,d,0,e) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a server. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for server sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPListen(port)			TCPOpen(0, TCP_OPEN_SERVER, port, TCP_PURPOSE_DEFAULT) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a client. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for client sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPConnect(remote,port)	TCPOpen((DWORD)remote, TCP_OPEN_NODE_INFO, port, TCP_PURPOSE_DEFAULT) 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.h 
....................  * Dependencies:    TCPIPStack.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  ********************************************************************/ 
.................... #ifndef __DHCP_H 
.................... #define __DHCP_H 
....................  
.................... // UDP client port for DHCP Client transactions 
.................... #define DHCP_CLIENT_PORT                (68u) 
.................... // UDP listening port for DHCP Server messages 
.................... #define DHCP_SERVER_PORT                (67u) 
....................  
.................... #define BOOT_REQUEST                    (1u)   // BOOT_REQUEST DHCP type 
.................... #define BOOT_REPLY                      (2u)   // BOOT_REPLY DHCP type 
.................... #define BOOT_HW_TYPE                    (1u)   // BOOT_HW_TYPE DHCP type 
.................... #define BOOT_LEN_OF_HW_TYPE             (6u)   // BOOT_LEN_OF_HW_TYPE DHCP type 
....................  
.................... #define DHCP_MESSAGE_TYPE               (53u)   // DHCP Message Type constant 
.................... #define DHCP_MESSAGE_TYPE_LEN           (1u)   // Length of DHCP Message Type 
....................  
.................... #define DHCP_UNKNOWN_MESSAGE            (0u)   // Code for unknown DHCP message 
....................  
.................... #define DHCP_DISCOVER_MESSAGE           (1u)   // DCHP Discover Message 
.................... #define DHCP_OFFER_MESSAGE              (2u)   // DHCP Offer Message 
.................... #define DHCP_REQUEST_MESSAGE            (3u)   // DHCP Request message 
.................... #define DHCP_DECLINE_MESSAGE            (4u)   // DHCP Decline Message 
.................... #define DHCP_ACK_MESSAGE                (5u)   // DHCP ACK Message 
.................... #define DHCP_NAK_MESSAGE                (6u)   // DHCP NAK Message 
.................... #define DHCP_RELEASE_MESSAGE            (7u)   // DCHP Release message 
....................  
.................... #define DHCP_SERVER_IDENTIFIER          (54u)   // DHCP Server Identifier 
.................... #define DHCP_SERVER_IDENTIFIER_LEN      (4u)   // DHCP Server Identifier length 
....................  
.................... #define DHCP_OPTION_ACK_MESSAGE         (53u)   // DHCP_OPTION_ACK_MESSAGE Type 
.................... #define DHCP_PARAM_REQUEST_LIST         (55u)   // DHCP_PARAM_REQUEST_LIST Type 
.................... #define DHCP_PARAM_REQUEST_LIST_LEN     (4u)   // DHCP_PARAM_REQUEST_LIST_LEN Type 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS       (50u)   // DHCP_PARAM_REQUEST_IP_ADDRESS Type 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS_LEN   (4u)   // DHCP_PARAM_REQUEST_IP_ADDRESS_LEN Type 
.................... #define DHCP_SUBNET_MASK                (1u)   // DHCP_SUBNET_MASK Type 
.................... #define DHCP_ROUTER                     (3u)   // DHCP_ROUTER Type 
.................... #define DHCP_DNS                  (6u)   // DHCP_DNS Type 
.................... #define DHCP_HOST_NAME               (12u)   // DHCP_HOST_NAME Type 
.................... #define DHCP_IP_LEASE_TIME              (51u)   // DHCP_IP_LEASE_TIME Type 
.................... #define DHCP_END_OPTION                 (255u)   // DHCP_END_OPTION Type 
....................  
.................... // DHCP or BOOTP Header structure 
.................... #if defined(__CCS__) 
.................... typedef struct __attribute__((packed)) 
.................... #else 
.................... typedef struct __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................    BYTE      MessageType;   // Message type for this message 
....................    BYTE      HardwareType;   // Hardware type for this message 
....................    BYTE      HardwareLen;   // Length of hardware type 
....................    BYTE      Hops;         // Number of hops 
....................    DWORD      TransactionID;   // DHCP Transaction ID 
....................    WORD      SecondsElapsed;   // Number of elapsed seconds 
....................    WORD      BootpFlags;      // BOOTP Flags 
....................    IP_ADDR      ClientIP;      // Client IP 
....................    IP_ADDR      YourIP;         // Your IP 
....................    IP_ADDR      NextServerIP;   // Next Server IP 
....................    IP_ADDR      RelayAgentIP;   // Relay Agent IP 
....................    MAC_ADDR   ClientMAC;      // Client MAC Address 
.................... } BOOTP_HEADER; 
....................  
.................... // DHCP State Machine 
.................... typedef enum 
.................... { 
....................    SM_DHCP_DISABLED = 0,      // DHCP is not currently enabled 
....................    SM_DHCP_GET_SOCKET,         // DHCP is trying to obtain a socket 
....................    SM_DHCP_SEND_DISCOVERY,      // DHCP is sending a DHCP Discover message 
....................    SM_DHCP_GET_OFFER,         // DHCP is waiting for a DHCP Offer 
....................    SM_DHCP_SEND_REQUEST,      // DHCP is sending a DHCP Send Reequest message 
....................    SM_DHCP_GET_REQUEST_ACK,   // DCHP is waiting for a Request ACK message 
....................    SM_DHCP_BOUND,            // DHCP is bound 
....................    SM_DHCP_SEND_RENEW,         // DHCP is sending a DHCP renew message (first try) 
....................    SM_DHCP_GET_RENEW_ACK,      // DHCP is waiting for a renew ACK 
....................    SM_DHCP_SEND_RENEW2,      // DHCP is sending a DHCP renew message (second try) 
....................    SM_DHCP_GET_RENEW_ACK2,      // DHCP is waiting for a renew ACK 
....................    SM_DHCP_SEND_RENEW3,      // DHCP is sending a DHCP renew message (third try) 
....................    SM_DHCP_GET_RENEW_ACK3      // DHCP is waiting for a renew ACK 
.................... } SM_DHCP; 
....................  
....................  
.................... void DHCPInit(BYTE vInterface); 
.................... void DHCPTask(void); 
.................... void DHCPServerTask(void); 
.................... void DHCPDisable(BYTE vInterface); 
.................... void DHCPEnable(BYTE vInterface); 
.................... BOOL DHCPIsEnabled(BYTE vInterface); 
.................... BOOL DHCPIsBound(BYTE vInterface); 
.................... BOOL DHCPStateChanged(BYTE vInterface); 
.................... BOOL DHCPIsServerDetected(BYTE vInterface); 
....................  
.................... #if defined(STACK_USE_DHCP_SERVER) 
.................... extern BOOL bDHCPServerEnabled; 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #ifndef __ICMP_H 
.................... #define __ICMP_H 
....................  
.................... void ICMPProcess(NODE_INFO *remote, WORD len); 
....................  
.................... BOOL ICMPBeginUsage(void); 
.................... void ICMPSendPing(DWORD dwRemoteIP); 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost); 
.................... LONG ICMPGetReply(void); 
.................... void ICMPEndUsage(void); 
....................  
.................... #if defined(__18CXX) 
.................... 	void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost); 
.................... #else 
.................... 	#define ICMPSendPingToHostROM(a) 	ICMPSendPingToHost((BYTE*)(a)) 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(MRF24WG) 
....................  #define WF_DisplayModuleAssertInfo() 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SCAN_TASK) 
....................    #include "ccs_wifiscan.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP2.H                                /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack using web pages     ///  
.................... /// on an MultiMediaCard.                                                /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   0 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   0 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_TRIPLE_ESCAPE 
.................... #define HTTP_USE_TRIPLE_ESCAPE   0 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_AUTHENTICATION 
.................... #define  HTTP_USE_AUTHENTICATION FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_LAST_MODIFIED_CHECK 
.................... #define HTTP_LAST_MODIFIED_CHECK FALSE 
.................... #endif 
....................  
.................... void HTTPInit(void); 
.................... void HTTPServer(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following two functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation 
.................... /// in http2.c for more help. 
....................  
.................... #if HTTP_USE_TRIPLE_ESCAPE 
.................... unsigned int8 http_format_char(char* file, unsigned int16 id, char *str, unsigned int8 max_ret); 
.................... #else 
.................... unsigned int8 http_format_char(char* file, char id, char *str, unsigned int8 max_ret); 
.................... #endif 
....................  
.................... void http_exec_cgi(char* file, char *key, char *val); 
....................  
.................... #if HTTP_USE_AUTHENTICATION 
....................  int1 http_check_authentication(char *fileName, char *user, char *pwd); 
.................... #endif 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TWITTER) 
....................    #include "ccs_twitter.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.h" 
.................... #endif 
....................  
.................... #define TickGetDiff(a, b)  (a-b) 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif        
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #ifndef STACK_USE_MPFS 
....................       #define STACK_USE_MPFS 
....................     #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #if !defined(STACK_CLIENT_MODE) 
....................        #define STACK_CLIENT_MODE 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_WIFI 
....................    // if defined, MyWFIsConnected() won't return TRUE in AdHoc mode until after 
....................    // it receives some IP traffic.  It will then stay connected until after 5 
....................    // minutes of no activity. 
....................    #define WIFI_ADHOC_CONNECTION_TIMER ((TICK)TICKS_PER_SECOND * 300) 
....................     
....................    extern unsigned int8 g_connectionProfileID; 
....................     
....................    #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    extern int1 g_WifiAdhocIsConn; 
....................    extern TICK g_WifiAdhocTickConn; 
....................    #endif 
....................     
....................    // this is optional 
....................    extern tWFDeviceInfo g_tWFDeviceInfo; 
....................    #define WIFI_GET_VERSION_INFO g_tWFDeviceInfo 
....................     
....................    extern unsigned int8 WIFI_channelList[16]; 
....................    extern unsigned int8 WIFI_numChannelsInList; 
....................    extern unsigned int8 WIFI_region; 
....................    extern int1 g_WifiConnectFail; 
....................     
....................    // this is similar to MACIsLinked() and WFisConnected().  this one has some 
....................    // filters and extra UI logic to better represent link status to the user. 
....................    // use this for UI displays. 
....................    // REMOVED - Use IsLinked() instead 
....................    //int1 MyWFisConnected(void); 
....................     
....................    // This routine does a few things: 
....................    //  * Reset WIFI unit if no it goes a long time without a connection, 
....................    //       because old modules would hang on WPA connect failure. 
....................    //  * Ad-Hoc connection timer support (WIFI_ADHOC_CONNECTION_TIMER) 
....................    //  * LED Traffic flickering and LED connection status 
....................    void WIFIConnectTask(void); 
....................    void WIFIConnectInitStates(void); 
....................     
....................    #if defined(WF_FORCE_NO_PS_POLL) 
....................       void WF_CCS_PsPollDisable(void); 
....................    #endif 
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void); 
....................  
.................... // A higher level version of MACIsLinked(). 
.................... //  - returns FALSE if MACIsLinked() is TRUE -but- DHCP is enabled and not 
.................... //       bound. 
.................... //  - returns FALSE in WIFI if using AdHoc mode and it has been a while 
.................... //       since no traffic 
.................... //  - else, returns MACIsLinked() 
.................... int1 IsLinked(void); 
....................  
.................... //this macro called by stack when new tcp/ip traffic tx/rx. 
.................... #if STACK_USE_WIFI 
....................    #define STACK_USE_CCS_TX_EVENT()  LinkTraffic(TRUE) 
....................    #define STACK_USE_CCS_RX_EVENT()  LinkTraffic(FALSE) 
....................    void LinkTraffic(int1 isTx); 
....................     
....................    #define WF_SECURITY_NUM_CHOICES  (WF_SECURITY_WEP_AUTO+1) 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "TCPIP Stack/mpfs.h" 
.................... /********************************************************************* 
....................  * 
....................  *               Microchip File System 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MPFS.h 
....................  * Dependencies:    StackTsk.H 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01     Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      5/31/06      Changed EEPROM addressing to 32 bits 
....................  * DSR/CCS              5/18/11     To be compatible with #import of mpfs 
....................  *                                   into program memory, MPFS_INVALID changed 
....................  *                                   to FFFFFFFF for all modes. 
.................... ********************************************************************/ 
.................... #ifndef __MPFS_H 
.................... #define __MPFS_H 
....................  
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) 
....................     typedef DWORD MPFS;                           // For default 32 bit addressing (use /ll option with MPFS.exe) 
....................     #define MPFS_INVALID            (0xffffffffu)   // For default 32 bit addressing (use /ll option with MPFS.exe) 
.................... //    typedef WORD MPFS;                        // For old short 16 bit addressing (use /b option with MPFS.exe) 
.................... //    #define MPFS_INVALID            (0xffff)      // For old short 16 bit addressing (use /b option with MPFS.exe) 
.................... #else 
....................    /* ccs bug, this creates confusion for compiler.  maybe ptr to ptr confusion? 
....................    #if defined(__C30__) 
....................       typedef DWORD MPFS; 
....................        #define MPFS_INVALID                (MPFS)(0xffffffffu) 
....................    #else 
....................       typedef ROM BYTE* MPFS; 
....................        #define MPFS_INVALID                (MPFS)(0xffffffu) 
....................    #endif 
....................    */ 
....................   #if defined(__PCD__) || defined(__PCH__)   //__CCS__ 
....................    #define MPFS_INVALID                (MPFS)(0xffffffffu) 
....................   #else 
....................    #define MPFS_INVALID                (MPFS)(0xffffffu) 
....................   #endif 
....................    #define MPFS   __ADDRESS__ 
.................... #endif 
....................  
.................... #define MPFS_NOT_AVAILABLE              (0x0u) 
....................  
.................... #if defined(MPFS_USE_EEPROM) 
....................    #if defined(USE_EEPROM_25LC1024) 
....................       #define MPFS_WRITE_PAGE_SIZE      (256u) 
....................    #else 
....................       #define MPFS_WRITE_PAGE_SIZE      (64u) 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... BOOL MPFSInit(void); 
.................... MPFS MPFSOpen(BYTE* name); 
.................... MPFS MPFSOpenROM(ROM BYTE* name); 
.................... BYTE MPFSGet(void); 
.................... void MPFSClose(void); 
.................... MPFS MPFSFormat(void); 
.................... BOOL MPFSPut(BYTE b); 
.................... MPFS MPFSPutEnd(void); 
.................... MPFS MPFSSeek(MPFS offset); 
.................... BOOL MPFSGetLong(DWORD *ul); 
....................  
.................... #if !defined(__MPFS_C) 
....................    extern BYTE mpfsOpenCount; 
....................     extern MPFS _currentHandle; 
....................     //extern BYTE _currentCount; //ccs bug removing for now because it doesn't match definition in mpfs.c 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSGetBegin(MPFS handle) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  * 
....................  * Input:           handle      - handle of file that is to be read 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS storage media for subsequent reads. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
....................     BOOL MPFSGetBegin(MPFS handle); 
.................... #else 
....................     #define MPFSGetBegin(handle)    (_currentHandle = handle) 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSGetEnd(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  *                  MPFSGetBegin() = TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current mpfs handle. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Ends on-going read cycle. 
....................  *                  MPFS handle that is returned must be used 
....................  *                  for subsequent begin gets.. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
....................     MPFS MPFSGetEnd(void); 
.................... #else 
....................     #define MPFSGetEnd()        _currentHandle 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL MPFSIsEOF(void) 
....................  * 
....................  * PreCondition:    MPFSGetBegin() must be called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if current file read has reached end of file. 
....................  *                  FALSE if otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define MPFSIsEOF()     (_currentHandle == MPFS_INVALID) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSPutBegin(MPFS handle) 
....................  * 
....................  * PreCondition:    MPFSInit() and MPFSFormat() are already called. 
....................  * 
....................  * Input:           handle  - handle to where put to begin 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS image to get re-written 
....................  * 
....................  * Note:            MPFS will be unaccessible until MPFSClose is 
....................  *                  called. 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
....................     BOOL MPFSPutBegin(MPFS handle); 
.................... #else 
....................     #define MPFSPutBegin(handle)        (_currentHandle = handle) 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSTell(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          current MPFS file pointer 
....................  * 
....................  * Side Effects:    None. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None. 
....................  ********************************************************************/ 
.................... #define MPFSTell()      (_currentHandle) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BYTE MPFSInUse(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          No. of file currently open. 
....................  *                  If == 0, MPFS is not in use. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define MPFSIsInUse()       (mpfsOpenCount) 
....................  
.................... #endif 
....................  
....................     
....................    extern MPFS _MpfsEofLoc; 
....................     
....................    //returns number of bytes read before EOF. 
....................    //if it returns n then no EOF. 
....................    unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n); 
.................... #endif 
....................  
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void); 
.................... #endif 
....................  
.................... BYTE GenerateRandomByteFromTimers(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/TCPIP Stack/TCPIPConfig.h" 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
....................  
.................... #define STACK_USE_ICMP_SERVER    1 
.................... #define STACK_USE_TCP            1 
.................... #define STACK_USE_DHCP_CLIENT    1 
....................  
.................... #define STACK_CCS_SMTP_TX_SIZE    0 
.................... #define STACK_CCS_SMTP_RX_SIZE    0 
....................  
.................... #define STACK_USE_CCS_HTTP2_SERVER 
.................... #define STACK_CCS_HTTP2_SERVER_TX_SIZE    1500 
.................... #define STACK_CCS_HTTP2_SERVER_RX_SIZE    500 
.................... #define HTTP_NUM_SOCKETS                  1 
.................... #define HTTP_PORT                         (80u) 
.................... #define HTTP_USE_DOUBLE_ESCAPE            1 
.................... #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................  
.................... #define STACK_MY_TELNET_SERVER_TX_SIZE    0 
.................... #define STACK_MY_TELNET_SERVER_RX_SIZE    0 
....................  
.................... #define MY_DEFAULT_HOST_NAME      "CCS_EXAMPLES" 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1      (0x0) 
.................... #define MY_DEFAULT_MAC_BYTE2      (0x20) 
.................... #define MY_DEFAULT_MAC_BYTE3      (0x30) 
.................... #define MY_DEFAULT_MAC_BYTE4      (0x40) 
.................... #define MY_DEFAULT_MAC_BYTE5      (0x50) 
.................... #define MY_DEFAULT_MAC_BYTE6      (0x60) 
....................  
.................... #define MY_DEFAULT_IP_ADDR_BYTE1  (192ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2  (168ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3  (1ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4  (118ul) 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1     (192ul) 
.................... #define MY_DEFAULT_GATE_BYTE2     (168ul) 
.................... #define MY_DEFAULT_GATE_BYTE3     (1ul) 
.................... #define MY_DEFAULT_GATE_BYTE4     (1ul) 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE2     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE3     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE4     (0ul) 
....................  
.................... #define TCP_CONFIGURATION      1 
....................  
.................... #define TCP_ETH_RAM_SIZE (STACK_CCS_SMTP_TX_SIZE + \ 
....................                           STACK_CCS_SMTP_RX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_TX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_RX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_TX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_RX_SIZE + \ 
....................                           100*TCP_CONFIGURATION) 
....................  
.................... // Define names of socket types 
.................... #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
.................... #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
.................... #define TCP_PURPOSE_TELNET             2 
.................... #define TCP_PURPOSE_FTP_COMMAND        3 
.................... #define TCP_PURPOSE_FTP_DATA           4 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
.................... #define TCP_PURPOSE_UART_2_TCP_BRIDGE  7 
.................... #define TCP_PURPOSE_HTTP_SERVER        8 
.................... #define TCP_PURPOSE_DEFAULT            9 
.................... #define TCP_PURPOSE_BERKELEY_SERVER    10 
.................... #define TCP_PURPOSE_BERKELEY_CLIENT    11 
.................... #define TCP_PURPOSE_CCS_SMTP           0x40 
....................  
.................... typedef struct 
.................... { 
....................    BYTE vSocketPurpose; 
....................    BYTE vMemoryMedium; 
....................    WORD wTXBufferSize; 
....................    WORD wRXBufferSize; 
.................... } TCPSocketInitializer_t; 
....................  
.................... #if TCP_CONFIGURATION > 0 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................          {TCP_PURPOSE_HTTP_SERVER, TCP_ETH_RAM, STACK_CCS_HTTP2_SERVER_TX_SIZE, STACK_CCS_HTTP2_SERVER_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_SMTP_CLIENT) 
....................          {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, STACK_CCS_SMTP_TX_SIZE, STACK_CCS_SMTP_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_MY_TELNET_SERVER) 
....................          {TCP_PURPOSE_TELNET, TCP_ETH_RAM, STACK_MY_TELNET_SERVER_TX_SIZE, STACK_MY_TELNET_SERVER_RX_SIZE}, 
....................       #endif 
....................    }; 
.................... #else 
....................    #undef TCP_CONFIGURATION 
....................    #define TCP_CONFIGURATION 1 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 250, 250} 
....................    }; 
.................... #endif 
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/TCPIP Stack/HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk2.c" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
.................... // 
.................... // __DISABLE_WIFI_INTERRUPT__ was supported in an older 5.3x version of the 
.................... // stack, but it is currently not supported anymore. 
....................  
.................... #ifndef __CCS_STACKTSK2_C__ 
.................... #define __CCS_STACKTSK2_C__ 
....................  
.................... #if defined(__DISABLE_WIFI_INTERRUPT__) 
....................    #error This has been removed. 
.................... #endif 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if defined(__PCH__) 
.................... #int_timer0 NOCLEAR 
.................... void ISRTimer0(void) 
.................... { 
....................    TickUpdate(); 
*
000C8:  BRA    00AA
.................... } 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && !defined(__DISABLE_WIFI_INTERRUPT__) 
.................... #int_EXT HIGH NOCLEAR 
....................    void ISREXT0(void) 
....................    { 
....................          WFEintISR(); 
....................        
....................    } 
.................... #endif 
....................  
.................... #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    int1 g_WifiAdhocIsConn = FALSE; 
....................    TICK g_WifiAdhocTickConn; 
....................    #define WIFIAdhocConnectionPing()   g_WifiAdhocIsConn=TRUE; g_WifiAdhocTickConn=TickGet() 
....................    #define WIFIAdhocConnectionReset()  g_WifiAdhocIsConn = FALSE 
.................... #endif 
....................  
.................... #if !defined(wf_debug_printf) 
....................    #define wf_debug_printf(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) 
....................    #define wf_debug_putc(c) 
.................... #endif 
....................  
.................... #include "StackTsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *   TCP/IP Stack Manager 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Handles internal RX packet pre-processing prior to dispatching  
....................  *    to upper application layers. 
....................  *    -Reference: AN833 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    ARP, IP, Network layer interface (ENC28J60.c,  
....................  *               ETH97J60.c, ENCX24J600.c, or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  * 
....................  * Darren Rook/CCS       4/13/11    Added some CCS modules (see STACK_USE_CCS_*) 
....................  *                                  Added STACK_USE_CCS_RX_EVENT() macro on TCP/IP traffic.  
.................... ********************************************************************/ 
.................... #define __STACKTSK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
000CA:  GOTO   0064
.................... #if defined( WF_CS_TRIS ) 
....................     #if defined( WF_CONFIG_CONSOLE ) 
....................         #include "TCPIP Stack/WFConsole.h" 
....................     #endif 
....................     #if defined( STACK_USE_EZ_CONFIG ) || defined( EZ_CONFIG_SCAN ) 
....................         #include "TCPIP Stack/WFEasyConfig.h" 
....................     #endif 
....................    #include "TCPIP Stack/WFApi.h" 
.................... #endif 
....................  
.................... // Stack FSM states. 
.................... typedef enum 
.................... { 
....................     SM_STACK_IDLE, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
.................... BOOL g_DhcpRenew = FALSE; 
.................... extern void SetDhcpProgressState(void); 
.................... UINT32 g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................    static BOOL once = FALSE; 
....................     smStack                     = SM_STACK_IDLE; 
*
014F4:  MOVLB  1
014F6:  CLRF   x05
....................  
.................... #if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT) 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
014F8:  BSF    4F.7
....................  
.................... #endif 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
....................    g_DhcpRenew = FALSE; 
....................    g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................    if (!once) { 
014FA:  BTFSC  x10.0
014FC:  BRA    152C
....................       // Seed the LFSRRand() function 
....................       LFSRSeedRand(GenerateRandomDWORD()); 
014FE:  MOVLB  0
01500:  GOTO   0410
01504:  MOVFF  03,3C3
01508:  MOVFF  02,3C2
0150C:  MOVFF  01,3C1
01510:  MOVFF  00,3C0
01514:  MOVFF  03,3D9
01518:  MOVFF  02,3D8
0151C:  MOVFF  01,3D7
01520:  MOVFF  00,3D6
01524:  CALL   03AE
....................       once = TRUE; 
01528:  MOVLB  1
0152A:  BSF    x10.0
....................    } 
....................  
....................     MACInit(); 
0152C:  MOVLB  0
0152E:  GOTO   0766
....................  
.................... #if defined (WF_AGGRESSIVE_PS) && defined (WF_CS_TRIS) 
....................    WFEnableAggressivePowerSave(); 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_EZ_CONFIG) && !defined(__18CXX) 
....................     WFEasyConfigInit(); 
.................... #endif     
....................  
....................     ARPInit(); 
....................  
.................... #if defined(STACK_USE_UDP) 
....................     UDPInit(); 
01532:  GOTO   0A0E
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................     TCPInit(); 
01536:  BRA    11FC
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    BerkeleySocketInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................     HTTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    RSAInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................     SSLInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................     FTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    DHCPInit(0); 
01538:  MOVLB  3
0153A:  CLRF   xC9
0153C:  MOVLB  0
0153E:  RCALL  1398
....................     if(!AppConfig.Flags.bIsDHCPEnabled) 
01540:  BTFSC  4F.6
01542:  BRA    154C
....................     { 
....................         DHCPDisable(0); 
01544:  MOVLB  3
01546:  CLRF   xC0
01548:  MOVLB  0
0154A:  BRA    13D6
....................     } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     AutoIPInit(0); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    RandomInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPInit(); 
0154C:  BRA    146C
.................... #endif 
....................  
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
0154E:  GOTO   A8C2 (RETURN)
....................    TFTPSInit(); 
....................    #endif 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     WORD dataCount; 
....................     IP_ADDR tempLocalIP; 
....................    BYTE cFrameType; 
....................    BYTE cIPFrameType; 
....................  
....................     
....................     #if defined( WF_CS_TRIS ) 
....................         // This task performs low-level MAC processing specific to the MRF24W 
....................         MACProcess(); 
....................         #if defined( STACK_USE_EZ_CONFIG ) && !defined(__18CXX) 
....................             WFEasyConfigMgr(); 
....................         #endif 
....................          
....................        #if defined(STACK_USE_DHCP_CLIENT) 
....................            // Normally, an application would not include  DHCP module 
....................            // if it is not enabled. But in case some one wants to disable 
....................            // DHCP module at run-time, remember to not clear our IP 
....................            // address if link is removed. 
....................            if(AppConfig.Flags.bIsDHCPEnabled) 
....................            { 
....................               if(g_DhcpRenew == TRUE) 
....................               { 
....................                  g_DhcpRenew = FALSE; 
....................                   AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
....................                  AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
....................                  AppConfig.Flags.bInConfigMode = TRUE; 
....................                  DHCPInit(0); 
....................                g_DhcpRetryTimer = (UINT32)TickGet(); 
....................               } else { 
....................                  if (g_DhcpRetryTimer && TickGet() - g_DhcpRetryTimer >= TICKS_PER_SECOND * 8) { 
....................                   DHCPInit(0); 
....................                   g_DhcpRetryTimer = (UINT32)TickGet(); 
....................                  } 
....................               } 
....................             
....................               // DHCP must be called all the time even after IP configuration is 
....................               // discovered. 
....................               // DHCP has to account lease expiration time and renew the configuration 
....................               // time. 
....................               DHCPTask(); 
....................                
....................               if(DHCPIsBound(0)) { 
....................                  AppConfig.Flags.bInConfigMode = FALSE; 
....................                g_DhcpRetryTimer = 0; 
....................               } 
....................            } 
....................        #endif // STACK_USE_DHCP_CLIENT 
....................          
....................     #endif // WF_CS_TRIS 
....................  
....................  
....................    #if defined(STACK_USE_DHCP_CLIENT) && !defined(WF_CS_TRIS) 
....................    // Normally, an application would not include  DHCP module 
....................    // if it is not enabled. But in case some one wants to disable 
....................    // DHCP module at run-time, remember to not clear our IP 
....................    // address if link is removed. 
....................    if(AppConfig.Flags.bIsDHCPEnabled) 
*
06BC6:  BTFSS  4F.6
06BC8:  BRA    6C3E
....................    { 
....................       static BOOL bLastLinkState = FALSE; 
....................       BOOL bCurrentLinkState; 
....................        
....................       bCurrentLinkState = MACIsLinked(); 
06BCA:  CALL   160E
06BCE:  MOVLB  3
06BD0:  BCF    xC8.0
06BD2:  BTFSC  01.0
06BD4:  BSF    xC8.0
....................       if(bCurrentLinkState != bLastLinkState) 
06BD6:  CLRF   00
06BD8:  MOVLB  1
06BDA:  BTFSC  x10.1
06BDC:  BSF    00.0
06BDE:  MOVLB  3
06BE0:  MOVF   xC8,W
06BE2:  XORWF  00,W
06BE4:  ANDLW  01
06BE6:  BZ    6C28
....................       { 
....................          bLastLinkState = bCurrentLinkState; 
06BE8:  MOVLB  1
06BEA:  BCF    x10.1
06BEC:  MOVLB  3
06BEE:  BTFSS  xC8.0
06BF0:  BRA    6BF8
06BF2:  MOVLB  1
06BF4:  BSF    x10.1
06BF6:  MOVLB  3
....................          if(!bCurrentLinkState) 
06BF8:  BTFSC  xC8.0
06BFA:  BRA    6C28
....................          { 
....................             AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
06BFC:  MOVFF  3A,26
06C00:  MOVFF  39,25
06C04:  MOVFF  38,24
06C08:  MOVFF  37,23
....................             AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
06C0C:  MOVFF  3E,2A
06C10:  MOVFF  3D,29
06C14:  MOVFF  3C,28
06C18:  MOVFF  3B,27
....................             AppConfig.Flags.bInConfigMode = TRUE; 
06C1C:  BSF    4F.7
....................             DHCPInit(0); 
06C1E:  CLRF   xC9
06C20:  MOVLB  0
06C22:  CALL   1398
06C26:  MOVLB  3
....................          } 
....................       } 
....................     
....................       // DHCP must be called all the time even after IP configuration is 
....................       // discovered. 
....................       // DHCP has to account lease expiration time and renew the configuration 
....................       // time. 
....................       DHCPTask(); 
06C28:  MOVLB  0
06C2A:  GOTO   2A80
....................        
....................       if(DHCPIsBound(0)) 
06C2E:  MOVLB  3
06C30:  CLRF   xC9
06C32:  MOVLB  0
06C34:  GOTO   2FC6
06C38:  MOVF   01,F
06C3A:  BZ    6C3E
....................          AppConfig.Flags.bInConfigMode = FALSE; 
06C3C:  BCF    4F.7
....................    } 
....................    #endif 
....................     
....................  
....................     #if defined (STACK_USE_AUTO_IP) 
....................     AutoIPTasks(); 
....................     #endif 
....................  
....................    #if defined(STACK_USE_TCP) 
....................    // Perform all TCP time related tasks (retransmit, send acknowledge, close connection, etc) 
....................    TCPTick(); 
06C3E:  GOTO   3D28
....................    #endif 
....................  
....................  
....................    #if defined(STACK_USE_UDP) 
....................    UDPTask(); 
06C42:  GOTO   4580
....................    #endif 
....................  
....................   #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpTask(); 
....................   #endif 
....................  
....................    // Process as many incomming packets as we can 
....................    while(1) 
....................    { 
....................       //if using the random module, generate entropy 
....................       #if defined(STACK_USE_RANDOM) 
....................          RandomAdd(remoteNode.MACAddr.v[5]); 
....................       #endif 
....................  
....................       // We are about to fetch a new packet, make sure that the  
....................       // UDP module knows that any old RX data it has laying  
....................       // around will now be gone. 
....................       #if defined(STACK_USE_UDP) 
....................          UDPDiscard(); 
06C46:  CALL   266C
....................       #endif 
....................  
....................       // Fetch a packet (throws old one away, if not thrown away  
....................       // yet) 
....................       if(!MACGetHeader(&remoteNode.MACAddr, &cFrameType)) 
06C4A:  MOVLW  01
06C4C:  MOVLB  3
06C4E:  MOVWF  xCA
06C50:  MOVLW  0A
06C52:  MOVWF  xC9
06C54:  MOVLW  03
06C56:  MOVWF  xCC
06C58:  MOVLW  C6
06C5A:  MOVWF  xCB
06C5C:  MOVLB  0
06C5E:  GOTO   460A
06C62:  MOVF   01,F
06C64:  BNZ   6C68
....................          break; 
06C66:  BRA    6DAE
....................  
....................       // When using a WiFi module, filter out all incoming packets that have  
....................       // the same source MAC address as our own MAC address.  This is to  
....................       // prevent receiving and passing our own broadcast packets up to other  
....................       // layers and avoid, for example, having our own gratuitous ARPs get  
....................       // answered by ourself. 
....................       #if defined(WF_CS_TRIS) 
....................          if(memcmp((void*)&remoteNode.MACAddr, (void*)&AppConfig.MyMACAddr, 6) == 0u) 
....................             continue; 
....................       #endif 
....................        
....................       #if defined(STACK_USE_CCS_RX_EVENT) 
....................       STACK_USE_CCS_RX_EVENT();  //__CCS__ 
....................       #endif 
....................        
....................       // Dispatch the packet to the appropriate handler 
....................       switch(cFrameType) 
06C68:  MOVLB  3
06C6A:  MOVF   xC6,W
06C6C:  XORLW  06
06C6E:  MOVLB  0
06C70:  BZ    6C78
06C72:  XORLW  06
06C74:  BZ    6C7E
06C76:  BRA    6DAC
....................       { 
....................          case MAC_ARP: 
....................             ARPProcess(); 
06C78:  GOTO   4940
....................             break; 
06C7C:  BRA    6DAC
....................     
....................          case MAC_IP: 
....................             if(!IPGetHeader(&tempLocalIP, &remoteNode, &cIPFrameType, &dataCount)) 
06C7E:  MOVLW  03
06C80:  MOVLB  3
06C82:  MOVWF  xCA
06C84:  MOVLW  C2
06C86:  MOVWF  xC9
06C88:  MOVLW  01
06C8A:  MOVWF  xCC
06C8C:  MOVLW  06
06C8E:  MOVWF  xCB
06C90:  MOVLW  03
06C92:  MOVWF  xCE
06C94:  MOVLW  C7
06C96:  MOVWF  xCD
06C98:  MOVLW  03
06C9A:  MOVWF  xD0
06C9C:  MOVLW  C0
06C9E:  MOVWF  xCF
06CA0:  MOVLB  0
06CA2:  GOTO   4B10
06CA6:  MOVF   01,F
06CA8:  BNZ   6CAC
....................                break; 
06CAA:  BRA    6DAC
....................  
....................             #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................             if(cIPFrameType == IP_PROT_ICMP) 
06CAC:  MOVLB  3
06CAE:  DECFSZ xC7,W
06CB0:  BRA    6D5A
....................             { 
....................                #if defined(STACK_USE_IP_GLEANING) 
....................                if(AppConfig.Flags.bInConfigMode && AppConfig.Flags.bIsDHCPEnabled) 
....................                { 
....................                   // According to "IP Gleaning" procedure, 
....................                   // when we receive an ICMP packet with a valid 
....................                   // IP address while we are still in configuration 
....................                   // mode, accept that address as ours and conclude 
....................                   // configuration mode. 
....................                   if(tempLocalIP.Val != 0xffffffff) 
....................                   { 
....................                      AppConfig.Flags.bInConfigMode = FALSE; 
....................                      AppConfig.MyIPAddr = tempLocalIP; 
....................                   } 
....................                } 
....................                #endif 
....................  
....................                // Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees 
....................                if( (tempLocalIP.Val == AppConfig.MyIPAddr.Val) || 
....................                   (tempLocalIP.Val == 0xFFFFFFFF) || 
.................... #if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................                                                 (tempLocalIP.Val == 0xFB0000E0) || 
.................... #endif 
....................                   (tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val))) 
06CB2:  MOVF   23,W
06CB4:  SUBWF  xC2,W
06CB6:  BNZ   6CCA
06CB8:  MOVF   24,W
06CBA:  SUBWF  xC3,W
06CBC:  BNZ   6CCA
06CBE:  MOVF   25,W
06CC0:  SUBWF  xC4,W
06CC2:  BNZ   6CCA
06CC4:  MOVF   26,W
06CC6:  SUBWF  xC5,W
06CC8:  BZ    6D3C
06CCA:  INCFSZ xC2,W
06CCC:  BRA    6CDC
06CCE:  INCFSZ xC3,W
06CD0:  BRA    6CDC
06CD2:  INCFSZ xC4,W
06CD4:  BRA    6CDC
06CD6:  INCFSZ xC5,W
06CD8:  BRA    6CDC
06CDA:  BRA    6D3C
06CDC:  MOVF   23,W
06CDE:  ANDWF  27,W
06CE0:  MOVWF  xC9
06CE2:  MOVF   24,W
06CE4:  ANDWF  28,W
06CE6:  MOVWF  xCA
06CE8:  MOVF   25,W
06CEA:  ANDWF  29,W
06CEC:  MOVWF  xCB
06CEE:  MOVF   26,W
06CF0:  ANDWF  2A,W
06CF2:  MOVWF  xCC
06CF4:  MOVFF  27,00
06CF8:  COMF   00,F
06CFA:  MOVFF  28,01
06CFE:  COMF   01,F
06D00:  MOVFF  29,02
06D04:  COMF   02,F
06D06:  MOVFF  2A,03
06D0A:  COMF   03,F
06D0C:  MOVF   00,W
06D0E:  IORWF  xC9,W
06D10:  MOVWF  00
06D12:  MOVF   01,W
06D14:  IORWF  xCA,W
06D16:  MOVWF  01
06D18:  MOVF   02,W
06D1A:  IORWF  xCB,W
06D1C:  MOVWF  02
06D1E:  MOVF   03,W
06D20:  IORWF  xCC,W
06D22:  MOVWF  03
06D24:  MOVF   00,W
06D26:  SUBWF  xC2,W
06D28:  BNZ   6D54
06D2A:  MOVF   01,W
06D2C:  SUBWF  xC3,W
06D2E:  BNZ   6D54
06D30:  MOVF   02,W
06D32:  SUBWF  xC4,W
06D34:  BNZ   6D54
06D36:  MOVF   03,W
06D38:  SUBWF  xC5,W
06D3A:  BNZ   6D54
....................                { 
....................                   ICMPProcess(&remoteNode, dataCount); 
06D3C:  MOVLW  01
06D3E:  MOVWF  xCA
06D40:  MOVLW  06
06D42:  MOVWF  xC9
06D44:  MOVFF  3C1,3CC
06D48:  MOVFF  3C0,3CB
06D4C:  MOVLB  0
06D4E:  GOTO   4C16
06D52:  MOVLB  3
....................                } 
....................  
....................                break; 
06D54:  MOVLB  0
06D56:  BRA    6DAC
06D58:  MOVLB  3
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_TCP) 
....................             if(cIPFrameType == IP_PROT_TCP) 
06D5A:  MOVF   xC7,W
06D5C:  SUBLW  06
06D5E:  BNZ   6D80
....................             { 
....................                TCPProcess(&remoteNode, &tempLocalIP, dataCount); 
06D60:  MOVLW  01
06D62:  MOVWF  xCA
06D64:  MOVLW  06
06D66:  MOVWF  xC9
06D68:  MOVLW  03
06D6A:  MOVWF  xCC
06D6C:  MOVLW  C2
06D6E:  MOVWF  xCB
06D70:  MOVFF  3C1,3CE
06D74:  MOVFF  3C0,3CD
06D78:  MOVLB  0
06D7A:  BRA    6736
....................                break; 
06D7C:  BRA    6DAC
06D7E:  MOVLB  3
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_UDP) 
....................             if(cIPFrameType == IP_PROT_UDP) 
06D80:  MOVF   xC7,W
06D82:  SUBLW  11
06D84:  BNZ   6DAA
....................             { 
....................                // Stop processing packets if we came upon a UDP frame with application data in it 
....................                if(UDPProcess(&remoteNode, &tempLocalIP, dataCount)) 
06D86:  MOVLW  01
06D88:  MOVWF  xCA
06D8A:  MOVLW  06
06D8C:  MOVWF  xC9
06D8E:  MOVLW  03
06D90:  MOVWF  xCC
06D92:  MOVLW  C2
06D94:  MOVWF  xCB
06D96:  MOVFF  3C1,3CE
06D9A:  MOVFF  3C0,3CD
06D9E:  MOVLB  0
06DA0:  BRA    6A3A
06DA2:  MOVF   01,F
06DA4:  BZ    6DA8
....................                   return; 
06DA6:  BRA    6DAE
06DA8:  MOVLB  3
....................             } 
....................             #endif 
....................  
....................             break; 
06DAA:  MOVLB  0
....................       } 
06DAC:  BRA    6C46
....................    } 
06DAE:  GOTO   A8C8 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackApplications(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Calls all loaded application modules. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackApplications(void) 
.................... { 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................    HTTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................    FTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_ANNOUNCE) 
....................    DiscoveryTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_NBNS) 
....................    NBNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DHCP_SERVER) 
....................    DHCPServerTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DNS_SERVER) 
....................    DNSServerTask(); 
....................    #endif 
....................     
....................    #if defined (STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TELNET_SERVER) 
....................    TelnetTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_REBOOT_SERVER) 
....................    RebootTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNTP_CLIENT) 
....................    SNTPClient(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    UDPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    TCPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SMTP_CLIENT) 
....................    SMTPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    UART2TCPBridgeTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPTask(); 
....................    #endif    
....................  
....................    #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPServer(); 
*
0A74E:  GOTO   991A
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    TFTPSTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_TWITTER)   //should be renamed STACK_USE_CCS_TWITTER 
0A752:  GOTO   A8CA (RETURN)
....................    TwitterTask();         // processes TCP tasks including the Tweet tasks 
....................    #endif    
.................... } 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_DHCP_CLIENT) 
.................... void RenewDhcp(void) 
.................... { 
....................     g_DhcpRenew = TRUE; 
....................     SetDhcpProgressState(); 
.................... }     
....................      
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "Helpers.c" 
.................... /********************************************************************* 
....................   
....................  Helper Functions for Microchip TCPIP Stack 
....................   
....................  FileName:      Helpers.c 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................       ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................       used in conjunction with a Microchip ethernet controller for 
....................       the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release; Rewritten CalcIPChecksum() to avoid 
....................               multi-byte shift operation; Added hexatob(), 
....................               btohexa_high(), and btohexa_low(); Optimized swapl(); 
....................               Added leftRotateDWORD() 
....................   5.36        Updated compile time check for ultoa(); 
....................  
....................    DARREN ROOK/CCS   Remove leftRotateDWORD() 
....................  
....................  ********************************************************************/ 
.................... #define __HELPERS_C 
....................  
.................... #include <stdarg.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDARG 
....................  
.................... #define _STDARG 
....................  
.................... typedef char * va_list; 
....................  
.................... #define va_start(a,b)  a=_VA_LIST 
.................... #define va_arg(a,b)    *(b *)_va_arg(a) 
.................... #define va_end 
.................... #define nargs          _nargs(&_va_list) 
....................  
.................... int8 _nargs(int8 * ptr) { 
....................   int8 n; 
....................  
....................   n=0; 
....................   while(*ptr) { 
....................     n++; 
....................     ptr+=*ptr; 
....................   } 
....................   return(n); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Default Random Number Generator seed. 0x41FE9F9E corresponds to calling LFSRSeedRand(1) 
.................... static DWORD dwLFSRRandSeed = 0x41FE9F9E; 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD LFSRSeedRand(DWORD dwSeed) 
....................  
....................   Summary: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Description: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    wSeed - The new 32-bit seed value to assign to the LFSR. 
....................  
....................   Returns: 
....................      The last seed in use.  This can be saved and restored by a subsequent call  
....................    to LFSRSeedRand() if you wish to use LFSRRand() in multiple contexts  
....................    without disrupting the random number sequence from the alternative  
....................    context.  For example, if App 1 needs a given sequence of random numbers  
....................    to perform a test, if you save and restore the seed in App 2, it is  
....................    possible for App 2 to not disrupt the random number sequence provided to  
....................    App 1, even if the number of times App 2 calls LFSRRand() varies. 
....................       
....................   Side Effects: 
....................    None 
....................     
....................   Remarks: 
....................    Upon initial power up, the internal seed is initialized to 0x1.  Using a  
....................    dwSeed value of 0x0 will return the same sequence of random numbers as  
....................    using the seed of 0x1. 
....................   ***************************************************************************/ 
.................... DWORD LFSRSeedRand(DWORD dwSeed) 
.................... { 
....................    DWORD dwOldSeed; 
....................    BYTE i; 
....................  
....................    // Save original seed to be returned later 
....................    dwOldSeed = dwLFSRRandSeed; 
*
003AE:  MOVFF  114,3DD
003B2:  MOVFF  113,3DC
003B6:  MOVFF  112,3DB
003BA:  MOVFF  111,3DA
....................  
....................    // Ensure zero isn't selected as a seed value, this would result in all  
....................    // 0x0000 output values from the LFSR 
....................    if(dwSeed == 0u) 
003BE:  MOVLB  3
003C0:  MOVF   xD6,F
003C2:  BNZ   03DA
003C4:  MOVF   xD7,F
003C6:  BNZ   03DA
003C8:  MOVF   xD8,F
003CA:  BNZ   03DA
003CC:  MOVF   xD9,F
003CE:  BNZ   03DA
....................       dwSeed = 1; 
003D0:  CLRF   xD9
003D2:  CLRF   xD8
003D4:  CLRF   xD7
003D6:  MOVLW  01
003D8:  MOVWF  xD6
....................        
....................    // Set the new seed 
....................    dwLFSRRandSeed = dwSeed; 
003DA:  MOVFF  3D9,114
003DE:  MOVFF  3D8,113
003E2:  MOVFF  3D7,112
003E6:  MOVFF  3D6,111
....................     
....................    // Run the LFSR a few times to get rid of obvious start up artifacts for  
....................    // seed values that don't have many set bits. 
....................    for(i = 0; i < 16; i++) 
003EA:  CLRF   xDE
003EC:  MOVF   xDE,W
003EE:  SUBLW  0F
003F0:  BNC   03FC
....................       LFSRRand(); 
003F2:  MOVLB  0
003F4:  RCALL  030E
003F6:  MOVLB  3
003F8:  INCF   xDE,F
003FA:  BRA    03EC
....................     
....................    // Return saved old seed 
....................    return dwOldSeed; 
003FC:  MOVFF  3DA,00
00400:  MOVFF  3DB,01
00404:  MOVFF  3DC,02
00408:  MOVFF  3DD,03
0040C:  MOVLB  0
0040E:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD LFSRRand(void) 
....................  
....................   Summary: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF). 
....................  
....................   Description: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF).  The random number is generated using a  
....................    Linear Feedback Shift Register (LFSR) type pseudo-random number generator  
....................    algorithm.  The LFSR can be seeded by calling the LFSRSeedRand() function 
....................    to generate the same sequence of random numbers as a prior string of calls. 
....................     
....................    The internal LFSR will repeat after 2^32-1 iterations. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 16-bit unsigned integer. 
....................       
....................   Side Effects: 
....................    The internal LFSR seed is updated so that the next call to LFSRRand()  
....................    will return a different random number. 
....................     
....................   Remarks: 
....................    None 
....................   ***************************************************************************/ 
.................... WORD LFSRRand(void) 
.................... { 
....................    BYTE i; 
....................     
....................    // Taps: 32 31 29 1 
....................    // Characteristic polynomial: x^32 + x^31 + x^29 + x + 1 
....................    // Repeat 15 times to make the shift pattern less obvious 
....................    for(i = 0; i < 15; i++) 
*
0030E:  MOVLB  4
00310:  CLRF   x18
00312:  MOVF   x18,W
00314:  SUBLW  0E
00316:  BNC   03A0
....................       dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul); 
00318:  BCF    FD8.0
0031A:  MOVLB  1
0031C:  RRCF   x14,W
0031E:  MOVLB  4
00320:  MOVWF  x1D
00322:  MOVLB  1
00324:  RRCF   x13,W
00326:  MOVLB  4
00328:  MOVWF  x1C
0032A:  MOVLB  1
0032C:  RRCF   x12,W
0032E:  MOVLB  4
00330:  MOVWF  x1B
00332:  MOVLB  1
00334:  RRCF   x11,W
00336:  MOVLB  4
00338:  MOVWF  x1A
0033A:  MOVLB  1
0033C:  MOVF   x11,W
0033E:  ANDLW  01
00340:  MOVWF  00
00342:  CLRF   01
00344:  CLRF   02
00346:  CLRF   03
00348:  MOVLW  00
0034A:  BSF    FD8.0
0034C:  SUBFWB 00,W
0034E:  MOVLB  4
00350:  MOVWF  x1E
00352:  MOVLW  00
00354:  SUBFWB 01,W
00356:  MOVWF  x1F
00358:  MOVLW  00
0035A:  SUBFWB 02,W
0035C:  MOVWF  x20
0035E:  MOVLW  00
00360:  SUBFWB 03,W
00362:  MOVWF  x21
00364:  MOVF   x1E,W
00366:  ANDLW  01
00368:  MOVWF  00
0036A:  CLRF   01
0036C:  CLRF   02
0036E:  MOVF   x21,W
00370:  ANDLW  D0
00372:  MOVWF  03
00374:  MOVF   00,W
00376:  XORWF  x1A,W
00378:  MOVLB  1
0037A:  MOVWF  x11
0037C:  MOVF   01,W
0037E:  MOVLB  4
00380:  XORWF  x1B,W
00382:  MOVLB  1
00384:  MOVWF  x12
00386:  MOVF   02,W
00388:  MOVLB  4
0038A:  XORWF  x1C,W
0038C:  MOVLB  1
0038E:  MOVWF  x13
00390:  MOVF   03,W
00392:  MOVLB  4
00394:  XORWF  x1D,W
00396:  MOVLB  1
00398:  MOVWF  x14
0039A:  MOVLB  4
0039C:  INCF   x18,F
0039E:  BRA    0312
....................  
....................    // Return 16-bits as pseudo-random number 
....................    return (WORD)dwLFSRRandSeed; 
003A0:  MOVLB  1
003A2:  MOVFF  111,01
003A6:  MOVFF  112,02
003AA:  MOVLB  0
003AC:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD GenerateRandomDWORD(void) 
....................  
....................   Summary: 
....................    Generates a random DWORD. 
....................  
....................   Description: 
....................    This function generates a random 32-bit integer.  It collects 
....................    randomness by comparing the A/D converter's internal R/C oscillator 
....................    clock with our main system clock.  By passing collected entropy to the 
....................    LFSRSeedRand()/LFSRRand() functions, the output is normalized (deskewed)  
....................    in the hopes of meeting statistical randomness tests. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 32-bit number. 
....................       
....................   Side Effects: 
....................    This function uses the A/D converter (and so you must disable  
....................    interrupts if you use the A/D converted in your ISR).  The LFSRRand()  
....................    function will be reseeded, and Timer0 (PIC18) and Timer1 (PIC24,  
....................    dsPIC, and PIC32) will be used.  TMR#H:TMR#L will have a new value. 
....................    Note that this is the same timer used by the Tick module. 
....................     
....................   Remarks: 
....................    This function times out after 1 second of attempting to generate the  
....................    random DWORD.  In such a case, the output may not be truly random.   
....................    Typically, this function executes in around 500,000 instruction cycles. 
....................     
....................    The intent of this function is to produce statistically random and 
....................    cryptographically secure random number.  Whether or not this is true on 
....................    all (or any) devices/voltages/temperatures is not tested. 
....................   ***************************************************************************/ 
.................... DWORD GenerateRandomDWORD(void) 
.................... { 
....................    BYTE vBitCount; 
....................    WORD w, wTime, wLastValue; 
....................    DWORD dwTotalTime; 
....................    union 
....................    { 
....................       DWORD   dw; 
....................       WORD   w[2]; 
....................    } randomResult; 
....................  
.................... #if defined __18CXX    
.................... { 
....................    BYTE ADCON0Save, ADCON2Save; 
....................    BYTE T0CONSave, TMR0HSave, TMR0LSave; 
....................  
....................    // Save hardware SFRs 
....................    ADCON0Save = ADCON0; 
*
00410:  MOVFF  FC2,3CF
....................    ADCON2Save = ADCON2; 
00414:  MOVFF  FC0,3D0
....................    T0CONSave = T0CON; 
00418:  MOVFF  FD5,3D1
....................    TMR0LSave = TMR0L; 
0041C:  MOVFF  FD6,3D3
....................    TMR0HSave = TMR0H; 
00420:  MOVFF  FD7,3D2
....................  
....................    // Set up Timer and A/D converter module 
....................    ADCON0 = 0x01;   // Turn on the A/D module 
00424:  MOVLW  01
00426:  MOVWF  FC2
....................    ADCON2 = 0x3F;   // 20 Tad acquisition, Frc A/D clock used for conversion 
00428:  MOVLW  3F
0042A:  MOVWF  FC0
....................    T0CON = 0x88;   // TMR0ON = 1, no prescalar 
0042C:  MOVLW  88
0042E:  MOVWF  FD5
....................    vBitCount = 0; 
00430:  MOVLB  3
00432:  CLRF   xC0
....................    dwTotalTime = 0; 
00434:  CLRF   xCA
00436:  CLRF   xC9
00438:  CLRF   xC8
0043A:  CLRF   xC7
....................    wLastValue = 0; 
0043C:  CLRF   xC6
0043E:  CLRF   xC5
....................    randomResult.dw = LFSRRand(); 
00440:  MOVLB  0
00442:  RCALL  030E
00444:  MOVLB  3
00446:  CLRF   xCE
00448:  CLRF   xCD
0044A:  MOVFF  02,3CC
0044E:  MOVFF  01,3CB
....................    while(1) 
....................    { 
....................       // Time the duration of an A/D acquisition and conversion 
....................       TMR0H = 0x00; 
00452:  CLRF   FD7
....................       TMR0L = 0x00; 
00454:  CLRF   FD6
....................       ADCON0bits.GO = 1; 
00456:  BSF    FC2.1
....................       ClrWdt(); 
00458:  CLRWDT
....................       while(ADCON0bits.GO); 
0045A:  BTFSC  FC2.1
0045C:  BRA    045A
....................       ((BYTE*)&wTime)[0] = TMR0L; 
0045E:  MOVFF  FD6,3C3
....................       ((BYTE*)&wTime)[1] = TMR0H; 
00462:  MOVFF  FD7,3C4
....................       w = LFSRRand(); 
00466:  MOVLB  0
00468:  RCALL  030E
0046A:  MOVFF  02,3C2
0046E:  MOVFF  01,3C1
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
00472:  MOVLB  3
00474:  MOVF   xC3,W
00476:  ADDWF  xC7,F
00478:  MOVF   xC4,W
0047A:  ADDWFC xC8,F
0047C:  MOVLW  00
0047E:  ADDWFC xC9,F
00480:  ADDWFC xCA,F
....................       if(dwTotalTime >= GetInstructionClock()) 
00482:  MOVF   xCA,F
00484:  BNZ   04A0
00486:  MOVF   xC9,W
00488:  SUBLW  4B
0048A:  BC    04BE
0048C:  XORLW  FF
0048E:  BNZ   04A0
00490:  MOVF   xC8,W
00492:  SUBLW  4A
00494:  BC    04BE
00496:  XORLW  FF
00498:  BNZ   04A0
0049A:  MOVF   xC7,W
0049C:  SUBLW  3F
0049E:  BC    04BE
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
004A0:  MOVLB  0
004A2:  RCALL  030E
004A4:  MOVF   01,W
004A6:  MOVLB  3
004A8:  XORWF  xCB,F
004AA:  MOVF   02,W
004AC:  XORWF  xCC,F
....................          randomResult.w[1] ^= LFSRRand(); 
004AE:  MOVLB  0
004B0:  RCALL  030E
004B2:  MOVF   01,W
004B4:  MOVLB  3
004B6:  XORWF  xCD,F
004B8:  MOVF   02,W
004BA:  XORWF  xCE,F
....................          break; 
004BC:  BRA    052C
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
004BE:  MOVF   xC3,W
004C0:  SUBWF  xC5,W
004C2:  BNZ   04CC
004C4:  MOVF   xC4,W
004C6:  SUBWF  xC6,W
004C8:  BNZ   04CC
....................          continue; 
004CA:  BRA    0452
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
004CC:  MOVF   xC3,W
004CE:  SUBWF  xC5,W
004D0:  MOVWF  00
004D2:  MOVF   xC4,W
004D4:  SUBWFB xC6,W
004D6:  MOVWF  03
004D8:  MOVF   00,W
004DA:  ADDWF  xC1,W
004DC:  MOVWF  xD4
004DE:  MOVF   03,W
004E0:  ADDWFC xC2,W
004E2:  MOVWF  xD5
004E4:  CLRF   xD9
004E6:  CLRF   xD8
004E8:  MOVWF  xD7
004EA:  MOVFF  3D4,3D6
004EE:  MOVLB  0
004F0:  RCALL  03AE
....................       wLastValue = wTime; 
004F2:  MOVFF  3C4,3C6
004F6:  MOVFF  3C3,3C5
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
004FA:  BCF    FD8.0
004FC:  MOVLB  3
004FE:  RLCF   xCB,F
00500:  RLCF   xCC,F
00502:  RLCF   xCD,F
00504:  RLCF   xCE,F
....................       if(LFSRRand() & 0x0080) 
00506:  MOVLB  0
00508:  RCALL  030E
0050A:  MOVFF  02,3D5
0050E:  MOVFF  01,3D4
00512:  MOVLB  3
00514:  MOVF   01,W
00516:  ANDLW  80
00518:  MOVWF  00
0051A:  CLRF   03
0051C:  MOVF   00,W
0051E:  IORWF  03,W
00520:  BZ    0524
....................          randomResult.w[0] |= 0x1; 
00522:  BSF    xCB.0
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
00524:  INCF   xC0,F
00526:  BNZ   052A
....................          break; 
00528:  BRA    052C
0052A:  BRA    0452
....................    } 
....................  
....................    // Restore hardware SFRs 
....................    ADCON0 = ADCON0Save; 
0052C:  MOVFF  3CF,FC2
....................    ADCON2 = ADCON2Save; 
00530:  MOVFF  3D0,FC0
....................    TMR0H = TMR0HSave; 
00534:  MOVFF  3D2,FD7
....................    TMR0L = TMR0LSave; 
00538:  MOVFF  3D3,FD6
....................    T0CON = T0CONSave; 
0053C:  MOVFF  3D1,FD5
.................... } 
.................... #else 
.................... { 
....................    WORD AD1CON1Save, AD1CON2Save, AD1CON3Save; 
....................    WORD T1CONSave, PR1Save; 
....................  
....................    // Save hardware SFRs 
....................    AD1CON1Save = AD1CON1; 
....................    AD1CON2Save = AD1CON2; 
....................    AD1CON3Save = AD1CON3; 
....................    T1CONSave = T1CON; 
....................    PR1Save = PR1; 
....................  
....................    // Set up Timer and A/D converter module 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = 0x9F00;      // Frc A/D clock, 31 Tad acquisition 
....................    AD1CON2 = 0x003F;      // Interrupt after every 16th sample/convert 
....................    AD1CON1 = 0x80E4;      // Turn on the A/D module, auto-convert 
....................    T1CON = 0x8000;         // TON = 1, no prescalar 
....................    PR1 = 0xFFFF;         // Don't clear timer early 
....................    vBitCount = 0; 
....................    dwTotalTime = 0; 
....................    wLastValue = 0; 
....................    randomResult.dw = LFSRRand(); 
....................    while(1) 
....................    { 
....................       ClrWdt(); 
....................       #if defined(__C30__) 
....................          while(!IFS0bits.AD1IF); 
....................       #else 
....................          while(!IFS1bits.AD1IF); 
....................       #endif 
....................       wTime = TMR1; 
....................       TMR1 = 0x0000; 
....................  
....................       #if defined(__C30__) 
....................          IFS0bits.AD1IF = 0; 
....................       #else 
....................          IFS1CLR = _IFS1_AD1IF_MASK; 
....................       #endif 
....................       w = LFSRRand(); 
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
....................       if(dwTotalTime >= GetInstructionClock()) 
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
....................          randomResult.w[1] ^= LFSRRand(); 
....................          break; 
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
....................          continue; 
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
....................       wLastValue = wTime; 
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
....................       if(LFSRRand() & 0x0080) 
....................          randomResult.w[0] |= 0x1; 
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
....................          break; 
....................    } 
....................  
....................  
....................    // Restore hardware SFRs 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = AD1CON3Save; 
....................    AD1CON2 = AD1CON2Save; 
....................    AD1CON1 = AD1CON1Save; 
....................    T1CON = T1CONSave; 
....................    PR1 = PR1Save; 
.................... } 
.................... #endif 
....................  
....................    return randomResult.dw; 
00540:  MOVFF  3CB,00
00544:  MOVFF  3CC,01
00548:  MOVFF  3CD,02
0054C:  MOVFF  3CE,03
00550:  MOVLB  0
00552:  GOTO   1504 (RETURN)
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_HTTP_SERVER) 
.................... /***************************************************************************** 
....................   Function: 
....................    void UnencodeURL(BYTE* URL) 
....................  
....................   Summary: 
....................    Decodes a URL-encoded string. 
....................  
....................   Description: 
....................    This function is deprecated except for use with HTTP Classic.  It 
....................    attempts to decode a URL encoded string, converting all hex escape 
....................    sequences into a literal byte.  However, it is inefficient over long 
....................    strings and does not handle URL-encoded data strings ('&' and '='). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    URL - the null-terminated string to decode 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UnencodeURL(BYTE* URL) 
.................... { 
....................    BYTE *Right, *Copy; 
....................    WORD_VAL Number; 
....................  
....................    while((Right = (BYTE*)strchr((char*)URL, '%'))) 
....................    { 
....................       // Make sure the string is long enough 
....................       if(Right[1] == '\0') 
....................          break; 
....................       if(Right[2] == '\0') 
....................          break; 
....................  
....................       // Update the string in place 
....................       Number.v[0] = Right[2]; 
....................       Number.v[1] = Right[1]; 
....................       *Right++ = hexatob(Number); 
....................       URL = Right; 
....................  
....................       // Remove two blank spots by shifting all remaining characters right two 
....................       Copy = Right + 2; 
....................       while((*Right++ = *Copy++)); 
....................    } 
.................... }           
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................   ***************************************************************************/ 
.................... BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while((i = *str++)) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................    
....................   Remarks: 
....................    This function is aliased to StringToIPAddress on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while(i = *str++) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen,  
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Decodes a Base-64 array to its literal representation. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of Base-64 encoded data 
....................    wSourceLen   - Length of the Base-64 source data 
....................    cDestData   - Pointer to write the decoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of decoded bytes written to cDestData. 
....................    
....................   Remarks: 
....................    This function is binary safe and will ignore invalid characters (CR, LF,  
....................    etc).  If cSourceData is equal to cDestData, the data will be converted 
....................    in-place.  If cSourceData is not equal to cDestData, but the regions  
....................    overlap, the behavior is undefined. 
....................     
....................    Decoded data is always at least 1/4 smaller than the source data. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_DECODE) 
.................... WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i; 
....................    BYTE vByteNumber; 
....................    WORD wBytesOutput; 
....................  
....................    vByteNumber = 0; 
....................    wBytesOutput = 0; 
....................  
....................    // Loop over all provided bytes 
....................    while(wSourceLen--) 
....................    { 
....................       // Fetch a Base64 byte and decode it to the original 6 bits 
....................       i = *cSourceData++; 
....................       if(i >= 'A' && i <= 'Z')   // Regular data 
....................          i -= 'A' - 0; 
....................       else if(i >= 'a' && i <= 'z') 
....................          i -= 'a' - 26; 
....................       else if(i >= '0' && i <= '9') 
....................          i -= '0' - 52; 
....................       else if(i == '+' || i == '-') 
....................          i = 62; 
....................       else if(i == '/' || i == '_') 
....................          i = 63; 
....................       else                   // Skip all padding (=) and non-Base64 characters 
....................          continue; 
....................  
....................  
....................       // Write the 6 bits to the correct destination location(s) 
....................       if(vByteNumber == 0u) 
....................       { 
....................          vByteNumber++; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 2; 
....................       } 
....................       else if(vByteNumber == 1u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 4; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 4; 
....................       } 
....................       else if(vByteNumber == 2u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 2; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 6; 
....................       } 
....................       else 
....................       { 
....................          vByteNumber = 0; 
....................          *cDestData++ |= i; 
....................       } 
....................    } 
....................  
....................    return wBytesOutput; 
.................... } 
.................... #endif   // #if defined(STACK_USE_BASE64_DECODE) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, 
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Encodes a binary array to Base-64. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of binary data 
....................    wSourceLen   - Length of the binary source data 
....................    cDestData   - Pointer to write the Base-64 encoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of encoded bytes written to cDestData.  This will always be 
....................      a multiple of 4. 
....................    
....................   Remarks: 
....................    Encoding cannot be performed in-place.  If cSourceData overlaps with  
....................    cDestData, the behavior is undefined. 
....................     
....................    Encoded data is always at least 1/3 larger than the source data.  It may 
....................    be 1 or 2 bytes larger than that. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP_CLIENT) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i, j; 
....................    BYTE vOutput[4]; 
....................    WORD wOutputLen; 
....................  
....................    wOutputLen = 0; 
....................    while(wDestLen >= 4u) 
....................    { 
....................       // Start out treating the output as all padding 
....................       vOutput[0] = 0xFF; 
....................       vOutput[1] = 0xFF; 
....................       vOutput[2] = 0xFF; 
....................       vOutput[3] = 0xFF; 
....................  
....................       // Get 3 input octets and split them into 4 output hextets (6-bits each)  
....................       if(wSourceLen == 0u) 
....................          break; 
....................       i = *cSourceData++; 
....................       wSourceLen--; 
....................       vOutput[0] = (i & 0xFC)>>2; 
....................       vOutput[1] = (i & 0x03)<<4; 
....................       if(wSourceLen) 
....................       { 
....................          i = *cSourceData++; 
....................          wSourceLen--; 
....................          vOutput[1] |= (i & 0xF0)>>4; 
....................          vOutput[2] = (i & 0x0F)<<2; 
....................          if(wSourceLen) 
....................          { 
....................             i = *cSourceData++; 
....................             wSourceLen--; 
....................             vOutput[2] |= (i & 0xC0)>>6; 
....................             vOutput[3] = i & 0x3F; 
....................          } 
....................       } 
....................     
....................       // Convert hextets into Base 64 alphabet and store result 
....................       for(i = 0; i < 4u; i++) 
....................       { 
....................          j = vOutput[i]; 
....................  
....................          if(j <= 25u) 
....................             j += 'A' - 0; 
....................          else if(j <= 51u) 
....................             j += 'a' - 26; 
....................          else if(j <= 61u) 
....................             j += '0' - 52; 
....................          else if(j == 62u) 
....................             j = '+'; 
....................          else if(j == 63u) 
....................             j = '/'; 
....................          else            // Padding 
....................             j = '='; 
....................  
....................          *cDestData++ = j; 
....................       } 
....................  
....................       // Update counters 
....................       wDestLen -= 4; 
....................       wOutputLen += 4; 
....................    } 
....................  
....................    return wOutputLen; 
.................... } 
.................... #endif // #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void uitoa(WORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 16-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void uitoa(WORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    WORD Digit; 
....................    WORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 10000; i < 5u; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... }              
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ultoa(DWORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 32-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... // HI-TECH PICC-18 PRO 9.63, C30 v3.25, and C32 v1.12 already have a ultoa() library function 
.................... // C18 already has a ultoa() function that more-or-less matches this one 
.................... // C32 < 1.12 and C30 < v3.25 need this function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... void ultoa(DWORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    DWORD Digit; 
....................    DWORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 1000000000; i < 10; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE hexatob(WORD_VAL AsciiChars) 
....................  
....................   Summary: 
....................    Converts a hex string to a single byte. 
....................     
....................   Description: 
....................    Converts a two-character ASCII hex string to a single packed byte. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    AsciiChars - WORD_VAL where .v[0] is the ASCII value for the lower nibble 
....................                and .v[1] is the ASCII value for the upper nibble.  Each 
....................                must range from '0'-'9', 'A'-'F', or 'a'-'f'. 
....................  
....................   Returns: 
....................      Resulting packed byte 0x00 - 0xFF. 
....................   ***************************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'A'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The upper hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'E'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The lower hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
....................  
....................   Summary: 
....................    Case-insensitive comparison of a string in RAM to a string in ROM. 
....................  
....................   Description: 
....................    Performs a case-insensitive comparison of a string in RAM to a string 
....................    in ROM.  This function performs identically to strcmppgm2ram, except that 
....................    the comparison is not case-sensitive. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    a - Pinter to tring in RAM 
....................    b - Pointer to string in ROM 
....................  
....................   Return Values: 
....................      \-1 - a < b 
....................      0   - a = b 
....................      1   - a > b 
....................   ***************************************************************************/ 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
.................... { 
....................    BYTE cA, cB; 
....................     
....................    // Load first two characters 
....................    cA = *a; 
....................    cB = *b; 
....................     
....................    // Loop until one string terminates 
....................    while(cA != '\0' && cB != '\0') 
....................    { 
....................       // Shift case if necessary 
....................       if(cA >= 'a' && cA <= 'z') 
....................          cA -= 'a' - 'A'; 
....................       if(cB >= 'a' && cB <= 'z') 
....................          cB -= 'a' - 'A'; 
....................           
....................       // Compare 
....................       if(cA > cB) 
....................          return 1; 
....................       if(cA < cB) 
....................          return -1; 
....................        
....................       // Characters matched, so continue 
....................       a++; 
....................       b++; 
....................       cA = *a; 
....................       cB = *b; 
....................    } 
....................     
....................    // See if one string terminated first 
....................    if(cA > cB) 
....................       return 1; 
....................    if(cA < cB) 
....................       return -1; 
....................        
....................    // Strings match 
....................    return 0; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD swaps(WORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a WORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the WORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... WORD swaps(WORD v) 
.................... { 
....................    WORD_VAL t; 
....................    BYTE b; 
....................  
....................    t.Val   = v; 
*
01A24:  MOVFF  45E,460
01A28:  MOVFF  45D,45F
....................    b       = t.v[1]; 
01A2C:  MOVFF  460,461
....................    t.v[1]  = t.v[0]; 
01A30:  MOVFF  45F,460
....................    t.v[0]  = b; 
01A34:  MOVFF  461,45F
....................  
....................    return t.Val; 
01A38:  MOVLB  4
01A3A:  MOVFF  45F,01
01A3E:  MOVFF  460,02
01A42:  MOVLB  0
01A44:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD swapl(DWORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a DWORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the DWORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v) 
.................... #else 
.................... DWORD swapl(DWORD v) 
.................... #endif 
.................... { 
....................    // Swap bytes 0 and 3 
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
*
0313C:  MOVLW  04
0313E:  MOVLB  4
03140:  MOVWF  x4B
03142:  MOVLW  46
03144:  MOVWF  01
03146:  MOVFF  44B,FEA
0314A:  MOVWF  FE9
0314C:  MOVFF  FEF,44E
03150:  MOVLW  04
03152:  MOVWF  x50
03154:  MOVLW  46
03156:  MOVWF  x4F
03158:  MOVLW  03
0315A:  ADDWF  x4F,W
0315C:  MOVWF  FE9
0315E:  MOVLW  00
03160:  ADDWFC x50,W
03162:  MOVWF  FEA
03164:  MOVF   FEF,W
03166:  XORWF  x4E,W
03168:  MOVFF  44B,FEA
0316C:  MOVFF  01,FE9
03170:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0]; 
03172:  MOVLW  04
03174:  MOVWF  x4B
03176:  MOVLW  46
03178:  MOVWF  x4A
0317A:  MOVLW  03
0317C:  ADDWF  x4A,W
0317E:  MOVWF  01
03180:  MOVLW  00
03182:  ADDWFC x4B,W
03184:  MOVWF  03
03186:  MOVWF  FEA
03188:  MOVFF  01,FE9
0318C:  MOVFF  FEF,44E
03190:  MOVLW  04
03192:  MOVWF  x50
03194:  MOVLW  46
03196:  MOVWF  FE9
03198:  MOVFF  450,FEA
0319C:  MOVF   FEF,W
0319E:  XORWF  x4E,W
031A0:  MOVFF  03,FEA
031A4:  MOVFF  01,FE9
031A8:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
031AA:  MOVLW  04
031AC:  MOVWF  x4B
031AE:  MOVLW  46
031B0:  MOVWF  01
031B2:  MOVFF  44B,FEA
031B6:  MOVWF  FE9
031B8:  MOVFF  FEF,44E
031BC:  MOVLW  04
031BE:  MOVWF  x50
031C0:  MOVLW  46
031C2:  MOVWF  x4F
031C4:  MOVLW  03
031C6:  ADDWF  x4F,W
031C8:  MOVWF  FE9
031CA:  MOVLW  00
031CC:  ADDWFC x50,W
031CE:  MOVWF  FEA
031D0:  MOVF   FEF,W
031D2:  XORWF  x4E,W
031D4:  MOVFF  44B,FEA
031D8:  MOVFF  01,FE9
031DC:  MOVWF  FEF
....................  
....................    // Swap bytes 1 and 2 
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
031DE:  MOVLW  04
031E0:  MOVWF  x4B
031E2:  MOVLW  46
031E4:  MOVWF  x4A
031E6:  MOVLW  01
031E8:  ADDWF  x4A,W
031EA:  MOVWF  01
031EC:  MOVLW  00
031EE:  ADDWFC x4B,W
031F0:  MOVWF  03
031F2:  MOVWF  FEA
031F4:  MOVFF  01,FE9
031F8:  MOVFF  FEF,44E
031FC:  MOVLW  04
031FE:  MOVWF  x50
03200:  MOVLW  46
03202:  MOVWF  x4F
03204:  MOVLW  02
03206:  ADDWF  x4F,W
03208:  MOVWF  FE9
0320A:  MOVLW  00
0320C:  ADDWFC x50,W
0320E:  MOVWF  FEA
03210:  MOVF   FEF,W
03212:  XORWF  x4E,W
03214:  MOVFF  03,FEA
03218:  MOVFF  01,FE9
0321C:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[2] ^= ((DWORD_VAL*)&v)->v[1]; 
0321E:  MOVLW  04
03220:  MOVWF  x4B
03222:  MOVLW  46
03224:  MOVWF  x4A
03226:  MOVLW  02
03228:  ADDWF  x4A,W
0322A:  MOVWF  01
0322C:  MOVLW  00
0322E:  ADDWFC x4B,W
03230:  MOVWF  03
03232:  MOVWF  FEA
03234:  MOVFF  01,FE9
03238:  MOVFF  FEF,44E
0323C:  MOVLW  04
0323E:  MOVWF  x50
03240:  MOVLW  46
03242:  MOVWF  x4F
03244:  MOVLW  01
03246:  ADDWF  x4F,W
03248:  MOVWF  FE9
0324A:  MOVLW  00
0324C:  ADDWFC x50,W
0324E:  MOVWF  FEA
03250:  MOVF   FEF,W
03252:  XORWF  x4E,W
03254:  MOVFF  03,FEA
03258:  MOVFF  01,FE9
0325C:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
0325E:  MOVLW  04
03260:  MOVWF  x4B
03262:  MOVLW  46
03264:  MOVWF  x4A
03266:  MOVLW  01
03268:  ADDWF  x4A,W
0326A:  MOVWF  01
0326C:  MOVLW  00
0326E:  ADDWFC x4B,W
03270:  MOVWF  03
03272:  MOVWF  FEA
03274:  MOVFF  01,FE9
03278:  MOVFF  FEF,44E
0327C:  MOVLW  04
0327E:  MOVWF  x50
03280:  MOVLW  46
03282:  MOVWF  x4F
03284:  MOVLW  02
03286:  ADDWF  x4F,W
03288:  MOVWF  FE9
0328A:  MOVLW  00
0328C:  ADDWFC x50,W
0328E:  MOVWF  FEA
03290:  MOVF   FEF,W
03292:  XORWF  x4E,W
03294:  MOVFF  03,FEA
03298:  MOVFF  01,FE9
0329C:  MOVWF  FEF
....................  
....................    return v; 
0329E:  MOVFF  446,00
032A2:  MOVFF  447,01
032A6:  MOVFF  448,02
032AA:  MOVFF  449,03
032AE:  MOVLB  0
032B0:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD CalcIPChecksum(BYTE* buffer, WORD count) 
....................  
....................   Summary: 
....................    Calculates an IP checksum value. 
....................  
....................   Description: 
....................    This function calculates an IP checksum over an array of input data.  The 
....................    checksum is the 16-bit one's complement of one's complement sum of all  
....................    words in the data (with zero-padding if an odd number of bytes are  
....................    summed).  This checksum is defined in RFC 793. 
....................  
....................   Precondition: 
....................    buffer is WORD aligned (even memory address) on 16- and 32-bit PICs. 
....................  
....................   Parameters: 
....................    buffer - pointer to the data to be checksummed 
....................    count  - number of bytes to be checksummed 
....................  
....................   Returns: 
....................    The calculated checksum. 
....................     
....................   Internal: 
....................    This function could be improved to do 32-bit sums on PIC32 platforms. 
....................   ***************************************************************************/ 
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................    union 
....................    { 
....................       WORD w[2]; 
....................       DWORD dw; 
....................    } sum; 
....................  
....................    i = count >> 1; 
*
01B20:  BCF    FD8.0
01B22:  MOVLB  4
01B24:  RRCF   x5C,W
01B26:  MOVWF  x5E
01B28:  RRCF   x5B,W
01B2A:  MOVWF  x5D
....................    val = (WORD*)buffer; 
01B2C:  MOVFF  45A,460
01B30:  MOVFF  459,45F
....................  
....................    // Calculate the sum of all words 
....................    sum.dw = 0x00000000ul; 
01B34:  CLRF   x64
01B36:  CLRF   x63
01B38:  CLRF   x62
01B3A:  CLRF   x61
....................    while(i--) 
01B3C:  MOVFF  45E,03
01B40:  MOVF   x5D,W
01B42:  BTFSC  FD8.2
01B44:  DECF   x5E,F
01B46:  DECF   x5D,F
01B48:  IORWF  03,W
01B4A:  BZ    1B88
....................       sum.dw += (DWORD)*val++; 
01B4C:  MOVFF  460,03
01B50:  MOVFF  45F,00
01B54:  MOVLW  02
01B56:  ADDWF  x5F,F
01B58:  BTFSC  FD8.0
01B5A:  INCF   x60,F
01B5C:  MOVFF  00,FE9
01B60:  MOVFF  03,FEA
01B64:  MOVFF  FEC,03
01B68:  MOVF   FED,F
01B6A:  MOVFF  FEF,00
01B6E:  MOVFF  03,01
01B72:  CLRF   02
01B74:  CLRF   03
01B76:  MOVF   00,W
01B78:  ADDWF  x61,F
01B7A:  MOVF   01,W
01B7C:  ADDWFC x62,F
01B7E:  MOVF   02,W
01B80:  ADDWFC x63,F
01B82:  MOVF   03,W
01B84:  ADDWFC x64,F
01B86:  BRA    1B3C
....................  
....................    // Add in the sum of the remaining byte, if present 
....................    if(count & 0x1) 
01B88:  MOVF   x5B,W
01B8A:  ANDLW  01
01B8C:  MOVWF  00
01B8E:  CLRF   03
01B90:  MOVF   00,W
01B92:  IORWF  03,W
01B94:  BZ    1BBC
....................       sum.dw += (DWORD)*(BYTE*)val; 
01B96:  MOVFF  460,03
01B9A:  MOVFF  45F,FE9
01B9E:  MOVFF  460,FEA
01BA2:  MOVFF  FEF,00
01BA6:  CLRF   01
01BA8:  CLRF   02
01BAA:  CLRF   03
01BAC:  MOVF   00,W
01BAE:  ADDWF  x61,F
01BB0:  MOVF   01,W
01BB2:  ADDWFC x62,F
01BB4:  MOVF   02,W
01BB6:  ADDWFC x63,F
01BB8:  MOVF   03,W
01BBA:  ADDWFC x64,F
....................  
....................    // Do an end-around carry (one's complement arrithmatic) 
....................    sum.dw = (DWORD)sum.w[0] + (DWORD)sum.w[1]; 
01BBC:  CLRF   x68
01BBE:  CLRF   x67
01BC0:  MOVFF  462,466
01BC4:  MOVFF  461,465
01BC8:  MOVFF  463,00
01BCC:  MOVFF  464,01
01BD0:  CLRF   02
01BD2:  CLRF   03
01BD4:  MOVF   x63,W
01BD6:  ADDWF  x61,W
01BD8:  MOVWF  x61
01BDA:  MOVF   x64,W
01BDC:  ADDWFC x62,W
01BDE:  MOVWF  x62
01BE0:  MOVF   02,W
01BE2:  ADDWFC x67,W
01BE4:  MOVWF  x63
01BE6:  MOVF   03,W
01BE8:  ADDWFC x68,W
01BEA:  MOVWF  x64
....................  
....................    // Do another end-around carry in case if the prior add  
....................    // caused a carry out 
....................    sum.w[0] += sum.w[1]; 
01BEC:  MOVF   x63,W
01BEE:  ADDWF  x61,F
01BF0:  MOVF   x64,W
01BF2:  ADDWFC x62,F
....................  
....................    // Return the resulting checksum 
....................    return ~sum.w[0]; 
01BF4:  MOVFF  462,03
01BF8:  COMF   03,F
01BFA:  MOVF   x61,W
01BFC:  XORLW  FF
01BFE:  MOVWF  01
01C00:  MOVFF  03,02
01C04:  MOVLB  0
01C06:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strupr(char* s) 
....................  
....................   Summary: 
....................    Converts a string to uppercase. 
....................  
....................   Description: 
....................    This function converts strings to uppercase on platforms that do not 
....................    already have this function defined.  All lower-case characters are 
....................    converted, an characters not included in 'a'-'z' are left as-is. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    s - the null-terminated string to be converted. 
....................  
....................   Returns: 
....................    Pointer to the initial string. 
....................   ***************************************************************************/ 
.................... #if (!defined(__PCD__) && !defined(__18CXX)) || defined(HI_TECH_C) 
.................... char* strupr(char* s) 
.................... { 
....................    char c; 
....................    char *t; 
....................  
....................    t = s; 
....................    while( (c = *t) ) 
....................    { 
....................       if(c >= 'a' && c <= 'z') 
....................       { 
....................          *t -= ('a' - 'A'); 
....................       } 
....................       t++; 
....................    } 
....................    return s; 
.................... } 
.................... #endif 
....................  
.................... #if defined(__18CXX) //&& !defined(__PCH__) 
.................... // Make this variable global for the following function. 
.................... // Hi-Tech PICC18 cannot access local function variables from inline asm. 
.................... DWORD_VAL toRotate;  
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD leftRotateDWORD(DWORD val, BYTE bits) 
....................  
....................   Summary: 
....................    Left-rotates a DWORD. 
....................  
....................   Description: 
....................    This function rotates the bits in a 32-bit DWORD left by a specific  
....................    number of bits. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    val      - the DWORD to be rotated 
....................    bits   - the number of bits by which to shift 
....................  
....................   Returns: 
....................    Rotated DWORD value. 
....................     
....................   Remarks: 
....................    This function is only implemented on 8-bit platforms for now.  The  
....................    8-bit compilers generate excessive code for this function, while C30 
....................    and C32 already generate compact code.  Those compilers are served 
....................    by a macro defined in Helpers.h. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... DWORD leftRotateDWORD(DWORD val, BYTE bits) 
.................... { 
....................    BYTE i, t; 
....................    //DWORD_VAL toRotate; 
....................    toRotate.Val = val; 
....................     
....................    for(i = bits; i >= 8u; i -= 8) 
....................    { 
....................       t = toRotate.v[3]; 
....................       toRotate.v[3] = toRotate.v[2]; 
....................       toRotate.v[2] = toRotate.v[1]; 
....................       toRotate.v[1] = toRotate.v[0]; 
....................       toRotate.v[0] = t; 
....................    } 
....................     
....................     
....................    #if defined(HI_TECH_C) 
....................    for(; i != 0; i--) 
....................    { 
....................       asm("movlb (_toRotate)>>8"); 
....................       //asm("bcf _STATUS,0,C"); 
....................       asm("bcf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("btfsc (_toRotate)&0ffh+3,7,B"); 
....................       //asm("bsf _STATUS,0,C"); 
....................       asm("bsf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("rlcf (_toRotate)&0ffh+0,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+1,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+2,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+3,F,B"); 
....................    } 
....................    #else 
....................    for(; i != 0u; i--) 
....................    { 
....................       _asm 
....................       movlb toRotate 
....................       bcf STATUS,0,0 
....................       btfsc toRotate+3,7,1 
....................       bsf STATUS,0,0 
....................       rlcf toRotate+0,1,1 
....................       rlcf toRotate+1,1,1 
....................       rlcf toRotate+2,1,1 
....................       rlcf toRotate+3,1,1 
....................       _endasm 
....................    } 
....................    #endif 
....................     
....................    return toRotate.Val; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void FormatNetBIOSName(BYTE Name[]) 
....................  
....................   Summary: 
....................    Formats a string to a valid NetBIOS name. 
....................  
....................   Description: 
....................    This function formats a string to a valid NetBIOS name.  Names will be 
....................    exactly 16 characters, as defined by the NetBIOS spec.  The 16th  
....................    character will be a 0x00 byte, while the other 15 will be the  
....................    provided string, padded with spaces as necessary. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Name - the string to format as a NetBIOS name.  This parameter must have 
....................      at least 16 bytes allocated. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void FormatNetBIOSName(BYTE Name[]) 
.................... { 
....................    BYTE i; 
....................  
....................    Name[15] = '\0'; 
....................    strupr((char*)Name); 
....................    i = 0; 
....................    while(i < 15u) 
....................    { 
....................       if(Name[i] == '\0') 
....................       { 
....................          while(i < 15u) 
....................          { 
....................             Name[i++] = ' '; 
....................          } 
....................          break; 
....................       } 
....................       i++; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char * strnchr(const char *searchString, size_t count, char c) 
....................  
....................   Summary: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character. 
....................  
....................   Description: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character.  The string is searched forward and the first occurance  
....................    location is returned.  If the search character is not present in the  
....................    string, or if the maximum character count is reached first, then a NULL  
....................    pointer is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    searchString - Pointer to a null terminated string to search.  If count is  
....................       less than the string size, then the string need not be null terminated. 
....................    count - Maximum number of characters to search before aborting. 
....................    c - Character to search for 
....................     
....................   Returns: 
....................    Pointer to the first occurance of the character c in the string  
....................    searchString.  If the character is not found or the maximum count is  
....................    reached, a NULL pointer is returned. 
....................   ***************************************************************************/ 
.................... char * strnchr(const char *searchString, size_t count, char c) 
.................... { 
....................    char c2; 
....................     
....................    while(count--) 
....................    { 
....................       c2  = *searchString++; 
....................       if(c2 == 0u) 
....................          return NULL; 
....................       if(c2 == c) 
....................          return (char*)--searchString; 
....................    } 
....................    return NULL; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
....................  
....................   Summary: 
....................    Copies multiple strings to a destination 
....................  
....................   Description: 
....................    Copies multiple strings to a destination 
....................     but doesn't copy more than destSize characters. 
....................     Useful where the destination is actually an array and an extra \0 
....................     won't be appended to overflow the buffer 
....................      
....................   Precondition: 
....................    - valid string pointers 
....................     - destSize should be > 0 
....................  
....................   Parameters: 
....................    destStr - Pointer to a string to be initialized with the multiple strings provided as arguments. 
....................  
....................     destSize    - the maximum size of the destStr field, that cannot be exceeded. 
....................                   An \0 won't be appended if the resulting size is > destSize 
....................  
....................     nStrings    - number of string parameters to be copied into destStr 
....................  
....................     ...         - variable number of arguments 
....................      
....................     
....................   Returns: 
....................    Length of the destination string, terminating \0 (if exists) not included 
....................   ***************************************************************************/ 
.................... size_t strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
.................... { 
....................     va_list     args; 
....................     const char* str; 
....................     char*       end; 
....................     size_t      len; 
....................  
....................     destStr[0] = '\0'; 
....................     end = destStr + destSize - 1; 
....................     *end = '\0'; 
....................     len = 0; 
....................      
....................     va_start( args, nStrings ); 
....................      
....................     while(nStrings--) 
....................     { 
....................         if(*end) 
....................         {   // if already full don't calculate strlen outside the string area 
....................             len = destSize; 
....................             break; 
....................         } 
....................          
....................         str = va_arg(args, const char*); 
....................         strncpy(destStr + len, str, destSize - len); 
....................         len += strlen(str); 
....................     } 
....................  
....................     va_end( args ); 
....................      
....................     return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE ExtractURLFields(BYTE *vURL,  
....................                     PROTOCOLS *protocol,  
....................                     BYTE *vUsername, WORD *wUsernameLen,  
....................                     BYTE *vPassword, WORD *wPasswordLen,  
....................                     BYTE *vHostname, WORD *wHostnameLen,  
....................                     WORD *wPort,  
....................                     BYTE *vFilePath, WORD *wFilePathLen) 
....................  
....................   Summary: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................  
....................   Description: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................     
....................    The URL string can be null terminated, or alternatively could be terminated  
....................    by a carriage return or line feed. 
....................     
....................    If the protocol is unrecognized or the protocol is recognized but the URL  
....................    is malformed, than an error is safely returned.  For more information on  
....................    URL/URI interpretation see RFC 2396. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vURL -   Pointer to null terminated URL to decode and extract from.  This  
....................       parameter is required and needs to have the minimum RFC 1738 components  
....................       in it (protocol and hostname). 
....................        
....................    protocol - Optional pointer to a PROTOCOLS enum to retrieve the decoded  
....................       protocol type.  If this parameter is unneeded, specify a NULL pointer.   
....................       The protocol is a required part of the URL, so it must always be  
....................       present.  The protocol also determines what scheme all other parameters  
....................       are decoded using, so the function will fail if an unrecognized  
....................       protocol is provided.  The PROTOCOLS enum members show all of the  
....................       currently supported protocols for this function. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       PROTOCOL_HTTP would be returned for this field. 
....................        
....................    vUsername - Optional pointer to a buffer to write the decoded username  
....................       portion of the URL.  If the URL does not contain a username or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "admin"  
....................       would be returned for this field. 
....................        
....................    wUsernameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vUsername buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wUsernameLen and vUsername are non-NULL, the  
....................       *wUsernameLen WORD is updated with the actual number of characters  
....................       written to the vUsername buffer, including the null terminator  
....................       character.  If vUsername is NULL but wUsernameLen is non-NULL, then no  
....................       characters are copied, but *wUsernameLen will return the number of  
....................       characters required to fit the full username string.  If wUsernameLen  
....................       is NULL, then the username field in the URL, if present, is ignored and  
....................       the vUsername pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a username field.  If one character was written, this indicates  
....................       that a username field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 6 (0x0006)  
....................       would be returned for this field. 
....................        
....................    vPassword - Optional pointer to a buffer to write the decoded password  
....................       portion of the URL.  If the URL does not contain a password or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "passwd"  
....................       would be returned for this field. 
....................        
....................    wPasswordLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vPassword buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wPasswordLen and vPassword are non-NULL, the  
....................       *wPasswordLen WORD is updated with the actual number of characters  
....................       written to the vPassword buffer, including the null terminator  
....................       character.  If vPassword is NULL but wPasswordLen is non-NULL, then no  
....................       characters are copied, but *wPasswordLen will return the number of  
....................       characters required to fit the full password string.  If wPasswordLen  
....................       is NULL, then the password field in the URL, if present, is ignored and  
....................       the vPassword pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a password field.  If one character was written, this indicates  
....................       that a password field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 7 (0x0007)  
....................       would be returned for this field. 
....................        
....................    vHostname - Optional pointer to a buffer to write the decoded hostname  
....................       portion of the URL.  All Internet URLs must contain a hostname or IP  
....................       address, however, if a NULL pointer is supplied, then this field is  
....................       ignored. 
....................  
....................       <p>For the example URL provided in the function description,  
....................       "www.microchip.com" would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as  
....................       "192.168.0.1".   The IP address would not be decoded to a DWORD (use the  
....................       StringToIPAddress() helper function to do this). 
....................        
....................    wHostnameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vHostname buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wHostnameLen and vHostname are non-NULL, the  
....................       *wHostnameLen WORD is updated with the actual number of characters  
....................       written to the vHostname buffer, including the null terminator  
....................       character.  If vHostname is NULL but wHostnameLen is non-NULL, then no  
....................       characters are copied, but *wHostnameLen will return the number of  
....................       characters required to fit the full hostname string.  If wHostnameLen  
....................       is NULL, then the hostname field in the URL, is ignored and the  
....................       vHostname pointer is not used. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       18 (0x0012) would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as 12 (0x000C). 
....................        
....................    wPort - Optional pointer to a WORD specifying the TCP or UDP port that the  
....................       server is listening on.  If the port field is absent from the URL, then  
....................       this parameter will specify the default port for the protocol.  For  
....................       example, "http://www.microchip.com" would result in 80 being return as  
....................       the specified port. 
....................         
....................       <p>If the wPort pointer is NULL, then the port field in the URL  
....................       is ignored, if present. 
....................        
....................    vFilePath - Optional pointer to a buffer to write the decoded file path  
....................       portion of the URL.  If a NULL pointer is supplied, then this field is  
....................       ignored.  If a file path is not present in the URL, then "/" will be  
....................       returned in this field.   
....................  
....................       <p>For the example URL provided in the function description,  
....................       "/myfile.gif" would be returned for this field. 
....................        
....................    wFilePathLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vFilePath buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wFilePathLen and vFilePath are non-NULL, the  
....................       *wFilePathLen WORD is updated with the actual number of characters  
....................       written to the vFilePath buffer, including the null terminator  
....................       character.  If vFilePath is NULL but wFilePathLen is non-NULL, then no  
....................       characters are copied, but *wFilePathLen will return the number of  
....................       characters required to fit the full file path string.  If wFilePathLen  
....................       is NULL, then the file path field in the URL, if present, is ignored and  
....................       the vFilePath pointer is not used. 
....................        
....................       <p>This function always returns "/" if no file path is present, so 
....................       *wFilePathLen will also be at least 2 characters ('/' and null  
....................       terminator) if the pointer is non-NULL. 
....................     
....................       <p>For the example URL provided in the function description, 12 (0x000C)  
....................       would be returned for this field. 
....................        
....................   Returns: 
....................    Zero on success.  Nonzero indicates an error code.  If a nonzero error code  
....................    is returned, none of the returned buffers or pointer values should be  
....................    treated as valid, but some of them may have been written to.  The following  
....................    are all possible return values. 
....................    <table> 
....................       0   No error 
....................       1   Protocol unknown (additional code needs to be added to  
....................           ExtractURLFields() and the PROTOCOLS enum needs to be updated if  
....................           you want to decode URLs of this protocol type. 
....................       2   URL malformed. Illegal or unknown URL format encountered. 
....................       3   Buffer too small.  One of the input buffer sizes is too small to  
....................           contain the URL parameter. 
....................    </table> 
....................   ***************************************************************************/ 
.................... #if 0    
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen) 
.................... { 
....................    // These two arrays must exactly match up each other and the PROTOCOLS enum  
....................    // elements.  The protocol name strings must also be specified in all  
....................    // lowercase. 
....................    static ROM char * ROM   vProtocolNames[] = {"http", "https", "mms", "rtsp"}; 
....................    static ROM WORD       wProtocolPorts[] = { 80,     443,     1755,  554}; 
....................    WORD w, w2; 
....................    BYTE i, j; 
....................    PROTOCOLS prot; 
....................    BYTE *temp, *temp2; 
....................    WORD wURLLen; 
....................    WORD wLocalPort; 
....................     
....................     
....................    // Calculate how long this URL is 
....................    wURLLen = strlen((char*)vURL); 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\r'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\n'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................     
....................  
....................    // Parse starting protocol field 
....................    // Find out how long the protocol name field is 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    if(temp == NULL) 
....................       return 2; 
....................     
....................    // Search protocol list to see if this is a recognized protocol 
....................    for(prot = 0; (BYTE)prot < sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]); prot++) 
....................    { 
....................       w = strlenpgm(vProtocolNames[prot]); 
....................       if((WORD)(temp - vURL) == w) 
....................       { 
....................          w2 = 0; 
....................          temp2 = vURL; 
....................          while(w) 
....................          { 
....................             i = *temp2++; 
....................             if((i >= 'A') && (i <= 'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != (BYTE)vProtocolNames[prot][w2++]) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w == 0u) 
....................          { 
....................             if(protocol) 
....................                *protocol = prot; 
....................             break; 
....................          } 
....................       } 
....................    } 
....................  
....................    // If we've search the whole list and didn't find a match, then  
....................    // this protocol is unknown and this URL cannot be parsed. 
....................    if((BYTE)prot >= sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0])) 
....................       return 1; 
....................     
....................    w = temp - vURL + 1; 
....................    vURL += w; 
....................    wURLLen -= w; 
....................  
....................    // Protocols using the authority field all must have a double  
....................    // slash "//" prefix 
....................    if(wURLLen < 2u) 
....................       return 2; 
....................    for(j = 0; j < 2u; j++) 
....................    { 
....................       i = *vURL++; 
....................       if(i != '/') 
....................          return 2; 
....................    } 
....................    wURLLen -= 2; 
....................     
....................  
....................    // Parse username and password fields 
....................    // See if there is a @ sign, indicating that there is at  
....................    // least a username and possibly a password in this URL 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '@'); 
....................    if(temp == NULL) 
....................    { 
....................       if(wUsernameLen) 
....................          *wUsernameLen = 0; 
....................       if(wPasswordLen) 
....................          *wPasswordLen = 0; 
....................    } 
....................    else 
....................    { 
....................       // If we get down here, there is a user name present, let's  
....................       // see if a password is also present by searching for a  
....................       // colon between the current string position and the @  
....................       // symbol. 
....................       temp2 = (BYTE*)strnchr((char*)vURL, temp - vURL, ':'); 
....................        
....................       // Calculate username length and password length, including  
....................       // null terminator (if the field exists) 
....................       if(temp2 == NULL) 
....................       { 
....................          w = temp - vURL + 1;   // Username 
....................          w2 = 0;               // Password 
....................       } 
....................       else 
....................       { 
....................          w = temp2 - vURL + 1;   // Username 
....................          w2 = temp - temp2;      // Password 
....................       } 
....................        
....................       if(wUsernameLen) 
....................       { 
....................          if(vUsername) 
....................          { 
....................             if(*wUsernameLen < w) 
....................                return 3; 
....................             memcpy((void*)vUsername, (void*)vURL, w - 1); 
....................             vUsername[w-1] = 0; 
....................          } 
....................          *wUsernameLen = w; 
....................       } 
....................     
....................       if(wPasswordLen) 
....................       { 
....................          if(vPassword) 
....................          { 
....................             if(*wPasswordLen < w2) 
....................                return 3; 
....................             if(w2) 
....................             { 
....................                memcpy((void*)vPassword, (void*)temp2+1, w2 - 1); 
....................                vPassword[w2-1] = 0; 
....................             } 
....................          } 
....................          *wPasswordLen = w2; 
....................       } 
....................     
....................       vURL += w; 
....................       wURLLen -= w; 
....................       if(w2) 
....................       { 
....................          vURL += w2; 
....................          wURLLen -= w2; 
....................       } 
....................    } 
....................  
....................  
....................    // Parse hostname field 
....................    // Find the length of the hostname, including NULL  
....................    // terminator 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    temp2 = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................    if(temp && temp2) 
....................    { 
....................       if(temp > temp2) 
....................          temp = NULL; 
....................    } 
....................    if(temp == NULL) 
....................    { 
....................       temp = temp2; 
....................       if(temp2 == NULL) 
....................          temp = vURL + wURLLen; 
....................    } 
....................    w = temp - vURL + 1; 
....................    if(wHostnameLen) 
....................    { 
....................       if(vHostname) 
....................       { 
....................          if(*wHostnameLen < w) 
....................             return 3; 
....................          memcpy((void*)vHostname, (void*)vURL, w - 1); 
....................          vHostname[w-1] = 0; 
....................       } 
....................       *wHostnameLen = w; 
....................    } 
....................    vURL += w - 1; 
....................    wURLLen -= w - 1; 
....................  
....................  
....................    // Parse port field 
....................    if(*vURL == ':') 
....................    { 
....................       vURL++; 
....................       wURLLen--; 
....................       wLocalPort = 0; 
....................       w = wURLLen; 
....................       temp = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................       if(temp != NULL) 
....................          w = temp - vURL; 
....................       w2 = w; 
....................       if(wPort) 
....................       { 
....................          while(w--) 
....................          { 
....................             wLocalPort *= 10; 
....................             wLocalPort += *vURL++ - '0'; 
....................          } 
....................          *wPort = wLocalPort; 
....................       } 
....................       else 
....................          vURL += w2; 
....................       wURLLen -= w2; 
....................    } 
....................    else if(wPort) 
....................       *wPort = wProtocolPorts[prot]; 
....................  
....................  
....................    // Parse file path field 
....................    if(wFilePathLen) 
....................    { 
....................       w = ++wURLLen; 
....................       if(wURLLen == 1u) 
....................          w = 2; 
....................       if(vFilePath) 
....................       { 
....................          if(*wFilePathLen < w) 
....................             return 3; 
....................          if(wURLLen == 1u) 
....................             vFilePath[0] = '/'; 
....................          else 
....................             memcpy((void*)vFilePath, (void*)vURL, wURLLen - 1); 
....................          vFilePath[w - 1] = 0; 
....................          *wFilePathLen = w; 
....................          return 0; 
....................       } 
....................       *wFilePathLen = w; 
....................    } 
....................    return 0; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement,  
....................               WORD wMaxLen, BOOL bSearchCaseInsensitive) 
....................  
....................   Summary: 
....................    Replaces all instances of a particular substring with a new string 
....................  
....................   Description: 
....................    Searches a string (vExpression) and replaces all instances of a particular  
....................    substring (vFind) with a new string (vReplacement).  The start offset to  
....................    being searching and a maximum number of replacements can be specified.  The  
....................    search can be performed in a case sensitive or case insensitive manner. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vExpression - Null terminated string to search and make replacements within. 
....................    vFind - Null terminated string to search for. 
....................    vReplacement - Null terminated string to replace all instances of vFind with. 
....................    wMaxLen - Maximum length of the output vExpression string if string  
....................       expansion is going to occur (replacement length is longer than find  
....................       length).  If the replacements will cause this maximum string length to  
....................       be exceeded, then no replacements will be made and a negative result  
....................       will be returned, indicating failure.  If the replacement length is  
....................       shorter or equal to the search length, then this parameter is ignored. 
....................    bSearchCaseInsensitive - Boolean indicating if the search should be  
....................       performed in a case insensitive manner.  Specify TRUE for case  
....................       insensitive searches (slower) or FALSE for case sensitive  
....................       searching (faster). 
....................  
....................   Remarks: 
....................    If the replacement string length is shorter than or equal to the search  
....................    string length and the search string occurs in multiple overlapping  
....................    locations (ex\: expression is "aaa", find is "aa", and replacement is "bb")  
....................    then the first find match occuring when searching from left to right will  
....................    be replaced.  (ex\: output expression will be "bba"). 
....................     
....................    However, if the replacement string length is longer than the search string  
....................    length, the search will occur starting from the end of the string and  
....................    proceed to the beginning (right to left searching).  In this case if the  
....................    expression was "aaa", find was "aa", and replacement was "bbb", then the  
....................    final output expression will be "abbb".   
....................  
....................   Returns: 
....................    If zero or greater, indicates the count of how many replacements were made.   
....................    If less than zero (negative result), indicates that wMaxLen was too small  
....................    to make the necessary replacements.  In this case, no replacements were  
....................    made. 
....................   ***************************************************************************/ 
.................... #if 0 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive) 
.................... { 
....................    WORD wExpressionLen, wFindLen, wFindLenMinusOne, wReplacementLen; 
....................    WORD wFindCount, wReplacementsLeft; 
....................    BYTE i, j; 
....................    BYTE vFirstFindChar; 
....................    WORD wBytesLeft; 
....................    BYTE *vDest; 
....................    BYTE *vExpressionCompare; 
....................    ROM BYTE *vFindCompare; 
....................    WORD w; 
....................  
....................    wFindLen = strlenpgm((ROM char*)vFind); 
....................    if(wFindLen == 0u) 
....................       return 0; 
....................     
....................    wExpressionLen = strlen((char*)vExpression); 
....................    wReplacementLen = strlenpgm((ROM char*)vReplacement); 
....................  
....................    wFindCount = 0; 
....................    wFindLenMinusOne = wFindLen - 1; 
....................    vFirstFindChar = *vFind++; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................  
....................    // If the replacement string is the same length as the search string, then  
....................    // we can immediately do the needed replacements inline and return. 
....................    if(wFindLen == wReplacementLen) 
....................    { 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vExpression-1, (ROM void*)vReplacement, wReplacementLen); 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       return wFindCount; 
....................    } 
....................     
....................     
....................    // If the replacement string is shorter than the search string, then we can  
....................    // search from left to right and move the string over as we find occurrences. 
....................    if(wFindLen > wReplacementLen) 
....................    { 
....................       vDest = vExpression; 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          *vDest++ = i; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vDest-1, (ROM void*)vReplacement, wReplacementLen); 
....................          vDest += wReplacementLen-1; 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       *vDest = 0x00;   // Write new null terminator since the string may have shrunk 
....................       return wFindCount; 
....................    } 
....................     
....................    // If the replacement string is longer than the search string, then we will  
....................    // take a two pass approach.  On the first pass, we will merely count how  
....................    // many replacements to make.  With this we can calculate how long the  
....................    // final string is going to be.  On the second pass, we will search from  
....................    // right to left and expand the string as needed. 
....................  
....................    // Pass 1: count how many occurrences of vFind are in vExpression 
....................    for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................    { 
....................       i = *vExpression++; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = vFind; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare++; 
....................             j = *vFindCompare++; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................  
....................       wFindCount++; 
....................       vExpression += wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................    } 
....................     
....................    // Return immediately if no replacements are needed 
....................    if(wFindCount == 0u) 
....................       return 0; 
....................  
....................    // Pass 2: make replacements and move string over 
....................    vDest = vExpression + wFindCount * (wReplacementLen - wFindLen); 
....................    if(vDest > vExpression - wExpressionLen + wMaxLen) 
....................       return -1; 
....................    *vDest-- = 0x00;   // Write new null terminator 
....................    vExpression -= 1; 
....................    vFind -= 1; 
....................    vFirstFindChar = vFind[wFindLenMinusOne]; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................    wReplacementsLeft = wFindCount; 
....................    while(wReplacementsLeft) 
....................    { 
....................       i = *vExpression--; 
....................       *vDest-- = i; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = &vFind[wFindLenMinusOne-1]; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare--; 
....................             j = *vFindCompare--; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression-wFindLenMinusOne, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................       memcpypgm2ram((void*)vDest-wReplacementLen+2, (ROM void*)vReplacement, wReplacementLen); 
....................       vDest -= wReplacementLen-1; 
....................  
....................       vExpression -= wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................       wReplacementsLeft--; 
....................    } 
....................    return wFindCount; 
.................... } 
.................... #endif 
....................  
.................... //#include "Delay.c" //not needed, we overrode this in StackTsk2.h 
.................... #include "Tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for Timekeeping 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    Timer 0 (PIC18) or Timer 1 (PIC24F, PIC24H,  
....................  *					dsPIC30F, dsPIC33F, PIC32) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.10b or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		6/13/07		Changed to use timer without  
....................  *									writing for perfect accuracy. 
.................... ********************************************************************/ 
.................... #define __TICK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // Internal counter to store Ticks.  This variable is incremented in an ISR and  
.................... // therefore must be marked volatile to prevent the compiler optimizer from  
.................... // reordering code to use this value in the main context while interrupts are  
.................... // disabled. 
.................... static volatile DWORD dwInternalTicks = 0; 
....................  
.................... // 6-byte value to store Ticks.  Allows for use over longer periods of time. 
.................... static BYTE vTickReading[6]; 
....................  
.................... static void GetTickCopy(void); 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickInit(void) 
....................  
....................   Summary: 
.................... 	Initializes the Tick manager module. 
....................  
....................   Description: 
.................... 	Configures the Tick module and any necessary hardware resources. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   	 
....................   Remarks: 
.................... 	This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TickInit(void) 
.................... { 
.................... #if defined(__18CXX) 
.................... 	// Use Timer0 for 8 bit processors 
....................     // Initialize the time 
....................     TMR0H = 0; 
*
002FC:  CLRF   FD7
....................     TMR0L = 0; 
002FE:  CLRF   FD6
....................  
.................... 	// Set up the timer interrupt 
.................... 	INTCON2bits.TMR0IP = 0;		// Low priority 
00300:  BCF    FF1.2
....................     INTCONbits.TMR0IF = 0; 
00302:  BCF    FF2.2
....................     INTCONbits.TMR0IE = 1;		// Enable interrupt 
00304:  BSF    FF2.5
....................  
....................     // Timer0 on, 16-bit, internal timer, 1:256 prescalar 
....................     T0CON = 0x87; 
00306:  MOVLW  87
00308:  MOVWF  FD5
....................  
.................... #else 
0030A:  GOTO   A8BE (RETURN)
.................... 	// Use Timer 1 for 16-bit and 32-bit processors 
.................... 	// 1:256 prescale 
.................... 	T1CONbits.TCKPS = 3; 
.................... 	// Base 
.................... 	PR1 = 0xFFFF; 
.................... 	// Clear counter 
.................... 	TMR1 = 0; 
....................  
.................... 	// Enable timer interrupt 
.................... 	#if defined(__C30__) 
.................... 		IPC0bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0bits.T1IF = 0; 
.................... 		IEC0bits.T1IE = 1; 
.................... 	#else 
.................... 		IPC1bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0CLR = _IFS0_T1IF_MASK; 
.................... 		IEC0SET = _IEC0_T1IE_MASK; 
.................... 	#endif 
....................  
.................... 	// Start timer 
.................... 	T1CONbits.TON = 1; 
.................... #endif 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void GetTickCopy(void) 
....................  
....................   Summary: 
.................... 	Reads the tick value. 
....................  
....................   Description: 
.................... 	This function performs an interrupt-safe and synchronized read of the  
.................... 	48-bit Tick value. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... static void GetTickCopy(void) 
.................... { 
.................... 	// Perform an Interrupt safe and synchronized read of the 48-bit  
.................... 	// tick value 
.................... #if defined(__18CXX) 
.................... 	do 
.................... 	{ 
.................... 		INTCONbits.TMR0IE = 1;		// Enable interrupt 
*
023EA:  BSF    FF2.5
.................... 		Nop(); 
023EC:  NOP   
.................... 		INTCONbits.TMR0IE = 0;		// Disable interrupt 
023EE:  BCF    FF2.5
.................... 		vTickReading[0] = TMR0L; 
023F0:  MOVFF  FD6,11D
.................... 		vTickReading[1] = TMR0H; 
023F4:  MOVFF  FD7,11E
.................... 		*((DWORD*)&vTickReading[2]) = dwInternalTicks; 
023F8:  MOVLW  01
023FA:  MOVLB  4
023FC:  MOVWF  x3F
023FE:  MOVLW  1F
02400:  MOVWF  FE9
02402:  MOVFF  43F,FEA
02406:  MOVFF  119,FEF
0240A:  MOVFF  11A,FEC
0240E:  MOVFF  11B,FEC
02412:  MOVFF  11C,FEC
.................... 	} while(INTCONbits.TMR0IF); 
02416:  BTFSS  FF2.2
02418:  BRA    241E
0241A:  MOVLB  0
0241C:  BRA    23EA
.................... 	INTCONbits.TMR0IE = 1;			// Enable interrupt 
0241E:  BSF    FF2.5
.................... #elif defined(__C30__) 
02420:  MOVLB  0
02422:  RETURN 0
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0bits.T1IE = 1;			// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0bits.T1IE = 0;			// Disable interrupt 
....................  
.................... 		// Get low 2 bytes 
.................... 		((WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
.................... 		if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 			dwTempTicks--; 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0bits.T1IE = 1;				// Enable interrupt 
.................... #else	// PIC32 
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0SET = _IEC0_T1IE_MASK;	// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0CLR = _IEC0_T1IE_MASK;	// Disable interrupt 
.................... 		 
.................... 		// Get low 2 bytes 
.................... 		((volatile WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
....................  
.................... 		// PIC32MX3XX/4XX devices trigger the timer interrupt when TMR1 == PR1  
.................... 		// (TMR1 prescalar is 0x00), requiring us to undo the ISR's increment  
.................... 		// of the upper 32 bits of our 48 bit timer in the special case when  
.................... 		// TMR1 == PR1 == 0xFFFF.  For other PIC32 families, the ISR is  
.................... 		// triggered when TMR1 increments from PR1 to 0x0000, making no special  
.................... 		// corner case. 
.................... 		#if __PIC32_FEATURE_SET__ <= 460 
.................... 			if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 				dwTempTicks--; 
.................... 		#elif !defined(__PIC32_FEATURE_SET__) 
.................... 			#error __PIC32_FEATURE_SET__ macro must be defined.  You need to download a newer C32 compiler version. 
.................... 		#endif 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0SET = _IEC0_T1IE_MASK;		// Enable interrupt 
.................... #endif 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGet(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the least significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	microseconds to a few hours.  Use TickGetDiv256 or TickGetDiv64K for 
.................... 	longer periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Lower 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGet(void) 
.................... { 
.................... 	GetTickCopy(); 
02424:  RCALL  23EA
.................... 	return *((DWORD*)&vTickReading[0]); 
02426:  MOVLW  01
02428:  MOVLB  4
0242A:  MOVWF  x3F
0242C:  MOVLW  1D
0242E:  MOVFF  43F,03
02432:  MOVWF  FE9
02434:  MOVFF  43F,FEA
02438:  MOVFF  FEF,00
0243C:  MOVFF  FEC,01
02440:  MOVFF  FEC,02
02444:  MOVFF  FEC,03
02448:  MOVLB  0
0244A:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv256(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 256. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the middle 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	minutes to a few weeks.  Use TickGet for shorter periods or TickGetDiv64K 
.................... 	for longer ones. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Middle 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv256(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
*
02FD6:  CALL   23EA
.................... 	((BYTE*)&dw)[0] = vTickReading[1];	// Note: This copy must be done one  
02FDA:  MOVFF  11E,414
.................... 	((BYTE*)&dw)[1] = vTickReading[2];	// byte at a time to prevent misaligned  
02FDE:  MOVFF  11F,415
.................... 	((BYTE*)&dw)[2] = vTickReading[3];	// memory reads, which will reset the PIC. 
02FE2:  MOVFF  120,416
.................... 	((BYTE*)&dw)[3] = vTickReading[4]; 
02FE6:  MOVFF  121,417
.................... 	 
.................... 	return dw; 
02FEA:  MOVFF  414,00
02FEE:  MOVFF  415,01
02FF2:  MOVFF  416,02
02FF6:  MOVFF  417,03
02FFA:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv64K(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 64K. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the most significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	days to a few years, or for absolute time measurements.  Use TickGet or 
.................... 	TickGetDiv256 for shorter periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Upper 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv64K(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
.................... 	((BYTE*)&dw)[0] = vTickReading[2];	// Note: This copy must be done one  
.................... 	((BYTE*)&dw)[1] = vTickReading[3];	// byte at a time to prevent misaligned  
.................... 	((BYTE*)&dw)[2] = vTickReading[4];	// memory reads, which will reset the PIC. 
.................... 	((BYTE*)&dw)[3] = vTickReading[5]; 
.................... 	 
.................... 	return dw; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
....................  
....................   Summary: 
.................... 	Converts a Tick value or difference to milliseconds. 
....................  
....................   Description: 
.................... 	This function converts a Tick value or difference to milliseconds.  For 
.................... 	example, TickConvertToMilliseconds(32768) returns 1000 when a 32.768kHz  
.................... 	clock with no prescaler drives the Tick module interrupt. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	dwTickValue	- Value to convert to milliseconds 
....................  
....................   Returns: 
....................   	Input value expressed in milliseconds. 
....................  
....................   Remarks: 
.................... 	This function performs division on DWORDs, which is slow.  Avoid using 
.................... 	it unless you absolutely must (such as displaying data to a user).  For 
.................... 	timeout comparisons, compare the current value to a multiple or fraction  
.................... 	of TICK_SECOND, which will be calculated only once at compile time. 
....................   ***************************************************************************/ 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
.................... { 
.................... 	return (dwTickValue+(TICKS_PER_SECOND/2000ul))/((DWORD)(TICKS_PER_SECOND/1000ul)); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickUpdate(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... void TickUpdate(void) 
.................... { 
....................     if(INTCONbits.TMR0IF) 
*
000AA:  BTFSS  FF2.2
000AC:  BRA    00C2
....................     { 
.................... 		// Increment internal high tick counter 
.................... 		dwInternalTicks++; 
000AE:  MOVLW  01
000B0:  MOVLB  1
000B2:  ADDWF  x19,F
000B4:  BTFSC  FD8.0
000B6:  INCF   x1A,F
000B8:  BTFSC  FD8.2
000BA:  INCF   x1B,F
000BC:  BTFSC  FD8.2
000BE:  INCF   x1C,F
....................  
.................... 		// Reset interrupt flag 
....................         INTCONbits.TMR0IF = 0; 
000C0:  BCF    FF2.2
000C2:  MOVLB  0
....................     } 
000C4:  GOTO   00CA (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void _ISR _T1Interrupt(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #elif defined(__PIC32MX__) 
.................... void __attribute((interrupt(ipl2), vector(_TIMER_1_VECTOR), nomips16)) _T1Interrupt(void) 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0CLR = _IFS0_T1IF_MASK; 
.................... } 
.................... #else 
.................... #if defined(__PCD__)  //__CCS__ __PCH__ __PCD__ ccs added 
.................... #int_timer1 NOCLEAR 
.................... void _T1Interrupt(void) 
.................... #elif __C30_VERSION__ >= 300 
.................... void _ISR __attribute__((__no_auto_psv__)) _T1Interrupt(void) 
.................... #else 
.................... void _ISR _T1Interrupt(void) 
.................... #endif 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0bits.T1IF = 0; 
.................... } 
.................... #endif 
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "ETH97J60.c" 
.................... #elif defined(WF_CS_TRIS) 
....................       #include "WF_Config.c" 
....................       #if defined(WF_USE_SCAN_FUNCTIONS) 
....................          #include "WFScan.c" 
....................       #endif 
....................       #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................          #include "WFPowerSave.c" 
....................       #else 
....................          BOOL GetAppPowerSaveMode(void) {return(TRUE);} 
....................       #endif 
....................       #if defined(WF_USE_TX_POWER_CONTROL_FUNCTIONS) 
....................          #include "WFTxPower.c" 
....................       #endif 
....................       #include "WF_Spi.c" 
....................       #include "WF_Eint.c" 
....................       #include "WFConnectionProfile.c" 
....................       #include "WFConnectionAlgorithm.c" 
....................       #include "WFConnectionManager.c" 
....................       #include "WFEventHandler.c" 
....................       #include "WFInit.c" 
....................      #if defined(STACK_USE_CCS_SCAN_TASK) 
....................       #include "ccs_wifiscan.c" 
....................      #endif       
....................      #if defined(MRF24WG) 
....................       #include "WFDriverCom_24G.c" 
....................       #include "WFDriverRaw_24G.c" 
....................       #include "WFMac_24G.c" 
....................       #include "WFMgmtMsg_24G.c" 
....................       #include "WFParamMsg_24G.c"      
....................      #else 
....................       #include "WFDriverCom.c" 
....................       #include "WFDriverRaw.c" 
....................       #include "WFMac.c" 
....................       #include "WFMgmtMsg.c" 
....................       #include "WFParamMsg.c" 
....................      #endif 
.................... #elif defined(ENC_CS_TRIS) 
....................    #include "tcpip\ENC28J60.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Medium Access Control (MAC) Layer for Microchip ENC28J60 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides access to ENC28J60 Ethernet controller 
....................  *   -Reference: ENC28J60 Data sheet, IEEE 802.3 Standard 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                  MAC.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  Delay.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     6/28/04 Original 
....................  * Howard Schlunder     10/8/04 Cleanup 
....................  * Howard Schlunder     10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder     11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder     12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder     1/09/06 Added comments and minor mods 
....................  * Howard Schlunder     1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder     6/16/06 Synchronized with PIC18F97J60 code 
....................  * Howard Schlunder     7/17/06 Updated TestMemory() for C30 
....................  * Howard Schlunder     8/07/06 Added SetRXHashTableEntry() function 
.................... ********************************************************************/ 
.................... #define __ENC28J60_C 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // Make sure that this hardware profile has an ENC28J60 in it 
.................... #if defined(ENC_CS_TRIS) 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (ENC_SPI_IF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the ENC_SPI_IF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                  ((a) & 0xFF) 
.................... #define HIGH(a)                 (((a)>>8) & 0xFF) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define WCR (0x2<<5)            // Write Control Register command 
.................... #define BFS (0x4<<5)            // Bit Field Set command 
.................... #define BFC (0x5<<5)            // Bit Field Clear command 
.................... #define RCR (0x0<<5)            // Read Control Register command 
.................... #define RBM ((0x1<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define WBM ((0x3<<5) | 0x1A)   // Write Buffer Memory command 
.................... #define SR  ((0x7<<5) | 0x1F)   // System Reset command does not use an address. 
....................                                 //   It requires 0x1F, however. 
....................  
.................... // Maximum SPI frequency specified in data sheet 
.................... #define ENC_MAX_SPI_FREQ    (20000000ul)    // Hz 
....................  
.................... #define ETHER_IP    (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... #if defined(__CCS__) 
.................... typedef struct  __attribute__((packed)) 
.................... #else 
.................... typedef struct  __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD            NextPacketPointer; 
....................     RXSTATUS        StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
....................  
.................... #if defined (__18CXX) 
....................     #define ClearSPIDoneFlag()  {ENC_SPI_IF = 0;} 
....................     #define WaitForDataByte()   {while(!ENC_SPI_IF); ENC_SPI_IF = 0;} 
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.SSPEN) 
.................... #elif defined(__C30__) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while ((ENC_SPISTATbits.SPITBF == 1) || (ENC_SPISTATbits.SPIRBF == 0)); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPISTATbits.SPIEN) 
.................... #elif defined( __PIC32MX__ ) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while (!ENC_SPISTATbits.SPITBE || !ENC_SPISTATbits.SPIRBF); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.ON) 
.................... #else 
....................     #error Determine SPI flag mechanism 
.................... #endif 
....................  
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... //void Get8KBRAM(void); 
....................  
.................... // Internal MAC level variables and flags. 
.................... static WORD_VAL NextPacketLocation; 
.................... static WORD_VAL CurrentPacketLocation; 
.................... static BOOL WasDiscarded; 
.................... static BYTE ENCRevID; 
....................  
....................  
.................... //NOTE: All code in this module expects Bank 0 to be currently selected.  If code ever changes the bank, it must restore it to Bank 0 before returning. 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *                  registers in the ENC28J60 so that normal operation can 
....................  *                  begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................     BYTE i; 
....................  
....................     // Set up the SPI module on the PIC for communications with the ENC28J60 
....................     ENC_CS_IO = 1; 
*
00766:  BSF    F8B.1
....................     ENC_CS_TRIS = 0;        // Make the Chip Select pin an output 
00768:  BCF    F94.1
....................  
.................... #if defined(__18CXX) 
....................     ENC_SCK_TRIS = 0; 
0076A:  BCF    F94.3
....................     ENC_SDO_TRIS = 0; 
0076C:  BCF    F94.5
....................     ENC_SDI_TRIS = 1; 
0076E:  BSF    F94.4
.................... #endif 
....................  
....................     // If the RESET pin is connected, take the chip out of reset 
.................... #if defined(ENC_RST_IO) 
....................     ENC_RST_IO      = 1; 
00770:  BSF    F8B.0
....................     ENC_RST_TRIS    = 0; 
00772:  BCF    F94.0
.................... #endif 
....................  
....................     // Set up SPI 
....................     ClearSPIDoneFlag(); 
00774:  BCF    F9E.3
.................... #if defined(__18CXX) 
....................     ENC_SPICON1 = 0x20;     // SSPEN bit is set, SPI in master mode, FOSC/4, 
00776:  MOVLW  20
00778:  MOVWF  FC6
....................                             //   IDLE state is low level 
....................     ENC_SPISTATbits.CKE = 1;// Transmit data on rising edge of clock 
0077A:  BSF    FC7.6
....................     ENC_SPISTATbits.SMP = 0;// Input sampled at middle of data output time 
0077C:  BCF    FC7.7
.................... #elif defined(__C30__) 
....................     ENC_SPISTAT = 0;        // clear SPI 
....................     #if defined(__PIC24H__) || defined(__dsPIC33F__) || defined(__dsPIC33E__)|| defined(__PIC24E__) 
....................         ENC_SPICON1 = 0x0F;     // 1:1 primary prescale, 5:1 secondary prescale (8MHz  @ 40MIPS) 
....................     //    ENC_SPICON1 = 0x1E;   // 4:1 primary prescale, 1:1 secondary prescale (10MHz @ 40MIPS, Doesn't work.  CLKRDY is incorrectly reported as being clear.  Problem caused by dsPIC33/PIC24H ES silicon bug.) 
....................     #elif defined(__PIC24F__) || defined(__PIC24FK__) 
....................         ENC_SPICON1 = 0x1B;     // 1:1 primary prescale, 2:1 secondary prescale (8MHz  @ 16MIPS) 
....................     #else   // dsPIC30F 
....................         ENC_SPICON1 = 0x17;     // 1:1 primary prescale, 3:1 secondary prescale (10MHz @ 30MIPS) 
....................     #endif 
....................     ENC_SPICON2 = 0; 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPISTATbits.SPIEN = 1; 
.................... #elif defined(__C32__) 
....................     ENC_SPIBRG = (GetPeripheralClock()-1ul)/2ul/ENC_MAX_SPI_FREQ; 
....................    ENC_SPICON1bits.SMP = 1;   // Delay SDI input sampling (PIC perspective) by 1/2 SPI clock 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPICON1bits.ON = 1; 
.................... #endif 
....................  
....................     // RESET the entire ENC28J60, clearing all registers 
....................     // Also wait for CLKRDY to become set. 
....................     // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................     // means the part is in RESET or there is something wrong with the SPI 
....................     // connection.  This loop makes sure that we can communicate with the 
....................     // ENC28J60 before proceeding. 
....................     do 
....................     { 
....................         SendSystemReset(); 
0077E:  BRA    0580
....................         i = ReadETHReg(ESTAT).Val; 
00780:  MOVLW  1D
00782:  MOVLB  4
00784:  MOVWF  x5E
00786:  MOVLB  0
00788:  RCALL  05B8
0078A:  MOVFF  01,3C0
....................     } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
0078E:  MOVLB  3
00790:  BTFSS  xC0.3
00792:  BRA    0798
00794:  MOVLB  0
00796:  BRA    077E
00798:  MOVF   xC0,W
0079A:  XORLW  FF
0079C:  ANDLW  01
0079E:  BTFSC  FD8.2
007A0:  BRA    07A6
007A2:  MOVLB  0
007A4:  BRA    077E
....................  
....................     // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................     // and the buffer write protect pointer (receive buffer read pointer) 
....................     WasDiscarded = TRUE; 
007A6:  MOVLB  1
007A8:  BSF    x10.2
....................     NextPacketLocation.Val = RXSTART; 
007AA:  CLRF   x24
007AC:  CLRF   x23
....................  
....................     WriteReg(ERXSTL, LOW(RXSTART)); 
007AE:  MOVLW  08
007B0:  MOVLB  4
007B2:  MOVWF  x63
007B4:  CLRF   x64
007B6:  MOVLB  0
007B8:  RCALL  05E2
....................     WriteReg(ERXSTH, HIGH(RXSTART)); 
007BA:  MOVLW  09
007BC:  MOVLB  4
007BE:  MOVWF  x63
007C0:  CLRF   x64
007C2:  MOVLB  0
007C4:  RCALL  05E2
....................     WriteReg(ERXRDPTL, LOW(RXSTOP));    // Write low byte first 
007C6:  MOVLW  0C
007C8:  MOVLB  4
007CA:  MOVWF  x63
007CC:  MOVLW  D5
007CE:  MOVWF  x64
007D0:  MOVLB  0
007D2:  RCALL  05E2
....................     WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
007D4:  MOVLW  0D
007D6:  MOVLB  4
007D8:  MOVWF  x63
007DA:  MOVLW  11
007DC:  MOVWF  x64
007DE:  MOVLB  0
007E0:  RCALL  05E2
....................     WriteReg(ERXNDL, LOW(RXSTOP)); 
007E2:  MOVLW  0A
007E4:  MOVLB  4
007E6:  MOVWF  x63
007E8:  MOVLW  D5
007EA:  MOVWF  x64
007EC:  MOVLB  0
007EE:  RCALL  05E2
....................     WriteReg(ERXNDH, HIGH(RXSTOP)); 
007F0:  MOVLW  0B
007F2:  MOVLB  4
007F4:  MOVWF  x63
007F6:  MOVLW  11
007F8:  MOVWF  x64
007FA:  MOVLB  0
007FC:  RCALL  05E2
....................     WriteReg(ETXSTL, LOW(TXSTART)); 
007FE:  MOVLW  04
00800:  MOVLB  4
00802:  MOVWF  x63
00804:  MOVLW  D6
00806:  MOVWF  x64
00808:  MOVLB  0
0080A:  RCALL  05E2
....................     WriteReg(ETXSTH, HIGH(TXSTART)); 
0080C:  MOVLW  05
0080E:  MOVLB  4
00810:  MOVWF  x63
00812:  MOVLW  11
00814:  MOVWF  x64
00816:  MOVLB  0
00818:  RCALL  05E2
....................  
....................     // Write a permanant per packet control byte of 0x00 
....................     WriteReg(EWRPTL, LOW(TXSTART)); 
0081A:  MOVLW  02
0081C:  MOVLB  4
0081E:  MOVWF  x63
00820:  MOVLW  D6
00822:  MOVWF  x64
00824:  MOVLB  0
00826:  RCALL  05E2
....................     WriteReg(EWRPTH, HIGH(TXSTART)); 
00828:  MOVLW  03
0082A:  MOVLB  4
0082C:  MOVWF  x63
0082E:  MOVLW  11
00830:  MOVWF  x64
00832:  MOVLB  0
00834:  RCALL  05E2
....................     MACPut(0x00); 
00836:  MOVLB  4
00838:  CLRF   x61
0083A:  MOVLB  0
0083C:  RCALL  060C
....................  
....................  
....................     // Enter Bank 1 and configure Receive Filters 
....................     // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................     // acceptable) 
....................     // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................  
....................     // Promiscious mode example: 
....................     //BankSel(ERXFCON); 
....................     //WriteReg((BYTE)ERXFCON, ERXFCON_CRCEN); 
....................  
....................     // Enter Bank 2 and configure the MAC 
....................     BankSel(MACON1); 
0083E:  MOVLW  02
00840:  MOVLB  4
00842:  MOVWF  x43
00844:  CLRF   x42
00846:  MOVLB  0
00848:  RCALL  065A
....................  
....................     // Enable the receive portion of the MAC 
....................     WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
0084A:  MOVLB  4
0084C:  CLRF   x63
0084E:  MOVLW  0D
00850:  MOVWF  x64
00852:  MOVLB  0
00854:  RCALL  05E2
....................  
....................     // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
.................... #if defined(FULL_DUPLEX) 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX); 
....................     WriteReg((BYTE)MABBIPG, 0x15); 
.................... #else 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
00856:  MOVLW  02
00858:  MOVLB  4
0085A:  MOVWF  x63
0085C:  MOVLW  32
0085E:  MOVWF  x64
00860:  MOVLB  0
00862:  RCALL  05E2
....................     WriteReg((BYTE)MABBIPG, 0x12); 
00864:  MOVLW  04
00866:  MOVLB  4
00868:  MOVWF  x63
0086A:  MOVLW  12
0086C:  MOVWF  x64
0086E:  MOVLB  0
00870:  RCALL  05E2
.................... #endif 
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
00872:  MOVLW  03
00874:  MOVLB  4
00876:  MOVWF  x63
00878:  MOVLW  40
0087A:  MOVWF  x64
0087C:  MOVLB  0
0087E:  RCALL  05E2
....................  
....................     // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................     // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................     // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
00880:  MOVLW  09
00882:  MOVLB  4
00884:  MOVWF  x63
00886:  MOVLW  3F
00888:  MOVWF  x64
0088A:  MOVLB  0
0088C:  RCALL  05E2
....................  
....................     // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................     // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................     // later. 
....................     WriteReg((BYTE)MAIPGL, 0x12); 
0088E:  MOVLW  06
00890:  MOVLB  4
00892:  MOVWF  x63
00894:  MOVLW  12
00896:  MOVWF  x64
00898:  MOVLB  0
0089A:  RCALL  05E2
....................     WriteReg((BYTE)MAIPGH, 0x0C); 
0089C:  MOVLW  07
0089E:  MOVLB  4
008A0:  MOVWF  x63
008A2:  MOVLW  0C
008A4:  MOVWF  x64
008A6:  MOVLB  0
008A8:  RCALL  05E2
....................  
....................     // Set the maximum packet size which the controller will accept 
....................     WriteReg((BYTE)MAMXFLL, LOW(6+6+2+1500+4));  // 1518 is the IEEE 802.3 specified limit 
008AA:  MOVLW  0A
008AC:  MOVLB  4
008AE:  MOVWF  x63
008B0:  MOVLW  EE
008B2:  MOVWF  x64
008B4:  MOVLB  0
008B6:  RCALL  05E2
....................     WriteReg((BYTE)MAMXFLH, HIGH(6+6+2+1500+4)); // 1518 is the IEEE 802.3 specified limit 
008B8:  MOVLW  0B
008BA:  MOVLB  4
008BC:  MOVWF  x63
008BE:  MOVLW  05
008C0:  MOVWF  x64
008C2:  MOVLB  0
008C4:  RCALL  05E2
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................     BankSel(MAADR1); 
008C6:  MOVLW  03
008C8:  MOVLB  4
008CA:  MOVWF  x43
008CC:  MOVLW  04
008CE:  MOVWF  x42
008D0:  MOVLB  0
008D2:  RCALL  065A
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
008D4:  MOVLW  04
008D6:  MOVLB  4
008D8:  MOVWF  x63
008DA:  MOVFF  50,464
008DE:  MOVLB  0
008E0:  RCALL  05E2
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
008E2:  MOVLW  05
008E4:  MOVLB  4
008E6:  MOVWF  x63
008E8:  MOVFF  51,464
008EC:  MOVLB  0
008EE:  RCALL  05E2
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
008F0:  MOVLW  02
008F2:  MOVLB  4
008F4:  MOVWF  x63
008F6:  MOVFF  52,464
008FA:  MOVLB  0
008FC:  RCALL  05E2
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
008FE:  MOVLW  03
00900:  MOVLB  4
00902:  MOVWF  x63
00904:  MOVFF  53,464
00908:  MOVLB  0
0090A:  RCALL  05E2
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
0090C:  MOVLB  4
0090E:  CLRF   x63
00910:  MOVFF  54,464
00914:  MOVLB  0
00916:  RCALL  05E2
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
00918:  MOVLW  01
0091A:  MOVLB  4
0091C:  MOVWF  x63
0091E:  MOVFF  55,464
00922:  MOVLB  0
00924:  RCALL  05E2
....................  
....................     // Disable the CLKOUT output to reduce EMI generation 
....................     WriteReg((BYTE)ECOCON, 0x00);   // Output off (0V) 
00926:  MOVLW  15
00928:  MOVLB  4
0092A:  MOVWF  x63
0092C:  CLRF   x64
0092E:  MOVLB  0
00930:  RCALL  05E2
....................     //WriteReg((BYTE)ECOCON, 0x01); // 25.000MHz 
....................     //WriteReg((BYTE)ECOCON, 0x03); // 8.3333MHz (*4 with PLL is 33.3333MHz) 
....................  
....................     // Get the Rev ID so that we can implement the correct errata workarounds 
....................     ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
00932:  MOVLW  12
00934:  MOVLB  4
00936:  MOVWF  x5E
00938:  MOVLB  0
0093A:  RCALL  05B8
0093C:  MOVFF  01,127
....................  
....................     // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................     // side effect. 
....................     WritePHYReg(PHCON2, PHCON2_HDLDIS); 
00940:  MOVLW  10
00942:  MOVLB  3
00944:  MOVWF  xC1
00946:  MOVLW  01
00948:  MOVWF  xC3
0094A:  CLRF   xC2
0094C:  MOVLB  0
0094E:  RCALL  06C6
....................  
....................     // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................     SetLEDConfig(0x3472); 
00950:  MOVLW  14
00952:  MOVLB  3
00954:  MOVWF  xC1
00956:  MOVLW  34
00958:  MOVWF  xC3
0095A:  MOVLW  72
0095C:  MOVWF  xC2
0095E:  MOVLB  0
00960:  RCALL  06C6
....................  
....................     // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................     WritePHYReg(PHCON1, PHCON1_PDPXMD); 
.................... #elif defined(HALF_DUPLEX) 
....................     WritePHYReg(PHCON1, 0x0000); 
00962:  MOVLB  3
00964:  CLRF   xC1
00966:  CLRF   xC3
00968:  CLRF   xC2
0096A:  MOVLB  0
0096C:  RCALL  06C6
.................... #else 
....................     // Use the external LEDB polarity to determine weather full or half duplex 
....................     // communication mode should be set. 
....................     { 
....................         REG Register; 
....................         PHYREG PhyReg; 
....................  
....................         // Read the PHY duplex mode 
....................         PhyReg = ReadPHYReg(PHCON1); 
....................         DuplexState = PhyReg.PHCON1bits.PDPXMD; 
....................  
....................         // Set the MAC to the proper duplex mode 
....................         BankSel(MACON3); 
....................         Register = ReadMACReg((BYTE)MACON3); 
....................         Register.MACON3bits.FULDPX = PhyReg.PHCON1bits.PDPXMD; 
....................         WriteReg((BYTE)MACON3, Register.Val); 
....................  
....................         // Set the back-to-back inter-packet gap time to IEEE specified 
....................         // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................         // state, so it must be updated in this function. 
....................         // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................         WriteReg((BYTE)MABBIPG, PhyReg.PHCON1bits.PDPXMD ? 0x15 : 0x12); 
....................     } 
.................... #endif 
....................  
....................     BankSel(ERDPTL);        // Return to default Bank 0 
0096E:  MOVLB  4
00970:  CLRF   x43
00972:  CLRF   x42
00974:  MOVLB  0
00976:  RCALL  065A
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
00978:  MOVLW  1F
0097A:  MOVLB  4
0097C:  MOVWF  x58
0097E:  MOVLW  04
00980:  MOVWF  x59
00982:  MOVLB  0
00984:  RCALL  0630
00986:  GOTO   1532 (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                        and the link has been up continuously since the last 
....................  *                        call to MACIsLinked() 
....................  *                  FALSE: If the PHY reports no link partner, or the link went 
....................  *                         down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................     // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................     // goes down and comes back up before a higher level stack program calls 
....................     // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................     // call to MACIsLinked() will return TRUE (unless the link goes down 
....................     // again). 
....................     return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
0160E:  MOVLW  01
01610:  MOVLB  3
01612:  MOVWF  xCA
01614:  MOVLB  0
01616:  BRA    1552
01618:  MOVFF  01,3CA
0161C:  MOVLW  00
0161E:  MOVLB  3
01620:  BTFSC  01.2
01622:  MOVLW  01
01624:  MOVWF  01
01626:  MOVLB  0
01628:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *                  FALSE: If a previous transmission was started, and it has 
....................  *                         not completed yet.  While FALSE, the data in the 
....................  *                         transmit buffer and the TXST/TXND pointers must not 
....................  *                         be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
01786:  MOVLW  1F
01788:  MOVLB  4
0178A:  MOVWF  x5E
0178C:  MOVLB  0
0178E:  CALL   05B8
01792:  MOVFF  01,43E
01796:  MOVLW  00
01798:  MOVLB  4
0179A:  BTFSC  01.3
0179C:  MOVLW  01
0179E:  XORLW  00
017A0:  BZ    17A6
017A2:  MOVLW  00
017A4:  BRA    17A8
017A6:  MOVLW  01
017A8:  MOVWF  01
017AA:  MOVLB  0
017AC:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *                  MACGetHeader())as being processed and frees the buffer 
....................  *                  memory associated with it 
....................  * 
....................  * Note:            Is is safe to call this function multiple times between 
....................  *                  MACGetHeader() calls.  Extra packets won't be thrown away 
....................  *                  until MACGetHeader() makes it available. 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................     WORD_VAL NewRXRDLocation; 
....................  
....................     // Make sure the current packet was not already discarded 
....................     if(WasDiscarded) 
*
02602:  MOVLB  1
02604:  BTFSS  x10.2
02606:  BRA    260A
....................         return; 
02608:  BRA    2668
....................     WasDiscarded = TRUE; 
0260A:  BSF    x10.2
....................  
....................     // Decrement the next packet pointer before writing it into 
....................     // the ERXRDPT registers.  This is a silicon errata workaround. 
....................     // RX buffer wrapping must be taken into account if the 
....................     // NextPacketLocation is precisely RXSTART. 
....................     NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
0260C:  MOVLW  01
0260E:  SUBWF  x23,W
02610:  MOVLB  3
02612:  MOVWF  xF4
02614:  MOVLW  00
02616:  MOVLB  1
02618:  SUBWFB x24,W
0261A:  MOVLB  3
0261C:  MOVWF  xF5
....................     if(NewRXRDLocation.Val > RXSTOP) 
0261E:  MOVF   xF5,W
02620:  SUBLW  10
02622:  BC    2636
02624:  XORLW  FF
02626:  BNZ   262E
02628:  MOVF   xF4,W
0262A:  SUBLW  D5
0262C:  BC    2636
....................     { 
....................         NewRXRDLocation.Val = RXSTOP; 
0262E:  MOVLW  11
02630:  MOVWF  xF5
02632:  MOVLW  D5
02634:  MOVWF  xF4
....................     } 
....................  
....................     // Decrement the RX packet counter register, EPKTCNT 
....................     BFSReg(ECON2, ECON2_PKTDEC); 
02636:  MOVLW  1E
02638:  MOVLB  4
0263A:  MOVWF  x58
0263C:  MOVLW  40
0263E:  MOVWF  x59
02640:  MOVLB  0
02642:  CALL   0630
....................  
....................     // Move the receive read pointer to unwrite-protect the memory used by the 
....................     // last packet.  The writing order is important: set the low byte first, 
....................     // high byte last. 
....................     WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
02646:  MOVLW  0C
02648:  MOVLB  4
0264A:  MOVWF  x63
0264C:  MOVFF  3F4,464
02650:  MOVLB  0
02652:  CALL   05E2
....................     WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
02656:  MOVLW  0D
02658:  MOVLB  4
0265A:  MOVWF  x63
0265C:  MOVFF  3F5,464
02660:  MOVLB  0
02662:  CALL   05E2
02666:  MOVLB  1
02668:  MOVLB  0
0266A:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *                  the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................     WORD_VAL ReadPT, WritePT; 
....................  
....................     // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................     // received at any time, it can change between reading the low and high 
....................     // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................     // is read. 
....................     BankSel(EPKTCNT); 
*
03024:  MOVLW  01
03026:  MOVLB  4
03028:  MOVWF  x43
0302A:  MOVLW  19
0302C:  MOVWF  x42
0302E:  MOVLB  0
03030:  CALL   065A
....................     do { 
....................         // Save EPKTCNT in a temporary location 
....................         ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
03034:  MOVLW  19
03036:  MOVLB  4
03038:  MOVWF  x5E
0303A:  MOVLB  0
0303C:  CALL   05B8
03040:  MOVFF  01,43E
....................  
....................         BankSel(ERXWRPTL); 
03044:  MOVLB  4
03046:  CLRF   x43
03048:  MOVLW  0E
0304A:  MOVWF  x42
0304C:  MOVLB  0
0304E:  CALL   065A
....................         WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
03052:  MOVLW  0E
03054:  MOVLB  4
03056:  MOVWF  x5E
03058:  MOVLB  0
0305A:  CALL   05B8
0305E:  MOVFF  01,440
....................         WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
03062:  MOVLW  0F
03064:  MOVLB  4
03066:  MOVWF  x5E
03068:  MOVLB  0
0306A:  CALL   05B8
0306E:  MOVFF  01,441
....................  
....................         BankSel(EPKTCNT); 
03072:  MOVLW  01
03074:  MOVLB  4
03076:  MOVWF  x43
03078:  MOVLW  19
0307A:  MOVWF  x42
0307C:  MOVLB  0
0307E:  CALL   065A
....................     } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
03082:  MOVLW  19
03084:  MOVLB  4
03086:  MOVWF  x5E
03088:  MOVLB  0
0308A:  CALL   05B8
0308E:  MOVFF  01,442
03092:  MOVLB  4
03094:  MOVF   x3E,W
03096:  SUBWF  01,W
03098:  BTFSC  FD8.2
0309A:  BRA    30A0
0309C:  MOVLB  0
0309E:  BRA    3034
....................  
....................     // Determine where the write protection pointer is 
....................     BankSel(ERXRDPTL); 
030A0:  CLRF   x43
030A2:  MOVLW  0C
030A4:  MOVWF  x42
030A6:  MOVLB  0
030A8:  CALL   065A
....................     ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
030AC:  MOVLW  0C
030AE:  MOVLB  4
030B0:  MOVWF  x5E
030B2:  MOVLB  0
030B4:  CALL   05B8
030B8:  MOVFF  01,43E
....................     ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
030BC:  MOVLW  0D
030BE:  MOVLB  4
030C0:  MOVWF  x5E
030C2:  MOVLB  0
030C4:  CALL   05B8
030C8:  MOVFF  01,43F
....................  
....................     // Calculate the difference between the pointers, taking care to account 
....................     // for buffer wrapping conditions 
....................     if(WritePT.Val > ReadPT.Val) 
030CC:  MOVLB  4
030CE:  MOVF   x3F,W
030D0:  SUBWF  x41,W
030D2:  BNC   3100
030D4:  BNZ   30DC
030D6:  MOVF   x40,W
030D8:  SUBWF  x3E,W
030DA:  BC    3100
....................     { 
....................         return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
030DC:  MOVF   x3E,W
030DE:  SUBWF  x40,W
030E0:  MOVWF  00
030E2:  MOVF   x3F,W
030E4:  SUBWFB x41,W
030E6:  MOVWF  03
030E8:  MOVF   00,W
030EA:  XORLW  FF
030EC:  ADDLW  D6
030EE:  MOVWF  00
030F0:  MOVLW  11
030F2:  SUBFWB 03,F
030F4:  MOVFF  00,01
030F8:  MOVFF  03,02
030FC:  BRA    3136
....................     } 
030FE:  BRA    3136
....................     else if(WritePT.Val == ReadPT.Val) 
03100:  MOVF   x3E,W
03102:  SUBWF  x40,W
03104:  BNZ   3118
03106:  MOVF   x3F,W
03108:  SUBWF  x41,W
0310A:  BNZ   3118
....................     { 
....................         return RXSIZE - 1; 
0310C:  MOVLW  D5
0310E:  MOVWF  01
03110:  MOVLW  11
03112:  MOVWF  02
03114:  BRA    3136
....................     } 
03116:  BRA    3136
....................     else 
....................     { 
....................         return ReadPT.Val - WritePT.Val - 1; 
03118:  MOVF   x40,W
0311A:  SUBWF  x3E,W
0311C:  MOVWF  x42
0311E:  MOVF   x41,W
03120:  SUBWFB x3F,W
03122:  MOVWF  x43
03124:  MOVLW  01
03126:  SUBWF  x42,W
03128:  MOVWF  00
0312A:  MOVLW  00
0312C:  SUBWFB x43,W
0312E:  MOVWF  03
03130:  MOVFF  00,01
03134:  MOVWF  02
....................     } 
03136:  MOVLB  0
03138:  GOTO   3A8C (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                           received frame. 
....................  *                  *type: Location of a BYTE to store the constant 
....................  *                         MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                         the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                        remote, and type values are updated. 
....................  *                  FALSE: If a packet was not pending.  remote and type are 
....................  *                         not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *                  been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................     ENC_PREAMBLE header; 
....................     BYTE PacketCount; 
....................  
....................     // Test if at least one packet has been received and is waiting 
....................     BankSel(EPKTCNT); 
*
0460A:  MOVLW  01
0460C:  MOVLB  4
0460E:  MOVWF  x43
04610:  MOVLW  19
04612:  MOVWF  x42
04614:  MOVLB  0
04616:  CALL   065A
....................     PacketCount = ReadETHReg((BYTE)EPKTCNT).Val; 
0461A:  MOVLW  19
0461C:  MOVLB  4
0461E:  MOVWF  x5E
04620:  MOVLB  0
04622:  CALL   05B8
04626:  MOVFF  01,3E1
....................     BankSel(ERDPTL); 
0462A:  MOVLB  4
0462C:  CLRF   x43
0462E:  CLRF   x42
04630:  MOVLB  0
04632:  CALL   065A
....................     if(PacketCount == 0u) 
04636:  MOVLB  3
04638:  MOVF   xE1,F
0463A:  BNZ   4642
....................         return FALSE; 
0463C:  MOVLW  00
0463E:  MOVWF  01
04640:  BRA    475A
....................  
....................     // Make absolutely certain that any previous packet was discarded 
....................     if(WasDiscarded == FALSE) 
04642:  MOVLB  1
04644:  BTFSC  x10.2
04646:  BRA    4658
....................     { 
....................         MACDiscardRx(); 
04648:  MOVLB  0
0464A:  CALL   2602
....................         return FALSE; 
0464E:  MOVLW  00
04650:  MOVWF  01
04652:  MOVLB  3
04654:  BRA    475A
04656:  MOVLB  1
....................     } 
....................  
....................     // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................     CurrentPacketLocation.Val = NextPacketLocation.Val; 
04658:  MOVFF  124,126
0465C:  MOVFF  123,125
....................     WriteReg(ERDPTL, CurrentPacketLocation.v[0]); 
04660:  MOVLB  4
04662:  CLRF   x63
04664:  MOVFF  125,464
04668:  MOVLB  0
0466A:  CALL   05E2
....................     WriteReg(ERDPTH, CurrentPacketLocation.v[1]); 
0466E:  MOVLW  01
04670:  MOVLB  4
04672:  MOVWF  x63
04674:  MOVFF  126,464
04678:  MOVLB  0
0467A:  CALL   05E2
....................  
....................     // Obtain the MAC header from the Ethernet buffer 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
0467E:  MOVLW  03
04680:  MOVLB  3
04682:  MOVWF  xE3
04684:  MOVLW  CD
04686:  MOVWF  xE2
04688:  MOVFF  3E3,461
0468C:  MOVFF  FE8,460
04690:  MOVLB  4
04692:  CLRF   x63
04694:  MOVLW  14
04696:  MOVWF  x62
04698:  MOVLB  0
0469A:  CALL   0C14
....................  
....................     // The EtherType field, like most items transmitted on the Ethernet medium 
....................     // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
0469E:  MOVFF  3E0,45E
046A2:  MOVFF  3DF,45D
046A6:  CALL   1A24
046AA:  MOVFF  02,3E0
046AE:  MOVFF  01,3DF
....................  
....................     // Validate the data returned from the ENC28J60.  Random data corruption, 
....................     // such as if a single SPI bit error occurs while communicating or a 
....................     // momentary power glitch could cause this to occur in rare circumstances. 
....................     if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................        header.StatusVector.bits.Zero || 
....................        header.StatusVector.bits.CRCError || 
....................        header.StatusVector.bits.ByteCount > 1518u || 
....................        !header.StatusVector.bits.ReceiveOk) 
046B2:  MOVLB  3
046B4:  MOVF   xCE,W
046B6:  SUBLW  10
046B8:  BC    46C4
046BA:  XORLW  FF
046BC:  BNZ   46F0
046BE:  MOVF   xCD,W
046C0:  SUBLW  D5
046C2:  BNC   46F0
046C4:  MOVLW  03
046C6:  MOVWF  xE3
046C8:  MOVLW  CD
046CA:  MOVWF  FE9
046CC:  MOVFF  3E3,FEA
046D0:  BTFSC  FEF.0
046D2:  BRA    46F0
046D4:  BTFSC  xD2.7
046D6:  BRA    46F0
046D8:  BTFSC  xD1.4
046DA:  BRA    46F0
046DC:  MOVF   xD0,W
046DE:  SUBLW  04
046E0:  BC    46EC
046E2:  XORLW  FF
046E4:  BNZ   46F0
046E6:  MOVF   xCF,W
046E8:  SUBLW  EE
046EA:  BNC   46F0
046EC:  BTFSC  xD1.7
046EE:  BRA    46F2
....................     { 
....................         Reset(); 
046F0:  RESET
....................     } 
....................  
....................     // Save the location where the hardware will write the next packet to 
....................     NextPacketLocation.Val = header.NextPacketPointer; 
046F2:  MOVFF  3CE,124
046F6:  MOVFF  3CD,123
....................  
....................     // Return the Ethernet frame's Source MAC address field to the caller 
....................     // This parameter is useful for replying to requests without requiring an 
....................     // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
046FA:  MOVFF  3CA,03
046FE:  MOVFF  3C9,3E2
04702:  MOVFF  3CA,3E3
04706:  MOVLW  03
04708:  MOVWF  xE5
0470A:  MOVLW  D9
0470C:  MOVFF  3CA,FEA
04710:  MOVFF  3C9,FE9
04714:  MOVFF  3E5,FE2
04718:  MOVWF  FE1
0471A:  MOVLW  06
0471C:  MOVWF  01
0471E:  MOVFF  FE6,FEE
04722:  DECFSZ 01,F
04724:  BRA    471E
....................  
....................     // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
04726:  MOVFF  3CC,03
0472A:  MOVFF  3CB,FE9
0472E:  MOVFF  03,FEA
04732:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................         ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
04734:  MOVF   xE0,W
04736:  SUBLW  08
04738:  BNZ   4750
0473A:  MOVF   xDF,F
0473C:  BZ    4744
0473E:  MOVF   xDF,W
04740:  SUBLW  06
04742:  BNZ   4750
....................     { 
....................         *type = header.Type.v[0]; 
04744:  MOVFF  3CB,FE9
04748:  MOVFF  3CC,FEA
0474C:  MOVFF  3DF,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
04750:  MOVLB  1
04752:  BCF    x10.2
....................     return TRUE; 
04754:  MOVLW  01
04756:  MOVWF  01
04758:  MOVLB  3
0475A:  MOVLB  0
0475C:  GOTO   6C62 (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                           MAC address (6 bytes) 
....................  *                  type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                        value to write into the Ethernet header's type field. 
....................  *                  dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *                  advantagous to call this function immediately before 
....................  *                  transmitting a packet rather than initially when the 
....................  *                  packet is first created.  The order in which the packet 
....................  *                  is constructed (header first or data first) is not 
....................  *                  important. 
....................  *****************************************************************************/ 
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
.................... { 
....................     // Set the SPI write pointer to the beginning of the transmit buffer (post per packet control byte) 
....................     WriteReg(EWRPTL, LOW(TXSTART+1)); 
*
01C08:  MOVLW  02
01C0A:  MOVLB  4
01C0C:  MOVWF  x63
01C0E:  MOVLW  D7
01C10:  MOVWF  x64
01C12:  MOVLB  0
01C14:  CALL   05E2
....................     WriteReg(EWRPTH, HIGH(TXSTART+1)); 
01C18:  MOVLW  03
01C1A:  MOVLB  4
01C1C:  MOVWF  x63
01C1E:  MOVLW  11
01C20:  MOVWF  x64
01C22:  MOVLB  0
01C24:  CALL   05E2
....................  
....................     // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
01C28:  MOVLW  E4
01C2A:  MOVLB  4
01C2C:  ADDWF  x5E,F
01C2E:  MOVLW  11
01C30:  ADDWFC x5F,F
....................  
....................     // Write the TXND pointer into the registers, given the dataLen given 
....................     WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
01C32:  MOVLW  04
01C34:  MOVWF  x61
01C36:  MOVLW  5E
01C38:  MOVWF  x60
01C3A:  MOVWF  FE9
01C3C:  MOVFF  461,FEA
01C40:  MOVFF  FEF,462
01C44:  MOVLW  06
01C46:  MOVWF  x63
01C48:  MOVFF  462,464
01C4C:  MOVLB  0
01C4E:  CALL   05E2
....................     WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
01C52:  MOVLW  04
01C54:  MOVLB  4
01C56:  MOVWF  x61
01C58:  MOVLW  5E
01C5A:  MOVWF  x60
01C5C:  MOVLW  01
01C5E:  ADDWF  x60,W
01C60:  MOVWF  FE9
01C62:  MOVLW  00
01C64:  ADDWFC x61,W
01C66:  MOVWF  FEA
01C68:  MOVFF  FEF,462
01C6C:  MOVLW  07
01C6E:  MOVWF  x63
01C70:  MOVFF  462,464
01C74:  MOVLB  0
01C76:  CALL   05E2
....................  
....................     // Set the per-packet control byte and write the Ethernet destination 
....................     // address 
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
01C7A:  MOVFF  45C,463
01C7E:  MOVFF  45B,462
01C82:  MOVLB  4
01C84:  CLRF   x65
01C86:  MOVLW  06
01C88:  MOVWF  x64
01C8A:  MOVLB  0
01C8C:  CALL   0B62
....................  
....................     // Write our MAC address in the Ethernet source field 
....................     MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
01C90:  MOVLB  4
01C92:  CLRF   x61
01C94:  MOVLW  50
01C96:  MOVWF  x60
01C98:  MOVFF  461,463
01C9C:  MOVWF  x62
01C9E:  CLRF   x65
01CA0:  MOVLW  06
01CA2:  MOVWF  x64
01CA4:  MOVLB  0
01CA6:  CALL   0B62
....................  
....................     // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
01CAA:  MOVLW  08
01CAC:  MOVLB  4
01CAE:  MOVWF  x61
01CB0:  MOVLB  0
01CB2:  CALL   060C
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
01CB6:  MOVLB  4
01CB8:  MOVF   x5D,F
01CBA:  BNZ   1CC0
01CBC:  MOVLW  00
01CBE:  BRA    1CC2
01CC0:  MOVLW  06
01CC2:  MOVWF  x60
01CC4:  MOVWF  x61
01CC6:  MOVLB  0
01CC8:  CALL   060C
01CCC:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *                  MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *                  the Ethernet medium.  The hardware MAC will take control 
....................  *                  and handle CRC generation, collision retransmission and 
....................  *                  other details. 
....................  * 
....................  * Note:            After transmission completes (MACIsTxReady() returns TRUE), 
....................  *                  the packet can be modified and transmitted again by calling 
....................  *                  MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *                  called (in the TX data area), the data in the TX buffer 
....................  *                  will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
....................     // Reset transmit logic if a TX Error has previously occured 
....................     // This is a silicon errata workaround 
....................     BFSReg(ECON1, ECON1_TXRST); 
*
01DB8:  MOVLW  1F
01DBA:  MOVLB  4
01DBC:  MOVWF  x58
01DBE:  MOVLW  80
01DC0:  MOVWF  x59
01DC2:  MOVLB  0
01DC4:  CALL   0630
....................     BFCReg(ECON1, ECON1_TXRST); 
01DC8:  MOVLW  1F
01DCA:  MOVLB  4
01DCC:  MOVWF  x58
01DCE:  MOVLW  80
01DD0:  MOVWF  x59
01DD2:  MOVLB  0
01DD4:  CALL   0556
....................     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01DD8:  MOVLW  1C
01DDA:  MOVLB  4
01DDC:  MOVWF  x58
01DDE:  MOVLW  0A
01DE0:  MOVWF  x59
01DE2:  MOVLB  0
01DE4:  CALL   0556
....................  
....................     // Start the transmission 
....................     // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................     // can be modified and transmitted again by calling MACFlush() again. 
....................     // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................     // corrupted. 
....................     BFSReg(ECON1, ECON1_TXRTS); 
01DE8:  MOVLW  1F
01DEA:  MOVLB  4
01DEC:  MOVWF  x58
01DEE:  MOVLW  08
01DF0:  MOVWF  x59
01DF2:  MOVLB  0
01DF4:  CALL   0630
....................  
....................     // Revision B5 and B7 silicon errata workaround 
....................     if(ENCRevID == 0x05u || ENCRevID == 0x06u) 
01DF8:  MOVLB  1
01DFA:  MOVF   x27,W
01DFC:  SUBLW  05
01DFE:  BZ    1E08
01E00:  MOVF   x27,W
01E02:  SUBLW  06
01E04:  BTFSS  FD8.2
01E06:  BRA    1FEC
....................     { 
....................         WORD AttemptCounter = 0x0000; 
01E08:  MOVLB  4
01E0A:  CLRF   x3F
01E0C:  CLRF   x3E
....................         while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)) && (++AttemptCounter < 1000u)); 
01E0E:  MOVLW  1C
01E10:  MOVWF  x5E
01E12:  MOVLB  0
01E14:  CALL   05B8
01E18:  MOVFF  01,44C
01E1C:  MOVLB  4
01E1E:  MOVF   01,W
01E20:  ANDLW  0A
01E22:  BNZ   1E38
01E24:  INCF   x3E,F
01E26:  BTFSC  FD8.2
01E28:  INCF   x3F,F
01E2A:  MOVF   x3F,W
01E2C:  SUBLW  03
01E2E:  BNC   1E38
01E30:  BNZ   1E0E
01E32:  MOVF   x3E,W
01E34:  SUBLW  E7
01E36:  BC    1E0E
....................         if(ReadETHReg(EIR).EIRbits.TXERIF || (AttemptCounter >= 1000u)) 
01E38:  MOVLW  1C
01E3A:  MOVWF  x5E
01E3C:  MOVLB  0
01E3E:  CALL   05B8
01E42:  MOVFF  01,44C
01E46:  MOVLW  00
01E48:  MOVLB  4
01E4A:  BTFSC  01.1
01E4C:  MOVLW  01
01E4E:  XORLW  00
01E50:  BNZ   1E66
01E52:  MOVF   x3F,W
01E54:  SUBLW  02
01E56:  BTFSC  FD8.0
01E58:  BRA    1FEA
01E5A:  XORLW  FF
01E5C:  BNZ   1E66
01E5E:  MOVF   x3E,W
01E60:  SUBLW  E7
01E62:  BTFSC  FD8.0
01E64:  BRA    1FEA
....................         { 
....................             WORD_VAL ReadPtrSave; 
....................             WORD_VAL TXEnd; 
....................             TXSTATUS TXStatus; 
....................             BYTE i; 
....................  
....................             // Cancel the previous transmission if it has become stuck set 
....................             BFCReg(ECON1, ECON1_TXRTS); 
01E66:  MOVLW  1F
01E68:  MOVWF  x58
01E6A:  MOVLW  08
01E6C:  MOVWF  x59
01E6E:  MOVLB  0
01E70:  CALL   0556
....................  
....................             // Save the current read pointer (controlled by application) 
....................             ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
01E74:  MOVLB  4
01E76:  CLRF   x5E
01E78:  MOVLB  0
01E7A:  CALL   05B8
01E7E:  MOVFF  01,440
....................             ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
01E82:  MOVLW  01
01E84:  MOVLB  4
01E86:  MOVWF  x5E
01E88:  MOVLB  0
01E8A:  CALL   05B8
01E8E:  MOVFF  01,441
....................  
....................             // Get the location of the transmit status vector 
....................             TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
01E92:  MOVLW  06
01E94:  MOVLB  4
01E96:  MOVWF  x5E
01E98:  MOVLB  0
01E9A:  CALL   05B8
01E9E:  MOVFF  01,442
....................             TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
01EA2:  MOVLW  07
01EA4:  MOVLB  4
01EA6:  MOVWF  x5E
01EA8:  MOVLB  0
01EAA:  CALL   05B8
01EAE:  MOVFF  01,443
....................             TXEnd.Val++; 
01EB2:  MOVLB  4
01EB4:  INCF   x42,F
01EB6:  BTFSC  FD8.2
01EB8:  INCF   x43,F
....................  
....................             // Read the transmit status vector 
....................             WriteReg(ERDPTL, TXEnd.v[0]); 
01EBA:  CLRF   x63
01EBC:  MOVFF  442,464
01EC0:  MOVLB  0
01EC2:  CALL   05E2
....................             WriteReg(ERDPTH, TXEnd.v[1]); 
01EC6:  MOVLW  01
01EC8:  MOVLB  4
01ECA:  MOVWF  x63
01ECC:  MOVFF  443,464
01ED0:  MOVLB  0
01ED2:  CALL   05E2
....................             MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01ED6:  MOVLW  04
01ED8:  MOVLB  4
01EDA:  MOVWF  x4D
01EDC:  MOVLW  44
01EDE:  MOVWF  x4C
01EE0:  MOVFF  44D,461
01EE4:  MOVWF  x60
01EE6:  CLRF   x63
01EE8:  MOVLW  07
01EEA:  MOVWF  x62
01EEC:  MOVLB  0
01EEE:  CALL   0C14
....................  
....................             // Implement retransmission if a late collision occured (this can 
....................             // happen on B5 when certain link pulses arrive at the same time 
....................             // as the transmission) 
....................             for(i = 0; i < 16u; i++) 
01EF2:  MOVLB  4
01EF4:  CLRF   x4B
01EF6:  MOVF   x4B,W
01EF8:  SUBLW  0F
01EFA:  BNC   1FCC
....................             { 
....................                 if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
01EFC:  MOVLW  1C
01EFE:  MOVWF  x5E
01F00:  MOVLB  0
01F02:  CALL   05B8
01F06:  MOVFF  01,44C
01F0A:  MOVLW  00
01F0C:  MOVLB  4
01F0E:  BTFSC  01.1
01F10:  MOVLW  01
01F12:  XORLW  00
01F14:  BZ    1FC2
01F16:  BTFSS  x47.5
01F18:  BRA    1FC2
....................                 { 
....................                     // Reset the TX logic 
....................                     BFSReg(ECON1, ECON1_TXRST); 
01F1A:  MOVLW  1F
01F1C:  MOVWF  x58
01F1E:  MOVLW  80
01F20:  MOVWF  x59
01F22:  MOVLB  0
01F24:  CALL   0630
....................                     BFCReg(ECON1, ECON1_TXRST); 
01F28:  MOVLW  1F
01F2A:  MOVLB  4
01F2C:  MOVWF  x58
01F2E:  MOVLW  80
01F30:  MOVWF  x59
01F32:  MOVLB  0
01F34:  CALL   0556
....................                     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01F38:  MOVLW  1C
01F3A:  MOVLB  4
01F3C:  MOVWF  x58
01F3E:  MOVLW  0A
01F40:  MOVWF  x59
01F42:  MOVLB  0
01F44:  CALL   0556
....................  
....................                     // Transmit the packet again 
....................                     BFSReg(ECON1, ECON1_TXRTS); 
01F48:  MOVLW  1F
01F4A:  MOVLB  4
01F4C:  MOVWF  x58
01F4E:  MOVLW  08
01F50:  MOVWF  x59
01F52:  MOVLB  0
01F54:  CALL   0630
....................                     while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01F58:  MOVLW  1C
01F5A:  MOVLB  4
01F5C:  MOVWF  x5E
01F5E:  MOVLB  0
01F60:  CALL   05B8
01F64:  MOVFF  01,44C
01F68:  MOVLB  4
01F6A:  MOVF   01,W
01F6C:  ANDLW  0A
01F6E:  BTFSS  FD8.2
01F70:  BRA    1F76
01F72:  MOVLB  0
01F74:  BRA    1F58
....................  
....................                     // Cancel the previous transmission if it has become stuck set 
....................                     BFCReg(ECON1, ECON1_TXRTS); 
01F76:  MOVLW  1F
01F78:  MOVWF  x58
01F7A:  MOVLW  08
01F7C:  MOVWF  x59
01F7E:  MOVLB  0
01F80:  CALL   0556
....................  
....................                     // Read transmit status vector 
....................                     WriteReg(ERDPTL, TXEnd.v[0]); 
01F84:  MOVLB  4
01F86:  CLRF   x63
01F88:  MOVFF  442,464
01F8C:  MOVLB  0
01F8E:  CALL   05E2
....................                     WriteReg(ERDPTH, TXEnd.v[1]); 
01F92:  MOVLW  01
01F94:  MOVLB  4
01F96:  MOVWF  x63
01F98:  MOVFF  443,464
01F9C:  MOVLB  0
01F9E:  CALL   05E2
....................                     MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01FA2:  MOVLW  04
01FA4:  MOVLB  4
01FA6:  MOVWF  x4D
01FA8:  MOVLW  44
01FAA:  MOVWF  x4C
01FAC:  MOVFF  44D,461
01FB0:  MOVWF  x60
01FB2:  CLRF   x63
01FB4:  MOVLW  07
01FB6:  MOVWF  x62
01FB8:  MOVLB  0
01FBA:  CALL   0C14
....................                 } 
01FBE:  BRA    1FC6
01FC0:  MOVLB  4
....................                 else 
....................                 { 
....................                     break; 
01FC2:  BRA    1FCC
01FC4:  MOVLB  0
....................                 } 
01FC6:  MOVLB  4
01FC8:  INCF   x4B,F
01FCA:  BRA    1EF6
....................             } 
....................  
....................             // Restore the current read pointer 
....................             WriteReg(ERDPTL, ReadPtrSave.v[0]); 
01FCC:  CLRF   x63
01FCE:  MOVFF  440,464
01FD2:  MOVLB  0
01FD4:  CALL   05E2
....................             WriteReg(ERDPTH, ReadPtrSave.v[1]); 
01FD8:  MOVLW  01
01FDA:  MOVLB  4
01FDC:  MOVWF  x63
01FDE:  MOVFF  441,464
01FE2:  MOVLB  0
01FE4:  CALL   05E2
01FE8:  MOVLB  4
01FEA:  MOVLB  1
....................         } 
....................     } 
01FEC:  MOVLB  0
01FEE:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetReadPtrInRx(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *                  getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                          header's type field to relocate the SPI read 
....................  *                          pointer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read pointer are updated.  All calls to 
....................  *                  MACGet() and MACGetArray() will use these new values. 
....................  * 
....................  * Note:            RXSTOP must be statically defined as being > RXSTART for 
....................  *                  this function to work correctly.  In other words, do not 
....................  *                  define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *                  boundary. 
....................  *****************************************************************************/ 
.................... void MACSetReadPtrInRx(WORD offset) 
.................... { 
....................     WORD_VAL ReadPT; 
....................  
....................     // Determine the address of the beginning of the entire packet 
....................     // and adjust the address to the desired location 
....................     ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
0244C:  MOVLW  14
0244E:  MOVLB  1
02450:  ADDWF  x25,W
02452:  MOVLB  4
02454:  MOVWF  x20
02456:  MOVLW  00
02458:  MOVLB  1
0245A:  ADDWFC x26,W
0245C:  MOVLB  4
0245E:  MOVWF  x21
02460:  MOVF   x1C,W
02462:  ADDWF  x20,W
02464:  MOVWF  x1E
02466:  MOVF   x1D,W
02468:  ADDWFC x21,W
0246A:  MOVWF  x1F
....................  
....................     // Since the receive buffer is circular, adjust if a wraparound is needed 
....................     if(ReadPT.Val > RXSTOP) 
0246C:  MOVF   x1F,W
0246E:  SUBLW  10
02470:  BC    2484
02472:  XORLW  FF
02474:  BNZ   247C
02476:  MOVF   x1E,W
02478:  SUBLW  D5
0247A:  BC    2484
....................         ReadPT.Val -= RXSIZE; 
0247C:  MOVLW  D6
0247E:  SUBWF  x1E,F
02480:  MOVLW  11
02482:  SUBWFB x1F,F
....................  
....................     // Set the SPI read pointer to the new calculated value 
....................     WriteReg(ERDPTL, ReadPT.v[0]); 
02484:  CLRF   x63
02486:  MOVFF  41E,464
0248A:  MOVLB  0
0248C:  CALL   05E2
....................     WriteReg(ERDPTH, ReadPT.v[1]); 
02490:  MOVLW  01
02492:  MOVLB  4
02494:  MOVWF  x63
02496:  MOVFF  41F,464
0249A:  MOVLB  0
0249C:  CALL   05E2
024A0:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetWritePtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old EWRPT location 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(EWRPTL).Val; 
*
00AF2:  MOVLW  02
00AF4:  MOVLB  4
00AF6:  MOVWF  x5E
00AF8:  MOVLB  0
00AFA:  RCALL  05B8
00AFC:  MOVFF  01,44F
....................     oldVal.v[1] = ReadETHReg(EWRPTH).Val; 
00B00:  MOVLW  03
00B02:  MOVLB  4
00B04:  MOVWF  x5E
00B06:  MOVLB  0
00B08:  RCALL  05B8
00B0A:  MOVFF  01,450
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(EWRPTL, ((WORD_VAL*)&address)->v[0]); 
00B0E:  MOVLW  04
00B10:  MOVLB  4
00B12:  MOVWF  x52
00B14:  MOVLW  4D
00B16:  MOVWF  x51
00B18:  MOVWF  FE9
00B1A:  MOVFF  452,FEA
00B1E:  MOVFF  FEF,453
00B22:  MOVLW  02
00B24:  MOVWF  x63
00B26:  MOVFF  453,464
00B2A:  MOVLB  0
00B2C:  RCALL  05E2
....................     WriteReg(EWRPTH, ((WORD_VAL*)&address)->v[1]); 
00B2E:  MOVLW  04
00B30:  MOVLB  4
00B32:  MOVWF  x52
00B34:  MOVLW  4D
00B36:  MOVWF  x51
00B38:  MOVLW  01
00B3A:  ADDWF  x51,W
00B3C:  MOVWF  FE9
00B3E:  MOVLW  00
00B40:  ADDWFC x52,W
00B42:  MOVWF  FEA
00B44:  MOVFF  FEF,453
00B48:  MOVLW  03
00B4A:  MOVWF  x63
00B4C:  MOVFF  453,464
00B50:  MOVLB  0
00B52:  RCALL  05E2
....................  
....................     return oldVal.Val; 
00B54:  MOVLB  4
00B56:  MOVFF  44F,01
00B5A:  MOVFF  450,02
00B5E:  MOVLB  0
00B60:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetReadPtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old ERDPT value 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(ERDPTL).Val; 
*
00BA8:  MOVLB  4
00BAA:  CLRF   x5E
00BAC:  MOVLB  0
00BAE:  RCALL  05B8
00BB0:  MOVFF  01,44F
....................     oldVal.v[1] = ReadETHReg(ERDPTH).Val; 
00BB4:  MOVLW  01
00BB6:  MOVLB  4
00BB8:  MOVWF  x5E
00BBA:  MOVLB  0
00BBC:  RCALL  05B8
00BBE:  MOVFF  01,450
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(ERDPTL, ((WORD_VAL*)&address)->v[0]); 
00BC2:  MOVLW  04
00BC4:  MOVLB  4
00BC6:  MOVWF  x52
00BC8:  MOVLW  4D
00BCA:  MOVWF  x51
00BCC:  MOVWF  FE9
00BCE:  MOVFF  452,FEA
00BD2:  MOVFF  FEF,453
00BD6:  CLRF   x63
00BD8:  MOVFF  453,464
00BDC:  MOVLB  0
00BDE:  RCALL  05E2
....................     WriteReg(ERDPTH, ((WORD_VAL*)&address)->v[1]); 
00BE0:  MOVLW  04
00BE2:  MOVLB  4
00BE4:  MOVWF  x52
00BE6:  MOVLW  4D
00BE8:  MOVWF  x51
00BEA:  MOVLW  01
00BEC:  ADDWF  x51,W
00BEE:  MOVWF  FE9
00BF0:  MOVLW  00
00BF2:  ADDWFC x52,W
00BF4:  MOVWF  FEA
00BF6:  MOVFF  FEF,453
00BFA:  MOVLW  01
00BFC:  MOVWF  x63
00BFE:  MOVFF  453,464
00C02:  MOVLB  0
00C04:  RCALL  05E2
....................  
....................     return oldVal.Val; 
00C06:  MOVLB  4
00C08:  MOVFF  44F,01
00C0C:  MOVFF  450,02
00C10:  MOVLB  0
00C12:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset  - Number of bytes beyond the beginning of the 
....................  *                          Ethernet data (first byte after the type field) 
....................  *                          where the checksum should begin 
....................  *                  len     - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................     WORD_VAL temp; 
....................     WORD_VAL RDSave; 
....................  
....................     // Add the offset requested by firmware plus the Ethernet header 
....................     temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
04A5C:  MOVLW  14
04A5E:  MOVLB  1
04A60:  ADDWF  x25,W
04A62:  MOVLB  3
04A64:  MOVWF  xEF
04A66:  MOVLW  00
04A68:  MOVLB  1
04A6A:  ADDWFC x26,W
04A6C:  MOVLB  3
04A6E:  MOVWF  xF0
04A70:  MOVF   xE7,W
04A72:  ADDWF  xEF,W
04A74:  MOVWF  xEB
04A76:  MOVF   xE8,W
04A78:  ADDWFC xF0,W
04A7A:  MOVWF  xEC
....................     if(temp.Val > RXSTOP)       // Adjust value if a wrap is needed 
04A7C:  MOVF   xEC,W
04A7E:  SUBLW  10
04A80:  BC    4A94
04A82:  XORLW  FF
04A84:  BNZ   4A8C
04A86:  MOVF   xEB,W
04A88:  SUBLW  D5
04A8A:  BC    4A94
....................     { 
....................         temp.Val -= RXSIZE; 
04A8C:  MOVLW  D6
04A8E:  SUBWF  xEB,F
04A90:  MOVLW  11
04A92:  SUBWFB xEC,F
....................     } 
....................  
....................     RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
04A94:  MOVLB  4
04A96:  CLRF   x5E
04A98:  MOVLB  0
04A9A:  CALL   05B8
04A9E:  MOVFF  01,3ED
....................     RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
04AA2:  MOVLW  01
04AA4:  MOVLB  4
04AA6:  MOVWF  x5E
04AA8:  MOVLB  0
04AAA:  CALL   05B8
04AAE:  MOVFF  01,3EE
....................  
....................     WriteReg(ERDPTL, temp.v[0]); 
04AB2:  MOVLB  4
04AB4:  CLRF   x63
04AB6:  MOVFF  3EB,464
04ABA:  MOVLB  0
04ABC:  CALL   05E2
....................     WriteReg(ERDPTH, temp.v[1]); 
04AC0:  MOVLW  01
04AC2:  MOVLB  4
04AC4:  MOVWF  x63
04AC6:  MOVFF  3EC,464
04ACA:  MOVLB  0
04ACC:  CALL   05E2
....................  
....................     temp.Val = CalcIPBufferChecksum(len); 
04AD0:  MOVFF  3EA,43F
04AD4:  MOVFF  3E9,43E
04AD8:  CALL   34D8
04ADC:  MOVFF  02,3EC
04AE0:  MOVFF  01,3EB
....................  
....................     WriteReg(ERDPTL, RDSave.v[0]); 
04AE4:  MOVLB  4
04AE6:  CLRF   x63
04AE8:  MOVFF  3ED,464
04AEC:  MOVLB  0
04AEE:  CALL   05E2
....................     WriteReg(ERDPTH, RDSave.v[1]); 
04AF2:  MOVLW  01
04AF4:  MOVLB  4
04AF6:  MOVWF  x63
04AF8:  MOVFF  3EE,464
04AFC:  MOVLB  0
04AFE:  CALL   05E2
....................  
....................     return temp.Val; 
04B02:  MOVLB  3
04B04:  MOVFF  3EB,01
04B08:  MOVFF  3EC,02
04B0C:  MOVLB  0
04B0E:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                       The first byte included in the checksum is the byte 
....................  *                       pointed to by ERDPT, which is updated by calls to 
....................  *                       MACSetReadPtr(), MACGet(), MACGetArray(), 
....................  *                       MACGetHeader(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *                  which can calculate the checksum faster than software, so 
....................  *                  this function replaces the CaclIPBufferChecksum() function 
....................  *                  defined in the helpers.c file.  Through the use of 
....................  *                  preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *                  buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     WORD_VAL Start; 
....................     DWORD_VAL Checksum = {0x00000000ul}; 
*
034D8:  MOVLB  4
034DA:  CLRF   x42
034DC:  CLRF   x43
034DE:  CLRF   x44
034E0:  CLRF   x45
....................     WORD ChunkLen; 
....................     WORD DataBuffer[10]; 
....................     WORD *DataPtr; 
....................  
....................     // Save the SPI read pointer starting address 
....................     Start.v[0] = ReadETHReg(ERDPTL).Val; 
034E2:  CLRF   x5E
034E4:  MOVLB  0
034E6:  CALL   05B8
034EA:  MOVFF  01,440
....................     Start.v[1] = ReadETHReg(ERDPTH).Val; 
034EE:  MOVLW  01
034F0:  MOVLB  4
034F2:  MOVWF  x5E
034F4:  MOVLB  0
034F6:  CALL   05B8
034FA:  MOVFF  01,441
....................  
....................     while(len) 
034FE:  MOVLB  4
03500:  MOVF   x3E,W
03502:  IORWF  x3F,W
03504:  BZ    35B6
....................     { 
....................         // Obtain a chunk of data (less SPI overhead compared 
....................         // to requesting one byte at a time) 
....................         ChunkLen = len > sizeof(DataBuffer) ? sizeof(DataBuffer) : len; 
03506:  MOVF   x3F,F
03508:  BNZ   3510
0350A:  MOVF   x3E,W
0350C:  SUBLW  14
0350E:  BC    3516
03510:  CLRF   03
03512:  MOVLW  14
03514:  BRA    351C
03516:  MOVFF  43F,03
0351A:  MOVF   x3E,W
0351C:  MOVWF  x46
0351E:  MOVFF  03,447
....................         MACGetArray((BYTE*)DataBuffer, ChunkLen); 
03522:  MOVLW  04
03524:  MOVWF  x5F
03526:  MOVLW  48
03528:  MOVWF  x5E
0352A:  MOVFF  45F,461
0352E:  MOVWF  x60
03530:  MOVFF  447,463
03534:  MOVFF  446,462
03538:  MOVLB  0
0353A:  CALL   0C14
....................  
....................         len -= ChunkLen; 
0353E:  MOVLB  4
03540:  MOVF   x46,W
03542:  SUBWF  x3E,F
03544:  MOVF   x47,W
03546:  SUBWFB x3F,F
....................  
....................         // Take care of a last odd numbered data byte 
....................         if(((WORD_VAL*)&ChunkLen)->bits.b0) 
03548:  MOVLW  04
0354A:  MOVWF  x5F
0354C:  MOVLW  46
0354E:  MOVWF  FE9
03550:  MOVFF  45F,FEA
03554:  BTFSS  FEF.0
03556:  BRA    3570
....................         { 
....................             ((BYTE*)DataBuffer)[ChunkLen] = 0x00; 
03558:  MOVLW  04
0355A:  MOVWF  x5F
0355C:  MOVLW  48
0355E:  ADDWF  x46,W
03560:  MOVWF  FE9
03562:  MOVF   x5F,W
03564:  ADDWFC x47,W
03566:  MOVWF  FEA
03568:  CLRF   FEF
....................             ChunkLen++; 
0356A:  INCF   x46,F
0356C:  BTFSC  FD8.2
0356E:  INCF   x47,F
....................         } 
....................  
....................         // Calculate the checksum over this chunk 
....................         DataPtr = DataBuffer; 
03570:  MOVLW  04
03572:  MOVWF  x5D
03574:  MOVLW  48
03576:  MOVWF  x5C
....................         while(ChunkLen) 
03578:  MOVF   x46,W
0357A:  IORWF  x47,W
0357C:  BZ    35B4
....................         { 
....................             Checksum.Val += *DataPtr++; 
0357E:  MOVFF  45D,03
03582:  MOVFF  45C,00
03586:  MOVLW  02
03588:  ADDWF  x5C,F
0358A:  BTFSC  FD8.0
0358C:  INCF   x5D,F
0358E:  MOVFF  00,FE9
03592:  MOVFF  03,FEA
03596:  MOVFF  FEC,03
0359A:  MOVF   FED,F
0359C:  MOVF   FEF,W
0359E:  ADDWF  x42,F
035A0:  MOVF   03,W
035A2:  ADDWFC x43,F
035A4:  MOVLW  00
035A6:  ADDWFC x44,F
035A8:  ADDWFC x45,F
....................             ChunkLen -= 2; 
035AA:  MOVLW  02
035AC:  SUBWF  x46,F
035AE:  MOVLW  00
035B0:  SUBWFB x47,F
035B2:  BRA    3578
....................         } 
035B4:  BRA    3500
....................     } 
....................  
....................     // Restore old read pointer location 
....................     WriteReg(ERDPTL, Start.v[0]); 
035B6:  CLRF   x63
035B8:  MOVFF  440,464
035BC:  MOVLB  0
035BE:  CALL   05E2
....................     WriteReg(ERDPTH, Start.v[1]); 
035C2:  MOVLW  01
035C4:  MOVLB  4
035C6:  MOVWF  x63
035C8:  MOVFF  441,464
035CC:  MOVLB  0
035CE:  CALL   05E2
....................  
....................     // Do an end-around carry (one's complement arrithmatic) 
....................     Checksum.Val = (DWORD)Checksum.w[0] + (DWORD)Checksum.w[1]; 
035D2:  MOVLB  4
035D4:  CLRF   x61
035D6:  CLRF   x60
035D8:  MOVFF  443,45F
035DC:  MOVFF  442,45E
035E0:  MOVFF  444,00
035E4:  MOVFF  445,01
035E8:  CLRF   02
035EA:  CLRF   03
035EC:  MOVF   x44,W
035EE:  ADDWF  x42,W
035F0:  MOVWF  x42
035F2:  MOVF   x45,W
035F4:  ADDWFC x43,W
035F6:  MOVWF  x43
035F8:  MOVF   02,W
035FA:  ADDWFC x60,W
035FC:  MOVWF  x44
035FE:  MOVF   03,W
03600:  ADDWFC x61,W
03602:  MOVWF  x45
....................  
....................     // Do another end-around carry in case if the prior add 
....................     // caused a carry out 
....................     Checksum.w[0] += Checksum.w[1]; 
03604:  MOVF   x44,W
03606:  ADDWF  x42,F
03608:  MOVF   x45,W
0360A:  ADDWFC x43,F
....................  
....................     // Return the resulting checksum 
....................     return ~Checksum.w[0]; 
0360C:  MOVFF  443,03
03610:  COMF   03,F
03612:  MOVF   x42,W
03614:  XORLW  FF
03616:  MOVWF  01
03618:  MOVFF  03,02
0361C:  MOVLB  0
0361E:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           destAddr:   Destination address in the Ethernet memory to 
....................  *                              copy to.  If (PTR_BASE)-1 is specified, the  
....................  *                        current EWRPT value will be used instead. 
....................  *                  sourceAddr: Source address to read from.  If (PTR_BASE)-1 is 
....................  *                              specified, the current ERDPT value will be used 
....................  *                              instead. 
....................  *                  len:        Number of bytes to copy 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Bytes are asynchrnously transfered within the buffer.  Call 
....................  *                  MACIsMemCopyDone() to see when the transfer is complete. 
....................  * 
....................  * Note:            If a prior transfer is already in progress prior to 
....................  *                  calling this function, this function will block until it 
....................  *                  can start this transfer. 
....................  * 
....................  *                  If (PTR_BASE)-1 is used for the sourceAddr or destAddr 
....................  *                  parameters, then that pointer will get updated with the 
....................  *                  next address after the read or write. 
....................  *****************************************************************************/ 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
*
00CB4:  MOVLB  4
00CB6:  BCF    x57.0
00CB8:  BCF    x57.1
.................... { 
....................     WORD_VAL ReadSave, WriteSave; 
....................     BOOL UpdateWritePointer = FALSE; 
....................     BOOL UpdateReadPointer = FALSE; 
....................  
....................     if(destAddr == (PTR_BASE)-1) 
00CBA:  INCFSZ x4D,W
00CBC:  BRA    0CE2
00CBE:  INCFSZ x4E,W
00CC0:  BRA    0CE2
....................     { 
....................         UpdateWritePointer = TRUE; 
00CC2:  BSF    x57.0
....................         destAddr = ReadETHReg(EWRPTL).Val; 
00CC4:  MOVLW  02
00CC6:  MOVWF  x5E
00CC8:  MOVLB  0
00CCA:  RCALL  05B8
00CCC:  MOVLB  4
00CCE:  CLRF   x4E
00CD0:  MOVFF  01,44D
....................         ((BYTE*)&destAddr)[1] = ReadETHReg(EWRPTH).Val; 
00CD4:  MOVLW  03
00CD6:  MOVWF  x5E
00CD8:  MOVLB  0
00CDA:  RCALL  05B8
00CDC:  MOVFF  01,44E
00CE0:  MOVLB  4
....................     } 
....................     if(sourceAddr == (PTR_BASE)-1) 
00CE2:  INCFSZ x4F,W
00CE4:  BRA    0D08
00CE6:  INCFSZ x50,W
00CE8:  BRA    0D08
....................     { 
....................         UpdateReadPointer = TRUE; 
00CEA:  BSF    x57.1
....................         sourceAddr = ReadETHReg(ERDPTL).Val; 
00CEC:  CLRF   x5E
00CEE:  MOVLB  0
00CF0:  RCALL  05B8
00CF2:  MOVLB  4
00CF4:  CLRF   x50
00CF6:  MOVFF  01,44F
....................         ((BYTE*)&sourceAddr)[1] = ReadETHReg(ERDPTH).Val; 
00CFA:  MOVLW  01
00CFC:  MOVWF  x5E
00CFE:  MOVLB  0
00D00:  RCALL  05B8
00D02:  MOVFF  01,450
00D06:  MOVLB  4
....................     } 
....................  
....................     // Handle special conditions where len == 0 or len == 1 
....................     // The DMA module is not capable of handling those corner cases 
....................     if(len <= 1u) 
00D08:  MOVF   x52,F
00D0A:  BTFSS  FD8.2
00D0C:  BRA    0DEE
00D0E:  MOVF   x51,W
00D10:  SUBLW  01
00D12:  BTFSS  FD8.0
00D14:  BRA    0DEE
....................     { 
....................         if(!UpdateReadPointer) 
00D16:  BTFSC  x57.1
00D18:  BRA    0D34
....................         { 
....................             ReadSave.v[0] = ReadETHReg(ERDPTL).Val; 
00D1A:  CLRF   x5E
00D1C:  MOVLB  0
00D1E:  RCALL  05B8
00D20:  MOVFF  01,453
....................             ReadSave.v[1] = ReadETHReg(ERDPTH).Val; 
00D24:  MOVLW  01
00D26:  MOVLB  4
00D28:  MOVWF  x5E
00D2A:  MOVLB  0
00D2C:  RCALL  05B8
00D2E:  MOVFF  01,454
00D32:  MOVLB  4
....................         } 
....................         if(!UpdateWritePointer) 
00D34:  BTFSC  x57.0
00D36:  BRA    0D54
....................         { 
....................             WriteSave.v[0] = ReadETHReg(EWRPTL).Val; 
00D38:  MOVLW  02
00D3A:  MOVWF  x5E
00D3C:  MOVLB  0
00D3E:  RCALL  05B8
00D40:  MOVFF  01,455
....................             WriteSave.v[1] = ReadETHReg(EWRPTH).Val; 
00D44:  MOVLW  03
00D46:  MOVLB  4
00D48:  MOVWF  x5E
00D4A:  MOVLB  0
00D4C:  RCALL  05B8
00D4E:  MOVFF  01,456
00D52:  MOVLB  4
....................         } 
....................         WriteReg(ERDPTL, ((BYTE*)&sourceAddr)[0]); 
00D54:  CLRF   x63
00D56:  MOVFF  44F,464
00D5A:  MOVLB  0
00D5C:  RCALL  05E2
....................         WriteReg(ERDPTH, ((BYTE*)&sourceAddr)[1]); 
00D5E:  MOVLW  01
00D60:  MOVLB  4
00D62:  MOVWF  x63
00D64:  MOVFF  450,464
00D68:  MOVLB  0
00D6A:  RCALL  05E2
....................         WriteReg(EWRPTL, ((BYTE*)&destAddr)[0]); 
00D6C:  MOVLW  02
00D6E:  MOVLB  4
00D70:  MOVWF  x63
00D72:  MOVFF  44D,464
00D76:  MOVLB  0
00D78:  RCALL  05E2
....................         WriteReg(EWRPTH, ((BYTE*)&destAddr)[1]); 
00D7A:  MOVLW  03
00D7C:  MOVLB  4
00D7E:  MOVWF  x63
00D80:  MOVFF  44E,464
00D84:  MOVLB  0
00D86:  RCALL  05E2
....................         while(len--) 
00D88:  MOVLB  4
00D8A:  MOVFF  452,03
00D8E:  MOVF   x51,W
00D90:  BTFSC  FD8.2
00D92:  DECF   x52,F
00D94:  DECF   x51,F
00D96:  IORWF  03,W
00D98:  BZ    0DAC
....................             MACPut(MACGet()); 
00D9A:  MOVLB  0
00D9C:  RCALL  0C8A
00D9E:  MOVFF  01,458
00DA2:  MOVFF  01,461
00DA6:  RCALL  060C
00DA8:  BRA    0D88
00DAA:  MOVLB  4
....................         if(!UpdateReadPointer) 
00DAC:  BTFSC  x57.1
00DAE:  BRA    0DCA
....................         { 
....................             WriteReg(ERDPTL, ReadSave.v[0]); 
00DB0:  CLRF   x63
00DB2:  MOVFF  453,464
00DB6:  MOVLB  0
00DB8:  RCALL  05E2
....................             WriteReg(ERDPTH, ReadSave.v[1]); 
00DBA:  MOVLW  01
00DBC:  MOVLB  4
00DBE:  MOVWF  x63
00DC0:  MOVFF  454,464
00DC4:  MOVLB  0
00DC6:  RCALL  05E2
00DC8:  MOVLB  4
....................         } 
....................         if(!UpdateWritePointer) 
00DCA:  BTFSC  x57.0
00DCC:  BRA    0DEC
....................         { 
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
00DCE:  MOVLW  02
00DD0:  MOVWF  x63
00DD2:  MOVFF  455,464
00DD6:  MOVLB  0
00DD8:  RCALL  05E2
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
00DDA:  MOVLW  03
00DDC:  MOVLB  4
00DDE:  MOVWF  x63
00DE0:  MOVFF  456,464
00DE4:  MOVLB  0
00DE6:  CALL   05E2
00DEA:  MOVLB  4
....................         } 
....................     } 
00DEC:  BRA    0F40
....................     else 
....................     { 
....................         if(UpdateWritePointer) 
00DEE:  BTFSS  x57.0
00DF0:  BRA    0E1E
....................         { 
....................             WriteSave.Val = destAddr + len; 
00DF2:  MOVF   x51,W
00DF4:  ADDWF  x4D,W
00DF6:  MOVWF  x55
00DF8:  MOVF   x52,W
00DFA:  ADDWFC x4E,W
00DFC:  MOVWF  x56
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
00DFE:  MOVLW  02
00E00:  MOVWF  x63
00E02:  MOVFF  455,464
00E06:  MOVLB  0
00E08:  CALL   05E2
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
00E0C:  MOVLW  03
00E0E:  MOVLB  4
00E10:  MOVWF  x63
00E12:  MOVFF  456,464
00E16:  MOVLB  0
00E18:  CALL   05E2
00E1C:  MOVLB  4
....................         } 
....................         len += sourceAddr - 1; 
00E1E:  MOVLW  01
00E20:  SUBWF  x4F,W
00E22:  MOVWF  00
00E24:  MOVLW  00
00E26:  SUBWFB x50,W
00E28:  MOVWF  03
00E2A:  MOVF   00,W
00E2C:  ADDWF  x51,F
00E2E:  MOVF   03,W
00E30:  ADDWFC x52,F
....................         while(ReadETHReg(ECON1).ECON1bits.DMAST); 
00E32:  MOVLW  1F
00E34:  MOVWF  x5E
00E36:  MOVLB  0
00E38:  CALL   05B8
00E3C:  MOVFF  01,458
00E40:  MOVLW  00
00E42:  MOVLB  4
00E44:  BTFSC  01.5
00E46:  MOVLW  01
00E48:  XORLW  00
00E4A:  BNZ   0E32
....................         WriteReg(EDMASTL, ((BYTE*)&sourceAddr)[0]); 
00E4C:  MOVLW  10
00E4E:  MOVWF  x63
00E50:  MOVFF  44F,464
00E54:  MOVLB  0
00E56:  CALL   05E2
....................         WriteReg(EDMASTH, ((BYTE*)&sourceAddr)[1]); 
00E5A:  MOVLW  11
00E5C:  MOVLB  4
00E5E:  MOVWF  x63
00E60:  MOVFF  450,464
00E64:  MOVLB  0
00E66:  CALL   05E2
....................         WriteReg(EDMADSTL, ((BYTE*)&destAddr)[0]); 
00E6A:  MOVLW  14
00E6C:  MOVLB  4
00E6E:  MOVWF  x63
00E70:  MOVFF  44D,464
00E74:  MOVLB  0
00E76:  CALL   05E2
....................         WriteReg(EDMADSTH, ((BYTE*)&destAddr)[1]); 
00E7A:  MOVLW  15
00E7C:  MOVLB  4
00E7E:  MOVWF  x63
00E80:  MOVFF  44E,464
00E84:  MOVLB  0
00E86:  CALL   05E2
....................         if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
00E8A:  MOVLB  4
00E8C:  MOVF   x50,W
00E8E:  SUBLW  11
00E90:  BNC   0EB2
00E92:  BNZ   0E9A
00E94:  MOVF   x4F,W
00E96:  SUBLW  D5
00E98:  BNC   0EB2
00E9A:  MOVF   x52,W
00E9C:  SUBLW  10
00E9E:  BC    0EB2
00EA0:  XORLW  FF
00EA2:  BNZ   0EAA
00EA4:  MOVF   x51,W
00EA6:  SUBLW  D5
00EA8:  BC    0EB2
....................             len -= RXSIZE; 
00EAA:  MOVLW  D6
00EAC:  SUBWF  x51,F
00EAE:  MOVLW  11
00EB0:  SUBWFB x52,F
....................         WriteReg(EDMANDL, ((BYTE*)&len)[0]); 
00EB2:  MOVLW  12
00EB4:  MOVWF  x63
00EB6:  MOVFF  451,464
00EBA:  MOVLB  0
00EBC:  CALL   05E2
....................         WriteReg(EDMANDH, ((BYTE*)&len)[1]); 
00EC0:  MOVLW  13
00EC2:  MOVLB  4
00EC4:  MOVWF  x63
00EC6:  MOVFF  452,464
00ECA:  MOVLB  0
00ECC:  CALL   05E2
....................         BFCReg(ECON1, ECON1_CSUMEN); 
00ED0:  MOVLW  1F
00ED2:  MOVLB  4
00ED4:  MOVWF  x58
00ED6:  MOVLW  10
00ED8:  MOVWF  x59
00EDA:  MOVLB  0
00EDC:  CALL   0556
....................         BFSReg(ECON1, ECON1_DMAST); 
00EE0:  MOVLW  1F
00EE2:  MOVLB  4
00EE4:  MOVWF  x58
00EE6:  MOVLW  20
00EE8:  MOVWF  x59
00EEA:  MOVLB  0
00EEC:  CALL   0630
....................         if(UpdateReadPointer) 
00EF0:  MOVLB  4
00EF2:  BTFSS  x57.1
00EF4:  BRA    0F40
....................         { 
....................             len++; 
00EF6:  INCF   x51,F
00EF8:  BTFSC  FD8.2
00EFA:  INCF   x52,F
....................             if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
00EFC:  MOVF   x50,W
00EFE:  SUBLW  11
00F00:  BNC   0F22
00F02:  BNZ   0F0A
00F04:  MOVF   x4F,W
00F06:  SUBLW  D5
00F08:  BNC   0F22
00F0A:  MOVF   x52,W
00F0C:  SUBLW  10
00F0E:  BC    0F22
00F10:  XORLW  FF
00F12:  BNZ   0F1A
00F14:  MOVF   x51,W
00F16:  SUBLW  D5
00F18:  BC    0F22
....................                 len -= RXSIZE; 
00F1A:  MOVLW  D6
00F1C:  SUBWF  x51,F
00F1E:  MOVLW  11
00F20:  SUBWFB x52,F
....................             WriteReg(ERDPTL, ((BYTE*)&len)[0]); 
00F22:  CLRF   x63
00F24:  MOVFF  451,464
00F28:  MOVLB  0
00F2A:  CALL   05E2
....................             WriteReg(ERDPTH, ((BYTE*)&len)[1]); 
00F2E:  MOVLW  01
00F30:  MOVLB  4
00F32:  MOVWF  x63
00F34:  MOVFF  452,464
00F38:  MOVLB  0
00F3A:  CALL   05E2
00F3E:  MOVLB  4
....................         } 
....................     } 
00F40:  MOVLB  0
00F42:  RETURN 0
.................... } 
....................  
.................... BOOL MACIsMemCopyDone(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.DMAST; 
00F44:  MOVLW  1F
00F46:  MOVLB  4
00F48:  MOVWF  x5E
00F4A:  MOVLB  0
00F4C:  CALL   05B8
00F50:  MOVFF  01,44D
00F54:  MOVLW  00
00F56:  MOVLB  4
00F58:  BTFSC  01.5
00F5A:  MOVLW  01
00F5C:  XORLW  00
00F5E:  BZ    0F64
00F60:  MOVLW  00
00F62:  BRA    0F66
00F64:  MOVLW  01
00F66:  MOVWF  01
00F68:  MOVLB  0
00F6A:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *                  increments ERDPT so MACGet() can be called again.  The 
....................  *                  increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
....................     BYTE Result; 
....................  
....................     ENC_CS_IO = 0; 
*
00C8A:  BCF    F8B.1
....................    ClearSPIDoneFlag(); 
00C8C:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         // Send the opcode and read a byte in two 8-bit operations 
....................         ENC_SSPBUF = RBM; 
00C8E:  MOVLW  3A
00C90:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/address is transmitted. 
00C92:  BTFSS  F9E.3
00C94:  BRA    0C92
00C96:  BCF    F9E.3
....................         Result = ENC_SSPBUF; 
00C98:  MOVFF  FC9,458
....................  
....................         ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
00C9C:  CLRF   FC9
....................                                 //   contents. 
....................         WaitForDataByte();      // Wait until register is received. 
00C9E:  BTFSS  F9E.3
00CA0:  BRA    0C9E
00CA2:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Result = ENC_SSPBUF; 
00CA4:  MOVFF  FC9,458
....................     ENC_CS_IO = 1; 
00CA8:  BSF    F8B.1
....................  
....................     return Result; 
00CAA:  MOVLB  4
00CAC:  MOVFF  458,01
00CB0:  MOVLB  0
00CB2:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *                  len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *                  and places them into local memory.  With SPI burst support, 
....................  *                  it performs much faster than multiple MACGet() calls. 
....................  *                  ERDPT is incremented after each byte, following the same 
....................  *                  rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
....................         if(val) 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................             *val++ = ENC_SSPBUF; 
....................         } 
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................         } 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return len; 
.................... #else 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     // Start the burst operation 
....................     ENC_CS_IO = 0; 
*
00C14:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
00C16:  BCF    F9E.3
....................     ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
00C18:  MOVLW  3A
00C1A:  MOVWF  FC9
....................     i = 0; 
00C1C:  MOVLB  4
00C1E:  CLRF   x65
00C20:  CLRF   x64
....................     if(val) 
00C22:  MOVF   x60,W
00C24:  IORWF  x61,W
00C26:  BZ    0C30
....................         val--; 
00C28:  MOVF   x60,W
00C2A:  BTFSC  FD8.2
00C2C:  DECF   x61,F
00C2E:  DECF   x60,F
....................     WaitForDataByte();      // Wait until opcode/address is transmitted. 
00C30:  BTFSS  F9E.3
00C32:  BRA    0C30
00C34:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00C36:  MOVFF  FC9,466
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Read the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x00000000;    // Send a dummy DWORD to generate 32 clocks 
....................                 i += 4; 
....................                 WaitForDataByte();         // Wait until DWORD is transmitted 
....................                 dwv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = dwv.v[3]; 
....................                     *(++val) = dwv.v[2]; 
....................                     *(++val) = dwv.v[1]; 
....................                     *(++val) = dwv.v[0]; 
....................                 } 
....................                 if(len - i < 4) 
....................                     break; 
....................             }; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Read the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x0000;    // Send a dummy WORD to generate 32 clocks 
....................                 i += 2; 
....................                 WaitForDataByte();      // Wait until WORD is transmitted 
....................                 wv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = wv.v[1]; 
....................                     *(++val) = wv.v[0]; 
....................                 } 
....................                 if(len - i < 2) 
....................                     break; 
....................             }; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Read the data 
....................     while(i<len) 
00C3A:  MOVF   x65,W
00C3C:  SUBWF  x63,W
00C3E:  BNC   0C7C
00C40:  BNZ   0C48
00C42:  MOVF   x62,W
00C44:  SUBWF  x64,W
00C46:  BC    0C7C
....................     { 
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
00C48:  CLRF   FC9
....................         i++; 
00C4A:  INCF   x64,F
00C4C:  BTFSC  FD8.2
00C4E:  INCF   x65,F
....................         if(val) 
00C50:  MOVF   x60,W
00C52:  IORWF  x61,W
00C54:  BZ    0C70
....................         { 
....................             val++; 
00C56:  INCF   x60,F
00C58:  BTFSC  FD8.2
00C5A:  INCF   x61,F
....................             WaitForDataByte();  // Wait until byte is received. 
00C5C:  BTFSS  F9E.3
00C5E:  BRA    0C5C
00C60:  BCF    F9E.3
....................             *val = ENC_SSPBUF; 
00C62:  MOVFF  460,FE9
00C66:  MOVFF  461,FEA
00C6A:  MOVFF  FC9,FEF
....................         } 
00C6E:  BRA    0C7A
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
00C70:  BTFSS  F9E.3
00C72:  BRA    0C70
00C74:  BCF    F9E.3
....................             Dummy = ENC_SSPBUF; 
00C76:  MOVFF  FC9,466
....................         } 
00C7A:  BRA    0C3A
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
00C7C:  BSF    F8B.1
....................  
....................     return i; 
00C7E:  MOVFF  464,01
00C82:  MOVFF  465,02
.................... #endif 
00C86:  MOVLB  0
00C88:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *                  (8 bits) and data to write (8 bits) over the SPI. 
....................  *                  EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
0060C:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
0060E:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WBM;       // Send the opcode and constant. 
00610:  MOVLW  7A
00612:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/constant is transmitted. 
00614:  BTFSS  F9E.3
00616:  BRA    0614
00618:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
0061A:  MOVFF  FC9,462
....................         ENC_SSPBUF = val;       // Send the byte to be writen. 
0061E:  MOVFF  461,FC9
....................         WaitForDataByte();      // Wait until finished transmitting 
00622:  BTFSS  F9E.3
00624:  BRA    0622
00626:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
00628:  MOVFF  FC9,462
....................     ENC_CS_IO = 1; 
0062C:  BSF    F8B.1
0062E:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
*
00B62:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
00B64:  BCF    F9E.3
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
00B66:  MOVLW  7A
00B68:  MOVWF  FC9
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
00B6A:  BTFSS  F9E.3
00B6C:  BRA    0B6A
00B6E:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00B70:  MOVFF  FC9,466
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Send the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             dwv.v[3] = *val++; 
....................             dwv.v[2] = *val++; 
....................             dwv.v[1] = *val++; 
....................             dwv.v[0] = *val++; 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = dwv.Val;       // Start sending the DWORD 
....................                 len -= 4; 
....................                 if(len < 4) 
....................                     break; 
....................                 dwv.v[3] = *val++; 
....................                 dwv.v[2] = *val++; 
....................                 dwv.v[1] = *val++; 
....................                 dwv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until DWORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until DWORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Send the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             wv.v[1] = *val++; 
....................             wv.v[0] = *val++; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = wv.Val;        // Start sending the WORD 
....................                 len -= 2; 
....................                 if(len < 2) 
....................                     break; 
....................                 wv.v[1] = *val++; 
....................                 wv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until WORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until WORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Send the data, one byte at a time 
....................     while(len) 
00B74:  MOVLB  4
00B76:  MOVF   x64,W
00B78:  IORWF  x65,W
00B7A:  BZ    0BA2
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
00B7C:  MOVFF  462,FE9
00B80:  MOVFF  463,FEA
00B84:  MOVFF  FEF,FC9
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
00B88:  INCF   x62,F
00B8A:  BTFSC  FD8.2
00B8C:  INCF   x63,F
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
00B8E:  MOVF   x64,W
00B90:  BTFSC  FD8.2
00B92:  DECF   x65,F
00B94:  DECF   x64,F
....................         WaitForDataByte();  // Wait until byte is transmitted 
00B96:  BTFSS  F9E.3
00B98:  BRA    0B96
00B9A:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
00B9C:  MOVFF  FC9,466
00BA0:  BRA    0B76
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
00BA2:  BSF    F8B.1
.................... #endif 
00BA4:  MOVLB  0
00BA6:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... #if defined(__18CXX) 
.................... /****************************************************************************** 
....................  * Function:        void MACPutROMArray(ROM BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutROMArray(ROM BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
....................     ClearSPIDoneFlag(); 
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
....................     Dummy = ENC_SSPBUF; 
....................  
....................     // Send the data 
....................     while(len) 
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
....................         WaitForDataByte();  // Wait until byte is transmitted 
....................         Dummy = ENC_SSPBUF; 
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
.................... #endif 
.................... }//end MACPutROMArray 
.................... #endif 
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *                  the Ethernet controller.  It resets all register contents 
....................  *                  (except for ECOCON) and returns the device to the power 
....................  *                  on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     // Note: The power save feature may prevent the reset from executing, so 
....................     // we must make sure that the device is not in power save before issuing 
....................     // a reset. 
....................     BFCReg(ECON2, ECON2_PWRSV); 
*
00580:  MOVLW  1E
00582:  MOVLB  4
00584:  MOVWF  x58
00586:  MOVLW  20
00588:  MOVWF  x59
0058A:  MOVLB  0
0058C:  RCALL  0556
....................  
....................     // Give some opportunity for the regulator to reach normal regulation and 
....................     // have all clocks running 
....................     DelayMs(1); 
0058E:  MOVLW  01
00590:  MOVLB  3
00592:  MOVWF  xC2
00594:  MOVLB  0
00596:  RCALL  0296
....................  
....................     // Execute the System Reset command 
....................     ENC_CS_IO = 0; 
00598:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
0059A:  BCF    F9E.3
....................     ENC_SSPBUF = SR; 
0059C:  SETF   FC9
....................     WaitForDataByte();      // Wait until the command is transmitted. 
0059E:  BTFSS  F9E.3
005A0:  BRA    059E
005A2:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
005A4:  MOVFF  FC9,3C1
....................     ENC_CS_IO = 1; 
005A8:  BSF    F8B.1
....................  
....................     // Wait for the oscillator start up timer and PHY to become ready 
....................     DelayMs(1); 
005AA:  MOVLW  01
005AC:  MOVLB  3
005AE:  MOVWF  xC2
005B0:  MOVLB  0
005B2:  RCALL  0296
005B4:  GOTO   0780 (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *                  the SPI and then retrives the register contents in the 
....................  *                  next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *                  registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     // Select the chip and send the Read Control Register opcode/address 
....................     ENC_CS_IO = 0; 
005B8:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
005BA:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; 
005BC:  MOVLB  4
005BE:  MOVFF  45E,FC9
....................  
....................     WaitForDataByte();      // Wait until the opcode/address is transmitted 
005C2:  BTFSS  F9E.3
005C4:  BRA    05C2
005C6:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
005C8:  MOVFF  FC9,45F
....................     ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
005CC:  CLRF   FC9
....................                             //   contents 
....................     WaitForDataByte();      // Wait until the register is received 
005CE:  BTFSS  F9E.3
005D0:  BRA    05CE
005D2:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
005D4:  MOVFF  FC9,45F
....................     ENC_CS_IO = 1; 
005D8:  BSF    F8B.1
....................  
....................     return r; 
005DA:  MOVFF  45F,01
005DE:  MOVLB  0
005E0:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *                  as a dummy byte over the SPI and then retrives the 
....................  *                  register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *                  registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     ENC_CS_IO = 0; 
*
00690:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
00692:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; // Send the Read Control Register opcode and 
00694:  MOVLB  3
00696:  MOVFF  3CD,FC9
....................                                 //   address. 
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
0069A:  BTFSS  F9E.3
0069C:  BRA    069A
0069E:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
006A0:  MOVFF  FC9,3CE
....................     ENC_SSPBUF = 0;             // Send a dummy byte 
006A4:  CLRF   FC9
....................     WaitForDataByte();          // Wait for the dummy byte to be transmitted 
006A6:  BTFSS  F9E.3
006A8:  BRA    06A6
006AA:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
006AC:  MOVFF  FC9,3CE
....................     ENC_SSPBUF = 0;             // Send another dummy byte to receive the register 
006B0:  CLRF   FC9
....................                                 //   contents. 
....................     WaitForDataByte();          // Wait until register is received. 
006B2:  BTFSS  F9E.3
006B4:  BRA    06B2
006B6:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
006B8:  MOVFF  FC9,3CE
....................     ENC_CS_IO = 1; 
006BC:  BSF    F8B.1
....................  
....................     return r; 
006BE:  MOVFF  3CE,01
006C2:  MOVLB  0
006C4:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time 
....................  *                  (10.24us). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................     PHYREG Result; 
....................  
....................     // Set the right address and start the register read operation 
....................     BankSel(MIREGADR); 
*
01552:  MOVLW  02
01554:  MOVLB  4
01556:  MOVWF  x43
01558:  MOVLW  14
0155A:  MOVWF  x42
0155C:  MOVLB  0
0155E:  CALL   065A
....................     WriteReg((BYTE)MIREGADR, Register); 
01562:  MOVLW  14
01564:  MOVLB  4
01566:  MOVWF  x63
01568:  MOVFF  3CA,464
0156C:  MOVLB  0
0156E:  CALL   05E2
....................     WriteReg((BYTE)MICMD, MICMD_MIIRD); 
01572:  MOVLW  12
01574:  MOVLB  4
01576:  MOVWF  x63
01578:  MOVLW  01
0157A:  MOVWF  x64
0157C:  MOVLB  0
0157E:  CALL   05E2
....................  
....................     // Loop to wait until the PHY register has been read through the MII 
....................     // This requires 10.24us 
....................     BankSel(MISTAT); 
01582:  MOVLW  03
01584:  MOVLB  4
01586:  MOVWF  x43
01588:  MOVLW  0A
0158A:  MOVWF  x42
0158C:  MOVLB  0
0158E:  CALL   065A
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
01592:  MOVLW  0A
01594:  MOVLB  3
01596:  MOVWF  xCD
01598:  MOVLB  0
0159A:  CALL   0690
0159E:  MOVFF  01,3CD
015A2:  MOVLW  00
015A4:  MOVLB  3
015A6:  BTFSC  01.0
015A8:  MOVLW  01
015AA:  XORLW  00
015AC:  BTFSC  FD8.2
015AE:  BRA    15B4
015B0:  MOVLB  0
015B2:  BRA    1592
....................  
....................     // Stop reading 
....................     BankSel(MIREGADR); 
015B4:  MOVLW  02
015B6:  MOVLB  4
015B8:  MOVWF  x43
015BA:  MOVLW  14
015BC:  MOVWF  x42
015BE:  MOVLB  0
015C0:  CALL   065A
....................     WriteReg((BYTE)MICMD, 0x00); 
015C4:  MOVLW  12
015C6:  MOVLB  4
015C8:  MOVWF  x63
015CA:  CLRF   x64
015CC:  MOVLB  0
015CE:  CALL   05E2
....................  
....................     // Obtain results and return 
....................     Result.VAL.v[0] = ReadMACReg((BYTE)MIRDL).Val; 
015D2:  MOVLW  18
015D4:  MOVLB  3
015D6:  MOVWF  xCD
015D8:  MOVLB  0
015DA:  CALL   0690
015DE:  MOVFF  01,3CB
....................     Result.VAL.v[1] = ReadMACReg((BYTE)MIRDH).Val; 
015E2:  MOVLW  19
015E4:  MOVLB  3
015E6:  MOVWF  xCD
015E8:  MOVLB  0
015EA:  CALL   0690
015EE:  MOVFF  01,3CC
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
015F2:  MOVLB  4
015F4:  CLRF   x43
015F6:  CLRF   x42
015F8:  MOVLB  0
015FA:  CALL   065A
....................     return Result; 
015FE:  MOVLB  3
01600:  MOVFF  3CB,01
01604:  MOVFF  3CC,02
01608:  MOVLB  0
0160A:  GOTO   1618 (RETURN)
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                    The top 3 bits must be 0. 
....................  *                  Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *                  SPI and then sends the data to write in the next 8 SPI 
....................  *                  clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *                  BFSReg() functions.  It is seperate to maximize speed. 
....................  *                  Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *                  can write to any ETH or MAC register.  Writing to PHY 
....................  *                  registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
005E2:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
005E4:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = ((WCR | Address)<<8) | (WORD)Data; // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WCR | Address; // Send the opcode and address. 
005E6:  MOVLB  4
005E8:  MOVF   x63,W
005EA:  IORLW  40
005EC:  MOVWF  FC9
....................         WaitForDataByte();          // Wait until opcode/constant is transmitted. 
005EE:  BTFSS  F9E.3
005F0:  BRA    05EE
005F2:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
005F4:  MOVFF  FC9,465
....................         ENC_SSPBUF = Data;          // Send the byte to be writen. 
005F8:  MOVFF  464,FC9
....................         WaitForDataByte();          // Wait until finished transmitting 
005FC:  BTFSS  F9E.3
005FE:  BRA    05FC
00600:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
00602:  MOVFF  FC9,465
....................  
....................  
....................    // For faster processors (dsPIC), delay for a few clock cycles to ensure  
....................    // the MAC/MII register write Chip Select hold time minimum of 210ns is met. 
....................    #if (GetInstructionClock() > 30000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 40000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 50000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................  
....................    ENC_CS_IO = 1; 
00606:  BSF    F8B.1
00608:  MOVLB  0
0060A:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                    to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFSReg() functions.  It is separate to maximize speed. 
....................  *                  BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
00556:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
00558:  BCF    F9E.3
....................     ENC_SSPBUF = BFC | Address; // Send the opcode and address. 
0055A:  MOVLB  4
0055C:  MOVF   x58,W
0055E:  IORLW  A0
00560:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
00562:  BTFSS  F9E.3
00564:  BRA    0562
00566:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00568:  MOVFF  FC9,45A
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
0056C:  MOVFF  459,FC9
....................     WaitForDataByte();          // Wait until register is written. 
00570:  BTFSS  F9E.3
00572:  BRA    0570
00574:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00576:  MOVFF  FC9,45A
....................     ENC_CS_IO = 1; 
0057A:  BSF    F8B.1
0057C:  MOVLB  0
0057E:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFCReg() functions.  It is separate to maximize speed. 
....................  *                  BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
00630:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
00632:  BCF    F9E.3
....................     ENC_SSPBUF = BFS | Address; // Send the opcode and address. 
00634:  MOVLB  4
00636:  MOVF   x58,W
00638:  IORLW  80
0063A:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
0063C:  BTFSS  F9E.3
0063E:  BRA    063C
00640:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00642:  MOVFF  FC9,45A
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
00646:  MOVFF  459,FC9
....................     WaitForDataByte();          // Wait until register is written. 
0064A:  BTFSS  F9E.3
0064C:  BRA    064A
0064E:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00650:  MOVFF  FC9,45A
....................     ENC_CS_IO = 1; 
00654:  BSF    F8B.1
00656:  MOVLB  0
00658:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *                  16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................     // Write the register address 
....................     BankSel(MIREGADR); 
*
006C6:  MOVLW  02
006C8:  MOVLB  4
006CA:  MOVWF  x43
006CC:  MOVLW  14
006CE:  MOVWF  x42
006D0:  MOVLB  0
006D2:  RCALL  065A
....................     WriteReg((BYTE)MIREGADR, Register); 
006D4:  MOVLW  14
006D6:  MOVLB  4
006D8:  MOVWF  x63
006DA:  MOVFF  3C1,464
006DE:  MOVLB  0
006E0:  RCALL  05E2
....................  
....................     // Write the data 
....................     // Order is important: write low byte first, high byte last 
....................     WriteReg((BYTE)MIWRL, ((WORD_VAL*)&Data)->v[0]); 
006E2:  MOVLW  03
006E4:  MOVLB  3
006E6:  MOVWF  xC5
006E8:  MOVLW  C2
006EA:  MOVWF  xC4
006EC:  MOVWF  FE9
006EE:  MOVFF  3C5,FEA
006F2:  MOVFF  FEF,3C6
006F6:  MOVLW  16
006F8:  MOVLB  4
006FA:  MOVWF  x63
006FC:  MOVFF  3C6,464
00700:  MOVLB  0
00702:  RCALL  05E2
....................     WriteReg((BYTE)MIWRH, ((WORD_VAL*)&Data)->v[1]); 
00704:  MOVLW  03
00706:  MOVLB  3
00708:  MOVWF  xC5
0070A:  MOVLW  C2
0070C:  MOVWF  xC4
0070E:  MOVLW  01
00710:  ADDWF  xC4,W
00712:  MOVWF  FE9
00714:  MOVLW  00
00716:  ADDWFC xC5,W
00718:  MOVWF  FEA
0071A:  MOVFF  FEF,3C6
0071E:  MOVLW  17
00720:  MOVLB  4
00722:  MOVWF  x63
00724:  MOVFF  3C6,464
00728:  MOVLB  0
0072A:  RCALL  05E2
....................  
....................     // Wait until the PHY register has been written 
....................     BankSel(MISTAT); 
0072C:  MOVLW  03
0072E:  MOVLB  4
00730:  MOVWF  x43
00732:  MOVLW  0A
00734:  MOVWF  x42
00736:  MOVLB  0
00738:  RCALL  065A
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
0073A:  MOVLW  0A
0073C:  MOVLB  3
0073E:  MOVWF  xCD
00740:  MOVLB  0
00742:  RCALL  0690
00744:  MOVFF  01,3C4
00748:  MOVLW  00
0074A:  MOVLB  3
0074C:  BTFSC  01.0
0074E:  MOVLW  01
00750:  XORLW  00
00752:  BTFSC  FD8.2
00754:  BRA    075A
00756:  MOVLB  0
00758:  BRA    073A
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
0075A:  MOVLB  4
0075C:  CLRF   x43
0075E:  CLRF   x42
00760:  MOVLB  0
00762:  RCALL  065A
00764:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                    select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *                  changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................     BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
0065A:  MOVLW  1F
0065C:  MOVLB  4
0065E:  MOVWF  x58
00660:  MOVLW  03
00662:  MOVWF  x59
00664:  MOVLB  0
00666:  RCALL  0556
....................     BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
00668:  MOVLW  04
0066A:  MOVLB  4
0066C:  MOVWF  x45
0066E:  MOVLW  42
00670:  MOVWF  x44
00672:  MOVLW  01
00674:  ADDWF  x44,W
00676:  MOVWF  FE9
00678:  MOVLW  00
0067A:  ADDWFC x45,W
0067C:  MOVWF  FEA
0067E:  MOVFF  FEF,446
00682:  MOVLW  1F
00684:  MOVWF  x58
00686:  MOVFF  446,459
0068A:  MOVLB  0
0068C:  RCALL  0630
0068E:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *                  sleep mode, no packets can be transmitted or received. 
....................  *                  All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                  called, this function will block until it is it complete. 
....................  *                  If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................     // Disable packet reception 
....................     BFCReg(ECON1, ECON1_RXEN); 
....................  
....................     // Make sure any last packet which was in-progress when RXEN was cleared 
....................     // is completed 
....................     while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................     // If a packet is being transmitted, wait for it to finish 
....................     while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................     // Enter sleep mode 
....................     BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *                  after a previous call to MACPowerDown().  Calling this 
....................  *                  function when already powered up will have no effect. 
....................  * 
....................  * Note:            If a link partner is present, it will take 10s of 
....................  *                  milliseconds before a new link will be established after 
....................  *                  waking up.  While not linked, packets which are 
....................  *                  transmitted will most likely be lost.  MACIsLinked() can 
....................  *                  be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................     // Leave power down mode 
....................     BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................     // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................     // delay is required for the PHY module to return to an operational state. 
....................     while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                              0x01: Divide by 1 (25 MHz) 
....................  *                              0x02: Divide by 2 (12.5 MHz) 
....................  *                              0x03: Divide by 3 (8.333333 MHz) 
....................  *                              0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                              0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *                  The CLKOUT pin will beginning outputting the new frequency 
....................  *                  immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................     BankSel(ECOCON); 
....................     WriteReg((BYTE)ECOCON, NewConfig); 
....................     BankSel(ERDPTL); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                         0x01: Divide by 1 (25 MHz) 
....................  *                         0x02: Divide by 2 (12.5 MHz) 
....................  *                         0x03: Divide by 3 (8.333333 MHz) 
....................  *                         0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                         0x05: Divide by 8 (3.125 MHz) 
....................  *                         0x06: Reserved 
....................  *                         0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................     BYTE i; 
....................  
....................     BankSel(ECOCON); 
....................     i = ReadETHReg((BYTE)ECOCON).Val; 
....................     BankSel(ERDPTL); 
....................     return i; 
.................... }//end GetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
....................  * 
....................  * PreCondition:    SPI interface must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           DestMACAddr: 6 byte group destination MAC address to allow  
....................  *                         through the Hash Table Filter.  If DestMACAddr  
....................  *                         is set to 00-00-00-00-00-00, then the hash  
....................  *                         table will be cleared of all entries and the  
....................  *                         filter will be disabled. 
....................  * 
....................  * Output:          Sets the appropriate bit in the EHT* registers to allow  
....................  *               packets sent to DestMACAddr to be received and enables the  
....................  *               Hash Table receive filter (if not already). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Calculates a CRC-32 using polynomial 0x4C11DB7 and then,  
....................  *               using bits 28:23 of the CRC, sets the appropriate bit in  
....................  *               the EHT0-EHT7 registers. 
....................  * 
....................  * Note:            This code is commented out to save code space on systems  
....................  *               that do not need this function.  Change the  
....................  *               "#if STACK_USE_ZEROCONF_MDNS_SD" line to "#if 1" to  
....................  *               uncomment it, assuming you aren't using the Zeroconf module,  
....................  *               which requires mutlicast support and enables this function  
....................  *               automatically. 
....................  * 
....................  *               There is no way to individually unset destination MAC  
....................  *               addresses from the hash table since it is possible to have  
....................  *               a hash collision and therefore multiple MAC addresses  
....................  *               relying on the same hash table bit.  The stack would have  
....................  *               to individually store each 6 byte MAC address to support  
....................  *               this feature, which would waste a lot of RAM and be  
....................  *               unnecessary in most applications.  As a simple compromise,  
....................  *               you can call SetRXHashTableEntry() using a  
....................  *               00-00-00-00-00-00 destination MAC address, which will clear  
....................  *               the entire hash table and disable the hash table filter.   
....................  *               This will allow you to then re-add the necessary  
....................  *               destination address(es). 
....................  * 
....................  *               This function is intended to be used when  
....................  *               ERXFCON.ANDOR == 0 (OR). 
....................  *****************************************************************************/ 
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
.................... void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
.................... { 
....................     DWORD_VAL CRC = {0xFFFFFFFF}; 
....................     BYTE HTRegister; 
....................     BYTE i, j; 
....................  
....................    // Select proper bank for ERXFCON and EHT0-EHT7 register access 
....................    BankSel(ERXFCON); 
....................  
....................    // Clear the Hash Table bits and disable the Hash Table Filter if a special  
....................    // 00-00-00-00-00-00 destination MAC address is provided. 
....................    if((DestMACAddr.v[0] | DestMACAddr.v[1] | DestMACAddr.v[2] | DestMACAddr.v[3] | DestMACAddr.v[4] | DestMACAddr.v[5]) == 0x00u) 
....................    { 
....................       // Disable the Hash Table receive filter and clear the hash table 
....................       BFCReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................       for(i = (BYTE)EHT0; i <= (BYTE)EHT7; i++) 
....................          WriteReg(i, 0x00); 
....................    } 
....................    else 
....................    { 
....................       // Calculate a CRC-32 over the 6 byte MAC address 
....................       // using polynomial 0x4C11DB7 
....................       for(i = 0; i < sizeof(MAC_ADDR); i++) 
....................       { 
....................          BYTE  crcnext; 
....................  
....................          // shift in 8 bits 
....................          for(j = 0; j < 8; j++) 
....................          { 
....................             crcnext = 0; 
....................             if(((BYTE_VAL*)&(CRC.v[3]))->bits.b7) 
....................                crcnext = 1; 
....................             crcnext ^= (((BYTE_VAL*)&DestMACAddr.v[i])->bits.b0); 
....................  
....................             CRC.Val <<= 1; 
....................             if(crcnext) 
....................                CRC.Val ^= 0x4C11DB7; 
....................             // next bit 
....................             DestMACAddr.v[i] >>= 1; 
....................          } 
....................       } 
....................  
....................       // CRC-32 calculated, now extract bits 28:23 
....................       // Bits 25:23 define where within the Hash Table byte the bit needs to be set 
....................       // Bits 28:26 define which of the 8 Hash Table bytes that bits 25:23 apply to 
....................       i = CRC.v[3] & 0x1F; 
....................       HTRegister = (i >> 2) + (BYTE)EHT0; 
....................       i = (i << 1) & 0x06; 
....................       ((BYTE_VAL*)&i)->bits.b0 = ((BYTE_VAL*)&CRC.v[2])->bits.b7; 
....................  
....................       // Set the proper bit in the Hash Table 
....................       BFSReg(HTRegister, 1<<i); 
....................  
....................       // Ensure that the Hash Table receive filter is enabled 
....................       BFSReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................    } 
....................  
....................     BankSel(ERDPTL);            // Return to Bank 0 
.................... } 
.................... #endif 
....................  
.................... //// GetRegs is a function for debugging purposes only.  It will read all 
.................... //// registers and store them in the PIC's RAM so they can be viewed with 
.................... //// the ICD2. 
.................... //REG Regs[4][32]; 
.................... //void GetRegs(void) 
.................... //{ 
.................... //  BYTE i; 
.................... // 
.................... //  BankSel(0x000); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x100); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x200); 
.................... //  for(i=0; i<5; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][5] = ReadETHReg(i); 
.................... //  for(i=6; i<0x0F; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x0F] = ReadETHReg(i); 
.................... //  for(i=0x10; i<0x13; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x13] = ReadETHReg(i); 
.................... //  for(i=0x14; i<0x1A; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[2][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x300); 
.................... //  for(i=0; i<0x06; i++) 
.................... //      Regs[3][i] = ReadMACReg(i); 
.................... //  for(i=6; i<0x0A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  Regs[3][0x0A] = ReadMACReg(i); 
.................... //  for(i=0x0B; i<0x1A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... // 
.................... //  Regs[0][0x1A].Val = 0; 
.................... //  Regs[1][0x1A].Val = 0; 
.................... //  Regs[2][0x1A].Val = 0; 
.................... //  Regs[3][0x1A].Val = 0; 
.................... // 
.................... //  BankSel(ERDPTL); 
.................... // 
.................... //  return; 
.................... //} 
....................  
.................... //// Get8KBMem is a function intended for debugging purposes.  It will read all 
.................... //// Ethernet RAM and output it in hex out the UART 
.................... //void Get8KBMem(void) 
.................... //{ 
.................... //  WORD_VAL i; 
.................... //  BYTE v; 
.................... //  WORD_VAL RDSave; 
.................... // 
.................... //  RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
.................... //  RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
.................... // 
.................... //  for(i.Val = 0; i.Val < 8192; i.Val++) 
.................... //  { 
.................... //      WriteReg(ERDPTL, i.v[0]); 
.................... //      WriteReg(ERDPTH, i.v[1]); 
.................... //      v = MACGet(); 
.................... // 
.................... //      putcUART('0'); 
.................... //      while(BusyUART()); 
.................... //      putcUART('x'); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_high(v)); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_low(v)); 
.................... //      while(BusyUART()); 
.................... //  } 
.................... // 
.................... //  WriteReg(ERDPTL, RDSave.v[0]); 
.................... //  WriteReg(ERDPTH, RDSave.v[1]); 
.................... // 
.................... //} 
....................  
.................... #endif //#if defined(ENC_CS_TRIS) 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "ENCX24J600.c" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or ZeroG ZG2100 must be present. 
.................... #endif 
.................... #include "IP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Protocol (IP) Version 4 Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides a transport for TCP, UDP, and ICMP messages 
....................  *	 -Reference: RFC 791 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.c 
....................  * Dependencies:    Network Layer interface (ENC28J60.c, ETH97J60.c,  
....................  *					ENCX24J600.c or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook			9/21/06	Corrected IPHeaderLen not being  
....................  * 								initialized when NON_MCHP_MAC defined. 
....................  ********************************************************************/ 
.................... #define __IP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................   #define MY_IP_TTL           (255)  // Time-To-Live in hops  
....................   // IP TTL is set to 255 for Multicast DNS compatibility. See mDNS-draft-08, section 4. 
.................... #else 
....................   #define MY_IP_TTL           (100)  // Time-To-Live in hops 
.................... #endif 
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if defined(NON_MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... 	#define MAX_OPTIONS_LEN     (40u)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
04B10:  MOVLW  03
04B12:  MOVLB  3
04B14:  MOVWF  xE8
04B16:  MOVLW  D3
04B18:  MOVWF  xE7
04B1A:  MOVFF  3E8,461
04B1E:  MOVFF  FE8,460
04B22:  MOVLB  4
04B24:  CLRF   x63
04B26:  MOVLW  14
04B28:  MOVWF  x62
04B2A:  MOVLB  0
04B2C:  CALL   0C14
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if((header.VersionIHL & 0xf0) != IP_VERSION) 
04B30:  MOVLB  3
04B32:  MOVF   xD3,W
04B34:  ANDLW  F0
04B36:  SUBLW  40
04B38:  BZ    4B40
....................     	return FALSE; 
04B3A:  MOVLW  00
04B3C:  MOVWF  01
04B3E:  BRA    4C10
....................  
.................... 	// Throw this packet away if it is a fragment.   
.................... 	// We don't have enough RAM for IP fragment reconstruction. 
.................... 	if(header.FragmentInfo & 0xFF1F) 
04B40:  MOVF   xD9,W
04B42:  ANDLW  1F
04B44:  MOVWF  00
04B46:  MOVFF  3DA,03
04B4A:  MOVF   00,W
04B4C:  IORWF  xDA,W
04B4E:  BZ    4B56
.................... 		return FALSE; 
04B50:  MOVLW  00
04B52:  MOVWF  01
04B54:  BRA    4C10
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
04B56:  MOVF   xD3,W
04B58:  ANDLW  0F
04B5A:  MOVWF  00
04B5C:  RLCF   00,W
04B5E:  MOVLB  1
04B60:  MOVWF  x2A
04B62:  RLCF   x2A,F
04B64:  MOVLW  FC
04B66:  ANDWF  x2A,F
....................  
.................... #if !defined(NON_MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum  
.................... 	// will come out to 0x0000 (because the header contains a  
.................... 	// precomputed checksum).  A corrupt header will have a  
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
04B68:  MOVLB  3
04B6A:  CLRF   xE8
04B6C:  CLRF   xE7
04B6E:  CLRF   xEA
04B70:  MOVFF  12A,3E9
04B74:  MOVLB  0
04B76:  RCALL  4A5C
04B78:  MOVFF  02,3D2
04B7C:  MOVFF  01,3D1
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetReadPtrInRx(IPHeaderLen); 
04B80:  MOVLB  4
04B82:  CLRF   x1D
04B84:  MOVFF  12A,41C
04B88:  MOVLB  0
04B8A:  CALL   244C
....................  
....................     if(CalcChecksum.Val) 
04B8E:  MOVLB  3
04B90:  MOVF   xD1,W
04B92:  IORWF  xD2,W
04B94:  BZ    4B9C
.................... #else 
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = IPHeaderLen - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0u ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0u ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE  
....................         // return value and it should discard the packet. 
....................         return FALSE; 
04B96:  MOVLW  00
04B98:  MOVWF  01
04B9A:  BRA    4C10
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
04B9C:  MOVLW  03
04B9E:  MOVLB  4
04BA0:  MOVWF  x58
04BA2:  MOVLW  D3
04BA4:  MOVWF  x57
04BA6:  MOVLB  0
04BA8:  CALL   1A46
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
04BAC:  MOVLB  3
04BAE:  MOVF   xC9,W
04BB0:  IORWF  xCA,W
04BB2:  BZ    4BCC
....................         localIP->Val    = header.DestAddress.Val; 
04BB4:  MOVFF  3C9,FE9
04BB8:  MOVFF  3CA,FEA
04BBC:  MOVFF  3E3,FEF
04BC0:  MOVFF  3E4,FEC
04BC4:  MOVFF  3E5,FEC
04BC8:  MOVFF  3E6,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
04BCC:  MOVFF  3CB,FE9
04BD0:  MOVF   xCC,W
04BD2:  MOVWF  FEA
04BD4:  MOVFF  3DF,FEF
04BD8:  MOVFF  3E0,FEC
04BDC:  MOVFF  3E1,FEC
04BE0:  MOVFF  3E2,FEC
....................     *protocol           = header.Protocol; 
04BE4:  MOVFF  3CD,FE9
04BE8:  MOVFF  3CE,FEA
04BEC:  MOVFF  3DC,FEF
....................     *len 				= header.TotalLength - IPHeaderLen; 
04BF0:  MOVFF  3CF,FE9
04BF4:  MOVFF  3D0,FEA
04BF8:  MOVLB  1
04BFA:  MOVF   x2A,W
04BFC:  MOVLB  3
04BFE:  SUBWF  xD5,W
04C00:  MOVWF  00
04C02:  MOVLW  00
04C04:  SUBWFB xD6,W
04C06:  MOVFF  00,FEF
04C0A:  MOVWF  FEC
....................  
....................     return TRUE; 
04C0C:  MOVLW  01
04C0E:  MOVWF  01
04C10:  MOVLB  0
04C12:  GOTO   6CA6 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                  BYTE protocol, 
....................                  WORD len) 
.................... { 
....................     IP_HEADER   header; 
....................      
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
01CCE:  MOVLW  14
01CD0:  MOVLB  1
01CD2:  MOVWF  x2A
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
01CD4:  MOVLW  45
01CD6:  MOVLB  4
01CD8:  MOVWF  x43
....................     header.TypeOfService    = IP_SERVICE; 
01CDA:  CLRF   x44
....................     header.TotalLength      = sizeof(header) + len; 
01CDC:  MOVLW  14
01CDE:  ADDWF  x41,W
01CE0:  MOVWF  x45
01CE2:  MOVLW  00
01CE4:  ADDWFC x42,W
01CE6:  MOVWF  x46
....................     header.Identification   = ++_Identifier; 
01CE8:  MOVLB  1
01CEA:  INCF   x28,F
01CEC:  BTFSC  FD8.2
01CEE:  INCF   x29,F
01CF0:  MOVFF  129,448
01CF4:  MOVFF  128,447
....................     header.FragmentInfo     = 0; 
01CF8:  MOVLB  4
01CFA:  CLRF   x4A
01CFC:  CLRF   x49
....................     header.TimeToLive       = MY_IP_TTL; 
01CFE:  MOVLW  64
01D00:  MOVWF  x4B
....................     header.Protocol         = protocol; 
01D02:  MOVFF  440,44C
....................     header.HeaderChecksum   = 0; 
01D06:  CLRF   x4E
01D08:  CLRF   x4D
.................... 	header.SourceAddress 	= AppConfig.MyIPAddr; 
01D0A:  MOVFF  26,452
01D0E:  MOVFF  25,451
01D12:  MOVFF  24,450
01D16:  MOVFF  23,44F
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
01D1A:  MOVFF  43E,FE9
01D1E:  MOVFF  43F,FEA
01D22:  MOVFF  FEF,453
01D26:  MOVFF  FEC,454
01D2A:  MOVFF  FEC,455
01D2E:  MOVFF  FEC,456
....................  
....................     SwapIPHeader(&header); 
01D32:  MOVLW  04
01D34:  MOVWF  x58
01D36:  MOVLW  43
01D38:  MOVWF  x57
01D3A:  MOVLB  0
01D3C:  RCALL  1A46
....................  
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, sizeof(header)); 
01D3E:  MOVLW  04
01D40:  MOVLB  4
01D42:  MOVWF  x58
01D44:  MOVLW  43
01D46:  MOVWF  x57
01D48:  MOVFF  458,45A
01D4C:  MOVWF  x59
01D4E:  CLRF   x5C
01D50:  MOVLW  14
01D52:  MOVWF  x5B
01D54:  MOVLB  0
01D56:  RCALL  1B20
01D58:  MOVFF  02,44E
01D5C:  MOVFF  01,44D
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
01D60:  MOVLW  04
01D62:  MOVLB  4
01D64:  ADDWF  x3E,W
01D66:  MOVWF  01
01D68:  MOVLW  00
01D6A:  ADDWFC x3F,W
01D6C:  MOVWF  03
01D6E:  MOVFF  01,457
01D72:  MOVWF  x58
01D74:  MOVLW  14
01D76:  ADDWF  x41,W
01D78:  MOVWF  x59
01D7A:  MOVLW  00
01D7C:  ADDWFC x42,W
01D7E:  MOVWF  x5A
01D80:  MOVFF  03,45C
01D84:  MOVFF  01,45B
01D88:  CLRF   x5D
01D8A:  MOVWF  x5F
01D8C:  MOVFF  459,45E
01D90:  MOVLB  0
01D92:  RCALL  1C08
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
01D94:  MOVLW  04
01D96:  MOVLB  4
01D98:  MOVWF  x58
01D9A:  MOVLW  43
01D9C:  MOVWF  x57
01D9E:  MOVFF  458,463
01DA2:  MOVWF  x62
01DA4:  CLRF   x65
01DA6:  MOVLW  14
01DA8:  MOVWF  x64
01DAA:  MOVLB  0
01DAC:  CALL   0B62
....................  
....................     return 0x0000; 
01DB0:  MOVLW  00
01DB2:  MOVWF  01
01DB4:  MOVWF  02
01DB6:  RETURN 0
....................  
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset)  
.................... { 
.................... 	MACSetReadPtrInRx(Offset+IPHeaderLen); 
*
024A2:  MOVLB  1
024A4:  MOVF   x2A,W
024A6:  MOVLB  4
024A8:  ADDWF  x18,W
024AA:  MOVWF  x1A
024AC:  MOVLW  00
024AE:  ADDWFC x19,W
024B0:  MOVWF  x1B
024B2:  MOVWF  x1D
024B4:  MOVFF  41A,41C
024B8:  MOVLB  0
024BA:  RCALL  244C
024BC:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
01A46:  MOVLW  02
01A48:  MOVLB  4
01A4A:  ADDWF  x57,W
01A4C:  MOVWF  01
01A4E:  MOVLW  00
01A50:  ADDWFC x58,W
01A52:  MOVWF  03
01A54:  MOVFF  01,459
01A58:  MOVWF  x5A
01A5A:  MOVLW  02
01A5C:  ADDWF  x57,W
01A5E:  MOVWF  FE9
01A60:  MOVLW  00
01A62:  ADDWFC x58,W
01A64:  MOVWF  FEA
01A66:  MOVFF  FEC,45C
01A6A:  MOVF   FED,F
01A6C:  MOVFF  FEF,45B
01A70:  MOVFF  45C,45E
01A74:  MOVFF  45B,45D
01A78:  MOVLB  0
01A7A:  RCALL  1A24
01A7C:  MOVFF  45A,FEA
01A80:  MOVFF  459,FE9
01A84:  MOVFF  02,FEC
01A88:  MOVF   FED,F
01A8A:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
01A8E:  MOVLW  04
01A90:  MOVLB  4
01A92:  ADDWF  x57,W
01A94:  MOVWF  01
01A96:  MOVLW  00
01A98:  ADDWFC x58,W
01A9A:  MOVWF  03
01A9C:  MOVFF  01,459
01AA0:  MOVWF  x5A
01AA2:  MOVLW  04
01AA4:  ADDWF  x57,W
01AA6:  MOVWF  FE9
01AA8:  MOVLW  00
01AAA:  ADDWFC x58,W
01AAC:  MOVWF  FEA
01AAE:  MOVFF  FEC,45C
01AB2:  MOVF   FED,F
01AB4:  MOVFF  FEF,45B
01AB8:  MOVFF  45C,45E
01ABC:  MOVFF  45B,45D
01AC0:  MOVLB  0
01AC2:  RCALL  1A24
01AC4:  MOVFF  45A,FEA
01AC8:  MOVFF  459,FE9
01ACC:  MOVFF  02,FEC
01AD0:  MOVF   FED,F
01AD2:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
01AD6:  MOVLW  0A
01AD8:  MOVLB  4
01ADA:  ADDWF  x57,W
01ADC:  MOVWF  01
01ADE:  MOVLW  00
01AE0:  ADDWFC x58,W
01AE2:  MOVWF  03
01AE4:  MOVFF  01,459
01AE8:  MOVWF  x5A
01AEA:  MOVLW  0A
01AEC:  ADDWF  x57,W
01AEE:  MOVWF  FE9
01AF0:  MOVLW  00
01AF2:  ADDWFC x58,W
01AF4:  MOVWF  FEA
01AF6:  MOVFF  FEC,45C
01AFA:  MOVF   FED,F
01AFC:  MOVFF  FEF,45B
01B00:  MOVFF  45C,45E
01B04:  MOVFF  45B,45D
01B08:  MOVLB  0
01B0A:  RCALL  1A24
01B0C:  MOVFF  45A,FEA
01B10:  MOVFF  459,FE9
01B14:  MOVFF  02,FEC
01B18:  MOVF   FED,F
01B1A:  MOVFF  01,FEF
01B1E:  RETURN 0
.................... } 
....................  
.................... #include "ARP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Address Resolution Protocol (ARP) Client and Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides IP address to Ethernet MAC address translation 
....................  *    -Reference: RFC 826 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  ARP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.c and ARPTsk.c into ARP.c;  
....................  *                        rewrote some of it to look more linear 
....................  * Darren Rook/CCS      Added call to GratArpReset() if using STACK_USE_CCS_GRATUITOUS_ARP 
....................  ********************************************************************/ 
.................... #define __ARP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Constants and Variables 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... //#define ARP_OPERATION_REQ       0x01u      // Operation code indicating an ARP Request 
.................... //#define ARP_OPERATION_RESP      0x02u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
.................... #endif 
....................  
.................... #ifdef STACK_CLIENT_MODE 
.................... static NODE_INFO Cache;                  // Cache for one ARP response 
.................... #endif 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define MAX_REG_APPS            2           // MAX num allowed registrations of Modules/Apps 
.................... static struct arp_app_callbacks reg_apps[MAX_REG_APPS]; // Call-Backs storage for MAX of two Modules/Apps 
.................... /* 
.................... // ARP packet structure 
.................... typedef struct __attribute__((aligned(2), packed)) 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
.................... */ 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Helper Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static BOOL ARPPut(ARP_PACKET* packet); 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Implementations 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... /************ User Application APIs ****************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
....................  
....................   Summary: 
....................    Registering callback with ARP module to get notified about certian events. 
....................     
....................   Description: 
....................      This function allows end user application to register with callbacks, which 
....................     will be called by ARP module to give notification to user-application about  
....................     events occurred at ARP layer. For ex: when a ARP-packet is received, which is 
....................     conflicting with our own pair of addresses (MAC-Address and IP-address). 
....................     This is an extension for zeroconf protocol implementation (ZeroconfLL.c) 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    app - ARP-Application callbacks structure supplied by user-application  
....................      
....................   Returns: 
....................     id > 0 - Returns non-negative value that represents the id of registration 
....................              The same id needs to be used in de-registration 
....................     -1     - When registered applications exceed MAX_REG_APPS and there is no 
....................              free slot for registration 
....................   
....................   ***************************************************************************/ 
.................... CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
.................... { 
....................     BYTE i; 
....................     for(i=0; i<MAX_REG_APPS; i++) 
....................     { 
....................         if(!reg_apps[i].used) 
....................         { 
....................             reg_apps[i].ARPPkt_notify = app->ARPPkt_notify; 
....................             reg_apps[i].used = 1; 
....................             return (i+1); // Return Code. Should be used in deregister. 
....................         } 
....................     } 
....................     return -1; // No space for registration 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
....................  
....................   Summary: 
....................    De-Registering callbacks with ARP module that are registered previously. 
....................     
....................   Description: 
....................      This function allows end user-application to de-register with callbacks,  
....................     which were registered previously. 
....................     This is called by user-application, when its no longer interested in  
....................     notifications from ARP-Module. This allows the other application to get  
....................     registered with ARP-module.    
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    reg_id - Registration-id returned in ARPRegisterCallbacks call 
....................      
....................   Returns: 
....................     TRUE  - On success 
....................     FALSE - Failure to indicate invalid reg_id   
....................   ***************************************************************************/  
.................... BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
.................... { 
....................     if(reg_id <= 0 || reg_id > MAX_REG_APPS) 
....................         return FALSE; 
....................  
....................     reg_apps[reg_id-1].used = 0; // To indicate free slot for registration 
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPProcessRxPkt(ARP_PACKET* packet) 
....................  
....................   Summary: 
....................    Processes Received-ARP packet (ARP request/Reply). 
....................     
....................   Description: 
....................      This function is to pass-on the ARP-packet to registered application, 
....................     with the notification of Rx-ARP packet.  
....................  
....................   Precondition: 
....................    ARP packet is received completely from MAC 
....................  
....................   Parameters: 
....................    packet - Rx packet to be processed      
....................  
....................   Returns: 
....................     None    
....................   ***************************************************************************/ 
.................... void ARPProcessRxPkt(ARP_PACKET* packet) 
.................... { 
....................     BYTE pass_on = 0; // Flag to indicate whether need to be forwarded 
....................     BYTE i; 
....................  
....................     // Probing Stage 
....................     if(AppConfig.MyIPAddr.Val == 0x00) 
....................     { 
....................         pass_on = 1; // Pass to Registered-Application for further processing         
....................     } 
....................     else if(AppConfig.MyIPAddr.Val) 
....................     { 
....................         /* Late-conflict */ 
....................         if(packet->SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................         { 
....................             pass_on = 1; 
....................         } 
....................     } 
....................     if(pass_on) 
....................     { 
....................      
....................         for(i =0; i< MAX_REG_APPS; i++) 
....................         { 
....................             if(reg_apps[i].used) 
....................             { 
....................                 reg_apps[i].ARPPkt_notify(packet->SenderIPAddr.Val, 
....................                                       packet->TargetIPAddr.Val, 
....................                                       &packet->SenderMACAddr, 
....................                                       &packet->TargetMACAddr, 
....................                                       packet->Operation);                 
....................             } 
....................         } 
....................     } 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPSendPkt(IP_ADDR* SrcIPAddr, IP_ADDR* DestIPAddr, int op_req ) 
....................  
....................   Summary: 
....................    Transmits an ARP request/Reply initated by Application or external module. 
....................     
....................   Description: 
....................      This function transmits and ARP request/reply to determine the hardware 
....................      address of a given IP address (or) Announce self-address to all nodes in 
....................     network. Extended for zeroconf protocol.  
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    SrcIPAddr - The Source IP-address  
....................     DestIPAddr - The Destination IP-Address 
....................     op_req     - Operation Request (ARP_REQ/ARP_RESP) 
....................  
....................   Returns: 
....................     TRUE - The ARP packet was generated properly 
....................      FALSE - Not possible return value 
....................  
....................   Remarks: 
....................      This API is to give control over AR-packet to external modules.  
....................   ***************************************************************************/ 
.................... BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................    DWORD_VAL *DestAddr = (DWORD_VAL *)&DestIPAddr; 
....................    if ((DestAddr->v[0] >= 224) &&(DestAddr->v[0] <= 239)) { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................     
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & DestAddr->v[1]; 
....................       Cache.MACAddr.v[4] = DestAddr->v[2]; 
....................       Cache.MACAddr.v[5] = DestAddr->v[3]; 
....................     
....................       Cache.IPAddr.Val = DestAddr->Val; 
....................     
....................       return TRUE; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................     packet.Operation = op_req; 
....................    packet.TargetMACAddr.v[0]   = 0xff; 
....................    packet.TargetMACAddr.v[1]   = 0xff; 
....................    packet.TargetMACAddr.v[2]   = 0xff; 
....................    packet.TargetMACAddr.v[3]   = 0xff; 
....................    packet.TargetMACAddr.v[4]   = 0xff; 
....................    packet.TargetMACAddr.v[5]   = 0xff; 
....................  
....................     packet.TargetIPAddr.Val   = DestIPAddr; 
....................     packet.SenderIPAddr.Val = SrcIPAddr; 
....................  
....................     return ( ARPPut(&packet) ); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL ARPPut(ARP_PACKET* packet) 
....................  
....................   Description: 
....................    Writes an ARP packet to the MAC. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    packet - A pointer to an ARP_PACKET structure with correct operation 
....................             and target preconfigured. 
....................  
....................   Return Values: 
....................      TRUE - The ARP packet was generated properly 
....................      FALSE - Not a possible return value 
....................   ***************************************************************************/ 
.................... static BOOL ARPPut(ARP_PACKET* packet) 
.................... { 
....................    while(!MACIsTxReady()); 
*
0483A:  CALL   1786
0483E:  MOVF   01,F
04840:  BZ    483A
....................    MACSetWritePtr(BASE_TX_ADDR); 
04842:  MOVLW  11
04844:  MOVLB  4
04846:  MOVWF  x4E
04848:  MOVLW  D7
0484A:  MOVWF  x4D
0484C:  MOVLB  0
0484E:  CALL   0AF2
....................     
....................  
....................     packet->HardwareType  = HW_ETHERNET; 
04852:  MOVLB  3
04854:  MOVFF  3E5,FE9
04858:  MOVFF  3E6,FEA
0485C:  CLRF   FEC
0485E:  MOVF   FED,F
04860:  MOVLW  01
04862:  MOVWF  FEF
....................     packet->Protocol      = ARP_IP; 
04864:  MOVLW  02
04866:  ADDWF  xE5,W
04868:  MOVWF  FE9
0486A:  MOVLW  00
0486C:  ADDWFC xE6,W
0486E:  MOVWF  FEA
04870:  MOVLW  08
04872:  MOVWF  FEC
04874:  MOVF   FED,F
04876:  CLRF   FEF
....................     packet->MACAddrLen    = sizeof(MAC_ADDR); 
04878:  MOVLW  04
0487A:  ADDWF  xE5,W
0487C:  MOVWF  FE9
0487E:  MOVLW  00
04880:  ADDWFC xE6,W
04882:  MOVWF  FEA
04884:  MOVLW  06
04886:  MOVWF  FEF
....................     packet->ProtocolLen   = sizeof(IP_ADDR); 
04888:  MOVLW  05
0488A:  ADDWF  xE5,W
0488C:  MOVWF  FE9
0488E:  MOVLW  00
04890:  ADDWFC xE6,W
04892:  MOVWF  FEA
04894:  MOVLW  04
04896:  MOVWF  FEF
.................... //    packet->SenderMACAddr = AppConfig.MyMACAddr;   // HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround 
....................    memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr)); 
04898:  MOVLW  08
0489A:  ADDWF  xE5,W
0489C:  MOVWF  01
0489E:  MOVLW  00
048A0:  ADDWFC xE6,W
048A2:  MOVWF  03
048A4:  MOVFF  01,3E7
048A8:  MOVWF  xE8
048AA:  CLRF   xEA
048AC:  MOVLW  50
048AE:  MOVFF  03,FEA
048B2:  MOVFF  01,FE9
048B6:  MOVFF  3EA,FE2
048BA:  MOVWF  FE1
048BC:  MOVLW  06
048BE:  MOVWF  01
048C0:  MOVFF  FE6,FEE
048C4:  DECFSZ 01,F
048C6:  BRA    48C0
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................     //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */ 
.................... #else 
....................     packet->SenderIPAddr  = AppConfig.MyIPAddr; 
048C8:  MOVLW  0E
048CA:  ADDWF  xE5,W
048CC:  MOVWF  FE9
048CE:  MOVLW  00
048D0:  ADDWFC xE6,W
048D2:  MOVWF  FEA
048D4:  MOVFF  23,FEF
048D8:  MOVFF  24,FEC
048DC:  MOVFF  25,FEC
048E0:  MOVFF  26,FEC
.................... #endif 
....................  
....................     SwapARPPacket(packet); 
048E4:  MOVFF  3E6,3E8
048E8:  MOVFF  3E5,3E7
048EC:  MOVLB  0
048EE:  RCALL  4760
....................  
....................     MACPutHeader(&packet->TargetMACAddr, MAC_ARP, sizeof(*packet)); 
048F0:  MOVLW  12
048F2:  MOVLB  3
048F4:  ADDWF  xE5,W
048F6:  MOVWF  01
048F8:  MOVLW  00
048FA:  ADDWFC xE6,W
048FC:  MOVWF  03
048FE:  MOVFF  01,3E7
04902:  MOVWF  xE8
04904:  MOVFF  FE8,45C
04908:  MOVFF  01,45B
0490C:  MOVLW  06
0490E:  MOVLB  4
04910:  MOVWF  x5D
04912:  CLRF   x5F
04914:  MOVLW  1C
04916:  MOVWF  x5E
04918:  MOVLB  0
0491A:  CALL   1C08
....................     MACPutArray((BYTE*)packet, sizeof(*packet)); 
0491E:  MOVFF  3E6,463
04922:  MOVFF  3E5,462
04926:  MOVLB  4
04928:  CLRF   x65
0492A:  MOVLW  1C
0492C:  MOVWF  x64
0492E:  MOVLB  0
04930:  CALL   0B62
....................     MACFlush(); 
04934:  CALL   1DB8
....................     
....................    return TRUE; 
04938:  MOVLW  01
0493A:  MOVWF  01
0493C:  GOTO   4A3C (RETURN)
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPInit(void) 
....................  
....................   Summary: 
....................    Initializes the ARP module. 
....................     
....................   Description: 
....................      Initializes the ARP module.  Call this function once at boot to  
....................      invalidate the cached lookup. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................    
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPInit(void) 
.................... { 
....................     Cache.MACAddr.v[0] = 0xff; 
....................     Cache.MACAddr.v[1] = 0xff; 
....................     Cache.MACAddr.v[2] = 0xff; 
....................     Cache.MACAddr.v[3] = 0xff; 
....................     Cache.MACAddr.v[4] = 0xff; 
....................     Cache.MACAddr.v[5] = 0xff; 
....................  
....................    Cache.IPAddr.Val = 0xfffffffful; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPProcess(void) 
....................  
....................   Summary: 
....................    Processes an incoming ARP packet. 
....................     
....................   Description: 
....................      Retrieves an ARP packet from the MAC buffer and determines if it is a 
....................      response to our request (in which case the ARP is resolved) or if it 
....................      is a request requiring our response (in which case we transmit one.) 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Return Values: 
....................      TRUE - All processing of this ARP packet is complete.  Do not call  
....................            again until a new ARP packet is waiting in the RX buffer. 
....................      FALSE - This function must be called again.  More time is needed to  
....................            send an ARP response. 
....................   ***************************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................    ARP_PACKET packet; 
....................    static NODE_INFO Target; 
....................     #if defined(STACK_USE_AUTO_IP) 
....................         BYTE i; 
....................     #endif 
....................    static enum 
....................    { 
....................        SM_ARP_IDLE = 0, 
....................        SM_ARP_REPLY 
....................    } smARP = SM_ARP_IDLE; 
....................  
....................     switch(smARP) 
04940:  MOVLW  00
04942:  MOVLB  1
04944:  BTFSC  x10.3
04946:  MOVLW  01
04948:  XORLW  00
0494A:  MOVLB  0
0494C:  BZ    4954
0494E:  XORLW  01
04950:  BZ    49FC
04952:  BRA    4A50
....................     { 
....................        case SM_ARP_IDLE: 
....................          // Obtain the incoming ARP packet 
....................           MACGetArray((BYTE*)&packet, sizeof(packet));       
04954:  MOVLW  03
04956:  MOVLB  3
04958:  MOVWF  xE6
0495A:  MOVLW  C9
0495C:  MOVWF  xE5
0495E:  MOVFF  3E6,461
04962:  MOVFF  FE8,460
04966:  MOVLB  4
04968:  CLRF   x63
0496A:  MOVLW  1C
0496C:  MOVWF  x62
0496E:  MOVLB  0
04970:  CALL   0C14
....................           MACDiscardRx(); 
04974:  CALL   2602
....................           SwapARPPacket(&packet); 
04978:  MOVLW  03
0497A:  MOVLB  3
0497C:  MOVWF  xE8
0497E:  MOVLW  C9
04980:  MOVWF  xE7
04982:  MOVLB  0
04984:  RCALL  4760
....................        
....................          // Validate the ARP packet 
....................           if ( packet.HardwareType != HW_ETHERNET     || 
....................                packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................                packet.ProtocolLen != sizeof(IP_ADDR) ) 
04986:  MOVLB  3
04988:  DECFSZ xC9,W
0498A:  BRA    499C
0498C:  MOVF   xCA,F
0498E:  BNZ   499C
04990:  MOVF   xCD,W
04992:  SUBLW  06
04994:  BNZ   499C
04996:  MOVF   xCE,W
04998:  SUBLW  04
0499A:  BZ    49A2
....................           { 
....................                return TRUE; 
0499C:  MOVLW  01
0499E:  MOVWF  01
049A0:  BRA    4A56
....................           } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................          ARPProcessRxPkt(&packet); 
.................... #endif 
....................  
.................... #ifdef STACK_USE_AUTO_IP 
....................             if (packet.SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................             { 
....................                 AutoIPConflict(0); 
....................                 return TRUE;                 
....................             } 
.................... #endif 
.................... #ifdef STACK_USE_CCS_GRATUITOUS_ARP 
.................... GratArpReset(); 
.................... #endif 
....................          // Handle incoming ARP responses 
.................... #ifdef STACK_CLIENT_MODE 
....................          if(packet.Operation == ARP_OPERATION_RESP) 
....................          { 
.................... /*                #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                         AutoIPConflict(i); 
....................                 #endif*/ 
....................             Cache.MACAddr = packet.SenderMACAddr; 
....................             Cache.IPAddr = packet.SenderIPAddr; 
....................             return TRUE; 
....................          } 
.................... #endif 
....................  
....................          // Handle incoming ARP requests for our MAC address 
....................          if(packet.Operation == ARP_OPERATION_REQ) 
049A2:  DECFSZ xCF,W
049A4:  BRA    49FA
049A6:  MOVF   xD0,F
049A8:  BNZ   49FA
....................          { 
....................             if(packet.TargetIPAddr.Val != AppConfig.MyIPAddr.Val) 
049AA:  MOVF   23,W
049AC:  SUBWF  xE1,W
049AE:  BNZ   49C2
049B0:  MOVF   24,W
049B2:  SUBWF  xE2,W
049B4:  BNZ   49C2
049B6:  MOVF   25,W
049B8:  SUBWF  xE3,W
049BA:  BNZ   49C2
049BC:  MOVF   26,W
049BE:  SUBWF  xE4,W
049C0:  BZ    49C8
....................             { 
....................                return TRUE; 
049C2:  MOVLW  01
049C4:  MOVWF  01
049C6:  BRA    4A56
....................             } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................                                /* Fix for Loop-Back suppression: 
....................                                 * For ZCLL-Claim packets, host should not respond. 
....................                                 * Check Sender's MAC-address with own MAC-address and  
....................                                 * if it is matched, response will not be sent back. This 
....................                                 * was leading to flooding of ARP-answeres */ 
....................                                 if(!memcmp (&packet.SenderMACAddr, &AppConfig.MyMACAddr, 6)) 
....................                                 { 
....................                                      putsUART("Loopback answer suppressed \r\n"); 
....................                                      return TRUE; 
....................                                 } 
.................... #endif 
....................                 #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                     { 
....................                         AutoIPConflict(i); 
....................                         return TRUE; 
....................                     }              
....................                 #endif 
....................             Target.IPAddr = packet.SenderIPAddr; 
049C8:  MOVFF  3DA,12E
049CC:  MOVFF  3D9,12D
049D0:  MOVFF  3D8,12C
049D4:  MOVFF  3D7,12B
....................             Target.MACAddr = packet.SenderMACAddr; 
049D8:  MOVLW  01
049DA:  MOVWF  FEA
049DC:  MOVLW  2F
049DE:  MOVWF  FE9
049E0:  MOVLW  03
049E2:  MOVWF  FE2
049E4:  MOVLW  D1
049E6:  MOVWF  FE1
049E8:  MOVLW  06
049EA:  MOVWF  01
049EC:  MOVFF  FE6,FEE
049F0:  DECFSZ 01,F
049F2:  BRA    49EC
....................  
....................             smARP = SM_ARP_REPLY; 
049F4:  MOVLB  1
049F6:  BSF    x10.3
049F8:  MOVLB  3
049FA:  MOVLB  0
....................          } 
....................          // Do not break.  If we get down here, we need to send a reply.    
....................  
....................        case SM_ARP_REPLY: 
....................            packet.Operation      = ARP_OPERATION_RESP; 
049FC:  MOVLB  3
049FE:  CLRF   xD0
04A00:  MOVLW  02
04A02:  MOVWF  xCF
....................             #if defined(STACK_USE_AUTO_IP) 
....................             if (AutoIPIsConfigured(0)) 
....................             { 
....................                 packet.TargetMACAddr.v[0] = 0xFF; 
....................                 packet.TargetMACAddr.v[1] = 0xFF; 
....................                 packet.TargetMACAddr.v[2] = 0xFF; 
....................                 packet.TargetMACAddr.v[3] = 0xFF; 
....................                 packet.TargetMACAddr.v[4] = 0xFF; 
....................                 packet.TargetMACAddr.v[5] = 0xFF; 
....................             } 
....................             else 
....................             #endif 
....................                packet.TargetMACAddr   = Target.MACAddr; 
04A04:  MOVLW  03
04A06:  MOVWF  FEA
04A08:  MOVLW  DB
04A0A:  MOVWF  FE9
04A0C:  MOVLW  01
04A0E:  MOVWF  FE2
04A10:  MOVLW  2F
04A12:  MOVWF  FE1
04A14:  MOVLW  06
04A16:  MOVWF  01
04A18:  MOVFF  FE6,FEE
04A1C:  DECFSZ 01,F
04A1E:  BRA    4A18
....................            packet.TargetIPAddr      = Target.IPAddr; 
04A20:  MOVFF  12E,3E4
04A24:  MOVFF  12D,3E3
04A28:  MOVFF  12C,3E2
04A2C:  MOVFF  12B,3E1
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................             packet.SenderIPAddr      = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................          // Send an ARP response to a previously received request 
....................          if(!ARPPut(&packet)) 
04A30:  MOVLW  03
04A32:  MOVWF  xE6
04A34:  MOVLW  C9
04A36:  MOVWF  xE5
04A38:  MOVLB  0
04A3A:  BRA    483A
04A3C:  MOVF   01,F
04A3E:  BNZ   4A4A
....................          { 
....................               return FALSE; 
04A40:  MOVLW  00
04A42:  MOVWF  01
04A44:  MOVLB  3
04A46:  BRA    4A56
04A48:  MOVLB  0
....................          } 
....................  
....................          // Begin listening for ARP requests again 
....................          smARP = SM_ARP_IDLE; 
04A4A:  MOVLB  1
04A4C:  BCF    x10.3
....................            break; 
04A4E:  MOVLB  0
....................    } 
....................  
....................     return TRUE; 
04A50:  MOVLW  01
04A52:  MOVWF  01
04A54:  MOVLB  3
04A56:  MOVLB  0
04A58:  GOTO   6DAC (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPResolve(IP_ADDR* IPAddr) 
....................  
....................   Summary: 
....................    Transmits an ARP request to resolve an IP address. 
....................     
....................   Description: 
....................      This function transmits and ARP request to determine the hardware 
....................      address of a given IP address. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  The address must be specified  
....................           in network byte order (big endian). 
....................  
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................  
....................    To retrieve the ARP query result, call the ARPIsResolved() function. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPResolve(IP_ADDR* IPAddr) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................     if ((IPAddr->v[0] >= 224) &&(IPAddr->v[0] <= 239)) 
....................     { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................  
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & IPAddr->v[1]; 
....................       Cache.MACAddr.v[4] = IPAddr->v[2]; 
....................       Cache.MACAddr.v[5] = IPAddr->v[3]; 
....................  
....................       Cache.IPAddr.Val = IPAddr->Val; 
....................  
....................       return; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................    packet.Operation            = ARP_OPERATION_REQ; 
....................    packet.TargetMACAddr.v[0]   = 0xff; 
....................    packet.TargetMACAddr.v[1]   = 0xff; 
....................    packet.TargetMACAddr.v[2]   = 0xff; 
....................    packet.TargetMACAddr.v[3]   = 0xff; 
....................    packet.TargetMACAddr.v[4]   = 0xff; 
....................    packet.TargetMACAddr.v[5]   = 0xff; 
....................  
....................  
....................     // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet 
....................    packet.TargetIPAddr         = ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr; 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    packet.SenderIPAddr         = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................     ARPPut(&packet); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
....................  
....................   Summary: 
....................    Determines if an ARP request has been resolved yet. 
....................     
....................   Description: 
....................      This function checks if an ARP request has been resolved yet, and if 
....................      so, stores the resolved MAC address in the pointer provided. 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  This must match the IP address  
....................           provided to the ARPResolve() function call. 
....................    MACAddr - A buffer to store the corresponding MAC address retrieved from  
....................           the ARP query. 
....................  
....................   Return Values: 
....................      TRUE - The IP address has been resolved and MACAddr MAC address field 
....................          indicates the response. 
....................      FALSE -   The IP address is not yet resolved.  Try calling ARPIsResolved()  
....................          again at a later time.  If you don't get a response after a  
....................          application specific timeout period, you may want to call  
....................          ARPResolve() again to transmit another ARP query (in case if the  
....................          original query or response was lost on the network).  If you never  
....................          receive an ARP response, this may indicate that the IP address  
....................          isn't in use. 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
.................... { 
....................     if((Cache.IPAddr.Val == IPAddr->Val) ||  
....................      ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val))) 
....................     { 
....................         *MACAddr = Cache.MACAddr; 
....................         return TRUE; 
....................     } 
....................     return FALSE; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void SwapARPPacket(ARP_PACKET* p) 
....................  
....................   Description: 
....................      Swaps endian-ness of header information in an ARP packet. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    p - The ARP packet to be swapped 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void SwapARPPacket(ARP_PACKET* p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
04760:  MOVLB  3
04762:  MOVFF  3E7,01
04766:  MOVFF  3E8,03
0476A:  MOVFF  3E7,3E9
0476E:  MOVFF  3E8,3EA
04772:  MOVFF  3E7,FE9
04776:  MOVFF  3E8,FEA
0477A:  MOVFF  FEC,3EC
0477E:  MOVF   FED,F
04780:  MOVFF  FEF,3EB
04784:  MOVFF  3EC,45E
04788:  MOVFF  3EB,45D
0478C:  MOVLB  0
0478E:  CALL   1A24
04792:  MOVFF  3EA,FEA
04796:  MOVFF  3E9,FE9
0479A:  MOVFF  02,FEC
0479E:  MOVF   FED,F
047A0:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
047A4:  MOVLW  02
047A6:  MOVLB  3
047A8:  ADDWF  xE7,W
047AA:  MOVWF  01
047AC:  MOVLW  00
047AE:  ADDWFC xE8,W
047B0:  MOVWF  03
047B2:  MOVFF  01,3E9
047B6:  MOVWF  xEA
047B8:  MOVLW  02
047BA:  ADDWF  xE7,W
047BC:  MOVWF  FE9
047BE:  MOVLW  00
047C0:  ADDWFC xE8,W
047C2:  MOVWF  FEA
047C4:  MOVFF  FEC,3EC
047C8:  MOVF   FED,F
047CA:  MOVFF  FEF,3EB
047CE:  MOVFF  3EC,45E
047D2:  MOVFF  3EB,45D
047D6:  MOVLB  0
047D8:  CALL   1A24
047DC:  MOVFF  3EA,FEA
047E0:  MOVFF  3E9,FE9
047E4:  MOVFF  02,FEC
047E8:  MOVF   FED,F
047EA:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
047EE:  MOVLW  06
047F0:  MOVLB  3
047F2:  ADDWF  xE7,W
047F4:  MOVWF  01
047F6:  MOVLW  00
047F8:  ADDWFC xE8,W
047FA:  MOVWF  03
047FC:  MOVFF  01,3E9
04800:  MOVWF  xEA
04802:  MOVLW  06
04804:  ADDWF  xE7,W
04806:  MOVWF  FE9
04808:  MOVLW  00
0480A:  ADDWFC xE8,W
0480C:  MOVWF  FEA
0480E:  MOVFF  FEC,3EC
04812:  MOVF   FED,F
04814:  MOVFF  FEF,3EB
04818:  MOVFF  3EC,45E
0481C:  MOVFF  3EB,45D
04820:  MOVLB  0
04822:  CALL   1A24
04826:  MOVFF  3EA,FEA
0482A:  MOVFF  3E9,FE9
0482E:  MOVFF  02,FEC
04832:  MOVF   FED,F
04834:  MOVFF  01,FEF
04838:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) 
....................    #include "ICMP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Control Message Protocol (ICMP) Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides "ping" diagnostics 
....................  *	 -Reference: RFC 792 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.c 
....................  * Dependencies:    IP, ARP 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #define __ICMP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... // ICMP Timeout Value 
.................... #define ICMP_TIMEOUT	(4ul*TICK_SECOND) 
....................  
.................... // ICMP Packet Structure 
.................... typedef struct 
.................... { 
.................... 	BYTE vType; 
.................... 	BYTE vCode; 
.................... 	WORD wChecksum; 
.................... 	WORD wIdentifier; 
.................... 	WORD wSequenceNumber; 
.................... 	WORD wData; 
.................... } ICMP_PACKET; 
....................  
.................... // ICMP Sequence Number 
.................... static WORD wICMPSequenceNumber; 
.................... // ICMP tick timer variable 
.................... static DWORD ICMPTimer; 
....................  
.................... // ICMP Flag structure 
.................... static struct 
.................... { 
.................... 	unsigned char bICMPInUse:1;         // Indicates that the ICMP Client is in use 
.................... 	unsigned char bReplyValid:1;        // Indicates that a correct Ping response to one of our pings was received 
.................... 	unsigned char bRemoteHostIsROM:1;   // Indicates that a remote host name was passed as a ROM pointer argument 
.................... } ICMPFlags = {0x00}; 
....................  
.................... // ICMP Static Variables 
.................... static union 
.................... { 
.................... 	union 
.................... 	{ 
.................... 		ROM BYTE *szROM; 
.................... 		BYTE *szRAM; 
.................... 	} RemoteHost; 
.................... 	NODE_INFO ICMPRemote; 
.................... } StaticVars; 
....................  
.................... // ICMP State Machine Enumeration 
.................... static enum 
.................... { 
.................... 	SM_IDLE = 0, 
.................... 	SM_DNS_SEND_QUERY, 
.................... 	SM_DNS_GET_RESPONSE, 
.................... 	SM_ARP_SEND_QUERY, 
.................... 	SM_ARP_GET_RESPONSE, 
.................... 	SM_ICMP_SEND_ECHO_REQUEST, 
.................... 	SM_ICMP_GET_ECHO_RESPONSE 
.................... } ICMPState; 
....................  
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPProcess(void) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           *remote: Pointer to a NODE_INFO structure of the  
....................  *					ping requester 
....................  *					len: Count of how many bytes the ping header and  
....................  *					payload are in this IP packet 
....................  * 
....................  * Output:          Generates an echo reply, if requested 
....................  *					Validates and sets ICMPFlags.bReplyValid if a  
....................  *					correct ping response to one of ours is received. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPProcess(NODE_INFO *remote, WORD len) 
.................... { 
.................... 	DWORD_VAL dwVal; 
....................  
....................     // Obtain the ICMP header Type, Code, and Checksum fields 
....................     MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
*
04C16:  MOVLW  03
04C18:  MOVLB  3
04C1A:  MOVWF  xD2
04C1C:  MOVLW  CD
04C1E:  MOVWF  xD1
04C20:  MOVFF  3D2,461
04C24:  MOVFF  FE8,460
04C28:  MOVLB  4
04C2A:  CLRF   x63
04C2C:  MOVLW  04
04C2E:  MOVWF  x62
04C30:  MOVLB  0
04C32:  CALL   0C14
.................... 	 
.................... 	// See if this is an ICMP echo (ping) request 
.................... 	if(dwVal.w[0] == 0x0008u) 
04C36:  MOVLB  3
04C38:  MOVF   xCD,W
04C3A:  SUBLW  08
04C3C:  BNZ   4CFA
04C3E:  MOVF   xCE,F
04C40:  BNZ   4CFA
.................... 	{ 
.................... 		// Validate the checksum using the Microchip MAC's DMA module 
.................... 		// The checksum data includes the precomputed checksum in the  
.................... 		// header, so a valid packet will always have a checksum of  
.................... 		// 0x0000 if the packet is not disturbed. 
.................... 		if(MACCalcRxChecksum(0+sizeof(IP_HEADER), len)) 
04C42:  CLRF   xE8
04C44:  MOVLW  14
04C46:  MOVWF  xE7
04C48:  MOVFF  3CC,3EA
04C4C:  MOVFF  3CB,3E9
04C50:  MOVLB  0
04C52:  RCALL  4A5C
04C54:  MOVF   01,W
04C56:  IORWF  02,W
04C58:  BZ    4C5C
.................... 			return; 
04C5A:  BRA    4CF8
.................... 	 
.................... 		// Calculate new Type, Code, and Checksum values 
.................... 		dwVal.v[0] = 0x00;	// Type: 0 (ICMP echo/ping reply) 
04C5C:  MOVLB  3
04C5E:  CLRF   xCD
.................... 		dwVal.v[2] += 8;	// Subtract 0x0800 from the checksum 
04C60:  MOVLW  08
04C62:  ADDWF  xCF,F
.................... 		if(dwVal.v[2] < 8u) 
04C64:  MOVF   xCF,W
04C66:  SUBLW  07
04C68:  BNC   4C72
.................... 		{ 
.................... 			dwVal.v[3]++; 
04C6A:  INCF   xD0,F
.................... 			if(dwVal.v[3] == 0u) 
04C6C:  MOVF   xD0,F
04C6E:  BNZ   4C72
.................... 				dwVal.v[2]++; 
04C70:  INCF   xCF,F
.................... 		} 
.................... 	 
.................... 	    // Wait for TX hardware to become available (finish transmitting  
.................... 	    // any previous packet) 
.................... 	    while(!IPIsTxReady()); 
04C72:  MOVLB  0
04C74:  CALL   1786
04C78:  MOVF   01,F
04C7A:  BZ    4C74
....................  
.................... 		// Position the write pointer for the next IPPutHeader operation 
.................... 		// NOTE: do not put this before the IPIsTxReady() call for WF compatbility 
.................... 	    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
04C7C:  MOVLW  11
04C7E:  MOVLB  4
04C80:  MOVWF  x4E
04C82:  MOVLW  E5
04C84:  MOVWF  x4D
04C86:  MOVLB  0
04C88:  CALL   0AF2
....................         	 
.................... 		// Create IP header in TX memory 
.................... 		IPPutHeader(remote, IP_PROT_ICMP, len); 
04C8C:  MOVFF  3CA,43F
04C90:  MOVFF  3C9,43E
04C94:  MOVLW  01
04C96:  MOVLB  4
04C98:  MOVWF  x40
04C9A:  MOVFF  3CC,442
04C9E:  MOVFF  3CB,441
04CA2:  MOVLB  0
04CA4:  CALL   1CCE
.................... 	 
.................... 		// Copy ICMP response into the TX memory 
.................... 		MACPutArray((BYTE*)&dwVal, sizeof(dwVal)); 
04CA8:  MOVLW  03
04CAA:  MOVLB  3
04CAC:  MOVWF  xD2
04CAE:  MOVLW  CD
04CB0:  MOVWF  xD1
04CB2:  MOVFF  3D2,463
04CB6:  MOVFF  FE8,462
04CBA:  MOVLB  4
04CBC:  CLRF   x65
04CBE:  MOVLW  04
04CC0:  MOVWF  x64
04CC2:  MOVLB  0
04CC4:  CALL   0B62
.................... 		MACMemCopyAsync(-1, -1, len-4); 
04CC8:  MOVLW  04
04CCA:  MOVLB  3
04CCC:  SUBWF  xCB,W
04CCE:  MOVWF  xD1
04CD0:  MOVLW  00
04CD2:  SUBWFB xCC,W
04CD4:  MOVWF  xD2
04CD6:  MOVLB  4
04CD8:  SETF   x4E
04CDA:  SETF   x4D
04CDC:  SETF   x50
04CDE:  SETF   x4F
04CE0:  MOVWF  x52
04CE2:  MOVFF  3D1,451
04CE6:  MOVLB  0
04CE8:  CALL   0CB4
.................... 		while(!MACIsMemCopyDone()); 
04CEC:  CALL   0F44
04CF0:  MOVF   01,F
04CF2:  BZ    4CEC
.................... 	 
.................... 		// Transmit the echo reply packet 
.................... 	    MACFlush(); 
04CF4:  CALL   1DB8
04CF8:  MOVLB  3
.................... 	} 
.................... #if defined(STACK_USE_ICMP_CLIENT) 
04CFA:  MOVLB  0
04CFC:  GOTO   6D52 (RETURN)
.................... 	else if(dwVal.w[0] == 0x0000u)	// See if this an ICMP Echo reply to our request 
.................... 	{ 
.................... 		// Get the sequence number and identifier fields 
.................... 		MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
.................... 		 
.................... 		// See if the identifier matches the one we sent 
.................... 		if(dwVal.w[0] != 0xEFBE)	 
.................... 			return; 
.................... 	 
.................... 		if(dwVal.w[1] != wICMPSequenceNumber) 
.................... 			return; 
....................  
.................... 		// Validate the ICMP checksum field 
.................... 	    IPSetRxBuffer(0); 
.................... 		if(CalcIPBufferChecksum(sizeof(ICMP_PACKET)))	// Two bytes of payload were sent in the echo request 
.................... 			return; 
.................... 		 
.................... 		// Flag that we received the response and stop the timer ticking 
.................... 		ICMPFlags.bReplyValid = 1; 
.................... 		ICMPTimer = TickGet() - ICMPTimer; 
.................... 	} 
.................... #endif 
.................... } 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPing(DWORD dwRemoteIP) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           dwRemoteIP: IP Address to ping.  Must be stored  
....................  *								big endian.  Ex. 192.168.0.1 should be 
....................  *								passed as 0x0100A8C0. 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPing(DWORD dwRemoteIP) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	StaticVars.ICMPRemote.IPAddr.Val = dwRemoteIP; 
.................... 	ICMPState = SM_ARP_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHost (BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in RAM if being called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 0; 
.................... 	StaticVars.RemoteHost.szRAM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(__18CXX) 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHostROM (ROM BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in ROM. Should only be called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 1; 
.................... 	StaticVars.RemoteHost.szROM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #endif 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        LONG ICMPGetReply(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE and ICMPSendPing()  
....................  *					was called 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          -3: Could not resolve hostname (DNS timeout or  
....................  *			    	    hostname invalid) 
....................  *					-2: No response received yet 
....................  *					-1: Operation timed out (longer than ICMP_TIMEOUT)  
....................  *						has elapsed. 
....................  *					>=0: Number of TICKs that elapsed between  
....................  *						 initial ICMP transmission and reception of  
....................  *						 a valid echo. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... LONG ICMPGetReply(void) 
.................... { 
.................... 	ICMP_PACKET ICMPPacket; 
....................  
.................... 	switch(ICMPState) 
.................... 	{ 
.................... #if defined(STACK_USE_DNS) 
.................... 		case SM_DNS_SEND_QUERY: 
.................... 			// Obtain DNS module ownership 
.................... 			if(!DNSBeginUsage()) 
.................... 				break; 
.................... 			 
.................... 			// Send DNS query 
.................... 			if(ICMPFlags.bRemoteHostIsROM) 
.................... 				DNSResolveROM(StaticVars.RemoteHost.szROM, DNS_TYPE_A); 
.................... 			else 
.................... 				DNSResolve(StaticVars.RemoteHost.szRAM, DNS_TYPE_A); 
.................... 			 
.................... 			ICMPState = SM_DNS_GET_RESPONSE; 
.................... 			break; 
.................... 				 
.................... 		case SM_DNS_GET_RESPONSE: 
.................... 			// See if DNS is done, and if so, get the remote IP address 
.................... 			if(!DNSIsResolved(&StaticVars.ICMPRemote.IPAddr)) 
.................... 				break; 
.................... 			 
.................... 			// Free the DNS module 
.................... 			DNSEndUsage(); 
.................... 			 
.................... 			// Return error code if the DNS query failed 
.................... 			if(StaticVars.ICMPRemote.IPAddr.Val == 0x00000000ul) 
.................... 			{ 
.................... 				ICMPState = SM_IDLE; 
.................... 				return -3; 
.................... 			} 
....................  
.................... 			ICMPState = SM_ARP_SEND_QUERY;	 
.................... 			// No break;	 
.................... #endif 
....................  
.................... 		case SM_ARP_SEND_QUERY: 
.................... 			ARPResolve(&StaticVars.ICMPRemote.IPAddr); 
.................... 			ICMPState = SM_ARP_GET_RESPONSE; 
.................... 			break; 
.................... 			 
.................... 		case SM_ARP_GET_RESPONSE: 
.................... 			// See if the ARP reponse was successfully received 
.................... 			if(!ARPIsResolved(&StaticVars.ICMPRemote.IPAddr, &StaticVars.ICMPRemote.MACAddr)) 
.................... 				break; 
.................... 			 
.................... 			ICMPState = SM_ICMP_SEND_ECHO_REQUEST; 
.................... 			// No break;  
.................... 		 
.................... 		case SM_ICMP_SEND_ECHO_REQUEST: 
.................... 		    if(!IPIsTxReady()) 
.................... 		    	break; 
....................  
.................... 			// Set up the ping packet 
.................... 			ICMPPacket.vType = 0x08;	// 0x08: Echo (ping) request 
.................... 			ICMPPacket.vCode = 0x00; 
.................... 			ICMPPacket.wChecksum = 0x0000; 
.................... 			ICMPPacket.wIdentifier = 0xEFBE; 
.................... 			wICMPSequenceNumber++;  
.................... 			ICMPPacket.wSequenceNumber = wICMPSequenceNumber; 
.................... 			ICMPPacket.wData = 0x2860; 
.................... 			ICMPPacket.wChecksum = CalcIPChecksum((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 		 
.................... 			// Record the current time.  This will be used as a basis for  
.................... 			// finding the echo response time, which exludes the ARP and DNS  
.................... 			// steps 
.................... 			ICMPTimer = TickGet(); 
....................  
.................... 			// Position the write pointer for the next IPPutHeader operation 
.................... 		    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
.................... 		 
.................... 			// Create IP header in TX memory 
.................... 			IPPutHeader(&StaticVars.ICMPRemote, IP_PROT_ICMP, sizeof(ICMPPacket)); 
.................... 			MACPutArray((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 			MACFlush(); 
....................  
.................... 			// Echo sent, advance state 
.................... 			ICMPState = SM_ICMP_GET_ECHO_RESPONSE; 
.................... 			break; 
....................  
.................... 		case SM_ICMP_GET_ECHO_RESPONSE: 
.................... 			// See if the echo was successfully received 
.................... 			if(ICMPFlags.bReplyValid) 
.................... 				return (LONG)ICMPTimer; 
.................... 		 
.................... 			break; 
.................... 		 
.................... 		// SM_IDLE or illegal/impossible state: 
.................... 		default: 
.................... 			return -1; 
.................... 	} 
....................  
.................... 	// See if the DNS/ARP/echo request timed out 
.................... 	if(TickGet() - ICMPTimer > ICMP_TIMEOUT) 
.................... 	{ 
.................... 		// Free DNS module if we have it in use 
.................... 		#if defined(STACK_USE_DNS) 
.................... 			if(ICMPState == SM_DNS_GET_RESPONSE) 
.................... 				DNSEndUsage(); 
.................... 		#endif 
.................... 		 
.................... 		// Stop ICMP echo test and return error to caller 
.................... 		ICMPState = SM_IDLE; 
.................... 		return -1; 
.................... 	} 
....................  
.................... 	// Still working.  No response to report yet. 
.................... 	return -2; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPBeginUsage(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: You have successfully gained ownership of  
....................  *						  the ICMP client module and can now use the  
....................  *						  ICMPSendPing() and ICMPGetReply() functions. 
....................  *					FALSE: Some other application is using the ICMP  
....................  *						   client module.  Calling ICMPSendPing()  
....................  *						   will corrupt the other application's ping  
....................  *						   result. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Claims ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPBeginUsage(void) 
.................... { 
.................... 	if(ICMPFlags.bICMPInUse) 
.................... 		return FALSE; 
....................  
.................... 	ICMPFlags.bICMPInUse = TRUE; 
.................... 	return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPEndUsage(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() was called by you and it  
....................  *					returned TRUE. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Your ownership of the ICMP module is released.   
....................  *					You can no longer use ICMPSendPing(). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Gives up ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPEndUsage(void) 
.................... { 
.................... 	ICMPFlags.bICMPInUse = FALSE; 
.................... } 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   User Datagram Protocol (UDP) Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides unreliable, minimum latency transport of application  
....................  *    datagram (packet) oriented data 
....................  *    -Reference: RFC 768 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.c 
....................  * Dependencies:    IP, Ethernet (ENC28J60.c or ETH97J60.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/26/03  Fixed UDPGet and UDPProcess bugs 
....................  *                               as discovered and fixed by John Owen 
....................  *                               of Powerwave. 
....................  *                               1. UDPGet would return FALSE on last good byte 
....................  *                               2. UDPProcess was incorrectly calculating length. 
....................  * Nilesh Rajbharti     5/19/03  Added bFirstRead flag similar to TCP 
....................  *                               to detect very first UDPGet and 
....................  *                               reset MAC Rx pointer to begining of 
....................  *                               UDP data area.  This would ensure that 
....................  *                               if UDP socket has pending Rx data and 
....................  *                               another module resets MAC Rx pointer, 
....................  *                               next UDP socket Get would get correct 
....................  *                               data. 
....................  * Robert Sloan (RSS)    5/29/03 Improved FindMatchingSocket() 
....................  * Nilesh Rajbharti     12/2/03  Added UDPChecksum logic in UDPProcess() 
....................  * Nilesh Rajbharti     12/5/03  Modified UDPProcess() and FindMatchingSocket() 
....................  *                               to include localIP as new parameter. 
....................  *                               This corrects pseudo header checksum 
....................  *                               logic in UDPProcess(). 
....................  *                               It also corrects broadcast packet 
....................  *                               matching correct in FindMatchingSocket(). 
....................  * Howard Schlunder      1/16/06    Fixed an imporbable RX checksum bug  
....................  *                         when using a Microchip Ethernet controller) 
....................  * Howard Schlunder      6/02/06    Fixed a bug where all RXed UDP packets  
....................  *                         without a checksum (0x0000) were thrown 
....................  *                         away.  No checksum is legal in UDP. 
....................  * Howard Schlunder      8/10/06    Fixed a bug where UDP sockets would  
....................  *                         unintentionally keep the remote MAC  
....................  *                         address cached, even after calling  
....................  *                         UDPInit(), UDPClose(), or reseting  
....................  *                         the part without clearing all the  
....................  *                         PIC memory. 
....................  ********************************************************************/ 
.................... #define __UDP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_UDP) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Configuration Parameters 
....................   ***************************************************************************/ 
....................  
.................... // First port number for randomized local port number selection 
.................... #define LOCAL_UDP_PORT_START_NUMBER (4096u) 
....................  
.................... // Last port number for randomized local port number selection 
.................... #define LOCAL_UDP_PORT_END_NUMBER   (8192u) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    UDP Global Variables 
....................   ***************************************************************************/ 
....................  
.................... // Stores an array of information pertaining to each UDP socket 
.................... UDP_SOCKET_INFO      UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
.................... // Indicates which UDP socket is currently active 
.................... UDP_SOCKET         activeUDPSocket; 
....................  
.................... WORD UDPTxCount;   // Number of bytes written to this UDP segment 
.................... WORD UDPRxCount;   // Number of bytes read from this UDP segment 
.................... static UDP_SOCKET   LastPutSocket = INVALID_UDP_SOCKET;   // Indicates the last socket to which data was written 
.................... static WORD wPutOffset;      // Offset from beginning of payload where data is to be written. 
.................... static WORD wGetOffset;      // Offset from beginning of payload from where data is to be read. 
....................  
.................... // Stores various flags for the UDP module 
.................... static struct 
.................... { 
....................    unsigned char bFirstRead : 1;      // No data has been read from this segment yet 
....................    unsigned char bWasDiscarded : 1;   // The data in this segment has been discarded 
.................... } Flags; 
....................  
.................... // Indicates which socket has currently received data for this loop 
.................... static UDP_SOCKET SocketWithRxData = INVALID_UDP_SOCKET; 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, NODE_INFO *remoteNode, 
....................                                     IP_ADDR *localIP); 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Connection Management Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPInit(void) 
....................  
....................   Summary: 
....................    Initializes the UDP module. 
....................  
....................   Description: 
....................    Initializes the UDP module.  This function initializes all the UDP  
....................    sockets to the closed state. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void UDPInit(void) 
.................... { 
....................     UDP_SOCKET s; 
....................  
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
*
00A0E:  MOVLB  3
00A10:  CLRF   xC0
00A12:  MOVF   xC0,W
00A14:  SUBLW  06
00A16:  BNC   0A26
....................     { 
....................       UDPClose(s); 
00A18:  MOVFF  3C0,3CB
00A1C:  MOVLB  0
00A1E:  RCALL  098A
00A20:  MOVLB  3
00A22:  INCF   xC0,F
00A24:  BRA    0A12
....................     } 
....................    Flags.bWasDiscarded = 1; 
00A26:  MOVLB  1
00A28:  BSF    x3A.1
00A2A:  MOVLB  0
00A2C:  GOTO   1536 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
.................... Function: 
....................    UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort, 
....................    UDP_PORT remotePort) 
....................  
....................  Summary: 
....................     Opens a UDP socket for a client. 
....................  
....................  Description: 
....................     Provides a unified method for opening UDP sockets. This function can open both client and  
....................     server   sockets. For client sockets, it can accept a host name string to query in DNS, an IP 
....................     address as a string, an IP address in binary form, or a previously resolved NODE_INFO  
....................     structure containing the remote IP address and associated MAC address. When a host name 
....................     or IP address only is provided, UDP module will internally perform the necessary DNSResolve 
....................     and/or ARP resolution steps before reporting that the UDP socket is connected (via a call to 
....................     UDPISOpen returning TRUE). Server sockets ignore this destination parameter and listen  
....................     only on the indicated port.   Sockets are statically allocated on boot, but can be claimed with 
....................     this function and freed using UDPClose . 
....................  
.................... Conditions: 
.................... UDPInit should be called. 
....................  
.................... Input: 
....................     remoteHost -     Pointer to remote node info (MAC and IP address) for this connection.   
....................     If this is a     server socket (receives the first packet) or the destination is the broadcast  
....................     address, then this parameter should be NULL. For client sockets only. Provide a pointer to 
....................     a null-terminated string of the remote host name (ex\:"www.microchip.com" or  
....................     "192.168.1.123"), a literal destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR data type), 
....................     or a pointer to a NODE_INFO structure with the remote IP address and remote node or gateway 
....................     MAC address specified, If a string is provided. 
....................      
....................     remoteHostType - Any one of the following flags to identify the meaning of the remoteHost parameter: 
....................        - UDP_OPEN_SERVER   = Open a server socket and ignore the remoteHost parameter.  
....................           (e.g. - SNMP agent, DHCP server, Announce) 
....................        - UDP_OPEN_IP_ADDRESS = Open a client socket and connect it to a remote IP address. 
....................           Ex: 0x7B01A8C0 for 192.168.1.123 (DWORD type). Note that the byte ordering is big endian. 
....................        - UDP_OPEN_NODE_INFO = Open a client socket and connect it to a remote IP and MAC  
....................           addresses pair stored in a NODE_INFO structure. 
....................         - UDP_OPEN_RAM_HOST = Open a client socket and connect it to a remote host who's  
....................            name is stored as a null terminated string in a RAM array. Ex:"www.microchip.com" or 
....................            "192.168.0.123" 
....................         - UDP_OPEN_ROM_HOST = Open a client socket and connect it to a remote host who's 
....................            name is stored as a null terminated string in a literal string or ROM array. Ex:  
....................            "www.microchip.com" or "192.168.0.123"  
....................  
....................     localPort - UDP port number to listen on.  If 0, stack will dynamically assign a unique port  
....................     number to use. 
....................  
....................     remotePort - For client sockets, the remote port number. 
....................  
.................... Return Values: 
....................      Success -  
....................       A UDP socket handle that can be used for subsequent UDP API calls. 
....................    Failure - 
....................       INVALID_UDP_SOCKET.  This function fails when no more UDP socket 
....................       handles are available.  Increase MAX_UDP_SOCKETS to make more sockets    available. 
.................... Remarks: 
....................    When finished using the UDP socket handle, call the UDPClose() function to free the  
....................    socket and delete the handle. 
....................  
.................... *****************************************************************************/ 
.................... UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort, 
....................       UDP_PORT remotePort) 
.................... { 
....................    UDP_SOCKET s; 
....................    UDP_SOCKET_INFO *p; 
....................  
....................    // Local temp port numbers. 
....................    static WORD NextPort __attribute__((persistent)); 
....................  
....................  
....................    p = UDPSocketInfo; 
*
0162A:  MOVLB  3
0162C:  CLRF   xD5
0162E:  MOVLW  57
01630:  MOVWF  xD4
....................    for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
01632:  CLRF   xD3
01634:  MOVF   xD3,W
01636:  SUBLW  06
01638:  BTFSS  FD8.0
0163A:  BRA    177E
....................    { 
....................       if(p->localPort == INVALID_UDP_PORT) 
0163C:  MOVLW  0C
0163E:  ADDWF  xD4,W
01640:  MOVWF  FE9
01642:  MOVLW  00
01644:  ADDWFC xD5,W
01646:  MOVWF  FEA
01648:  MOVFF  FEC,3D7
0164C:  MOVF   FED,F
0164E:  MOVFF  FEF,3D6
01652:  MOVF   xD6,F
01654:  BTFSS  FD8.2
01656:  BRA    1772
01658:  MOVF   xD7,F
0165A:  BTFSS  FD8.2
0165C:  BRA    1772
....................       { 
....................           p->localPort = localPort;   
0165E:  MOVLW  0C
01660:  ADDWF  xD4,W
01662:  MOVWF  FE9
01664:  MOVLW  00
01666:  ADDWFC xD5,W
01668:  MOVWF  FEA
0166A:  MOVFF  3D0,FEC
0166E:  MOVF   FED,F
01670:  MOVFF  3CF,FEF
....................          if(localPort == 0x0000u) 
01674:  MOVF   xCF,F
01676:  BNZ   16BE
01678:  MOVF   xD0,F
0167A:  BNZ   16BE
....................             { 
....................             if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER) 
0167C:  MOVLB  1
0167E:  MOVF   x3D,W
01680:  SUBLW  1F
01682:  BC    168E
01684:  XORLW  FF
01686:  BNZ   1694
01688:  MOVF   x3C,W
0168A:  SUBLW  00
0168C:  BNC   1694
0168E:  MOVF   x3D,W
01690:  SUBLW  0F
01692:  BNC   169A
....................                NextPort = LOCAL_UDP_PORT_START_NUMBER; 
01694:  MOVLW  10
01696:  MOVWF  x3D
01698:  CLRF   x3C
....................  
....................             p->localPort    = NextPort++; 
0169A:  MOVLW  0C
0169C:  MOVLB  3
0169E:  ADDWF  xD4,W
016A0:  MOVWF  FE9
016A2:  MOVLW  00
016A4:  ADDWFC xD5,W
016A6:  MOVWF  FEA
016A8:  MOVLB  1
016AA:  MOVFF  13D,03
016AE:  MOVF   x3C,W
016B0:  INCF   x3C,F
016B2:  BTFSC  FD8.2
016B4:  INCF   x3D,F
016B6:  MOVWF  FEF
016B8:  MOVFF  03,FEC
016BC:  MOVLB  3
....................             } 
....................          if((remoteHostType == UDP_OPEN_SERVER) || (remoteHost == 0)) 
016BE:  MOVF   xCE,F
016C0:  BZ    16D2
016C2:  MOVF   xCA,F
016C4:  BNZ   1708
016C6:  MOVF   xCB,F
016C8:  BNZ   1708
016CA:  MOVF   xCC,F
016CC:  BNZ   1708
016CE:  MOVF   xCD,F
016D0:  BNZ   1708
....................          { 
....................               //Set remote node as 0xFF ( broadcast address) 
....................               // else Set broadcast address 
....................               memset((void*)&p->remote.remoteNode, 0xFF, sizeof(p->remote)); 
016D2:  MOVFF  3D5,03
016D6:  MOVFF  3D4,3D6
016DA:  MOVFF  3D5,3D7
016DE:  MOVFF  3D5,FEA
016E2:  MOVFF  3D4,FE9
016E6:  SETF   00
016E8:  CLRF   02
016EA:  MOVLW  0A
016EC:  MOVWF  01
016EE:  MOVLB  0
016F0:  CALL   0A30
....................               p->smState = UDP_OPENED; 
016F4:  MOVLW  0E
016F6:  MOVLB  3
016F8:  ADDWF  xD4,W
016FA:  MOVWF  FE9
016FC:  MOVLW  00
016FE:  ADDWFC xD5,W
01700:  MOVWF  FEA
01702:  MOVLW  05
01704:  MOVWF  FEF
....................          } 
01706:  BRA    1752
....................          else 
....................          { 
....................             switch(remoteHostType) 
01708:  MOVF   xCE,W
0170A:  XORLW  04
0170C:  MOVLB  0
0170E:  BZ    1712
01710:  BRA    1750
....................             { 
.................... #if defined (STACK_CLIENT_MODE) 
.................... #if defined (STACK_USE_DNS) 
....................                case UDP_OPEN_RAM_HOST: 
....................                case UDP_OPEN_ROM_HOST: 
....................                   //set the UDP state to UDP_GET_DNS_MODULE 
....................                   p->remote.remoteHost = remoteHost; 
....................                   p->flags.bRemoteHostIsROM = (remoteHostType == UDP_OPEN_ROM_HOST); 
....................                   p->smState = UDP_DNS_RESOLVE; 
....................                break; 
.................... #endif 
....................                case UDP_OPEN_IP_ADDRESS: 
....................                // remoteHost is a literal IP address.   This doesn't need DNS and can skip directly to the Gateway ARPing step.     
....................                //Next UDP state UDP_GATEWAY_SEND_ARP; 
....................                p->remote.remoteNode.IPAddr.Val = remoteHost; 
....................                p->retryCount = 0; 
....................                p->retryInterval = (TICK_SECOND/4)/256; 
....................                p->smState = UDP_GATEWAY_SEND_ARP; 
....................                break; 
.................... #endif                   
....................                case UDP_OPEN_NODE_INFO: 
....................                //skip DNS and ARP resolution steps if connecting to a remote node which we've already 
....................                   memcpy((void*)(BYTE*)&p->remote,(void*)(BYTE*)(PTR_BASE)remoteHost,sizeof(p->remote)); 
01712:  MOVLB  3
01714:  MOVFF  3D5,03
01718:  MOVFF  3D4,3D6
0171C:  MOVFF  3D5,3D7
01720:  MOVFF  3D5,FEA
01724:  MOVFF  3D4,FE9
01728:  MOVFF  3CB,FE2
0172C:  MOVFF  3CA,FE1
01730:  MOVLW  0A
01732:  MOVWF  01
01734:  MOVFF  FE6,FEE
01738:  DECFSZ 01,F
0173A:  BRA    1734
....................                   p->smState = UDP_OPENED; 
0173C:  MOVLW  0E
0173E:  ADDWF  xD4,W
01740:  MOVWF  FE9
01742:  MOVLW  00
01744:  ADDWFC xD5,W
01746:  MOVWF  FEA
01748:  MOVLW  05
0174A:  MOVWF  FEF
....................                // CALL UDPFlushto transmit incluind peding data. 
....................                break; 
0174C:  BRA    1752
0174E:  MOVLB  0
....................                default: 
....................                   break; 
01750:  MOVLB  3
....................             } 
....................          } 
....................          p->remotePort   = remotePort; 
01752:  MOVLW  0A
01754:  ADDWF  xD4,W
01756:  MOVWF  FE9
01758:  MOVLW  00
0175A:  ADDWFC xD5,W
0175C:  MOVWF  FEA
0175E:  MOVFF  3D2,FEC
01762:  MOVF   FED,F
01764:  MOVFF  3D1,FEF
....................  
....................          // Mark this socket as active. 
....................          // Once an active socket is set, subsequent operation can be 
....................          // done without explicitely supply socket identifier. 
....................          activeUDPSocket = s; 
01768:  MOVFF  3D3,56
....................          return s; 
0176C:  MOVFF  3D3,01
01770:  BRA    1782
....................       } 
....................       p++; 
01772:  MOVLW  17
01774:  ADDWF  xD4,F
01776:  BTFSC  FD8.0
01778:  INCF   xD5,F
0177A:  INCF   xD3,F
0177C:  BRA    1634
....................    } 
....................  
....................    return (UDP_SOCKET)INVALID_UDP_SOCKET; 
0177E:  MOVLW  FF
01780:  MOVWF  01
01782:  MOVLB  0
01784:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... /****************************************************************************** 
.................... Function: 
....................    void UDPTask(void) 
....................  
....................   Summary: 
....................      Performs periodic UDP tasks. 
....................  
....................   Description: 
....................    This function performs any required periodic UDP tasks.  Each socket's state machine is  
....................    checked, and any elapsed timeout periods are handled. 
....................  
....................   Precondition: 
....................    UDP is initialized. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................  
.................... ******************************************************************************/ 
.................... void UDPTask(void) 
.................... { 
....................    UDP_SOCKET ss; 
....................     
....................    for ( ss = 0; ss < MAX_UDP_SOCKETS; ss++ ) 
*
04580:  MOVLB  3
04582:  CLRF   xC9
04584:  MOVF   xC9,W
04586:  SUBLW  06
04588:  BNC   4604
....................    { 
....................  
....................       // need to put Extra check if UDP has opened or NOT 
....................  
....................       if((UDPSocketInfo[ss].smState == UDP_OPENED) || 
....................          (UDPSocketInfo[ss].smState == UDP_CLOSED)) 
0458A:  MOVF   xC9,W
0458C:  MULLW  17
0458E:  MOVF   FF3,W
04590:  CLRF   xCB
04592:  MOVWF  xCA
04594:  MOVLW  0E
04596:  ADDWF  xCA,W
04598:  MOVWF  01
0459A:  MOVLW  00
0459C:  ADDWFC xCB,W
0459E:  MOVWF  03
045A0:  MOVF   01,W
045A2:  ADDLW  57
045A4:  MOVWF  FE9
045A6:  MOVLW  00
045A8:  ADDWFC 03,W
045AA:  MOVWF  FEA
045AC:  MOVF   FEF,W
045AE:  SUBLW  05
045B0:  BZ    45DA
045B2:  MOVF   xC9,W
045B4:  MULLW  17
045B6:  MOVF   FF3,W
045B8:  CLRF   xCB
045BA:  MOVWF  xCA
045BC:  MOVLW  0E
045BE:  ADDWF  xCA,W
045C0:  MOVWF  01
045C2:  MOVLW  00
045C4:  ADDWFC xCB,W
045C6:  MOVWF  03
045C8:  MOVF   01,W
045CA:  ADDLW  57
045CC:  MOVWF  FE9
045CE:  MOVLW  00
045D0:  ADDWFC 03,W
045D2:  MOVWF  FEA
045D4:  MOVF   FEF,W
045D6:  SUBLW  04
045D8:  BNZ   45DC
....................          continue; 
045DA:  BRA    4600
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(UDPSocketInfo[ss].smState) 
045DC:  MOVF   xC9,W
045DE:  MULLW  17
045E0:  MOVF   FF3,W
045E2:  CLRF   xCB
045E4:  MOVWF  xCA
045E6:  MOVLW  0E
045E8:  ADDWF  xCA,W
045EA:  MOVWF  01
045EC:  MOVLW  00
045EE:  ADDWFC xCB,W
045F0:  MOVWF  03
045F2:  MOVF   01,W
045F4:  ADDLW  57
045F6:  MOVWF  FE9
045F8:  MOVLW  00
045FA:  ADDWFC 03,W
045FC:  MOVWF  FEA
045FE:  MOVF   FEF,W
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          #if defined(STACK_USE_DNS) 
....................          case UDP_DNS_RESOLVE: 
....................          if(DNSBeginUsage()) 
....................          { 
....................             // call DNS Resolve function and move to UDP next State machine 
....................             UDPSocketInfo[ss].smState = UDP_DNS_IS_RESOLVED; 
....................             if(UDPSocketInfo[ss].flags.bRemoteHostIsROM) 
....................                DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A); 
....................             else 
....................                DNSResolve((BYTE*)(PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A); 
....................          } 
....................          break;             
....................          case UDP_DNS_IS_RESOLVED: 
....................          { 
....................             IP_ADDR ipResolvedDNSIP; 
....................             // See if DNS resolution has finished.   Note that if the DNS  
....................             // fails, the &ipResolvedDNSIP will be written with 0x00000000.  
....................             // MyTCB.remote.dwRemoteHost is unioned with  
....................             // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write  
....................             // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We  
....................             // must copy it over only if the DNS is resolution step was  
....................             // successful. 
....................              
....................             if(DNSIsResolved(&ipResolvedDNSIP)) 
....................             { 
....................                if(DNSEndUsage()) 
....................                { 
....................                   UDPSocketInfo[ss].remote.remoteNode.IPAddr.Val = ipResolvedDNSIP.Val; 
....................                   UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP; 
....................                   UDPSocketInfo[ss].retryCount = 0; 
....................                   UDPSocketInfo[ss].retryInterval = (TICK_SECOND/4)/256; 
....................                } 
....................                else 
....................                { 
....................                   UDPSocketInfo[ss].smState = UDP_DNS_RESOLVE; 
....................                } 
....................             }          
....................          } 
....................          break; 
....................          #endif // #if defined(STACK_USE_DNS) 
....................  
....................          case UDP_GATEWAY_SEND_ARP: 
....................             // Obtain the MAC address associated with the server's IP address  
....................             //(either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................             UDPSocketInfo[ss].eventTime = (WORD)TickGetDiv256(); 
....................             ARPResolve(&UDPSocketInfo[ss].remote.remoteNode.IPAddr); 
....................             UDPSocketInfo[ss].smState = UDP_GATEWAY_GET_ARP; 
....................             break; 
....................  
....................          case UDP_GATEWAY_GET_ARP: 
....................          if(!ARPIsResolved(&UDPSocketInfo[ss].remote.remoteNode.IPAddr,  
....................                         &UDPSocketInfo[ss].remote.remoteNode.MACAddr)) 
....................          { 
....................             // Time out if too much time is spent in this state 
....................             // Note that this will continuously send out ARP  
....................             // requests for an infinite time if the Gateway  
....................             // never responds 
....................             if((WORD)TickGetDiv256() - UDPSocketInfo[ss].eventTime> (WORD)UDPSocketInfo[ss].retryInterval) 
....................             { 
....................                // Exponentially increase timeout until we reach 6 attempts then stay constant 
....................                if(UDPSocketInfo[ss].retryCount < 6u) 
....................                { 
....................                   UDPSocketInfo[ss].retryCount++; 
....................                   UDPSocketInfo[ss].retryInterval <<= 1; 
....................                } 
....................                // Retransmit ARP request 
....................                UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP; 
....................             }             
....................          } 
....................          else 
....................          { 
....................             UDPSocketInfo[ss].smState = UDP_OPENED; 
....................          } 
....................          break; 
....................          default: 
....................          case UDP_OPENED: 
....................          case UDP_CLOSED: 
....................          // not used 
....................          break; 
.................... #endif // #if defined(STACK_CLIENT_MODE) 
....................       } 
04600:  INCF   xC9,F
04602:  BRA    4584
....................    } 
04604:  MOVLB  0
04606:  GOTO   6C46 (RETURN)
.................... }  
....................  
.................... /****************************************************************************** 
....................   
....................   Function: 
....................      BOOL UDPISOpened(UDP_SOCKET socket) 
....................    
....................  Summary: 
....................      Determines if a socket has an established connection. 
....................  
....................  Description: 
....................    This function determines if a socket has an established connection to a remote node .   
....................    Call this function after calling UDPOpen to determine when the connection is set up  
....................    and ready for use.   
....................  
....................  Precondition: 
....................    UDP is initialized. 
....................  
....................  Parameters: 
....................    socket - The socket to check. 
....................  
....................  Return Values: 
....................    TRUE - The socket has been opened and ARP has been resolved. 
....................    FALSE - The socket is not currently connected. 
....................  
....................  Remarks: 
....................    None 
....................   
....................  *****************************************************************************/ 
.................... BOOL UDPIsOpened(UDP_SOCKET socket) 
.................... { 
....................    return (UDPSocketInfo[socket].smState == UDP_OPENED); 
.................... } 
....................  
....................  
.................... #if 0 
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPTask(void) 
....................  
....................   Summary: 
....................    Performs state management and housekeeping for UDP. 
....................     
....................   Description: 
....................    Performs state management and housekeeping for UDP.  This is an internal 
....................    function meant to be called by StackTask() (not a user API). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Return Values: 
....................      None 
....................       
....................   Remarks: 
....................    UDPTask() is called once per StackTask() iteration to ensure that calls  
....................    to UDPIsPutReady() always update the Ethernet Write pointer location  
....................    between StackTask() iterations. 
....................   ***************************************************************************/ 
.................... void UDPTask(void) 
.................... { 
....................    LastPutSocket = INVALID_UDP_SOCKET; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO* remoteNode,  
....................                   UDP_PORT remotePort) 
....................  
....................   Summary: 
....................    Creates a UDP socket handle for transmiting or receiving UDP packets. 
....................     
....................   Description: 
....................    Creates a UDP socket handle for transmiting or receiving UDP packets.   
....................    Call this function to obtain a handle required by other UDP function. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    localPort - UDP port number to listen on.  If 0, stack will dynamically  
....................       assign a unique port number to use. 
....................    remoteNode - Pointer to remote node info (MAC and IP address) for this 
....................       connection.  If this is a server socket (receives the first packet)  
....................       or the destination is the broadcast address, then this parameter 
....................       should be NULL. 
....................    remotePort - For client sockets, the remote port number. 
....................  
....................   Return Values: 
....................      Success - 
....................       A UDP socket handle that can be used for subsequent UDP API calls. 
....................    Failure - 
....................       INVALID_UDP_SOCKET.  This function fails when no more UDP socket  
....................       handles are available.  Increase MAX_UDP_SOCKETS to make more sockets  
....................       available. 
....................       
....................   Remarks: 
....................    When finished using the UDP socket handle, call the UDPClose() function  
....................    to free the socket and delete the handle. 
....................   ***************************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort) 
.................... { 
....................     UDP_SOCKET s; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................    // Local temp port numbers. 
....................    static WORD NextPort __attribute__((persistent)); 
....................  
....................  
....................     p = UDPSocketInfo; 
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
....................     { 
....................         if(p->localPort == INVALID_UDP_PORT) 
....................         { 
....................          p->localPort = localPort;    
....................  
....................          if(localPort == 0x0000u) 
....................          { 
....................             if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER) 
....................                NextPort = LOCAL_UDP_PORT_START_NUMBER; 
....................     
....................                p->localPort    = NextPort++; 
....................          } 
....................  
....................             // If remoteNode is supplied, remember it. 
....................             if(remoteNode) 
....................             { 
....................                 memcpy((void*)&p->remoteNode, 
....................                         (const void*)remoteNode, 
....................                         sizeof(p->remoteNode)); 
....................             } 
....................             else 
....................          { 
....................             // else Set broadcast address 
....................             memset((void*)&p->remoteNode, 0xFF, sizeof(p->remoteNode)); 
....................          } 
....................  
....................             p->remotePort   = remotePort; 
....................  
....................             // Mark this socket as active. 
....................             // Once an active socket is set, subsequent operation can be 
....................             // done without explicitely supply socket identifier. 
....................             activeUDPSocket = s; 
....................             return s; 
....................         } 
....................         p++; 
....................     } 
....................  
....................     return (UDP_SOCKET)INVALID_UDP_SOCKET; 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPClose(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Closes a UDP socket and frees the handle. 
....................     
....................   Description: 
....................    Closes a UDP socket and frees the handle.  Call this function to release 
....................    a socket and return it to the pool for use by future communications. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket handle to be released.  If an illegal handle value is  
....................       provided, the function safely does nothing. 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function does not affect the previously designated active socket. 
....................   ***************************************************************************/ 
.................... void UDPClose(UDP_SOCKET s) 
.................... { 
....................    if(s >= MAX_UDP_SOCKETS) 
*
0098A:  MOVLB  3
0098C:  MOVF   xCB,W
0098E:  SUBLW  06
00990:  BC    0994
....................       return; 
00992:  BRA    0A0A
....................  
....................    UDPSocketInfo[s].localPort = INVALID_UDP_PORT; 
00994:  MOVF   xCB,W
00996:  MULLW  17
00998:  MOVF   FF3,W
0099A:  CLRF   xCD
0099C:  MOVWF  xCC
0099E:  MOVLW  0C
009A0:  ADDWF  xCC,W
009A2:  MOVWF  01
009A4:  MOVLW  00
009A6:  ADDWFC xCD,W
009A8:  MOVWF  03
009AA:  MOVF   01,W
009AC:  ADDLW  57
009AE:  MOVWF  FE9
009B0:  MOVLW  00
009B2:  ADDWFC 03,W
009B4:  MOVWF  FEA
009B6:  CLRF   FEC
009B8:  MOVF   FED,F
009BA:  CLRF   FEF
....................    UDPSocketInfo[s].remote.remoteNode.IPAddr.Val = 0x00000000; 
009BC:  MOVF   xCB,W
009BE:  MULLW  17
009C0:  MOVF   FF3,W
009C2:  CLRF   xCD
009C4:  MOVWF  xCC
009C6:  MOVLW  57
009C8:  ADDWF  xCC,W
009CA:  MOVWF  FE9
009CC:  MOVLW  00
009CE:  ADDWFC xCD,W
009D0:  MOVWF  FEA
009D2:  MOVF   FEE,F
009D4:  MOVF   FEE,F
009D6:  CLRF   FEC
009D8:  MOVF   FED,F
009DA:  CLRF   FEF
009DC:  MOVF   FED,F
009DE:  CLRF   FEF
009E0:  MOVF   FED,F
009E2:  CLRF   FEF
....................    UDPSocketInfo[s].smState = UDP_CLOSED; 
009E4:  MOVF   xCB,W
009E6:  MULLW  17
009E8:  MOVF   FF3,W
009EA:  CLRF   xCD
009EC:  MOVWF  xCC
009EE:  MOVLW  0E
009F0:  ADDWF  xCC,W
009F2:  MOVWF  01
009F4:  MOVLW  00
009F6:  ADDWFC xCD,W
009F8:  MOVWF  03
009FA:  MOVF   01,W
009FC:  ADDLW  57
009FE:  MOVWF  FE9
00A00:  MOVLW  00
00A02:  ADDWFC 03,W
00A04:  MOVWF  FEA
00A06:  MOVLW  04
00A08:  MOVWF  FEF
00A0A:  MOVLB  0
00A0C:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPSetTxBuffer(WORD wOffset) 
....................  
....................   Summary: 
....................    Moves the pointer within the TX buffer. 
....................     
....................   Description: 
....................    This function allows the write location within the TX buffer to be  
....................    specified.  Future calls to UDPPut, UDPPutArray, UDPPutString, etc will 
....................    write data from the indicated location. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called and a socket is currently  
....................    active. 
....................  
....................   Parameters: 
....................    wOffset - Offset from beginning of UDP packet data payload to place the 
....................       write pointer. 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UDPSetTxBuffer(WORD wOffset) 
.................... { 
....................    IPSetTxBuffer(wOffset+sizeof(UDP_HEADER)); 
*
017AE:  MOVLW  08
017B0:  MOVLB  3
017B2:  ADDWF  xCB,W
017B4:  MOVWF  xCD
017B6:  MOVLW  00
017B8:  ADDWFC xCC,W
017BA:  MOVWF  xCE
017BC:  MOVLW  D7
017BE:  ADDWF  xCD,F
017C0:  MOVLW  11
017C2:  ADDWFC xCE,F
017C4:  MOVLW  0E
017C6:  ADDWF  xCD,F
017C8:  MOVLW  00
017CA:  ADDWFC xCE,F
017CC:  MOVLW  14
017CE:  ADDWF  xCD,F
017D0:  MOVLW  00
017D2:  ADDWFC xCE,F
017D4:  MOVFF  3CE,44E
017D8:  MOVFF  3CD,44D
017DC:  MOVLB  0
017DE:  CALL   0AF2
....................    wPutOffset = wOffset; 
017E2:  MOVFF  3CC,137
017E6:  MOVFF  3CB,136
017EA:  GOTO   181A (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPSetRxBuffer(WORD wOffset) 
....................  
....................   Summary: 
....................    Moves the pointer within the RX buffer. 
....................     
....................   Description: 
....................    This function allows the read location within the RX buffer to be  
....................    specified.  Future calls to UDPGet and UDPGetArray will read data from 
....................    the indicated location forward. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called and a socket is currently  
....................    active. 
....................  
....................   Parameters: 
....................    wOffset - Offset from beginning of UDP packet data payload to place the 
....................       read pointer. 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UDPSetRxBuffer(WORD wOffset) 
.................... { 
....................    IPSetRxBuffer(wOffset+sizeof(UDP_HEADER)); 
*
024BE:  MOVLW  08
024C0:  MOVLB  3
024C2:  ADDWF  xD7,W
024C4:  MOVWF  xD9
024C6:  MOVLW  00
024C8:  ADDWFC xD8,W
024CA:  MOVWF  xDA
024CC:  MOVFF  FE8,419
024D0:  MOVFF  3D9,418
024D4:  MOVLB  0
024D6:  RCALL  24A2
....................    wGetOffset = wOffset; 
024D8:  MOVFF  3D8,139
024DC:  MOVFF  3D7,138
024E0:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Transmit Functions 
....................   ***************************************************************************/ 
....................    
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPIsPutReady(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Determines how many bytes can be written to the UDP socket. 
....................     
....................   Description: 
....................    This function determines if bytes can be written to the specified UDP 
....................    socket.  It also prepares the UDP module for writing by setting the  
....................    indicated socket as the currently active connection. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket to be made active 
....................  
....................   Returns: 
....................      The number of bytes that can be written to this socket. 
....................   ***************************************************************************/ 
.................... WORD UDPIsPutReady(UDP_SOCKET s) 
.................... { 
....................    if(!MACIsTxReady()) 
*
017EE:  RCALL  1786
017F0:  MOVF   01,F
017F2:  BNZ   17FC
....................       return 0; 
017F4:  MOVLW  00
017F6:  MOVWF  01
017F8:  MOVWF  02
017FA:  BRA    1836
....................  
....................    if(LastPutSocket != s) 
017FC:  MOVLB  3
017FE:  MOVF   xCA,W
01800:  MOVLB  1
01802:  SUBWF  x35,W
01804:  BZ    181C
....................    { 
....................       LastPutSocket = s; 
01806:  MOVFF  3CA,135
....................       UDPTxCount = 0; 
0180A:  MOVLB  0
0180C:  CLRF   xF9
0180E:  CLRF   xF8
....................       UDPSetTxBuffer(0); 
01810:  MOVLB  3
01812:  CLRF   xCC
01814:  CLRF   xCB
01816:  MOVLB  0
01818:  BRA    17AE
0181A:  MOVLB  1
....................    } 
....................  
....................    activeUDPSocket = s; 
0181C:  MOVFF  3CA,56
....................  
....................    return MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) - UDPTxCount; 
01820:  MOVLW  C0
01822:  BSF    FD8.0
01824:  MOVLB  0
01826:  SUBFWB xF8,W
01828:  MOVWF  00
0182A:  MOVLW  05
0182C:  SUBFWB xF9,W
0182E:  MOVWF  03
01830:  MOVFF  00,01
01834:  MOVWF  02
01836:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPPut(BYTE v) 
....................  
....................   Summary: 
....................    Writes a byte to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a single byte to the currently active UDP socket,  
....................    while incrementing the buffer length.  UDPIsPutReady should be used  
....................    before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    v - The byte to be loaded into the transmit buffer. 
....................  
....................   Return Values: 
....................      TRUE - The byte was successfully written to the socket. 
....................      FALSE - The transmit buffer is already full and so the write failed. 
....................   ***************************************************************************/ 
.................... BOOL UDPPut(BYTE v) 
.................... { 
....................    // See if we are out of transmit space. 
....................    if(wPutOffset >= (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER))) 
*
0194C:  MOVLB  1
0194E:  MOVF   x37,W
01950:  SUBLW  04
01952:  BC    1964
01954:  XORLW  FF
01956:  BNZ   195E
01958:  MOVF   x36,W
0195A:  SUBLW  BF
0195C:  BC    1964
....................    { 
....................       return FALSE; 
0195E:  MOVLW  00
01960:  MOVWF  01
01962:  BRA    199E
....................    } 
....................  
....................     // Load application data byte 
....................     MACPut(v); 
01964:  MOVFF  3D3,461
01968:  MOVLB  0
0196A:  CALL   060C
....................    wPutOffset++; 
0196E:  MOVLB  1
01970:  INCF   x36,F
01972:  BTFSC  FD8.2
01974:  INCF   x37,F
....................    if(wPutOffset > UDPTxCount) 
01976:  MOVLB  0
01978:  MOVF   xF9,W
0197A:  MOVLB  1
0197C:  SUBWF  x37,W
0197E:  BNC   199A
01980:  BNZ   1992
01982:  MOVF   x36,W
01984:  MOVLB  0
01986:  SUBWF  xF8,W
01988:  BTFSS  FD8.0
0198A:  BRA    1990
0198C:  MOVLB  1
0198E:  BRA    199A
01990:  MOVLB  1
....................       UDPTxCount = wPutOffset; 
01992:  MOVFF  137,F9
01996:  MOVFF  136,F8
....................  
....................     return TRUE; 
0199A:  MOVLW  01
0199C:  MOVWF  01
0199E:  MOVLB  0
019A0:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPPutArray(BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Writes an array of bytes to the currently active socket. 
....................     
....................   Description: 
....................    This function writes an array of bytes to the currently active UDP socket,  
....................    while incrementing the buffer length.  UDPIsPutReady should be used  
....................    before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The array to write to the socket. 
....................    wDateLen - Number of bytes from cData to be written. 
....................     
....................   Returns: 
....................      The number of bytes successfully placed in the UDP transmit buffer.  If 
....................      this value is less than wDataLen, then the buffer became full and the 
....................      input was truncated. 
....................   ***************************************************************************/ 
.................... WORD UDPPutArray(BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wTemp; 
....................  
....................    wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset; 
019A2:  MOVLW  C0
019A4:  BSF    FD8.0
019A6:  MOVLB  1
019A8:  SUBFWB x36,W
019AA:  MOVLB  3
019AC:  MOVWF  xD7
019AE:  MOVLW  05
019B0:  MOVLB  1
019B2:  SUBFWB x37,W
019B4:  MOVLB  3
019B6:  MOVWF  xD8
....................    if(wTemp < wDataLen) 
019B8:  MOVF   xD8,W
019BA:  SUBWF  xD6,W
019BC:  BNC   19CE
019BE:  BNZ   19C6
019C0:  MOVF   xD5,W
019C2:  SUBWF  xD7,W
019C4:  BC    19CE
....................       wDataLen = wTemp; 
019C6:  MOVFF  3D8,3D6
019CA:  MOVFF  3D7,3D5
....................  
....................    wPutOffset += wDataLen; 
019CE:  MOVF   xD5,W
019D0:  MOVLB  1
019D2:  ADDWF  x36,F
019D4:  MOVLB  3
019D6:  MOVF   xD6,W
019D8:  MOVLB  1
019DA:  ADDWFC x37,F
....................    if(wPutOffset > UDPTxCount) 
019DC:  MOVLB  0
019DE:  MOVF   xF9,W
019E0:  MOVLB  1
019E2:  SUBWF  x37,W
019E4:  BNC   1A00
019E6:  BNZ   19F8
019E8:  MOVF   x36,W
019EA:  MOVLB  0
019EC:  SUBWF  xF8,W
019EE:  BTFSS  FD8.0
019F0:  BRA    19F6
019F2:  MOVLB  1
019F4:  BRA    1A00
019F6:  MOVLB  1
....................       UDPTxCount = wPutOffset; 
019F8:  MOVFF  137,F9
019FC:  MOVFF  136,F8
....................  
....................     // Load application data bytes 
....................     MACPutArray(cData, wDataLen); 
01A00:  MOVFF  3D4,463
01A04:  MOVFF  3D3,462
01A08:  MOVFF  3D6,465
01A0C:  MOVFF  3D5,464
01A10:  MOVLB  0
01A12:  CALL   0B62
....................  
....................     return wDataLen; 
01A16:  MOVLB  3
01A18:  MOVFF  3D5,01
01A1C:  MOVFF  3D6,02
01A20:  MOVLB  0
01A22:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Writes an array of bytes from ROM to the currently active socket. 
....................     
....................   Description: 
....................    This function writes an array of bytes from ROM to the currently active  
....................    UDP socket, while incrementing the buffer length.  UDPIsPutReady should  
....................    be used before calling this function to specify the currently active  
....................    socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The array to write to the socket. 
....................    wDateLen - Number of bytes from cData to be written. 
....................     
....................   Returns: 
....................      The number of bytes successfully placed in the UDP transmit buffer.  If 
....................      this value is less than wDataLen, then the buffer became full and the 
....................      input was truncated. 
....................       
....................   Remarks: 
....................    This function is aliased to UDPPutArray on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wTemp; 
....................  
....................    wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset; 
....................    if(wTemp < wDataLen) 
....................       wDataLen = wTemp; 
....................  
....................    wPutOffset += wDataLen; 
....................    if(wPutOffset > UDPTxCount) 
....................       UDPTxCount = wPutOffset; 
....................  
....................     // Load application data bytes 
....................     MACPutROMArray(cData, wDataLen); 
....................  
....................     return wDataLen; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* UDPPutString(BYTE *strData) 
....................  
....................   Summary: 
....................    Writes null-terminated string to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a null-terminated string to the currently active  
....................    UDP socket, while incrementing the buffer length.  UDPIsPutReady should  
....................    be used before calling this function to specify the currently active 
....................    socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - Pointer to the string to be written to the socket. 
....................     
....................   Returns: 
....................      A pointer to the byte following the last byte written.  Note that this 
....................      is different than the UDPPutArray functions.  If this pointer does not 
....................      dereference to a NULL byte, then the buffer became full and the input 
....................      data was truncated. 
....................   ***************************************************************************/ 
.................... BYTE* UDPPutString(BYTE *strData) 
.................... { 
....................    return strData + UDPPutArray(strData, strlen((char*)strData)); 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* UDPPutString(BYTE *strData) 
....................  
....................   Summary: 
....................    Writes null-terminated string from ROM to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a null-terminated string from ROM to the currently 
....................    active UDP socket, while incrementing the buffer length.  UDPIsPutReady 
....................    should be used before calling this function to specify the currently 
....................    active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - Pointer to the string to be written to the socket. 
....................     
....................   Returns: 
....................      A pointer to the byte following the last byte written.  Note that this 
....................      is different than the UDPPutArray functions.  If this pointer does not 
....................      dereference to a NULL byte, then the buffer became full and the input 
....................      data was truncated. 
....................    
....................   Remarks: 
....................    This function is aliased to UDPPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... ROM BYTE* UDPPutROMString(ROM BYTE *strData) 
.................... { 
....................    return strData + UDPPutROMArray(strData, strlenpgm((ROM char*)strData)); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPFlush(void) 
....................  
....................   Summary: 
....................    Transmits all pending data in a UDP socket. 
....................     
....................   Description: 
....................    This function builds a UDP packet with the pending TX data and marks it  
....................    for transmission over the network interface.  Since UDP is a frame-based 
....................    protocol, this function must be called before returning to the main 
....................    stack loop whenever any data is written. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket, and 
....................    data has been written to the socket using the UDPPut family of functions. 
....................  
....................   Parameters: 
....................    None 
....................     
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................    Note that unlike TCPFlush, UDPFlush must be called before returning to  
....................    the main stack loop.  There is no auto transmit for UDP segments. 
....................   ***************************************************************************/ 
.................... void UDPFlush(void) 
.................... { 
....................     UDP_HEADER      h; 
....................     UDP_SOCKET_INFO *p; 
....................     WORD         wUDPLength; 
....................  
....................     p = &UDPSocketInfo[activeUDPSocket]; 
*
01FF0:  MOVF   56,W
01FF2:  MULLW  17
01FF4:  MOVF   FF3,W
01FF6:  CLRF   03
01FF8:  ADDLW  57
01FFA:  MOVWF  01
01FFC:  MOVLW  00
01FFE:  ADDWFC 03,F
02000:  MOVFF  01,3D9
02004:  MOVLB  3
02006:  MOVFF  03,3DA
....................  
....................    wUDPLength = UDPTxCount + sizeof(UDP_HEADER); 
0200A:  MOVLW  08
0200C:  MOVLB  0
0200E:  ADDWF  xF8,W
02010:  MOVLB  3
02012:  MOVWF  xDB
02014:  MOVLW  00
02016:  MOVLB  0
02018:  ADDWFC xF9,W
0201A:  MOVLB  3
0201C:  MOVWF  xDC
....................  
....................    // Generate the correct UDP header 
....................     h.SourcePort        = swaps(p->localPort); 
0201E:  MOVLW  0C
02020:  ADDWF  xD9,W
02022:  MOVWF  FE9
02024:  MOVLW  00
02026:  ADDWFC xDA,W
02028:  MOVWF  FEA
0202A:  MOVFF  FEC,3DE
0202E:  MOVF   FED,F
02030:  MOVFF  FEF,3DD
02034:  MOVFF  3DE,45E
02038:  MOVFF  3DD,45D
0203C:  MOVLB  0
0203E:  RCALL  1A24
02040:  MOVFF  02,3D2
02044:  MOVFF  01,3D1
....................     h.DestinationPort   = swaps(p->remotePort); 
02048:  MOVLW  0A
0204A:  MOVLB  3
0204C:  ADDWF  xD9,W
0204E:  MOVWF  FE9
02050:  MOVLW  00
02052:  ADDWFC xDA,W
02054:  MOVWF  FEA
02056:  MOVFF  FEC,3DE
0205A:  MOVF   FED,F
0205C:  MOVFF  FEF,3DD
02060:  MOVFF  3DE,45E
02064:  MOVFF  3DD,45D
02068:  MOVLB  0
0206A:  RCALL  1A24
0206C:  MOVFF  02,3D4
02070:  MOVFF  01,3D3
....................     h.Length            = swaps(wUDPLength); 
02074:  MOVFF  3DC,45E
02078:  MOVFF  3DB,45D
0207C:  RCALL  1A24
0207E:  MOVFF  02,3D6
02082:  MOVFF  01,3D5
....................    h.Checksum          = 0x0000; 
02086:  MOVLB  3
02088:  CLRF   xD8
0208A:  CLRF   xD7
....................      
....................    // Calculate IP pseudoheader checksum if we are going to enable  
....................    // the checksum field 
....................    #if defined(UDP_USE_TX_CHECKSUM) 
....................    { 
....................       PSEUDO_HEADER   pseudoHeader; 
....................        
....................       pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
....................       pseudoHeader.DestAddress    = p->remote.remoteNode.IPAddr; 
....................       pseudoHeader.Zero           = 0x0; 
....................       pseudoHeader.Protocol       = IP_PROT_UDP; 
....................       pseudoHeader.Length         = wUDPLength; 
....................       SwapPseudoHeader(pseudoHeader); 
....................       h.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader)); 
....................    } 
....................    #endif 
....................  
....................    // Position the hardware write pointer where we will need to  
....................    // begin writing the IP header 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
0208C:  MOVLW  11
0208E:  MOVLB  4
02090:  MOVWF  x4E
02092:  MOVLW  E5
02094:  MOVWF  x4D
02096:  MOVLB  0
02098:  CALL   0AF2
....................     
....................    // Write IP header to packet 
....................    IPPutHeader(&p->remote.remoteNode, IP_PROT_UDP, wUDPLength); 
0209C:  MOVFF  3D9,01
020A0:  MOVFF  3DA,03
020A4:  MOVFF  3D9,3DD
020A8:  MOVFF  3DA,3DE
020AC:  MOVFF  3DA,43F
020B0:  MOVFF  3D9,43E
020B4:  MOVLW  11
020B6:  MOVLB  4
020B8:  MOVWF  x40
020BA:  MOVFF  3DC,442
020BE:  MOVFF  3DB,441
020C2:  MOVLB  0
020C4:  RCALL  1CCE
....................  
....................     // Write UDP header to packet 
....................     MACPutArray((BYTE*)&h, sizeof(h)); 
020C6:  MOVLW  03
020C8:  MOVLB  3
020CA:  MOVWF  xDE
020CC:  MOVLW  D1
020CE:  MOVWF  xDD
020D0:  MOVFF  3DE,463
020D4:  MOVFF  FE8,462
020D8:  MOVLB  4
020DA:  CLRF   x65
020DC:  MOVLW  08
020DE:  MOVWF  x64
020E0:  MOVLB  0
020E2:  CALL   0B62
....................      
....................    // Calculate the final UDP checksum and write it in, if enabled 
....................    #if defined(UDP_USE_TX_CHECKSUM) 
....................    { 
....................         PTR_BASE   wReadPtrSave; 
....................         WORD      wChecksum; 
....................  
....................       wReadPtrSave = MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)); 
....................       wChecksum = CalcIPBufferChecksum(wUDPLength); 
....................       if(wChecksum == 0x0000u) 
....................          wChecksum = 0xFFFF; 
....................       MACSetReadPtr(wReadPtrSave); 
....................       MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 6);   // 6 is the offset to the Checksum field in UDP_HEADER 
....................       MACPutArray((BYTE*)&wChecksum, sizeof(wChecksum)); 
....................    } 
....................    #endif 
....................      
....................    // Transmit the packet 
....................     MACFlush(); 
020E6:  RCALL  1DB8
....................  
....................    // Reset packet size counter for the next TX operation 
....................     UDPTxCount = 0; 
020E8:  CLRF   xF9
020EA:  CLRF   xF8
....................    LastPutSocket = INVALID_UDP_SOCKET; 
020EC:  MOVLB  1
020EE:  SETF   x35
020F0:  MOVLB  0
020F2:  GOTO   23D8 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Receive Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPIsGetReady(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Determines how many bytes can be read from the UDP socket. 
....................     
....................   Description: 
....................    This function determines if bytes can be read from the specified UDP 
....................    socket.  It also prepares the UDP module for reading by setting the  
....................    indicated socket as the currently active connection. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket to be made active (which has already been opened or is 
....................       listening) 
....................  
....................   Returns: 
....................      The number of bytes that can be read from this socket. 
....................   ***************************************************************************/ 
.................... WORD UDPIsGetReady(UDP_SOCKET s) 
.................... { 
....................     activeUDPSocket = s; 
*
024E2:  MOVFF  3CA,56
....................    if(SocketWithRxData != s) 
024E6:  MOVLB  3
024E8:  MOVF   xCA,W
024EA:  MOVLB  1
024EC:  SUBWF  x3B,W
024EE:  BZ    24F8
....................       return 0; 
024F0:  MOVLW  00
024F2:  MOVWF  01
024F4:  MOVWF  02
024F6:  BRA    2524
....................  
....................     // If this is the very first time we are accessing this packet,  
....................     // move the read point to the begining of the packet. 
....................     if(Flags.bFirstRead) 
024F8:  BTFSS  x3A.0
024FA:  BRA    250A
....................     { 
....................         Flags.bFirstRead = 0; 
024FC:  BCF    x3A.0
....................         UDPSetRxBuffer(0); 
024FE:  MOVLB  3
02500:  CLRF   xD8
02502:  CLRF   xD7
02504:  MOVLB  0
02506:  RCALL  24BE
02508:  MOVLB  1
....................     } 
....................  
....................     return UDPRxCount - wGetOffset; 
0250A:  MOVF   x38,W
0250C:  MOVLB  0
0250E:  SUBWF  xFA,W
02510:  MOVWF  00
02512:  MOVLB  1
02514:  MOVF   x39,W
02516:  MOVLB  0
02518:  SUBWFB xFB,W
0251A:  MOVWF  03
0251C:  MOVFF  00,01
02520:  MOVWF  02
02522:  MOVLB  1
02524:  MOVLB  0
02526:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPGet(BYTE *v) 
....................  
....................   Summary: 
....................    Reads a byte from the currently active socket. 
....................     
....................   Description: 
....................    This function reads a single byte from the currently active UDP socket,  
....................    while decrementing the remaining buffer length.  UDPIsGetReady should be  
....................    used before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    v - The buffer to receive the data being read. 
....................  
....................   Return Values: 
....................      TRUE - A byte was successfully read 
....................      FALSE - No data remained in the read buffer 
....................   ***************************************************************************/ 
.................... BOOL UDPGet(BYTE *v) 
.................... { 
....................    // Make sure that there is data to return 
....................     if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket)) 
02528:  MOVF   xFB,W
0252A:  MOVLB  1
0252C:  SUBWF  x39,W
0252E:  BNC   253C
02530:  BNZ   2542
02532:  MOVLB  0
02534:  MOVF   xFA,W
02536:  MOVLB  1
02538:  SUBWF  x38,W
0253A:  BC    2542
0253C:  MOVF   56,W
0253E:  SUBWF  x3B,W
02540:  BZ    2548
....................         return FALSE; 
02542:  MOVLW  00
02544:  MOVWF  01
02546:  BRA    2572
....................  
....................     *v = MACGet(); 
02548:  MOVFF  3DA,03
0254C:  MOVFF  3D9,3DB
02550:  MOVFF  3DA,3DC
02554:  MOVLB  0
02556:  CALL   0C8A
0255A:  MOVFF  3DC,FEA
0255E:  MOVFF  3DB,FE9
02562:  MOVFF  01,FEF
....................     wGetOffset++; 
02566:  MOVLB  1
02568:  INCF   x38,F
0256A:  BTFSC  FD8.2
0256C:  INCF   x39,F
....................  
....................     return TRUE; 
0256E:  MOVLW  01
02570:  MOVWF  01
02572:  MOVLB  0
02574:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPGetArray(BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Reads an array of bytes from the currently active socket. 
....................     
....................   Description: 
....................    This function reads an array of bytes from the currently active UDP socket,  
....................    while decrementing the remaining bytes available. UDPIsGetReady should be  
....................    used before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The buffer to receive the bytes being read.  If NULL, the bytes are  
....................          simply discarded without being written anywhere (effectively skips  
....................          over the bytes in the RX buffer, although if you need to skip a lot  
....................          of data, seeking using the UDPSetRxBuffer() will be more efficient). 
....................    wDateLen - Number of bytes to be read from the socket. 
....................     
....................   Returns: 
....................      The number of bytes successfully read from the UDP buffer.  If this 
....................      value is less than wDataLen, then the buffer was emptied and no more  
....................      data is available. 
....................   ***************************************************************************/ 
.................... WORD UDPGetArray(BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wBytesAvailable; 
....................     
....................    // Make sure that there is data to return 
....................     if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket)) 
02576:  MOVF   xFB,W
02578:  MOVLB  1
0257A:  SUBWF  x39,W
0257C:  BNC   258A
0257E:  BNZ   2590
02580:  MOVLB  0
02582:  MOVF   xFA,W
02584:  MOVLB  1
02586:  SUBWF  x38,W
02588:  BC    2590
0258A:  MOVF   56,W
0258C:  SUBWF  x3B,W
0258E:  BZ    2598
....................       return 0; 
02590:  MOVLW  00
02592:  MOVWF  01
02594:  MOVWF  02
02596:  BRA    25FE
....................  
....................    // Make sure we don't try to read more data than exists 
....................    wBytesAvailable = UDPRxCount - wGetOffset; 
02598:  MOVF   x38,W
0259A:  MOVLB  0
0259C:  SUBWF  xFA,W
0259E:  MOVLB  3
025A0:  MOVWF  xDD
025A2:  MOVLB  1
025A4:  MOVF   x39,W
025A6:  MOVLB  0
025A8:  SUBWFB xFB,W
025AA:  MOVLB  3
025AC:  MOVWF  xDE
....................    if(wBytesAvailable < wDataLen) 
025AE:  MOVF   xDE,W
025B0:  SUBWF  xDC,W
025B2:  BNC   25C4
025B4:  BNZ   25BC
025B6:  MOVF   xDB,W
025B8:  SUBWF  xDD,W
025BA:  BC    25C4
....................       wDataLen = wBytesAvailable; 
025BC:  MOVFF  3DE,3DC
025C0:  MOVFF  3DD,3DB
....................  
....................    wDataLen = MACGetArray(cData, wDataLen); 
025C4:  MOVFF  3DA,461
025C8:  MOVFF  3D9,460
025CC:  MOVFF  3DC,463
025D0:  MOVFF  3DB,462
025D4:  MOVLB  0
025D6:  CALL   0C14
025DA:  MOVFF  02,3DC
025DE:  MOVFF  01,3DB
....................     wGetOffset += wDataLen; 
025E2:  MOVLB  3
025E4:  MOVF   xDB,W
025E6:  MOVLB  1
025E8:  ADDWF  x38,F
025EA:  MOVLB  3
025EC:  MOVF   xDC,W
025EE:  MOVLB  1
025F0:  ADDWFC x39,F
....................  
....................     return wDataLen; 
025F2:  MOVLB  3
025F4:  MOVFF  3DB,01
025F8:  MOVFF  3DC,02
025FC:  MOVLB  1
025FE:  MOVLB  0
02600:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPDiscard(void) 
....................  
....................   Summary: 
....................    Discards any remaining RX data from a UDP socket. 
....................     
....................   Description: 
....................    This function discards any remaining received data in the currently  
....................    active UDP socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to select the currently active 
....................    socket. 
....................  
....................   Parameters: 
....................    None 
....................     
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................    It is safe to call this function more than is necessary.  If no data is 
....................    available, this function does nothing. 
....................   ***************************************************************************/ 
.................... void UDPDiscard(void) 
.................... { 
....................    if(!Flags.bWasDiscarded) 
*
0266C:  MOVLB  1
0266E:  BTFSC  x3A.1
02670:  BRA    2680
....................    { 
....................       MACDiscardRx(); 
02672:  MOVLB  0
02674:  RCALL  2602
....................       UDPRxCount = 0; 
02676:  CLRF   xFB
02678:  CLRF   xFA
....................       SocketWithRxData = INVALID_UDP_SOCKET; 
0267A:  MOVLB  1
0267C:  SETF   x3B
....................       Flags.bWasDiscarded = 1; 
0267E:  BSF    x3A.1
....................    } 
02680:  MOVLB  0
02682:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Data Processing Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len) 
....................  
....................   Summary: 
....................    Handles an incoming UDP segment. 
....................     
....................   Description: 
....................    This function handles an incoming UDP segment to determine if it is  
....................    acceptable and should be handed to one of the stack applications for 
....................    processing. 
....................  
....................   Precondition: 
....................    UDPInit() has been called an a UDP segment is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    remoteNode - The remote node that sent this segment. 
....................    localIP - The destination IP address for this segment. 
....................    len - Total length of the UDP segment. 
....................     
....................   Return Values: 
....................      TRUE - A valid packet is waiting and the stack applications should be 
....................         called to handle it. 
....................      FALSE - The packet was discarded. 
....................   ***************************************************************************/ 
.................... BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len) 
.................... { 
....................     UDP_HEADER      h; 
....................     UDP_SOCKET      s; 
....................     PSEUDO_HEADER   pseudoHeader; 
....................     DWORD_VAL      checksums; 
....................  
....................    UDPRxCount = 0; 
*
06A3A:  CLRF   xFB
06A3C:  CLRF   xFA
....................  
....................     // Retrieve UDP header. 
....................     MACGetArray((BYTE*)&h, sizeof(h)); 
06A3E:  MOVLW  03
06A40:  MOVLB  3
06A42:  MOVWF  xE9
06A44:  MOVLW  CF
06A46:  MOVWF  xE8
06A48:  MOVFF  3E9,461
06A4C:  MOVFF  FE8,460
06A50:  MOVLB  4
06A52:  CLRF   x63
06A54:  MOVLW  08
06A56:  MOVWF  x62
06A58:  MOVLB  0
06A5A:  CALL   0C14
....................  
....................     h.SourcePort        = swaps(h.SourcePort); 
06A5E:  MOVFF  3D0,45E
06A62:  MOVFF  3CF,45D
06A66:  CALL   1A24
06A6A:  MOVFF  02,3D0
06A6E:  MOVFF  01,3CF
....................     h.DestinationPort   = swaps(h.DestinationPort); 
06A72:  MOVFF  3D2,45E
06A76:  MOVFF  3D1,45D
06A7A:  CALL   1A24
06A7E:  MOVFF  02,3D2
06A82:  MOVFF  01,3D1
....................     h.Length            = swaps(h.Length) - sizeof(UDP_HEADER); 
06A86:  MOVFF  3D4,45E
06A8A:  MOVFF  3D3,45D
06A8E:  CALL   1A24
06A92:  MOVLW  08
06A94:  MOVLB  3
06A96:  SUBWF  01,W
06A98:  MOVWF  xD3
06A9A:  MOVLW  00
06A9C:  SUBWFB 02,W
06A9E:  MOVWF  xD4
....................  
....................    // See if we need to validate the checksum field (0x0000 is disabled) 
....................    if(h.Checksum) 
06AA0:  MOVF   xD5,W
06AA2:  IORWF  xD6,W
06AA4:  BZ    6B74
....................    { 
....................        // Calculate IP pseudoheader checksum. 
....................        pseudoHeader.SourceAddress      = remoteNode->IPAddr; 
06AA6:  MOVFF  3C9,FE9
06AAA:  MOVFF  3CA,FEA
06AAE:  MOVFF  FEF,00
06AB2:  MOVFF  FEC,01
06AB6:  MOVFF  FEC,02
06ABA:  MOVFF  FEC,03
06ABE:  MOVFF  00,3D8
06AC2:  MOVFF  01,3D9
06AC6:  MOVFF  02,3DA
06ACA:  MOVFF  03,3DB
....................        pseudoHeader.DestAddress.Val   = localIP->Val; 
06ACE:  MOVFF  3CB,FE9
06AD2:  MOVFF  3CC,FEA
06AD6:  MOVFF  FEF,3DC
06ADA:  MOVFF  FEC,3DD
06ADE:  MOVFF  FEC,3DE
06AE2:  MOVFF  FEC,3DF
....................        pseudoHeader.Zero            = 0x0; 
06AE6:  CLRF   xE0
....................        pseudoHeader.Protocol         = IP_PROT_UDP; 
06AE8:  MOVLW  11
06AEA:  MOVWF  xE1
....................        pseudoHeader.Length            = len; 
06AEC:  MOVFF  3CE,3E3
06AF0:  MOVFF  3CD,3E2
....................  
....................        SwapPseudoHeader(pseudoHeader); 
06AF4:  MOVFF  3E3,45E
06AF8:  MOVFF  3E2,45D
06AFC:  MOVLB  0
06AFE:  CALL   1A24
06B02:  MOVFF  02,3E3
06B06:  MOVFF  01,3E2
....................     
....................        checksums.w[0] = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................                                        sizeof(pseudoHeader)); 
06B0A:  MOVLW  03
06B0C:  MOVLB  3
06B0E:  MOVWF  xE9
06B10:  MOVLW  D8
06B12:  MOVWF  xE8
06B14:  MOVFF  3E9,45A
06B18:  MOVFF  FE8,459
06B1C:  MOVLB  4
06B1E:  CLRF   x5C
06B20:  MOVLW  0C
06B22:  MOVWF  x5B
06B24:  MOVLB  0
06B26:  CALL   1B20
06B2A:  MOVFF  01,3E4
06B2E:  MOVLB  3
06B30:  COMF   xE4,F
06B32:  MOVFF  02,3E5
06B36:  COMF   xE5,F
....................     
....................     
....................        // Now calculate UDP packet checksum in NIC RAM -- should match pseudoHeader 
....................        IPSetRxBuffer(0); 
06B38:  MOVLB  4
06B3A:  CLRF   x19
06B3C:  CLRF   x18
06B3E:  MOVLB  0
06B40:  CALL   24A2
....................        checksums.w[1] = CalcIPBufferChecksum(len); 
06B44:  MOVFF  3CE,43F
06B48:  MOVFF  3CD,43E
06B4C:  CALL   34D8
06B50:  MOVFF  02,3E7
06B54:  MOVFF  01,3E6
....................     
....................        if(checksums.w[0] != checksums.w[1]) 
06B58:  MOVLB  3
06B5A:  MOVF   xE6,W
06B5C:  SUBWF  xE4,W
06B5E:  BNZ   6B66
06B60:  MOVF   xE7,W
06B62:  SUBWF  xE5,W
06B64:  BZ    6B74
....................        { 
....................            MACDiscardRx(); 
06B66:  MOVLB  0
06B68:  CALL   2602
....................            return FALSE; 
06B6C:  MOVLW  00
06B6E:  MOVWF  01
06B70:  BRA    6BC2
06B72:  MOVLB  3
....................        } 
....................    } 
....................  
....................     s = FindMatchingUDPSocket(&h, remoteNode, localIP); 
06B74:  MOVLW  03
06B76:  MOVWF  xE9
06B78:  MOVLW  CF
06B7A:  MOVWF  xE8
06B7C:  MOVFF  3CA,3EB
06B80:  MOVFF  3C9,3EA
06B84:  MOVFF  3CC,3ED
06B88:  MOVFF  3CB,3EC
06B8C:  MOVLB  0
06B8E:  BRA    68B4
06B90:  MOVFF  01,3D7
....................     if(s == INVALID_UDP_SOCKET) 
06B94:  MOVLB  3
06B96:  INCFSZ xD7,W
06B98:  BRA    6BAA
....................     { 
....................         // If there is no matching socket, There is no one to handle 
....................         // this data.  Discard it. 
....................         MACDiscardRx(); 
06B9A:  MOVLB  0
06B9C:  CALL   2602
....................       return FALSE; 
06BA0:  MOVLW  00
06BA2:  MOVWF  01
06BA4:  BRA    6BC2
....................     } 
06BA6:  BRA    6BBE
06BA8:  MOVLB  3
....................     else 
....................     { 
....................       SocketWithRxData = s; 
06BAA:  MOVFF  3D7,13B
....................         UDPRxCount = h.Length; 
06BAE:  MOVFF  3D4,FB
06BB2:  MOVFF  3D3,FA
....................         Flags.bFirstRead = 1; 
06BB6:  MOVLB  1
06BB8:  BSF    x3A.0
....................       Flags.bWasDiscarded = 0; 
06BBA:  BCF    x3A.1
06BBC:  MOVLB  0
....................     } 
....................  
....................  
....................     return TRUE; 
06BBE:  MOVLW  01
06BC0:  MOVWF  01
06BC2:  GOTO   6DA2 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, NODE_INFO *remoteNode, 
....................                                            IP_ADDR *localIP) 
....................  
....................   Summary: 
....................    Matches an incoming UDP segment to a currently active socket. 
....................     
....................   Description: 
....................    This function attempts to match an incoming UDP segment to a currently 
....................    active socket for processing. 
....................  
....................   Precondition: 
....................    UDP segment header and IP header have both been retrieved. 
....................  
....................   Parameters: 
....................    h - The UDP header that was received. 
....................    remoteNode - IP and MAC of the remote node that sent this segment. 
....................    localIP - IP address that this segment was destined for. 
....................     
....................   Returns: 
....................      A UDP_SOCKET handle of a matching socket, or INVALID_UDP_SOCKET when no 
....................      match could be made. 
....................   ***************************************************************************/ 
.................... static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, 
....................                                      NODE_INFO *remoteNode, 
....................                                      IP_ADDR *localIP) 
.................... { 
....................    UDP_SOCKET s; 
....................    UDP_SOCKET partialMatch; 
....................    UDP_SOCKET_INFO *p; 
....................  
.................... // This is commented out because most applications don't need this type of filtering.  It comes at a performance cost. 
.................... //   // Filter out unicast packets that aren't for our IP address, but accept  
.................... //   // all multicast and broadcast traffic 
.................... //   if(!((localIP->Val == AppConfig.MyIPAddr.Val) || (localIP->v[0] & 0x80) || (localIP->Val == (AppConfig.MyIPAddr.Val | (~AppConfig.MyMask.Val))))) 
.................... //      return INVALID_UDP_SOCKET; 
....................  
....................    // Discard any packets received that were generated by ourself.  In  
....................    // structured Wi-Fi networks, the Access Point rebroadcasts our broadcast  
....................    // and multicast packets, causing self-reception to occur unless filtered  
....................    // out. 
....................    if(remoteNode->IPAddr.Val == AppConfig.MyIPAddr.Val) 
*
068B4:  MOVLB  3
068B6:  MOVFF  3EA,FE9
068BA:  MOVFF  3EB,FEA
068BE:  MOVFF  FEF,3F2
068C2:  MOVFF  FEC,3F3
068C6:  MOVFF  FEC,3F4
068CA:  MOVFF  FEC,3F5
068CE:  MOVF   23,W
068D0:  SUBWF  xF2,W
068D2:  BNZ   68EC
068D4:  MOVF   24,W
068D6:  SUBWF  xF3,W
068D8:  BNZ   68EC
068DA:  MOVF   25,W
068DC:  SUBWF  xF4,W
068DE:  BNZ   68EC
068E0:  MOVF   26,W
068E2:  SUBWF  xF5,W
068E4:  BNZ   68EC
....................       return INVALID_UDP_SOCKET; 
068E6:  MOVLW  FF
068E8:  MOVWF  01
068EA:  BRA    6A34
....................  
....................    partialMatch = INVALID_UDP_SOCKET; 
068EC:  SETF   xEF
....................  
....................    p = UDPSocketInfo; 
068EE:  CLRF   xF1
068F0:  MOVLW  57
068F2:  MOVWF  xF0
....................     for(s = 0; s < MAX_UDP_SOCKETS; s++) 
068F4:  CLRF   xEE
068F6:  MOVF   xEE,W
068F8:  SUBLW  06
068FA:  BNC   69BE
....................    { 
....................       // This packet is said to be matching with current socket: 
....................       // 1. If its destination port matches with our local port and 
....................       // 2. Packet source IP address matches with previously saved socket remote IP address and 
....................       // 3. Packet source port number matches with previously saved socket remote port number 
....................       if(p->localPort == h->DestinationPort) 
068FC:  MOVLW  0C
068FE:  ADDWF  xF0,W
06900:  MOVWF  FE9
06902:  MOVLW  00
06904:  ADDWFC xF1,W
06906:  MOVWF  FEA
06908:  MOVFF  FEC,3F3
0690C:  MOVF   FED,F
0690E:  MOVFF  FEF,3F2
06912:  MOVLW  02
06914:  ADDWF  xE8,W
06916:  MOVWF  FE9
06918:  MOVLW  00
0691A:  ADDWFC xE9,W
0691C:  MOVWF  FEA
0691E:  MOVFF  FEC,03
06922:  MOVF   FED,F
06924:  MOVF   FEF,W
06926:  SUBWF  xF2,W
06928:  BNZ   69B2
0692A:  MOVF   03,W
0692C:  SUBWF  xF3,W
0692E:  BNZ   69B2
....................       { 
....................          if(p->remotePort == h->SourcePort) 
06930:  MOVLW  0A
06932:  ADDWF  xF0,W
06934:  MOVWF  FE9
06936:  MOVLW  00
06938:  ADDWFC xF1,W
0693A:  MOVWF  FEA
0693C:  MOVFF  FEC,3F3
06940:  MOVF   FED,F
06942:  MOVFF  FEF,3F2
06946:  MOVFF  3E8,FE9
0694A:  MOVFF  3E9,FEA
0694E:  MOVFF  FEC,03
06952:  MOVF   FED,F
06954:  MOVF   FEF,W
06956:  SUBWF  xF2,W
06958:  BNZ   69AE
0695A:  MOVF   03,W
0695C:  SUBWF  xF3,W
0695E:  BNZ   69AE
....................          { 
....................             if(p->remote.remoteNode.IPAddr.Val == remoteNode->IPAddr.Val) 
06960:  MOVFF  3F0,FE9
06964:  MOVFF  3F1,FEA
06968:  MOVFF  FEF,3F2
0696C:  MOVFF  FEC,3F3
06970:  MOVFF  FEC,3F4
06974:  MOVFF  FEC,3F5
06978:  MOVFF  3EA,FE9
0697C:  MOVFF  3EB,FEA
06980:  MOVFF  FEF,00
06984:  MOVFF  FEC,01
06988:  MOVFF  FEC,02
0698C:  MOVFF  FEC,03
06990:  MOVF   00,W
06992:  SUBWF  xF2,W
06994:  BNZ   69AE
06996:  MOVF   01,W
06998:  SUBWF  xF3,W
0699A:  BNZ   69AE
0699C:  MOVF   02,W
0699E:  SUBWF  xF4,W
069A0:  BNZ   69AE
069A2:  MOVF   03,W
069A4:  SUBWF  xF5,W
069A6:  BNZ   69AE
....................             { 
....................                return s; 
069A8:  MOVFF  3EE,01
069AC:  BRA    6A34
....................             } 
....................          } 
....................  
....................          partialMatch = s; 
069AE:  MOVFF  3EE,3EF
....................       } 
....................       p++; 
069B2:  MOVLW  17
069B4:  ADDWF  xF0,F
069B6:  BTFSC  FD8.0
069B8:  INCF   xF1,F
069BA:  INCF   xEE,F
069BC:  BRA    68F6
....................    } 
....................  
....................    if(partialMatch != INVALID_UDP_SOCKET) 
069BE:  INCFSZ xEF,W
069C0:  BRA    69C4
069C2:  BRA    6A30
....................    { 
....................       p = &UDPSocketInfo[partialMatch]; 
069C4:  MOVF   xEF,W
069C6:  MULLW  17
069C8:  MOVF   FF3,W
069CA:  CLRF   03
069CC:  ADDLW  57
069CE:  MOVWF  01
069D0:  MOVLW  00
069D2:  ADDWFC 03,F
069D4:  MOVFF  01,3F0
069D8:  MOVFF  03,3F1
....................  
....................       memcpy((void*)&p->remote.remoteNode, 
....................             (const void*)remoteNode, sizeof(p->remote.remoteNode) ); 
069DC:  MOVFF  3F1,03
069E0:  MOVFF  3F0,3F2
069E4:  MOVFF  3F1,3F3
069E8:  MOVFF  3F1,FEA
069EC:  MOVFF  3F0,FE9
069F0:  MOVFF  3EB,FE2
069F4:  MOVFF  3EA,FE1
069F8:  MOVLW  0A
069FA:  MOVWF  01
069FC:  MOVFF  FE6,FEE
06A00:  DECFSZ 01,F
06A02:  BRA    69FC
....................  
....................       p->remotePort = h->SourcePort; 
06A04:  MOVLW  0A
06A06:  ADDWF  xF0,W
06A08:  MOVWF  01
06A0A:  MOVLW  00
06A0C:  ADDWFC xF1,W
06A0E:  MOVFF  3E8,FE9
06A12:  MOVFF  3E9,FEA
06A16:  MOVFF  FEC,03
06A1A:  MOVF   FED,F
06A1C:  MOVFF  FEF,3F4
06A20:  MOVWF  FEA
06A22:  MOVFF  01,FE9
06A26:  MOVFF  03,FEC
06A2A:  MOVF   FED,F
06A2C:  MOVFF  3F4,FEF
....................    } 
....................  
....................    return partialMatch; 
06A30:  MOVFF  3EF,01
06A34:  MOVLB  0
06A36:  GOTO   6B90 (RETURN)
.................... } 
....................  
....................  
.................... #endif //#if defined(STACK_USE_UDP) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    #include "DHCP.c" 
.................... /********************************************************************* 
.................... * 
.................... *	Dynamic Host Configuration Protocol (DHCP) Client 
.................... *	Module for Microchip TCP/IP Stack 
.................... *	 -Provides automatic IP address, subnet mask, gateway address,  
.................... *	  DNS server address, and other configuration parameters on DHCP  
.................... *	  enabled networks. 
.................... *	 -Reference: RFC 2131, 2132 
.................... * 
.................... ********************************************************************* 
.................... * FileName:		DHCP.c 
.................... * Dependencies:	UDP 
.................... * Processor:	PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
.................... * Compiler:		Microchip C32 v1.05 or higher 
.................... *				Microchip C30 v3.12 or higher 
.................... *				Microchip C18 v3.30 or higher 
.................... *				HI-TECH PICC-18 PRO 9.63PL2 or higher 
.................... * Company:		Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
.................... * reserved. 
.................... * 
.................... * Microchip licenses to you the right to use, modify, copy, and 
.................... * distribute: 
.................... * (i)  the Software when embedded on a Microchip microcontroller or 
.................... *      digital signal controller product ("Device") which is 
.................... *      integrated into Licensee's product; or 
.................... * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
.................... *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
.................... *		used in conjunction with a Microchip ethernet controller for 
.................... *		the sole purpose of interfacing with the ethernet controller. 
.................... * 
.................... * You should refer to the license agreement accompanying this 
.................... * Software for additional information regarding your rights and 
.................... * obligations. 
.................... * 
.................... * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
.................... * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
.................... * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
.................... * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
.................... * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
.................... * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
.................... * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
.................... * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
.................... * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
.................... * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
.................... * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
.................... * 
.................... * 
.................... * Author               Date    Comment 
.................... *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
.................... * Nilesh Rajbharti     7/10/02  Explicitly initialized tempIPAddress 
.................... *                                               (Rev 2.11) 
.................... * Nilesh Rajbharti     5/16/03 Increased DHCP_TIMEOUT to 2 seconds. 
.................... * Nilesh Rajbharti     5/16/03 Fixed SM_DHCP_BROADCAST logic 
.................... *                              where UDPPut was called before setting 
.................... *                              active socket. 
.................... * Robert Sloan         5/29/03 Improved DHCP State machine to handle 
.................... *                              NAK and renew existing IP address. 
.................... * Nilesh Rajbharti     8/15/03 Modified _DHCPRecieve() to check for 
.................... *                              chaddr field before accpting the packet. 
.................... *                              Fixed DHCPTask() where it would not 
.................... *                              reply to first OFFER. 
.................... * Nilesh Rajbharti     3/1/04  Used tickDiff in DHCPTask() "bind" 
.................... *                              state to adjust for irregular TICK_SECOND 
.................... *                              Without this logic, actual lease time count 
.................... *                              down may be incorrect. 
.................... * Howard Schlunder		5/11/06	Fixed tickDiff usage, reducing  
.................... *								accumulated timing error.  Fixed DHCP  
.................... *								state machine requesting IP 0.0.0.0  
.................... *								after lease expiration. 
.................... * Howard Schlunder		6/01/06	Added DHCPFlags.bits.bOfferReceived flag to  
.................... *								allow operation on networks with multiple 
.................... *								DHCP servers offering multiple addresses 
.................... * Howard Schlunder		8/01/06 Added DNS server option to DHCP request,  
.................... *								untested Host Name option to DHCP request 
.................... * Howard Schlunder		1/09/06	Fixed a DHCP renewal not renewing lease time bug 
.................... * Howard Schlunder		3/16/07 Rewrote DHCP state machine 
.................... * Darren Rook/CCS       04/11/11 Changed default time from 2s to 5s. 
.................... * Darren Rook/CCS       04/11/11 Added MY_UNIT_HOSTNAME support. 
.................... * Darren Rook  (CCS)    01/06/12 Random XID (g_DNSTransactionID) 
.................... ********************************************************************/ 
.................... #define __DHCP_C 
....................  
.................... #include "TCPIPConfig.h" 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
....................  
.................... #define STACK_USE_ICMP_SERVER    1 
.................... #define STACK_USE_TCP            1 
.................... #define STACK_USE_DHCP_CLIENT    1 
....................  
.................... #define STACK_CCS_SMTP_TX_SIZE    0 
.................... #define STACK_CCS_SMTP_RX_SIZE    0 
....................  
.................... #define STACK_USE_CCS_HTTP2_SERVER 
.................... #define STACK_CCS_HTTP2_SERVER_TX_SIZE    1500 
.................... #define STACK_CCS_HTTP2_SERVER_RX_SIZE    500 
.................... #define HTTP_NUM_SOCKETS                  1 
.................... #define HTTP_PORT                         (80u) 
.................... #define HTTP_USE_DOUBLE_ESCAPE            1 
.................... #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................  
.................... #define STACK_MY_TELNET_SERVER_TX_SIZE    0 
.................... #define STACK_MY_TELNET_SERVER_RX_SIZE    0 
....................  
.................... #define MY_DEFAULT_HOST_NAME      "CCS_EXAMPLES" 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1      (0x0) 
.................... #define MY_DEFAULT_MAC_BYTE2      (0x20) 
.................... #define MY_DEFAULT_MAC_BYTE3      (0x30) 
.................... #define MY_DEFAULT_MAC_BYTE4      (0x40) 
.................... #define MY_DEFAULT_MAC_BYTE5      (0x50) 
.................... #define MY_DEFAULT_MAC_BYTE6      (0x60) 
....................  
.................... #define MY_DEFAULT_IP_ADDR_BYTE1  (192ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2  (168ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3  (1ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4  (118ul) 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1     (192ul) 
.................... #define MY_DEFAULT_GATE_BYTE2     (168ul) 
.................... #define MY_DEFAULT_GATE_BYTE3     (1ul) 
.................... #define MY_DEFAULT_GATE_BYTE4     (1ul) 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE2     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE3     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE4     (0ul) 
....................  
.................... #define TCP_CONFIGURATION      1 
....................  
.................... #define TCP_ETH_RAM_SIZE (STACK_CCS_SMTP_TX_SIZE + \ 
....................                           STACK_CCS_SMTP_RX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_TX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_RX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_TX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_RX_SIZE + \ 
....................                           100*TCP_CONFIGURATION) 
....................  
.................... // Define names of socket types 
.................... #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
.................... #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
.................... #define TCP_PURPOSE_TELNET             2 
.................... #define TCP_PURPOSE_FTP_COMMAND        3 
.................... #define TCP_PURPOSE_FTP_DATA           4 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
.................... #define TCP_PURPOSE_UART_2_TCP_BRIDGE  7 
.................... #define TCP_PURPOSE_HTTP_SERVER        8 
.................... #define TCP_PURPOSE_DEFAULT            9 
.................... #define TCP_PURPOSE_BERKELEY_SERVER    10 
.................... #define TCP_PURPOSE_BERKELEY_CLIENT    11 
.................... #define TCP_PURPOSE_CCS_SMTP           0x40 
....................  
.................... typedef struct 
.................... { 
....................    BYTE vSocketPurpose; 
....................    BYTE vMemoryMedium; 
....................    WORD wTXBufferSize; 
....................    WORD wRXBufferSize; 
.................... } TCPSocketInitializer_t; 
....................  
.................... #if TCP_CONFIGURATION > 0 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................          {TCP_PURPOSE_HTTP_SERVER, TCP_ETH_RAM, STACK_CCS_HTTP2_SERVER_TX_SIZE, STACK_CCS_HTTP2_SERVER_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_SMTP_CLIENT) 
....................          {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, STACK_CCS_SMTP_TX_SIZE, STACK_CCS_SMTP_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_MY_TELNET_SERVER) 
....................          {TCP_PURPOSE_TELNET, TCP_ETH_RAM, STACK_MY_TELNET_SERVER_TX_SIZE, STACK_MY_TELNET_SERVER_RX_SIZE}, 
....................       #endif 
....................    }; 
.................... #else 
....................    #undef TCP_CONFIGURATION 
....................    #define TCP_CONFIGURATION 1 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 250, 250} 
....................    }; 
.................... #endif 
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // Defines how long to wait before a DHCP request times out 
.................... #define DHCP_TIMEOUT            (5ul*TICK_SECOND) //__CCS__ 
....................  
.................... unsigned int32 g_DNSTransactionID;  //__CCS__ 
....................  
.................... // Unique variables per interface 
.................... typedef struct 
.................... { 
.................... 	UDP_SOCKET			hDHCPSocket;	// Handle to DHCP client socket 
.................... 	SM_DHCP				smState;		// DHCP client state machine variable 
.................... 	union 
.................... 	{ 
.................... 	    struct 
.................... 	    { 
.................... 	        unsigned char bIsBound : 1;				// Whether or not DHCP is currently bound 
.................... 	        unsigned char bEvent : 1;				// Indicates to an external module that the DHCP client has been reset, has obtained new parameters via the DHCP client, or has refreshed a lease on existing ones 
.................... 	        unsigned char bOfferReceived : 1;		// Whether or not an offer has been received 
.................... 			unsigned char bDHCPServerDetected : 1;	// Indicates if a DCHP server has been detected 
.................... 			unsigned char bUseUnicastMode : 1;		// Indicates if the  
.................... 	    } bits; 
.................... 	    BYTE val; 
.................... 	} flags; 
.................... 	DWORD 				dwTimer;		// Tick timer value used for triggering future events after a certain wait period. 
.................... 	DWORD				dwLeaseTime;	// DHCP lease time remaining, in seconds 
.................... 	DWORD				dwServerID;		// DHCP Server ID cache 
.................... 	IP_ADDR				tempIPAddress;	// Temporary IP address to use when no DHCP lease 
.................... 	IP_ADDR				tempGateway;	// Temporary gateway to use when no DHCP lease 
.................... 	IP_ADDR				tempMask;		// Temporary mask to use when no DHCP lease 
.................... 	#if defined(STACK_USE_DNS) 
.................... 	IP_ADDR				tempDNS;		// Temporary primary DNS server 
.................... 	IP_ADDR				tempDNS2;		// Temporary secondary DNS server 
.................... 	#endif	 
.................... 	// Indicates which DHCP values are currently valid 
.................... 	union 
.................... 	{ 
.................... 		struct 
.................... 		{ 
.................... 			char IPAddress:1;	// Leased IP address is valid 
.................... 			char Gateway:1;		// Gateway address is valid 
.................... 			char Mask:1;		// Subnet mask is valid 
.................... 			char DNS:1;			// Primary DNS is valid 
.................... 			char DNS2:1;		// Secondary DNS is valid 
.................... 			char HostName:1;	// Host name is valid (not implemented) 
.................... 		} bits; 
.................... 		BYTE val; 
.................... 	} validValues; 
.................... } DHCP_CLIENT_VARS; 
....................  
.................... BOOL DHCPClientInitializedOnce = FALSE; 
....................  
.................... static BYTE _DHCPReceive(void); 
.................... static void _DHCPSend(BYTE messageType, BOOL bRenewing); 
....................  
.................... #if defined (WF_CS_IO) 
.................... extern void SignalDHCPSuccessful(void); 
.................... extern void SetDhcpProgressState(void); 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void LoadState(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Saves the DHCPClient state information structure to the appropriate  
.................... 	location and loads DHCPClient with the state information for the specified  
.................... 	interface. 
....................  
....................   Description: 
.................... 	Saves the DHCPClient state information structure to the appropriate  
.................... 	location and loads DHCPClient with the state information for the specified  
.................... 	interface. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
.................... 	None 
....................  
....................   Remarks: 
....................   	This function does nothing when you only have one physical interface. 
.................... ***************************************************************************/ 
.................... #if NETWORK_INTERFACES > 1 
....................  
.................... static DHCP_CLIENT_VARS	DHCPClients[NETWORK_INTERFACES]; 
.................... static DHCP_CLIENT_VARS	*SelectedDHCPClient; 
.................... #define DHCPClient		(*SelectedDHCPClient) 
.................... #define LoadState(v)	do(SelectedDHCPClient = &DHCPClients[v])while(0) 
....................  
.................... #else 
....................  
.................... static DHCP_CLIENT_VARS DHCPClient; 
.................... #define LoadState(v) 
....................  
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void DHCPInit(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Resets the DHCP client module for the specified interface. 
....................  
....................   Description: 
.................... 	Resets the DHCP client module, giving up any current lease, knowledge of  
.................... 	DHCP servers, etc. for the specified interface. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to initialize DHCP client state variables  
.................... 		for.   If you only have one interface, specify 0x00. 
....................  
....................   Returns: 
.................... 	None 
....................  
....................   Remarks: 
.................... 	This function may be called multiple times throughout the life of the  
.................... 	application, if desired.   
.................... ***************************************************************************/ 
.................... void DHCPInit(BYTE vInterface) 
.................... { 
.................... 	BYTE i; 
.................... 	 
.................... 	// Upon the first call after POR, we must reset all handles to invalid so  
.................... 	// that we don't inadvertently close someone else's handle. 
.................... 	if(!DHCPClientInitializedOnce) 
*
01398:  MOVLB  1
0139A:  BTFSC  x10.4
0139C:  BRA    13B4
.................... 	{ 
.................... 		DHCPClientInitializedOnce = TRUE; 
0139E:  BSF    x10.4
.................... 		for(i = 0; i < NETWORK_INTERFACES; i++) 
013A0:  MOVLB  3
013A2:  CLRF   xCA
013A4:  MOVF   xCA,F
013A6:  BNZ   13B2
.................... 		{ 
.................... 			LoadState(i); 
.................... 			DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
013A8:  MOVLB  1
013AA:  SETF   x42
013AC:  MOVLB  3
013AE:  INCF   xCA,F
013B0:  BRA    13A4
013B2:  MOVLB  1
.................... 		}		 
.................... 	} 
.................... 	 
.................... 	 
.................... 	LoadState(vInterface); 
.................... 	 
.................... 	if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET) 
013B4:  INCFSZ x42,W
013B6:  BRA    13BA
013B8:  BRA    13C8
.................... 	{ 
.................... 		UDPClose(DHCPClient.hDHCPSocket); 
013BA:  MOVFF  142,3CB
013BE:  MOVLB  0
013C0:  CALL   098A
.................... 		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
013C4:  MOVLB  1
013C6:  SETF   x42
.................... 	} 
....................  
.................... 	// Reset state machine and flags to default values 
.................... 	DHCPClient.smState = SM_DHCP_GET_SOCKET; 
013C8:  MOVLW  01
013CA:  MOVWF  x43
.................... 	DHCPClient.flags.val = 0; 
013CC:  CLRF   x44
.................... 	DHCPClient.flags.bits.bUseUnicastMode = TRUE;	// This flag toggles before use, so this statement actually means to start out using broadcast mode. 
013CE:  BSF    x44.4
.................... 	DHCPClient.flags.bits.bEvent = TRUE; 
013D0:  BSF    x44.1
013D2:  MOVLB  0
013D4:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void DHCPDisable(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Disables the DHCP Client for the specified interface. 
....................  
....................   Description: 
.................... 	Disables the DHCP client for the specified interface by sending the state  
.................... 	machine to "SM_DHCP_DISABLED".  If the interface was previously configured  
.................... 	by DHCP, the configuration will continue to be used but the module will no  
.................... 	longer preform any renewals. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to disable the DHCP client on.   If you only  
.................... 		have one interface, specify 0x00. 
....................  
....................   Returns: 
.................... 	None 
....................  
....................   Remarks: 
.................... 	Since the interface continues using its old configuration, it is possible  
.................... 	that the lease may expire and the DHCP server provide the IP to another 
.................... 	client.  The application should replace the current IP address and other 
.................... 	configuration with static information following a call to this function. 
.................... ***************************************************************************/ 
.................... void DHCPDisable(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
....................  
.................... 	if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET) 
013D6:  MOVLB  1
013D8:  INCFSZ x42,W
013DA:  BRA    13DE
013DC:  BRA    13EC
.................... 	{ 
.................... 		UDPClose(DHCPClient.hDHCPSocket); 
013DE:  MOVFF  142,3CB
013E2:  MOVLB  0
013E4:  CALL   098A
.................... 		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
013E8:  MOVLB  1
013EA:  SETF   x42
.................... 	} 
....................  
.................... 	DHCPClient.smState = SM_DHCP_DISABLED; 
013EC:  CLRF   x43
013EE:  MOVLB  0
013F0:  GOTO   154C (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void DHCPEnable(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Enables the DHCP client for the specified interface. 
....................  
....................   Description: 
.................... 	Enables the DHCP client for the specified interface, if it is disabled.   
.................... 	If it is already enabled, nothing is done. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to enable the DHCP client on.   If you only  
.................... 		have one interface, specify 0x00. 
....................  
....................   Returns: 
.................... 	None 
.................... ***************************************************************************/ 
.................... void DHCPEnable(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
....................  
.................... 	if(DHCPClient.smState == SM_DHCP_DISABLED) 
.................... 	{ 
.................... 		DHCPClient.smState = SM_DHCP_GET_SOCKET; 
.................... 		DHCPClient.flags.bits.bIsBound = FALSE; 
.................... 	} 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	BOOL DHCPIsEnabled(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Determins if the DHCP client is enabled on the specified interface. 
....................  
....................   Description: 
.................... 	Determins if the DHCP client is enabled on the specified interface. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to query.   If you only have one interface,  
.................... 		specify 0x00. 
....................  
....................   Returns: 
.................... 	None 
.................... ***************************************************************************/ 
.................... BOOL DHCPIsEnabled(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
.................... 	return DHCPClient.smState != SM_DHCP_DISABLED; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	BOOL DHCPIsBound(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Determins if the DHCP client has an IP address lease on the specified  
.................... 	interface. 
....................  
....................   Description: 
.................... 	Determins if the DHCP client has an IP address lease on the specified  
.................... 	interface. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to query.   If you only have one interface,  
.................... 		specify 0x00. 
....................  
....................   Returns: 
.................... 	TRUE - DHCP client has obtained an IP address lease (and likely other  
.................... 		parameters) and these values are currently being used. 
.................... 	FALSE - No IP address is currently leased 
.................... ***************************************************************************/ 
.................... BOOL DHCPIsBound(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
.................... 	return DHCPClient.flags.bits.bIsBound; 
*
02FC6:  MOVLW  00
02FC8:  MOVLB  1
02FCA:  BTFSC  x44.0
02FCC:  MOVLW  01
02FCE:  MOVWF  01
02FD0:  MOVLB  0
02FD2:  GOTO   6C38 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	BOOL DHCPStateChanged(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Determins if the DHCP client on the specified interface has changed states  
.................... 	or refreshed its IP address lease. 
....................  
....................   Description: 
.................... 	Determins if the DHCP client on the specified interface has changed states  
.................... 	or refreshed its IP address lease.  This function can be used to determine 
.................... 	when to update an LCD or other display whenever the DHCP assigned IP  
.................... 	address has potentially changed. 
.................... 	 
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to query.   If you only have one interface,  
.................... 		specify 0x00. 
....................  
....................   Returns: 
.................... 	TRUE - The IP address lease have been reliquished (due to reinitilization),  
.................... 		obtained (first event), or renewed since the last call to  
.................... 		DHCPStateChanged(). 
.................... 	FALSE - The DHCP client has not detected any changes since the last call to  
.................... 		DHCPStateChanged(). 
.................... ***************************************************************************/ 
.................... BOOL DHCPStateChanged(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
.................... 	if(DHCPClient.flags.bits.bEvent) 
.................... 	{ 
.................... 		DHCPClient.flags.bits.bEvent = 0; 
.................... 		return TRUE; 
.................... 	} 
.................... 	return FALSE; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	BOOL DHCPIsServerDetected(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Determins if the DHCP client on the specified interface has seen a DHCP  
.................... 	server. 
....................  
....................   Description: 
.................... 	Determins if the DHCP client on the specified interface has seen a DHCP  
.................... 	server. 
.................... 	 
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to query.   If you only have one interface,  
.................... 		specify 0x00. 
....................  
....................   Returns: 
.................... 	TRUE - At least one DHCP server is attached to the specified network  
.................... 		interface. 
.................... 	FALSE - No DHCP servers are currently detected on the specified network  
.................... 		interface. 
.................... ***************************************************************************/ 
.................... BOOL DHCPIsServerDetected(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
.................... 	return DHCPClient.flags.bits.bDHCPServerDetected; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void DHCPTask(void) 
....................  
....................   Summary: 
.................... 	Performs periodic DHCP tasks for all interfaces. 
....................  
....................   Description: 
.................... 	This function performs any periodic tasks requied by the DHCP module,  
.................... 	such as sending and receiving messages involved with obtaining and 
.................... 	maintaining a lease. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
.................... 	None 
.................... ***************************************************************************/ 
.................... void DHCPTask(void) 
.................... { 
.................... 	BYTE i; 
.................... 	 
.................... 	for(i = 0; i < NETWORK_INTERFACES; i++) 
*
02A80:  MOVLB  3
02A82:  CLRF   xC9
02A84:  MOVF   xC9,F
02A86:  BTFSS  FD8.2
02A88:  BRA    2F7C
.................... 	{ 
.................... 		LoadState(i); 
.................... 		switch(DHCPClient.smState) 
02A8A:  MOVLB  1
02A8C:  MOVF   x43,W
02A8E:  ADDLW  F3
02A90:  BTFSC  FD8.0
02A92:  BRA    2F76
02A94:  ADDLW  0D
02A96:  MOVLB  0
02A98:  GOTO   2F82
.................... 		{ 
.................... 			case SM_DHCP_DISABLED: 
.................... 				// When the module is disabled, do absolutely nothing 
.................... 				break; 
02A9C:  MOVLB  1
02A9E:  BRA    2F76
.................... 			 
.................... 			case SM_DHCP_GET_SOCKET: 
.................... 				// Open a socket to send and receive broadcast messages on 
.................... 				//DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT); 
.................... 				 
.................... 				DHCPClient.hDHCPSocket = UDPOpenEx(0,UDP_OPEN_SERVER,DHCP_CLIENT_PORT, DHCP_SERVER_PORT); 
02AA0:  MOVLB  3
02AA2:  CLRF   xCD
02AA4:  CLRF   xCC
02AA6:  CLRF   xCB
02AA8:  CLRF   xCA
02AAA:  CLRF   xCE
02AAC:  CLRF   xD0
02AAE:  MOVLW  44
02AB0:  MOVWF  xCF
02AB2:  CLRF   xD2
02AB4:  MOVLW  43
02AB6:  MOVWF  xD1
02AB8:  MOVLB  0
02ABA:  CALL   162A
02ABE:  MOVFF  01,142
.................... 				if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET) 
02AC2:  MOVLB  1
02AC4:  INCFSZ x42,W
02AC6:  BRA    2ACA
.................... 					break; 
02AC8:  BRA    2F76
.................... 	 
.................... 				DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02ACA:  MOVLW  02
02ACC:  MOVWF  x43
02ACE:  MOVLB  0
.................... 				// No break 
.................... 	 
.................... 			case SM_DHCP_SEND_DISCOVERY: 
.................... 				// Assume default IP Lease time of 60 seconds. 
.................... 				// This should be minimum possible to make sure that if the 
.................... 				// server did not specify lease time, we try again after this  
.................... 				// minimum time. 
.................... 				DHCPClient.dwLeaseTime = 60; 
02AD0:  MOVLB  1
02AD2:  CLRF   x4C
02AD4:  CLRF   x4B
02AD6:  CLRF   x4A
02AD8:  MOVLW  3C
02ADA:  MOVWF  x49
.................... 				DHCPClient.validValues.val = 0x00; 
02ADC:  CLRF   x5D
.................... 				DHCPClient.flags.bits.bIsBound = FALSE;	 
02ADE:  BCF    x44.0
.................... 				DHCPClient.flags.bits.bOfferReceived = FALSE; 
02AE0:  BCF    x44.2
.................... 	 
.................... 				// No point in wasting time transmitting a discovery if we are  
.................... 				// unlinked.  No one will see it.   
.................... 				if(!MACIsLinked()) 
02AE2:  MOVLB  0
02AE4:  CALL   160E
02AE8:  MOVF   01,F
02AEA:  BNZ   2AF2
.................... 					break; 
02AEC:  MOVLB  1
02AEE:  BRA    2F76
02AF0:  MOVLB  0
.................... 	 
.................... 				// Ensure transmitter is ready to accept data 
.................... 				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 300u) 
02AF2:  MOVFF  142,3CA
02AF6:  CALL   17EE
02AFA:  MOVFF  02,3CB
02AFE:  MOVFF  01,3CA
02B02:  MOVLB  3
02B04:  MOVF   02,W
02B06:  SUBLW  01
02B08:  BNC   2B18
02B0A:  BNZ   2B12
02B0C:  MOVF   xCA,W
02B0E:  SUBLW  2B
02B10:  BNC   2B18
.................... 					break; 
02B12:  MOVLB  1
02B14:  BRA    2F76
02B16:  MOVLB  3
....................  
.................... 				// Toggle the BOOTP Broadcast flag to ensure compatibility with  
.................... 				// bad DHCP servers that don't know how to handle broadcast  
.................... 				// responses.  This results in the next discovery attempt to be  
.................... 				// made using the opposite mode. 
.................... 				DHCPClient.flags.bits.bUseUnicastMode ^= 1; 
02B18:  CLRF   00
02B1A:  MOVLB  1
02B1C:  BTFSC  x44.4
02B1E:  INCF   00,F
02B20:  MOVLW  01
02B22:  XORWF  00,F
02B24:  BCF    x44.4
02B26:  BTFSC  00.0
02B28:  BSF    x44.4
.................... 	 
.................... 				// Ensure that we transmit to the broadcast IP and MAC addresses 
.................... 				// The UDP Socket remembers who it was last talking to 
.................... 				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remote.remoteNode)); 
02B2A:  MOVF   x42,W
02B2C:  MULLW  17
02B2E:  MOVF   FF3,W
02B30:  MOVLB  3
02B32:  CLRF   xCB
02B34:  MOVWF  xCA
02B36:  MOVLW  57
02B38:  ADDWF  xCA,W
02B3A:  MOVWF  01
02B3C:  MOVLW  00
02B3E:  ADDWFC xCB,W
02B40:  MOVWF  03
02B42:  MOVFF  01,3CC
02B46:  MOVWF  xCD
02B48:  MOVWF  FEA
02B4A:  MOVFF  01,FE9
02B4E:  SETF   00
02B50:  CLRF   02
02B52:  MOVLW  0A
02B54:  MOVWF  01
02B56:  MOVLB  0
02B58:  CALL   0A30
.................... 	 
.................... 				// Send the DHCP Discover broadcast 
.................... 				_DHCPSend(DHCP_DISCOVER_MESSAGE, FALSE); 
02B5C:  MOVLW  01
02B5E:  MOVLB  3
02B60:  MOVWF  xCA
02B62:  CLRF   xCB
02B64:  MOVLB  0
02B66:  CALL   20F6
.................... 	 
.................... 				// Start a timer and begin looking for a response 
.................... 				DHCPClient.dwTimer = TickGet(); 
02B6A:  RCALL  2424
02B6C:  MOVFF  03,148
02B70:  MOVFF  02,147
02B74:  MOVFF  01,146
02B78:  MOVFF  00,145
.................... 				DHCPClient.smState = SM_DHCP_GET_OFFER; 
02B7C:  MOVLW  03
02B7E:  MOVLB  1
02B80:  MOVWF  x43
.................... 				break; 
02B82:  BRA    2F76
.................... 	 
.................... 			case SM_DHCP_GET_OFFER: 
.................... 				// Check to see if a packet has arrived 
.................... 				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) 
02B84:  MOVFF  142,3CA
02B88:  RCALL  24E2
02B8A:  MOVFF  02,3CB
02B8E:  MOVFF  01,3CA
02B92:  MOVLB  3
02B94:  MOVF   xCB,F
02B96:  BNZ   2BFC
02B98:  MOVF   xCA,W
02B9A:  SUBLW  F9
02B9C:  BNC   2BFC
.................... 				{ 
.................... 					// Go back and transmit a new discovery if we didn't get an offer after 2 seconds 
.................... 					if(TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT) 
02B9E:  MOVLB  0
02BA0:  RCALL  2424
02BA2:  MOVFF  03,3CD
02BA6:  MOVFF  02,3CC
02BAA:  MOVFF  01,3CB
02BAE:  MOVFF  00,3CA
02BB2:  MOVLB  1
02BB4:  MOVF   x45,W
02BB6:  MOVLB  3
02BB8:  SUBWF  xCA,F
02BBA:  MOVLB  1
02BBC:  MOVF   x46,W
02BBE:  MOVLB  3
02BC0:  SUBWFB xCB,F
02BC2:  MOVLB  1
02BC4:  MOVF   x47,W
02BC6:  MOVLB  3
02BC8:  SUBWFB xCC,F
02BCA:  MOVLB  1
02BCC:  MOVF   x48,W
02BCE:  MOVLB  3
02BD0:  SUBWFB xCD,F
02BD2:  BNZ   2BEE
02BD4:  MOVF   xCC,W
02BD6:  SUBLW  00
02BD8:  BC    2BF6
02BDA:  XORLW  FF
02BDC:  BNZ   2BEE
02BDE:  MOVF   xCB,W
02BE0:  SUBLW  7C
02BE2:  BC    2BF6
02BE4:  XORLW  FF
02BE6:  BNZ   2BEE
02BE8:  MOVF   xCA,W
02BEA:  SUBLW  76
02BEC:  BC    2BF6
.................... 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02BEE:  MOVLW  02
02BF0:  MOVLB  1
02BF2:  MOVWF  x43
02BF4:  MOVLB  3
.................... 					break; 
02BF6:  MOVLB  1
02BF8:  BRA    2F76
02BFA:  MOVLB  3
.................... 				} 
.................... 	 
.................... 				// Let the DHCP server module know that there is a DHCP server  
.................... 				// on this network 
.................... 				DHCPClient.flags.bits.bDHCPServerDetected = TRUE; 
02BFC:  MOVLB  1
02BFE:  BSF    x44.3
.................... 	 
.................... 				// Check to see if we received an offer 
.................... 				if(_DHCPReceive() != DHCP_OFFER_MESSAGE) 
02C00:  MOVLB  0
02C02:  RCALL  2684
02C04:  MOVF   01,W
02C06:  SUBLW  02
02C08:  BZ    2C10
.................... 					break; 
02C0A:  MOVLB  1
02C0C:  BRA    2F76
02C0E:  MOVLB  0
.................... 	 
.................... 				DHCPClient.smState = SM_DHCP_SEND_REQUEST; 
02C10:  MOVLW  04
02C12:  MOVLB  1
02C14:  MOVWF  x43
02C16:  MOVLB  0
.................... 				// No break 
.................... 	 
.................... 			case SM_DHCP_SEND_REQUEST: 
.................... 				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u) 
02C18:  MOVFF  142,3CA
02C1C:  CALL   17EE
02C20:  MOVFF  02,3CB
02C24:  MOVFF  01,3CA
02C28:  MOVLB  3
02C2A:  MOVF   02,W
02C2C:  SUBLW  01
02C2E:  BNC   2C3E
02C30:  BNZ   2C38
02C32:  MOVF   xCA,W
02C34:  SUBLW  01
02C36:  BNC   2C3E
.................... 					break; 
02C38:  MOVLB  1
02C3A:  BRA    2F76
02C3C:  MOVLB  3
....................  
.................... 				// Ensure that we transmit to the broadcast IP and MAC addresses 
.................... 				// The UDP Socket remembers who it was last talking to, so  
.................... 				// we must set this back to the broadcast address since the  
.................... 				// current socket values are the unicast addresses of the DHCP  
.................... 				// server. 
.................... 				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remote.remoteNode)); 
02C3E:  MOVLB  1
02C40:  MOVF   x42,W
02C42:  MULLW  17
02C44:  MOVF   FF3,W
02C46:  MOVLB  3
02C48:  CLRF   xCB
02C4A:  MOVWF  xCA
02C4C:  MOVLW  57
02C4E:  ADDWF  xCA,W
02C50:  MOVWF  01
02C52:  MOVLW  00
02C54:  ADDWFC xCB,W
02C56:  MOVWF  03
02C58:  MOVFF  01,3CC
02C5C:  MOVWF  xCD
02C5E:  MOVWF  FEA
02C60:  MOVFF  01,FE9
02C64:  SETF   00
02C66:  CLRF   02
02C68:  MOVLW  0A
02C6A:  MOVWF  01
02C6C:  MOVLB  0
02C6E:  CALL   0A30
.................... 	 
.................... 				// Send the DHCP request message 
.................... 				_DHCPSend(DHCP_REQUEST_MESSAGE, FALSE); 
02C72:  MOVLW  03
02C74:  MOVLB  3
02C76:  MOVWF  xCA
02C78:  CLRF   xCB
02C7A:  MOVLB  0
02C7C:  CALL   20F6
.................... 	 
.................... 				// Start a timer and begin looking for a response 
.................... 				DHCPClient.dwTimer = TickGet(); 
02C80:  CALL   2424
02C84:  MOVFF  03,148
02C88:  MOVFF  02,147
02C8C:  MOVFF  01,146
02C90:  MOVFF  00,145
.................... 				DHCPClient.smState = SM_DHCP_GET_REQUEST_ACK; 
02C94:  MOVLW  05
02C96:  MOVLB  1
02C98:  MOVWF  x43
.................... 				break; 
02C9A:  BRA    2F76
.................... 	 
.................... 			case SM_DHCP_GET_REQUEST_ACK: 
.................... 				// Check to see if a packet has arrived 
.................... 				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) 
02C9C:  MOVFF  142,3CA
02CA0:  RCALL  24E2
02CA2:  MOVFF  02,3CB
02CA6:  MOVFF  01,3CA
02CAA:  MOVLB  3
02CAC:  MOVF   xCB,F
02CAE:  BNZ   2D16
02CB0:  MOVF   xCA,W
02CB2:  SUBLW  F9
02CB4:  BNC   2D16
.................... 				{ 
.................... 					// Go back and transmit a new discovery if we didn't get an ACK after 2 seconds 
.................... 					if(TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT) 
02CB6:  MOVLB  0
02CB8:  CALL   2424
02CBC:  MOVFF  03,3CD
02CC0:  MOVFF  02,3CC
02CC4:  MOVFF  01,3CB
02CC8:  MOVFF  00,3CA
02CCC:  MOVLB  1
02CCE:  MOVF   x45,W
02CD0:  MOVLB  3
02CD2:  SUBWF  xCA,F
02CD4:  MOVLB  1
02CD6:  MOVF   x46,W
02CD8:  MOVLB  3
02CDA:  SUBWFB xCB,F
02CDC:  MOVLB  1
02CDE:  MOVF   x47,W
02CE0:  MOVLB  3
02CE2:  SUBWFB xCC,F
02CE4:  MOVLB  1
02CE6:  MOVF   x48,W
02CE8:  MOVLB  3
02CEA:  SUBWFB xCD,F
02CEC:  BNZ   2D08
02CEE:  MOVF   xCC,W
02CF0:  SUBLW  00
02CF2:  BC    2D10
02CF4:  XORLW  FF
02CF6:  BNZ   2D08
02CF8:  MOVF   xCB,W
02CFA:  SUBLW  7C
02CFC:  BC    2D10
02CFE:  XORLW  FF
02D00:  BNZ   2D08
02D02:  MOVF   xCA,W
02D04:  SUBLW  76
02D06:  BC    2D10
.................... 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02D08:  MOVLW  02
02D0A:  MOVLB  1
02D0C:  MOVWF  x43
02D0E:  MOVLB  3
.................... 					break; 
02D10:  MOVLB  1
02D12:  BRA    2F76
02D14:  MOVLB  3
.................... 				} 
.................... 	 
.................... 				// Check to see if we received an offer 
.................... 				switch(_DHCPReceive()) 
02D16:  MOVLB  0
02D18:  RCALL  2684
02D1A:  MOVF   01,W
02D1C:  XORLW  05
02D1E:  BZ    2D26
02D20:  XORLW  03
02D22:  BZ    2D92
02D24:  BRA    2D9A
.................... 				{ 
.................... 					case DHCP_ACK_MESSAGE: 
.................... 						UDPClose(DHCPClient.hDHCPSocket); 
02D26:  MOVFF  142,3CB
02D2A:  CALL   098A
.................... 						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
02D2E:  MOVLB  1
02D30:  SETF   x42
.................... 						DHCPClient.dwTimer = TickGet(); 
02D32:  MOVLB  0
02D34:  CALL   2424
02D38:  MOVFF  03,148
02D3C:  MOVFF  02,147
02D40:  MOVFF  01,146
02D44:  MOVFF  00,145
.................... 						DHCPClient.smState = SM_DHCP_BOUND; 
02D48:  MOVLW  06
02D4A:  MOVLB  1
02D4C:  MOVWF  x43
.................... 						DHCPClient.flags.bits.bEvent = 1; 
02D4E:  BSF    x44.1
.................... 						DHCPClient.flags.bits.bIsBound = TRUE;	 
02D50:  BSF    x44.0
....................  
.................... 						if(DHCPClient.validValues.bits.IPAddress) 
02D52:  BTFSS  x5D.0
02D54:  BRA    2D66
.................... 						{ 
.................... 							AppConfig.MyIPAddr = DHCPClient.tempIPAddress; 
02D56:  MOVFF  154,26
02D5A:  MOVFF  153,25
02D5E:  MOVFF  152,24
02D62:  MOVFF  151,23
.................... 							 
.................... 							#if defined(WF_CS_IO)  
.................... 							    #if defined(STACK_USE_UART ) 
.................... 							        putrsUART("DHCP client successful\r\n"); 
.................... 							    #endif 
....................     							SignalDHCPSuccessful(); 
.................... 							#endif 
.................... 							 
.................... 						}	 
.................... 						if(DHCPClient.validValues.bits.Mask) 
02D66:  BTFSS  x5D.2
02D68:  BRA    2D7A
.................... 							AppConfig.MyMask = DHCPClient.tempMask; 
02D6A:  MOVFF  15C,2A
02D6E:  MOVFF  15B,29
02D72:  MOVFF  15A,28
02D76:  MOVFF  159,27
.................... 						if(DHCPClient.validValues.bits.Gateway) 
02D7A:  BTFSS  x5D.1
02D7C:  BRA    2D8E
.................... 							AppConfig.MyGateway = DHCPClient.tempGateway; 
02D7E:  MOVFF  158,2E
02D82:  MOVFF  157,2D
02D86:  MOVFF  156,2C
02D8A:  MOVFF  155,2B
.................... 						#if defined(STACK_USE_DNS) 
.................... 							if(DHCPClient.validValues.bits.DNS) 
.................... 								AppConfig.PrimaryDNSServer.Val = DHCPClient.tempDNS.Val; 
.................... 							AppConfig.SecondaryDNSServer.Val = 0x00000000ul; 
.................... 							if(DHCPClient.validValues.bits.DNS2) 
.................... 								AppConfig.SecondaryDNSServer.Val = DHCPClient.tempDNS2.Val; 
.................... 						#endif 
.................... 						//if(DHCPClient.validValues.bits.HostName) 
.................... 						//	memcpy(AppConfig.NetBIOSName, (void*)DHCPClient.tempHostName, sizeof(AppConfig.NetBIOSName)); 
.................... 	 
.................... 						break; 
02D8E:  MOVLB  0
02D90:  BRA    2D9A
.................... 	 
.................... 					case DHCP_NAK_MESSAGE: 
.................... 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02D92:  MOVLW  02
02D94:  MOVLB  1
02D96:  MOVWF  x43
.................... 						break; 
02D98:  MOVLB  0
.................... 				} 
.................... 				break; 
02D9A:  MOVLB  1
02D9C:  BRA    2F76
.................... 	 
.................... 			case SM_DHCP_BOUND: 
.................... 				if(TickGet() - DHCPClient.dwTimer < TICK_SECOND) 
02D9E:  CALL   2424
02DA2:  MOVFF  03,3CD
02DA6:  MOVFF  02,3CC
02DAA:  MOVFF  01,3CB
02DAE:  MOVFF  00,3CA
02DB2:  MOVLB  1
02DB4:  MOVF   x45,W
02DB6:  MOVLB  3
02DB8:  SUBWF  xCA,F
02DBA:  MOVLB  1
02DBC:  MOVF   x46,W
02DBE:  MOVLB  3
02DC0:  SUBWFB xCB,F
02DC2:  MOVLB  1
02DC4:  MOVF   x47,W
02DC6:  MOVLB  3
02DC8:  SUBWFB xCC,F
02DCA:  MOVLB  1
02DCC:  MOVF   x48,W
02DCE:  MOVLB  3
02DD0:  SUBWFB xCD,F
02DD2:  BNZ   2DEC
02DD4:  MOVF   xCC,F
02DD6:  BNZ   2DEC
02DD8:  MOVF   xCB,W
02DDA:  SUBLW  4C
02DDC:  BNC   2DEC
02DDE:  BNZ   2DE6
02DE0:  MOVF   xCA,W
02DE2:  SUBLW  4A
02DE4:  BNC   2DEC
.................... 					break; 
02DE6:  MOVLB  1
02DE8:  BRA    2F76
02DEA:  MOVLB  3
.................... 	 
.................... 				// Check to see if our lease is still valid, if so, decrement lease  
.................... 				// time 
.................... 				if(DHCPClient.dwLeaseTime >= 2ul) 
02DEC:  MOVLB  1
02DEE:  MOVF   x4C,F
02DF0:  BNZ   2E00
02DF2:  MOVF   x4B,F
02DF4:  BNZ   2E00
02DF6:  MOVF   x4A,F
02DF8:  BNZ   2E00
02DFA:  MOVF   x49,W
02DFC:  SUBLW  01
02DFE:  BC    2E20
.................... 				{ 
.................... 					DHCPClient.dwTimer += TICK_SECOND; 
02E00:  MOVLW  4B
02E02:  ADDWF  x45,F
02E04:  MOVLW  4C
02E06:  ADDWFC x46,F
02E08:  MOVLW  00
02E0A:  ADDWFC x47,F
02E0C:  ADDWFC x48,F
.................... 					DHCPClient.dwLeaseTime--; 
02E0E:  MOVLW  FF
02E10:  ADDWF  x49,F
02E12:  BTFSS  FD8.0
02E14:  ADDWF  x4A,F
02E16:  BTFSS  FD8.0
02E18:  ADDWF  x4B,F
02E1A:  BTFSS  FD8.0
02E1C:  ADDWF  x4C,F
.................... 					break; 
02E1E:  BRA    2F76
.................... 				} 
.................... 	 
.................... 				// Open a socket to send and receive DHCP messages on 
.................... 				//DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT); 
.................... 				 
.................... 				DHCPClient.hDHCPSocket = UDPOpenEx(0,UDP_OPEN_SERVER,DHCP_CLIENT_PORT, DHCP_SERVER_PORT); 
02E20:  MOVLB  3
02E22:  CLRF   xCD
02E24:  CLRF   xCC
02E26:  CLRF   xCB
02E28:  CLRF   xCA
02E2A:  CLRF   xCE
02E2C:  CLRF   xD0
02E2E:  MOVLW  44
02E30:  MOVWF  xCF
02E32:  CLRF   xD2
02E34:  MOVLW  43
02E36:  MOVWF  xD1
02E38:  MOVLB  0
02E3A:  CALL   162A
02E3E:  MOVFF  01,142
.................... 				if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET) 
02E42:  MOVLB  1
02E44:  INCFSZ x42,W
02E46:  BRA    2E4A
.................... 					break; 
02E48:  BRA    2F76
.................... 	 
.................... 				DHCPClient.smState = SM_DHCP_SEND_RENEW; 
02E4A:  MOVLW  07
02E4C:  MOVWF  x43
02E4E:  MOVLB  0
.................... 				// No break 
.................... 	 
.................... 			case SM_DHCP_SEND_RENEW: 
.................... 			case SM_DHCP_SEND_RENEW2: 
.................... 			case SM_DHCP_SEND_RENEW3: 
.................... 				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u) 
02E50:  MOVFF  142,3CA
02E54:  CALL   17EE
02E58:  MOVFF  02,3CB
02E5C:  MOVFF  01,3CA
02E60:  MOVLB  3
02E62:  MOVF   02,W
02E64:  SUBLW  01
02E66:  BNC   2E76
02E68:  BNZ   2E70
02E6A:  MOVF   xCA,W
02E6C:  SUBLW  01
02E6E:  BNC   2E76
.................... 					break; 
02E70:  MOVLB  1
02E72:  BRA    2F76
02E74:  MOVLB  3
....................  
....................                                 #if defined(WF_CS_IO) 
....................                                     SetDhcpProgressState(); 
....................                                 #endif 
.................... 				// Send the DHCP request message 
.................... 				_DHCPSend(DHCP_REQUEST_MESSAGE, TRUE); 
02E76:  MOVLW  03
02E78:  MOVWF  xCA
02E7A:  MOVLW  01
02E7C:  MOVWF  xCB
02E7E:  MOVLB  0
02E80:  CALL   20F6
.................... 				DHCPClient.flags.bits.bOfferReceived = FALSE; 
02E84:  MOVLB  1
02E86:  BCF    x44.2
.................... 	 
.................... 				// Start a timer and begin looking for a response 
.................... 				DHCPClient.dwTimer = TickGet(); 
02E88:  MOVLB  0
02E8A:  CALL   2424
02E8E:  MOVFF  03,148
02E92:  MOVFF  02,147
02E96:  MOVFF  01,146
02E9A:  MOVFF  00,145
.................... 				DHCPClient.smState++; 
02E9E:  MOVLB  1
02EA0:  INCF   x43,F
.................... 				break; 
02EA2:  BRA    2F76
.................... 	 
.................... 			case SM_DHCP_GET_RENEW_ACK: 
.................... 			case SM_DHCP_GET_RENEW_ACK2: 
.................... 			case SM_DHCP_GET_RENEW_ACK3: 
.................... 				// Check to see if a packet has arrived 
.................... 				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) 
02EA4:  MOVFF  142,3CA
02EA8:  CALL   24E2
02EAC:  MOVFF  02,3CB
02EB0:  MOVFF  01,3CA
02EB4:  MOVLB  3
02EB6:  MOVF   xCB,F
02EB8:  BNZ   2F28
02EBA:  MOVF   xCA,W
02EBC:  SUBLW  F9
02EBE:  BNC   2F28
.................... 				{ 
.................... 					// Go back and transmit a new discovery if we didn't get an ACK after 2 seconds 
.................... 					if(TickGet() - DHCPClient.dwTimer >=  DHCP_TIMEOUT) 
02EC0:  MOVLB  0
02EC2:  CALL   2424
02EC6:  MOVFF  03,3CD
02ECA:  MOVFF  02,3CC
02ECE:  MOVFF  01,3CB
02ED2:  MOVFF  00,3CA
02ED6:  MOVLB  1
02ED8:  MOVF   x45,W
02EDA:  MOVLB  3
02EDC:  SUBWF  xCA,F
02EDE:  MOVLB  1
02EE0:  MOVF   x46,W
02EE2:  MOVLB  3
02EE4:  SUBWFB xCB,F
02EE6:  MOVLB  1
02EE8:  MOVF   x47,W
02EEA:  MOVLB  3
02EEC:  SUBWFB xCC,F
02EEE:  MOVLB  1
02EF0:  MOVF   x48,W
02EF2:  MOVLB  3
02EF4:  SUBWFB xCD,F
02EF6:  BNZ   2F12
02EF8:  MOVF   xCC,W
02EFA:  SUBLW  00
02EFC:  BC    2F22
02EFE:  XORLW  FF
02F00:  BNZ   2F12
02F02:  MOVF   xCB,W
02F04:  SUBLW  7C
02F06:  BC    2F22
02F08:  XORLW  FF
02F0A:  BNZ   2F12
02F0C:  MOVF   xCA,W
02F0E:  SUBLW  76
02F10:  BC    2F22
.................... 					{ 
.................... 						if(++DHCPClient.smState > SM_DHCP_GET_RENEW_ACK3) 
02F12:  MOVLB  1
02F14:  INCF   x43,F
02F16:  MOVF   x43,W
02F18:  SUBLW  0C
02F1A:  BC    2F20
.................... 							DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02F1C:  MOVLW  02
02F1E:  MOVWF  x43
02F20:  MOVLB  3
.................... 					} 
.................... 					break; 
02F22:  MOVLB  1
02F24:  BRA    2F76
02F26:  MOVLB  3
.................... 				} 
.................... 	 
.................... 				// Check to see if we received an offer 
.................... 				switch(_DHCPReceive()) 
02F28:  MOVLB  0
02F2A:  CALL   2684
02F2E:  MOVF   01,W
02F30:  XORLW  05
02F32:  BZ    2F3A
02F34:  XORLW  03
02F36:  BZ    2F68
02F38:  BRA    2F70
.................... 				{ 
.................... 					case DHCP_ACK_MESSAGE: 
.................... 						UDPClose(DHCPClient.hDHCPSocket); 
02F3A:  MOVFF  142,3CB
02F3E:  CALL   098A
.................... 						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
02F42:  MOVLB  1
02F44:  SETF   x42
.................... 						DHCPClient.dwTimer = TickGet(); 
02F46:  MOVLB  0
02F48:  CALL   2424
02F4C:  MOVFF  03,148
02F50:  MOVFF  02,147
02F54:  MOVFF  01,146
02F58:  MOVFF  00,145
.................... 						DHCPClient.smState = SM_DHCP_BOUND; 
02F5C:  MOVLW  06
02F5E:  MOVLB  1
02F60:  MOVWF  x43
.................... 						DHCPClient.flags.bits.bEvent = 1; 
02F62:  BSF    x44.1
.................... 						break; 
02F64:  MOVLB  0
02F66:  BRA    2F70
.................... 		 
.................... 					case DHCP_NAK_MESSAGE: 
.................... 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02F68:  MOVLW  02
02F6A:  MOVLB  1
02F6C:  MOVWF  x43
.................... 						break; 
02F6E:  MOVLB  0
.................... 				} 
.................... 				break; 
02F70:  MOVLB  1
02F72:  BRA    2F76
02F74:  MOVLB  1
.................... 		} 
02F76:  MOVLB  3
02F78:  INCF   xC9,F
02F7A:  BRA    2A84
.................... 	} 
02F7C:  MOVLB  0
02F7E:  GOTO   6C2E (RETURN)
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
.................... Function: 
....................   void _DHCPReceive(void) 
....................  
.................... Description: 
....................   Receives and parses a DHCP message. 
....................  
.................... Precondition: 
....................   A DHCP message is waiting in the UDP buffer. 
....................  
.................... Parameters: 
....................   None 
....................  
.................... Returns: 
....................   One of the DCHP_TYPE* contants. 
.................... ***************************************************************************/ 
.................... static BYTE _DHCPReceive(void) 
.................... { 
.................... 	/********************************************************************* 
.................... 	DHCP PACKET FORMAT AS PER RFC 1541 
....................  
.................... 	0                   1                   2                   3 
.................... 	0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
.................... 	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
.................... 	|     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    | 
.................... 	+---------------+---------------+---------------+---------------+ 
.................... 	|                            xid (4)                            | 
.................... 	+-------------------------------+-------------------------------+ 
.................... 	|           secs (2)            |           flags (2)           | 
.................... 	+-------------------------------+-------------------------------+ 
.................... 	|                          ciaddr  (4)                          | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                          yiaddr  (4)                          | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                          siaddr  (4)                          | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                          giaddr  (4)                          | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                                                               | 
.................... 	|                          chaddr  (16)                         | 
.................... 	|                                                               | 
.................... 	|                                                               | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                                                               | 
.................... 	|                          sname   (64)                         | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                                                               | 
.................... 	|                          file    (128)                        | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                                                               | 
.................... 	|                          options (312)                        | 
.................... 	+---------------------------------------------------------------+ 
....................  
.................... 	********************************************************************/ 
.................... 	BYTE v; 
.................... 	BYTE i, j; 
.................... 	BYTE type; 
.................... 	BOOL lbDone; 
.................... 	DWORD tempServerID; 
....................    unsigned int32 xid;  // __CCS__ add g_DNSTransactionID 
....................  
....................  
.................... 	// Assume unknown message until proven otherwise. 
.................... 	type = DHCP_UNKNOWN_MESSAGE; 
*
02684:  MOVLB  3
02686:  CLRF   xCD
....................  
.................... 	UDPGet(&v);                             // op 
02688:  MOVLW  03
0268A:  MOVWF  xDA
0268C:  MOVLW  CA
0268E:  MOVWF  xD9
02690:  MOVLB  0
02692:  RCALL  2528
....................  
.................... 	// Make sure this is BOOT_REPLY. 
.................... 	if ( v == BOOT_REPLY ) 
02694:  MOVLB  3
02696:  MOVF   xCA,W
02698:  SUBLW  02
0269A:  BTFSS  FD8.2
0269C:  BRA    2A1C
.................... 	{ 
....................       // __CCS__ add g_DNSTransactionID 
....................       // get xid 
....................       UDPSetRxBuffer(4); 
0269E:  CLRF   xD8
026A0:  MOVLW  04
026A2:  MOVWF  xD7
026A4:  MOVLB  0
026A6:  RCALL  24BE
....................       UDPGetArray(&xid, 4); 
026A8:  MOVLW  03
026AA:  MOVLB  3
026AC:  MOVWF  xDA
026AE:  MOVLW  D3
026B0:  MOVWF  xD9
026B2:  CLRF   xDC
026B4:  MOVLW  04
026B6:  MOVWF  xDB
026B8:  MOVLB  0
026BA:  RCALL  2576
....................       if (xid != g_DNSTransactionID) 
026BC:  MOVLB  1
026BE:  MOVF   x3E,W
026C0:  MOVLB  3
026C2:  SUBWF  xD3,W
026C4:  BNZ   26E4
026C6:  MOVLB  1
026C8:  MOVF   x3F,W
026CA:  MOVLB  3
026CC:  SUBWF  xD4,W
026CE:  BNZ   26E4
026D0:  MOVLB  1
026D2:  MOVF   x40,W
026D4:  MOVLB  3
026D6:  SUBWF  xD5,W
026D8:  BNZ   26E4
026DA:  MOVLB  1
026DC:  MOVF   x41,W
026DE:  MOVLB  3
026E0:  SUBWF  xD6,W
026E2:  BZ    26E6
....................          goto UDPInvalid; 
026E4:  BRA    2A72
....................           
.................... 		// Jump to chaddr field (Client Hardware Address -- our MAC address for  
.................... 		// Ethernet and WiFi networks) and verify that this message is directed  
.................... 		// to us before doing any other processing. 
.................... 		UDPSetRxBuffer(28);		// chaddr field is at offset 28 in the UDP packet payload -- see DHCP packet format above 
026E6:  CLRF   xD8
026E8:  MOVLW  1C
026EA:  MOVWF  xD7
026EC:  MOVLB  0
026EE:  RCALL  24BE
.................... 		for ( i = 0; i < 6u; i++ ) 
026F0:  MOVLB  3
026F2:  CLRF   xCB
026F4:  MOVF   xCB,W
026F6:  SUBLW  05
026F8:  BNC   2722
.................... 		{ 
.................... 			UDPGet(&v); 
026FA:  MOVLW  03
026FC:  MOVWF  xDA
026FE:  MOVLW  CA
02700:  MOVWF  xD9
02702:  MOVLB  0
02704:  RCALL  2528
.................... 			if ( v != AppConfig.MyMACAddr.v[i]) 
02706:  CLRF   03
02708:  MOVLB  3
0270A:  MOVF   xCB,W
0270C:  ADDLW  50
0270E:  MOVWF  FE9
02710:  MOVLW  00
02712:  ADDWFC 03,W
02714:  MOVWF  FEA
02716:  MOVF   FEF,W
02718:  SUBWF  xCA,W
0271A:  BZ    271E
.................... 				goto UDPInvalid; 
0271C:  BRA    2A72
0271E:  INCF   xCB,F
02720:  BRA    26F4
.................... 		} 
....................  
.................... 		// Check to see if this is the first offer.  If it is, record its  
.................... 		// yiaddr value ("Your (client) IP address") so that we can REQUEST to  
.................... 		// use it later. 
.................... 		if(!DHCPClient.flags.bits.bOfferReceived) 
02722:  MOVLB  1
02724:  BTFSC  x44.2
02726:  BRA    2752
.................... 		{ 
.................... 			UDPSetRxBuffer(16); 
02728:  MOVLB  3
0272A:  CLRF   xD8
0272C:  MOVLW  10
0272E:  MOVWF  xD7
02730:  MOVLB  0
02732:  RCALL  24BE
.................... 			UDPGetArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress)); 
02734:  MOVLW  01
02736:  MOVLB  3
02738:  MOVWF  xD8
0273A:  MOVLW  51
0273C:  MOVWF  xD7
0273E:  MOVFF  3D8,3DA
02742:  MOVWF  xD9
02744:  CLRF   xDC
02746:  MOVLW  04
02748:  MOVWF  xDB
0274A:  MOVLB  0
0274C:  RCALL  2576
.................... 			DHCPClient.validValues.bits.IPAddress = 1; 
0274E:  MOVLB  1
02750:  BSF    x5D.0
.................... 		} 
....................  
.................... 		// Jump to DHCP options (ignore htype, hlen, hops, xid, secs, flags,  
.................... 		// ciaddr, siaddr, giaddr, padding part of chaddr, sname, file, magic  
.................... 		// cookie fields) 
.................... 		UDPSetRxBuffer(240); 
02752:  MOVLB  3
02754:  CLRF   xD8
02756:  MOVLW  F0
02758:  MOVWF  xD7
0275A:  MOVLB  0
0275C:  RCALL  24BE
....................  
.................... 		lbDone = FALSE; 
0275E:  MOVLB  3
02760:  BCF    xCE.0
.................... 		do 
.................... 		{ 
.................... 			// Get the Option number 
.................... 			// Break out eventually in case if this is a malformed  
.................... 			// DHCP message, ie: missing DHCP_END_OPTION marker 
.................... 			if(!UDPGet(&v)) 
02762:  MOVLW  03
02764:  MOVWF  xDA
02766:  MOVLW  CA
02768:  MOVWF  xD9
0276A:  MOVLB  0
0276C:  RCALL  2528
0276E:  MOVF   01,F
02770:  BNZ   277A
.................... 			{ 
.................... 				lbDone = TRUE; 
02772:  MOVLB  3
02774:  BSF    xCE.0
.................... 				break; 
02776:  BRA    2A1C
02778:  MOVLB  0
.................... 			} 
....................  
.................... 			switch(v) 
0277A:  MOVLB  3
0277C:  MOVF   xCA,W
0277E:  XORLW  35
02780:  MOVLB  0
02782:  BZ    27A0
02784:  XORLW  34
02786:  BZ    27E2
02788:  XORLW  02
0278A:  BZ    2846
0278C:  XORLW  35
0278E:  BTFSC  FD8.2
02790:  BRA    28C6
02792:  XORLW  C9
02794:  BTFSC  FD8.2
02796:  BRA    291E
02798:  XORLW  CC
0279A:  BTFSC  FD8.2
0279C:  BRA    2926
0279E:  BRA    29EC
.................... 			{ 
.................... 				case DHCP_MESSAGE_TYPE: 
.................... 					UDPGet(&v);                         // Skip len 
027A0:  MOVLW  03
027A2:  MOVLB  3
027A4:  MOVWF  xDA
027A6:  MOVLW  CA
027A8:  MOVWF  xD9
027AA:  MOVLB  0
027AC:  RCALL  2528
.................... 					// Len must be 1. 
.................... 					if ( v == 1u ) 
027AE:  MOVLB  3
027B0:  DECFSZ xCA,W
027B2:  BRA    27DC
.................... 					{ 
.................... 						UDPGet(&type);                  // Get type 
027B4:  MOVLW  03
027B6:  MOVWF  xDA
027B8:  MOVLW  CD
027BA:  MOVWF  xD9
027BC:  MOVLB  0
027BE:  RCALL  2528
....................  
.................... 						// Throw away the packet if we know we don't need it (ie: another offer when we already have one) 
.................... 						if(DHCPClient.flags.bits.bOfferReceived && (type == DHCP_OFFER_MESSAGE)) 
027C0:  MOVLB  1
027C2:  BTFSS  x44.2
027C4:  BRA    27D8
027C6:  MOVLB  3
027C8:  MOVF   xCD,W
027CA:  SUBLW  02
027CC:  BTFSC  FD8.2
027CE:  BRA    27D4
027D0:  MOVLB  1
027D2:  BRA    27D8
.................... 						{ 
.................... 							goto UDPInvalid; 
027D4:  BRA    2A72
027D6:  MOVLB  1
.................... 						} 
.................... 					} 
027D8:  BRA    27E0
027DA:  MOVLB  3
.................... 					else 
.................... 						goto UDPInvalid; 
027DC:  BRA    2A72
027DE:  MOVLB  1
.................... 					break; 
027E0:  BRA    2A16
....................  
.................... 				case DHCP_SUBNET_MASK: 
.................... 					UDPGet(&v);                     // Skip len 
027E2:  MOVLW  03
027E4:  MOVLB  3
027E6:  MOVWF  xDA
027E8:  MOVLW  CA
027EA:  MOVWF  xD9
027EC:  MOVLB  0
027EE:  RCALL  2528
.................... 					// Len must be 4. 
.................... 					if ( v == 4u ) 
027F0:  MOVLB  3
027F2:  MOVF   xCA,W
027F4:  SUBLW  04
027F6:  BNZ   2840
.................... 					{ 
.................... 						// Check to see if this is the first offer 
.................... 						if(DHCPClient.flags.bits.bOfferReceived) 
027F8:  MOVLB  1
027FA:  BTFSS  x44.2
027FC:  BRA    281E
.................... 						{ 
.................... 							// Discard offered IP mask, we already have an offer 
.................... 							for ( i = 0; i < 4u; i++ ) 
027FE:  MOVLB  3
02800:  CLRF   xCB
02802:  MOVF   xCB,W
02804:  SUBLW  03
02806:  BNC   281A
.................... 								UDPGet(&v); 
02808:  MOVLW  03
0280A:  MOVWF  xDA
0280C:  MOVLW  CA
0280E:  MOVWF  xD9
02810:  MOVLB  0
02812:  RCALL  2528
02814:  MOVLB  3
02816:  INCF   xCB,F
02818:  BRA    2802
.................... 						} 
0281A:  BRA    283E
0281C:  MOVLB  1
.................... 						else 
.................... 						{ 
.................... 							UDPGetArray((BYTE*)&DHCPClient.tempMask, sizeof(DHCPClient.tempMask)); 
0281E:  MOVLW  01
02820:  MOVLB  3
02822:  MOVWF  xD8
02824:  MOVLW  59
02826:  MOVWF  xD7
02828:  MOVFF  3D8,3DA
0282C:  MOVWF  xD9
0282E:  CLRF   xDC
02830:  MOVLW  04
02832:  MOVWF  xDB
02834:  MOVLB  0
02836:  RCALL  2576
.................... 							DHCPClient.validValues.bits.Mask = 1; 
02838:  MOVLB  1
0283A:  BSF    x5D.2
0283C:  MOVLB  3
.................... 						} 
.................... 					} 
0283E:  BRA    2842
.................... 					else 
.................... 						goto UDPInvalid; 
02840:  BRA    2A72
.................... 					break; 
02842:  MOVLB  1
02844:  BRA    2A16
....................  
.................... 				case DHCP_ROUTER: 
.................... 					UDPGet(&j); 
02846:  MOVLW  03
02848:  MOVLB  3
0284A:  MOVWF  xDA
0284C:  MOVLW  CC
0284E:  MOVWF  xD9
02850:  MOVLB  0
02852:  RCALL  2528
.................... 					// Len must be >= 4. 
.................... 					if ( j >= 4u ) 
02854:  MOVLB  3
02856:  MOVF   xCC,W
02858:  SUBLW  03
0285A:  BC    28A4
.................... 					{ 
.................... 						// Check to see if this is the first offer 
.................... 						if(DHCPClient.flags.bits.bOfferReceived) 
0285C:  MOVLB  1
0285E:  BTFSS  x44.2
02860:  BRA    2882
.................... 						{ 
.................... 							// Discard offered Gateway address, we already have an offer 
.................... 							for ( i = 0; i < 4u; i++ ) 
02862:  MOVLB  3
02864:  CLRF   xCB
02866:  MOVF   xCB,W
02868:  SUBLW  03
0286A:  BNC   287E
.................... 								UDPGet(&v); 
0286C:  MOVLW  03
0286E:  MOVWF  xDA
02870:  MOVLW  CA
02872:  MOVWF  xD9
02874:  MOVLB  0
02876:  RCALL  2528
02878:  MOVLB  3
0287A:  INCF   xCB,F
0287C:  BRA    2866
.................... 						} 
0287E:  BRA    28A2
02880:  MOVLB  1
.................... 						else 
.................... 						{ 
.................... 							UDPGetArray((BYTE*)&DHCPClient.tempGateway, sizeof(DHCPClient.tempGateway)); 
02882:  MOVLW  01
02884:  MOVLB  3
02886:  MOVWF  xD8
02888:  MOVLW  55
0288A:  MOVWF  xD7
0288C:  MOVFF  3D8,3DA
02890:  MOVWF  xD9
02892:  CLRF   xDC
02894:  MOVLW  04
02896:  MOVWF  xDB
02898:  MOVLB  0
0289A:  RCALL  2576
.................... 							DHCPClient.validValues.bits.Gateway = 1; 
0289C:  MOVLB  1
0289E:  BSF    x5D.1
028A0:  MOVLB  3
.................... 						} 
.................... 					} 
028A2:  BRA    28A6
.................... 					else 
.................... 						goto UDPInvalid; 
028A4:  BRA    2A72
....................  
.................... 					// Discard any other router addresses. 
.................... 					j -= 4; 
028A6:  MOVLW  04
028A8:  SUBWF  xCC,F
.................... 					while(j--) 
028AA:  MOVF   xCC,W
028AC:  DECF   xCC,F
028AE:  XORLW  00
028B0:  BZ    28C2
.................... 						UDPGet(&v); 
028B2:  MOVLW  03
028B4:  MOVWF  xDA
028B6:  MOVLW  CA
028B8:  MOVWF  xD9
028BA:  MOVLB  0
028BC:  RCALL  2528
028BE:  MOVLB  3
028C0:  BRA    28AA
.................... 					break; 
028C2:  MOVLB  1
028C4:  BRA    2A16
....................  
.................... 				#if defined(STACK_USE_DNS) 
.................... 				case DHCP_DNS: 
.................... 					UDPGet(&j); 
.................... 					// Len must be >= 4. 
.................... 					if(j < 4u) 
.................... 						goto UDPInvalid; 
....................  
.................... 					// Check to see if this is the first offer 
.................... 					if(!DHCPClient.flags.bits.bOfferReceived) 
.................... 					{ 
.................... 						UDPGetArray((BYTE*)&DHCPClient.tempDNS, sizeof(DHCPClient.tempDNS)); 
.................... 						DHCPClient.validValues.bits.DNS = 1; 
.................... 						j -= 4; 
.................... 					} 
....................  
.................... 					// Len must be >= 4 for a secondary DNS server address 
.................... 					if(j >= 4u) 
.................... 					{ 
.................... 						// Check to see if this is the first offer 
.................... 						if(!DHCPClient.flags.bits.bOfferReceived) 
.................... 						{ 
.................... 							UDPGetArray((BYTE*)&DHCPClient.tempDNS2, sizeof(DHCPClient.tempDNS2)); 
.................... 							DHCPClient.validValues.bits.DNS2 = 1; 
.................... 							j -= 4; 
.................... 						} 
.................... 					} 
....................  
.................... 					// Discard any other DNS server addresses 
.................... 					while(j--) 
.................... 						UDPGet(&v); 
.................... 					break; 
.................... 				#endif 
....................  
.................... 					//            case DHCP_HOST_NAME: 
.................... 					//                UDPGet(&j); 
.................... 					//                // Len must be >= 4. 
.................... 					//                if(j < 1u) 
.................... 					//					goto UDPInvalid; 
.................... 					// 
.................... 					//				// Check to see if this is the first offer 
.................... 					//				if(DHCPFlags.bits.bOfferReceived) 
.................... 					//				{ 
.................... 					//			        // Discard offered host name, we already have an offer 
.................... 					//	                while(j--) 
.................... 					//	                    UDPGet(&v); 
.................... 					//				} 
.................... 					//				else 
.................... 					//				{ 
.................... 					//					for(i = 0; j, i < sizeof(tempHostName); i++, j--) 
.................... 					//					{ 
.................... 					//						UDPGet(&tempHostName[i]); 
.................... 					//					} 
.................... 					//					while(j--) 
.................... 					//					{ 
.................... 					//						UDPGet(&v); 
.................... 					//					} 
.................... 					//					ValidValues.bits.HostName = 1; 
.................... 					//				} 
.................... 					// 
.................... 					//                break; 
....................  
.................... 				case DHCP_SERVER_IDENTIFIER: 
.................... 					UDPGet(&v);                         // Get len 
028C6:  MOVLW  03
028C8:  MOVLB  3
028CA:  MOVWF  xDA
028CC:  MOVLW  CA
028CE:  MOVWF  xD9
028D0:  MOVLB  0
028D2:  RCALL  2528
.................... 					// Len must be 4. 
.................... 					if ( v == 4u ) 
028D4:  MOVLB  3
028D6:  MOVF   xCA,W
028D8:  SUBLW  04
028DA:  BNZ   2916
.................... 					{ 
.................... 						UDPGet(&(((BYTE*)&tempServerID)[3]));   // Get the id 
028DC:  MOVLW  03
028DE:  MOVWF  xDA
028E0:  MOVLW  D2
028E2:  MOVWF  xD9
028E4:  MOVLB  0
028E6:  RCALL  2528
.................... 						UDPGet(&(((BYTE*)&tempServerID)[2])); 
028E8:  MOVLW  03
028EA:  MOVLB  3
028EC:  MOVWF  xDA
028EE:  MOVLW  D1
028F0:  MOVWF  xD9
028F2:  MOVLB  0
028F4:  RCALL  2528
.................... 						UDPGet(&(((BYTE*)&tempServerID)[1])); 
028F6:  MOVLW  03
028F8:  MOVLB  3
028FA:  MOVWF  xDA
028FC:  MOVLW  D0
028FE:  MOVWF  xD9
02900:  MOVLB  0
02902:  RCALL  2528
.................... 						UDPGet(&(((BYTE*)&tempServerID)[0])); 
02904:  MOVLW  03
02906:  MOVLB  3
02908:  MOVWF  xDA
0290A:  MOVLW  CF
0290C:  MOVWF  xD9
0290E:  MOVLB  0
02910:  RCALL  2528
....................                   #warning this wasn't working with old compilers 
.................... 					} 
02912:  BRA    291A
02914:  MOVLB  3
.................... 					else 
.................... 						goto UDPInvalid; 
02916:  BRA    2A72
02918:  MOVLB  0
.................... 					break; 
0291A:  MOVLB  1
0291C:  BRA    2A16
....................  
.................... 				case DHCP_END_OPTION: 
.................... 					lbDone = TRUE; 
0291E:  MOVLB  3
02920:  BSF    xCE.0
.................... 					break; 
02922:  MOVLB  1
02924:  BRA    2A16
....................  
.................... 				case DHCP_IP_LEASE_TIME: 
.................... 					UDPGet(&v);                         // Get len 
02926:  MOVLW  03
02928:  MOVLB  3
0292A:  MOVWF  xDA
0292C:  MOVLW  CA
0292E:  MOVWF  xD9
02930:  MOVLB  0
02932:  RCALL  2528
.................... 					// Len must be 4. 
.................... 					if ( v == 4u ) 
02934:  MOVLB  3
02936:  MOVF   xCA,W
02938:  SUBLW  04
0293A:  BNZ   29E4
.................... 					{ 
.................... 						// Check to see if this is the first offer 
.................... 						if(DHCPClient.flags.bits.bOfferReceived) 
0293C:  MOVLB  1
0293E:  BTFSS  x44.2
02940:  BRA    2962
.................... 						{ 
.................... 							// Discard offered lease time, we already have an offer 
.................... 							for ( i = 0; i < 4u; i++ ) 
02942:  MOVLB  3
02944:  CLRF   xCB
02946:  MOVF   xCB,W
02948:  SUBLW  03
0294A:  BNC   295E
.................... 								UDPGet(&v); 
0294C:  MOVLW  03
0294E:  MOVWF  xDA
02950:  MOVLW  CA
02952:  MOVWF  xD9
02954:  MOVLB  0
02956:  RCALL  2528
02958:  MOVLB  3
0295A:  INCF   xCB,F
0295C:  BRA    2946
.................... 						} 
0295E:  BRA    29E2
02960:  MOVLB  1
.................... 						else 
.................... 						{ 
.................... 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[3])); 
02962:  MOVLW  01
02964:  MOVLB  3
02966:  MOVWF  xDA
02968:  MOVLW  4C
0296A:  MOVWF  xD9
0296C:  MOVLB  0
0296E:  RCALL  2528
.................... 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[2])); 
02970:  MOVLW  01
02972:  MOVLB  3
02974:  MOVWF  xDA
02976:  MOVLW  4B
02978:  MOVWF  xD9
0297A:  MOVLB  0
0297C:  RCALL  2528
.................... 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[1])); 
0297E:  MOVLW  01
02980:  MOVLB  3
02982:  MOVWF  xDA
02984:  MOVLW  4A
02986:  MOVWF  xD9
02988:  MOVLB  0
0298A:  RCALL  2528
.................... 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[0])); 
0298C:  MOVLW  01
0298E:  MOVLB  3
02990:  MOVWF  xDA
02992:  MOVLW  49
02994:  MOVWF  xD9
02996:  MOVLB  0
02998:  RCALL  2528
....................                      #warning this wasn't working with old compilers 
....................  
.................... 							// In case if our clock is not as accurate as the remote  
.................... 							// DHCP server's clock, let's treat the lease time as only  
.................... 							// 96.875% of the value given 
.................... 							DHCPClient.dwLeaseTime -= DHCPClient.dwLeaseTime>>5; 
0299A:  MOVLB  1
0299C:  RRCF   x4C,W
0299E:  MOVWF  03
029A0:  RRCF   x4B,W
029A2:  MOVWF  02
029A4:  RRCF   x4A,W
029A6:  MOVWF  01
029A8:  RRCF   x49,W
029AA:  MOVWF  00
029AC:  RRCF   03,F
029AE:  RRCF   02,F
029B0:  RRCF   01,F
029B2:  RRCF   00,F
029B4:  RRCF   03,F
029B6:  RRCF   02,F
029B8:  RRCF   01,F
029BA:  RRCF   00,F
029BC:  RRCF   03,F
029BE:  RRCF   02,F
029C0:  RRCF   01,F
029C2:  RRCF   00,F
029C4:  RRCF   03,F
029C6:  RRCF   02,F
029C8:  RRCF   01,F
029CA:  RRCF   00,F
029CC:  MOVLW  07
029CE:  ANDWF  03,F
029D0:  MOVF   00,W
029D2:  SUBWF  x49,F
029D4:  MOVF   01,W
029D6:  SUBWFB x4A,F
029D8:  MOVF   02,W
029DA:  SUBWFB x4B,F
029DC:  MOVF   03,W
029DE:  SUBWFB x4C,F
029E0:  MOVLB  3
.................... 						} 
.................... 					} 
029E2:  BRA    29E6
.................... 					else 
.................... 						goto UDPInvalid; 
029E4:  BRA    2A72
.................... 					break; 
029E6:  MOVLB  1
029E8:  BRA    2A16
029EA:  MOVLB  0
....................  
.................... 				default: 
.................... 					// Ignore all unsupport tags. 
.................... 					UDPGet(&j);                     // Get option len 
029EC:  MOVLW  03
029EE:  MOVLB  3
029F0:  MOVWF  xDA
029F2:  MOVLW  CC
029F4:  MOVWF  xD9
029F6:  MOVLB  0
029F8:  RCALL  2528
.................... 					while( j-- )                    // Ignore option values 
029FA:  MOVLB  3
029FC:  MOVF   xCC,W
029FE:  DECF   xCC,F
02A00:  XORLW  00
02A02:  BZ    2A14
.................... 						UDPGet(&v); 
02A04:  MOVLW  03
02A06:  MOVWF  xDA
02A08:  MOVLW  CA
02A0A:  MOVWF  xD9
02A0C:  MOVLB  0
02A0E:  RCALL  2528
02A10:  BRA    29FA
02A12:  MOVLB  3
02A14:  MOVLB  1
.................... 			} 
.................... 		} while( !lbDone ); 
02A16:  MOVLB  3
02A18:  BTFSS  xCE.0
02A1A:  BRA    2762
.................... 	} 
....................  
.................... 	// If this is an OFFER message, remember current server id. 
.................... 	if ( type == DHCP_OFFER_MESSAGE ) 
02A1C:  MOVF   xCD,W
02A1E:  SUBLW  02
02A20:  BNZ   2A3A
.................... 	{ 
.................... 		DHCPClient.dwServerID = tempServerID; 
02A22:  MOVFF  3D2,150
02A26:  MOVFF  3D1,14F
02A2A:  MOVFF  3D0,14E
02A2E:  MOVFF  3CF,14D
.................... 		DHCPClient.flags.bits.bOfferReceived = TRUE; 
02A32:  MOVLB  1
02A34:  BSF    x44.2
.................... 	} 
02A36:  BRA    2A66
02A38:  MOVLB  3
.................... 	else 
.................... 	{ 
.................... 		// For other types of messages, make sure that received 
.................... 		// server id matches with our previous one. 
.................... 		if ( DHCPClient.dwServerID != tempServerID ) 
02A3A:  MOVF   xCF,W
02A3C:  MOVLB  1
02A3E:  SUBWF  x4D,W
02A40:  BNZ   2A60
02A42:  MOVLB  3
02A44:  MOVF   xD0,W
02A46:  MOVLB  1
02A48:  SUBWF  x4E,W
02A4A:  BNZ   2A60
02A4C:  MOVLB  3
02A4E:  MOVF   xD1,W
02A50:  MOVLB  1
02A52:  SUBWF  x4F,W
02A54:  BNZ   2A60
02A56:  MOVLB  3
02A58:  MOVF   xD2,W
02A5A:  MOVLB  1
02A5C:  SUBWF  x50,W
02A5E:  BZ    2A66
.................... 			type = DHCP_UNKNOWN_MESSAGE; 
02A60:  MOVLB  3
02A62:  CLRF   xCD
02A64:  MOVLB  1
.................... 	} 
....................  
.................... 	UDPDiscard();                             // We are done with this packet 
02A66:  MOVLB  0
02A68:  RCALL  266C
.................... 	return type; 
02A6A:  MOVLB  3
02A6C:  MOVFF  3CD,01
02A70:  BRA    2A7C
....................  
.................... UDPInvalid: 
.................... 	UDPDiscard(); 
02A72:  MOVLB  0
02A74:  RCALL  266C
.................... 	return DHCP_UNKNOWN_MESSAGE; 
02A76:  MOVLW  00
02A78:  MOVWF  01
02A7A:  MOVLB  3
02A7C:  MOVLB  0
02A7E:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void _DHCPSend(BYTE messageType, BOOL bRenewing) 
....................  
....................   Description: 
.................... 	Sends a DHCP message. 
....................  
....................   Precondition: 
.................... 	UDP is ready to write a DHCP packet. 
....................  
....................   Parameters: 
.................... 	messageType - One of the DHCP_TYPE constants 
.................... 	bRenewing - Whether or not this is a renewal request 
....................  
....................   Returns: 
.................... 	None 
.................... ***************************************************************************/ 
.................... static void _DHCPSend(BYTE messageType, BOOL bRenewing) 
.................... { 
.................... 	BYTE i; 
.................... 	IP_ADDR	MyIP; 
....................  
....................             // __CCS__ add g_DNSTransactionID 
....................    if (messageType == DHCP_DISCOVER_MESSAGE) 
*
020F6:  MOVLB  3
020F8:  DECFSZ xCA,W
020FA:  BRA    2120
....................    { 
....................       g_DNSTransactionID = make32((int16)rand(), (int16)rand()); 
020FC:  MOVLB  0
020FE:  CALL   18DC
02102:  MOVFF  02,3D2
02106:  MOVFF  01,3D1
0210A:  CALL   18DC
0210E:  MOVFF  3D1,140
02112:  MOVFF  3D2,141
02116:  MOVFF  01,13E
0211A:  MOVFF  02,13F
0211E:  MOVLB  3
....................    } 
....................  
.................... 	UDPPut(BOOT_REQUEST);                       // op 
02120:  MOVLW  01
02122:  MOVWF  xD3
02124:  MOVLB  0
02126:  RCALL  194C
.................... 	UDPPut(BOOT_HW_TYPE);                       // htype 
02128:  MOVLW  01
0212A:  MOVLB  3
0212C:  MOVWF  xD3
0212E:  MOVLB  0
02130:  RCALL  194C
.................... 	UDPPut(BOOT_LEN_OF_HW_TYPE);                // hlen 
02132:  MOVLW  06
02134:  MOVLB  3
02136:  MOVWF  xD3
02138:  MOVLB  0
0213A:  RCALL  194C
.................... 	UDPPut(0);                                  // hops 
0213C:  MOVLB  3
0213E:  CLRF   xD3
02140:  MOVLB  0
02142:  RCALL  194C
....................    UDPPut(make8(g_DNSTransactionID,0));                               // xid[0] 
02144:  MOVFF  13E,3D1
02148:  MOVFF  13E,3D3
0214C:  CALL   194C
....................    UDPPut(make8(g_DNSTransactionID,1));                               // xid[1] 
02150:  MOVFF  13F,3D1
02154:  MOVFF  13F,3D3
02158:  CALL   194C
....................    UDPPut(make8(g_DNSTransactionID,2));                               // xid[2] 
0215C:  MOVFF  140,3D1
02160:  MOVFF  140,3D3
02164:  CALL   194C
....................    UDPPut(make8(g_DNSTransactionID,3));                               // xid[3] 
02168:  MOVFF  141,3D1
0216C:  MOVFF  141,3D3
02170:  CALL   194C
.................... 	UDPPut(0);                                  // secs[0] 
02174:  MOVLB  3
02176:  CLRF   xD3
02178:  MOVLB  0
0217A:  CALL   194C
.................... 	UDPPut(0);                                  // secs[1] 
0217E:  MOVLB  3
02180:  CLRF   xD3
02182:  MOVLB  0
02184:  CALL   194C
.................... 	UDPPut(DHCPClient.flags.bits.bUseUnicastMode ? 0x00: 0x80);// flags[0] with Broadcast flag clear/set to correspond to bUseUnicastMode 
02188:  MOVLB  1
0218A:  BTFSS  x44.4
0218C:  BRA    2192
0218E:  MOVLW  00
02190:  BRA    2194
02192:  MOVLW  80
02194:  MOVLB  3
02196:  MOVWF  xD1
02198:  MOVWF  xD3
0219A:  MOVLB  0
0219C:  CALL   194C
.................... 	UDPPut(0);                                  // flags[1] 
021A0:  MOVLB  3
021A2:  CLRF   xD3
021A4:  MOVLB  0
021A6:  CALL   194C
....................  
.................... 	// If this is DHCP REQUEST message, use previously allocated IP address. 
.................... 	if((messageType == DHCP_REQUEST_MESSAGE) && bRenewing) 
021AA:  MOVLB  3
021AC:  MOVF   xCA,W
021AE:  SUBLW  03
021B0:  BNZ   21D4
021B2:  MOVF   xCB,F
021B4:  BZ    21D4
.................... 	{ 
.................... 		UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress)); 
021B6:  MOVLW  01
021B8:  MOVWF  xD2
021BA:  MOVLW  51
021BC:  MOVWF  xD1
021BE:  MOVFF  3D2,3D4
021C2:  MOVWF  xD3
021C4:  CLRF   xD6
021C6:  MOVLW  04
021C8:  MOVWF  xD5
021CA:  MOVLB  0
021CC:  CALL   19A2
.................... 	} 
021D0:  BRA    21FA
021D2:  MOVLB  3
.................... 	else 
.................... 	{ 
.................... 		UDPPut(0x00); 
021D4:  CLRF   xD3
021D6:  MOVLB  0
021D8:  CALL   194C
.................... 		UDPPut(0x00); 
021DC:  MOVLB  3
021DE:  CLRF   xD3
021E0:  MOVLB  0
021E2:  CALL   194C
.................... 		UDPPut(0x00); 
021E6:  MOVLB  3
021E8:  CLRF   xD3
021EA:  MOVLB  0
021EC:  CALL   194C
.................... 		UDPPut(0x00); 
021F0:  MOVLB  3
021F2:  CLRF   xD3
021F4:  MOVLB  0
021F6:  CALL   194C
.................... 	} 
....................  
.................... 	// Set yiaddr, siaddr, giaddr as zeros, 
.................... 	for ( i = 0; i < 12u; i++ ) 
021FA:  MOVLB  3
021FC:  CLRF   xCC
021FE:  MOVF   xCC,W
02200:  SUBLW  0B
02202:  BNC   2212
.................... 		UDPPut(0x00); 
02204:  CLRF   xD3
02206:  MOVLB  0
02208:  CALL   194C
0220C:  MOVLB  3
0220E:  INCF   xCC,F
02210:  BRA    21FE
....................  
.................... 	// Load chaddr - Client hardware address. 
.................... 	UDPPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
02212:  CLRF   xD2
02214:  MOVLW  50
02216:  MOVWF  xD1
02218:  MOVFF  3D2,3D4
0221C:  MOVWF  xD3
0221E:  CLRF   xD6
02220:  MOVLW  06
02222:  MOVWF  xD5
02224:  MOVLB  0
02226:  CALL   19A2
....................  
.................... 	// Set chaddr[6..15], sname and file as zeros. 
.................... 	for ( i = 0; i < 202u; i++ ) 
0222A:  MOVLB  3
0222C:  CLRF   xCC
0222E:  MOVF   xCC,W
02230:  SUBLW  C9
02232:  BNC   2242
.................... 		UDPPut(0); 
02234:  CLRF   xD3
02236:  MOVLB  0
02238:  CALL   194C
0223C:  MOVLB  3
0223E:  INCF   xCC,F
02240:  BRA    222E
....................  
.................... 	// Load magic cookie as per RFC 1533. 
.................... 	UDPPut(99); 
02242:  MOVLW  63
02244:  MOVWF  xD3
02246:  MOVLB  0
02248:  CALL   194C
.................... 	UDPPut(130); 
0224C:  MOVLW  82
0224E:  MOVLB  3
02250:  MOVWF  xD3
02252:  MOVLB  0
02254:  CALL   194C
.................... 	UDPPut(83); 
02258:  MOVLW  53
0225A:  MOVLB  3
0225C:  MOVWF  xD3
0225E:  MOVLB  0
02260:  CALL   194C
.................... 	UDPPut(99); 
02264:  MOVLW  63
02266:  MOVLB  3
02268:  MOVWF  xD3
0226A:  MOVLB  0
0226C:  CALL   194C
....................  
.................... 	// Load message type. 
.................... 	UDPPut(DHCP_MESSAGE_TYPE); 
02270:  MOVLW  35
02272:  MOVLB  3
02274:  MOVWF  xD3
02276:  MOVLB  0
02278:  CALL   194C
.................... 	UDPPut(DHCP_MESSAGE_TYPE_LEN); 
0227C:  MOVLW  01
0227E:  MOVLB  3
02280:  MOVWF  xD3
02282:  MOVLB  0
02284:  CALL   194C
.................... 	UDPPut(messageType); 
02288:  MOVFF  3CA,3D3
0228C:  CALL   194C
....................  
.................... 	if(messageType == DHCP_DISCOVER_MESSAGE) 
02290:  MOVLB  3
02292:  DECFSZ xCA,W
02294:  BRA    229C
.................... 	{ 
.................... 		// Reset offered flag so we know to act upon the next valid offer 
.................... 		DHCPClient.flags.bits.bOfferReceived = FALSE; 
02296:  MOVLB  1
02298:  BCF    x44.2
0229A:  MOVLB  3
.................... 	} 
....................  
....................  
.................... 	if((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) 
0229C:  MOVF   xCA,W
0229E:  SUBLW  03
022A0:  BNZ   22DE
022A2:  MOVF   xCB,F
022A4:  BNZ   22DE
.................... 	{ 
.................... 		// DHCP REQUEST message must include server identifier the first time 
.................... 		// to identify the server we are talking to. 
.................... 		// _DHCPReceive() would populate "serverID" when it 
.................... 		// receives DHCP OFFER message. We will simply use that 
.................... 		// when we are replying to server. 
.................... 		// If this is a renwal request, we must not include server id. 
.................... 		UDPPut(DHCP_SERVER_IDENTIFIER); 
022A6:  MOVLW  36
022A8:  MOVWF  xD3
022AA:  MOVLB  0
022AC:  CALL   194C
.................... 		UDPPut(DHCP_SERVER_IDENTIFIER_LEN); 
022B0:  MOVLW  04
022B2:  MOVLB  3
022B4:  MOVWF  xD3
022B6:  MOVLB  0
022B8:  CALL   194C
.................... 		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[3]); 
022BC:  MOVFF  150,3D3
022C0:  CALL   194C
.................... 		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[2]); 
022C4:  MOVFF  14F,3D3
022C8:  CALL   194C
.................... 		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[1]); 
022CC:  MOVFF  14E,3D3
022D0:  CALL   194C
.................... 		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[0]); 
022D4:  MOVFF  14D,3D3
022D8:  CALL   194C
022DC:  MOVLB  3
....................       #warning not working in old compilers 
.................... 	} 
....................  
....................     //Set Host Name = ID String 
....................     //__CCS__ addition 
....................    #if defined(MY_UNIT_HOSTNAME) 
....................     UDPPut(12); 
....................     UDPPut(strlen(MY_UNIT_HOSTNAME)); 
....................     printf(UDPPut, "%s", MY_UNIT_HOSTNAME); 
....................    #endif    
....................     
.................... 	// Load our interested parameters 
.................... 	// This is hardcoded list.  If any new parameters are desired, 
.................... 	// new lines must be added here. 
.................... 	UDPPut(DHCP_PARAM_REQUEST_LIST); 
022DE:  MOVLW  37
022E0:  MOVWF  xD3
022E2:  MOVLB  0
022E4:  CALL   194C
.................... 	UDPPut(DHCP_PARAM_REQUEST_LIST_LEN); 
022E8:  MOVLW  04
022EA:  MOVLB  3
022EC:  MOVWF  xD3
022EE:  MOVLB  0
022F0:  CALL   194C
.................... 	UDPPut(DHCP_SUBNET_MASK); 
022F4:  MOVLW  01
022F6:  MOVLB  3
022F8:  MOVWF  xD3
022FA:  MOVLB  0
022FC:  CALL   194C
.................... 	UDPPut(DHCP_ROUTER); 
02300:  MOVLW  03
02302:  MOVLB  3
02304:  MOVWF  xD3
02306:  MOVLB  0
02308:  CALL   194C
.................... 	UDPPut(DHCP_DNS); 
0230C:  MOVLW  06
0230E:  MOVLB  3
02310:  MOVWF  xD3
02312:  MOVLB  0
02314:  CALL   194C
.................... 	UDPPut(DHCP_HOST_NAME); 
02318:  MOVLW  0C
0231A:  MOVLB  3
0231C:  MOVWF  xD3
0231E:  MOVLB  0
02320:  CALL   194C
....................  
.................... 	// Add requested IP address to DHCP Request Message 
.................... 	if( ((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) ||  
.................... 		((messageType == DHCP_DISCOVER_MESSAGE) && DHCPClient.tempIPAddress.Val)) 
02324:  MOVLB  3
02326:  MOVF   xCA,W
02328:  SUBLW  03
0232A:  BNZ   2330
0232C:  MOVF   xCB,F
0232E:  BZ    2360
02330:  DECFSZ xCA,W
02332:  BRA    2394
02334:  MOVLB  1
02336:  MOVF   x51,F
02338:  BTFSC  FD8.2
0233A:  BRA    2340
0233C:  MOVLB  3
0233E:  BRA    2360
02340:  MOVF   x52,F
02342:  BTFSC  FD8.2
02344:  BRA    234A
02346:  MOVLB  3
02348:  BRA    2360
0234A:  MOVF   x53,F
0234C:  BTFSC  FD8.2
0234E:  BRA    2354
02350:  MOVLB  3
02352:  BRA    2360
02354:  MOVF   x54,F
02356:  BTFSS  FD8.2
02358:  BRA    235E
0235A:  MOVLB  3
0235C:  BRA    2394
0235E:  MOVLB  3
.................... 	{ 
.................... 		UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS); 
02360:  MOVLW  32
02362:  MOVWF  xD3
02364:  MOVLB  0
02366:  CALL   194C
.................... 		UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS_LEN); 
0236A:  MOVLW  04
0236C:  MOVLB  3
0236E:  MOVWF  xD3
02370:  MOVLB  0
02372:  CALL   194C
.................... 		UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, DHCP_PARAM_REQUEST_IP_ADDRESS_LEN); 
02376:  MOVLW  01
02378:  MOVLB  3
0237A:  MOVWF  xD2
0237C:  MOVLW  51
0237E:  MOVWF  xD1
02380:  MOVFF  3D2,3D4
02384:  MOVWF  xD3
02386:  CLRF   xD6
02388:  MOVLW  04
0238A:  MOVWF  xD5
0238C:  MOVLB  0
0238E:  CALL   19A2
02392:  MOVLB  3
.................... 	} 
....................  
.................... 	// Add any new paramter request here. 
....................  
.................... 	// End of Options. 
.................... 	UDPPut(DHCP_END_OPTION); 
02394:  SETF   xD3
02396:  MOVLB  0
02398:  CALL   194C
....................  
.................... 	// Add zero padding to ensure compatibility with old BOOTP relays that discard small packets (<300 UDP octets) 
.................... 	while(UDPTxCount < 300u) 
0239C:  MOVF   xF9,W
0239E:  SUBLW  01
023A0:  BNC   23B6
023A2:  BNZ   23AA
023A4:  MOVF   xF8,W
023A6:  SUBLW  2B
023A8:  BNC   23B6
.................... 		UDPPut(0);  
023AA:  MOVLB  3
023AC:  CLRF   xD3
023AE:  MOVLB  0
023B0:  CALL   194C
023B4:  BRA    239C
....................  
.................... 	// Make sure we advertise a 0.0.0.0 IP address so all DHCP servers will respond.  If we have a static IP outside the DHCP server's scope, it may simply ignore discover messages. 
.................... 	MyIP.Val = AppConfig.MyIPAddr.Val; 
023B6:  MOVFF  26,3D0
023BA:  MOVFF  25,3CF
023BE:  MOVFF  24,3CE
023C2:  MOVFF  23,3CD
.................... 	if(!bRenewing) 
023C6:  MOVLB  3
023C8:  MOVF   xCB,F
023CA:  BNZ   23D4
.................... 		AppConfig.MyIPAddr.Val = 0x00000000; 
023CC:  CLRF   26
023CE:  CLRF   25
023D0:  CLRF   24
023D2:  CLRF   23
.................... 	UDPFlush(); 
023D4:  MOVLB  0
023D6:  BRA    1FF0
.................... 	AppConfig.MyIPAddr.Val = MyIP.Val; 
023D8:  MOVFF  3D0,26
023DC:  MOVFF  3CF,25
023E0:  MOVFF  3CE,24
023E4:  MOVFF  3CD,23
023E8:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... #endif	//#if defined(STACK_USE_DHCP_CLIENT) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS_SERVER) 
....................    #include "DNSs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Transmission Control Protocol (TCP) Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides reliable, handshaked transport of application stream  
....................  *    oriented data with flow control 
....................  *    -Reference: RFC 793 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.c 
....................  * Dependencies:    IP, Tick, Ethernet/WiFi (ENC28J60.c, ETH97J60.c,  
....................  *               ENCX24J600.c, or WFMac.c), ARP (optional),  
....................  *               DNS (optional) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date       Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01     Original        (Rev 1.0) 
....................  * Howard Schlunder      12/11/06   Changed almost everything to  
....................  *                           better meet RFC 793. 
....................  * Darren Rook          04/14/11 Changed TCP_SOCKET_COUNT to use TCP_CONFIGURATION. 
....................  ********************************************************************/ 
.................... #define __TCP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_TCP) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Configuration Parameters 
....................   ***************************************************************************/ 
....................  
.................... // Starting port for client sockets 
.................... #define LOCAL_PORT_START_NUMBER (1024u) 
.................... // End port for client sockets 
.................... #define LOCAL_PORT_END_NUMBER   (5000u) 
....................  
.................... // For debugging only.  Normal applications should never enable these 
.................... //#define DEBUG_GENERATE_TX_LOSS      62257 
.................... //#define DEBUG_GENERATE_RX_LOSS      64225 
....................  
.................... // A lot of pointer dereference code can be removed if you  
.................... // locally copy TCBStubs to an absolute memory location. 
.................... // If you define TCP_OPTIMIZE_FOR_SIZE, local caching will  
.................... // occur and will substantially decrease the entire TCP ROM  
.................... // footprint (up to 35%).  If you leave TCP_OPTIMIZE_FOR_SIZE  
.................... // undefined, the local caching will be disabled.  On PIC18  
.................... // products, this will improve TCP performance/throughput by  
.................... // approximately 15%. 
.................... #define TCP_OPTIMIZE_FOR_SIZE 
....................  
.................... // For smallest size and best throughput, TCP_OPTIMIZE_FOR_SIZE  
.................... // should always be enabled on PIC24/dsPIC products.  On PIC32  
.................... // products there is very little difference and depnds on compiler  
.................... // optimization level 
.................... #if defined(__C30__) && !defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #define TCP_OPTIMIZE_FOR_SIZE 
.................... #elif defined(__C32__) && defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #undef TCP_OPTIMIZE_FOR_SIZE 
.................... #endif 
....................  
.................... // TCP Maximum Segment Size for TX.  The TX maximum segment size is actually  
.................... // govered by the remote node's MSS option advirtised during connection  
.................... // establishment.  However, if the remote node specifies an unhandlably large  
.................... // MSS (ex: > Ethernet MTU), this define sets a hard limit so that we don't  
.................... // cause any TX buffer overflows.  If the remote node does not advirtise a MSS  
.................... // option, all TX segments are fixed at 536 bytes maximum. 
.................... #define TCP_MAX_SEG_SIZE_TX         (1460u) 
....................  
.................... // TCP Maximum Segment Size for RX.  This value is advirtised during connection  
.................... // establishment and the remote node should obey it.  This should be set to 536  
.................... // to avoid IP layer fragmentation from causing packet loss.  However, raising  
.................... // its value can enhance performance at the (small) risk of introducing  
.................... // incompatibility with certain special remote nodes (ex: ones connected via a  
.................... // slow dial up modem). 
.................... #define TCP_MAX_SEG_SIZE_RX         (536u) 
....................  
.................... // TCP Timeout and retransmit numbers 
.................... #define TCP_START_TIMEOUT_VAL      ((DWORD)TICK_SECOND*1)   // Timeout to retransmit unacked data 
.................... #define TCP_DELAYED_ACK_TIMEOUT      ((DWORD)TICK_SECOND/10)   // Timeout for delayed-acknowledgement algorithm 
.................... #define TCP_FIN_WAIT_2_TIMEOUT      ((DWORD)TICK_SECOND*5)   // Timeout for FIN WAIT 2 state 
.................... #define TCP_KEEP_ALIVE_TIMEOUT      ((DWORD)TICK_SECOND*10)   // Timeout for keep-alive messages when no traffic is sent 
.................... #define TCP_CLOSE_WAIT_TIMEOUT      ((DWORD)TICK_SECOND/5)   // Timeout for the CLOSE_WAIT state 
.................... #define TCP_MAX_RETRIES             (5u)               // Maximum number of retransmission attempts 
.................... #define TCP_MAX_UNACKED_KEEP_ALIVES   (6u)               // Maximum number of keep-alive messages that can be sent without receiving a response before automatically closing the connection 
.................... #define TCP_MAX_SYN_RETRIES         (2u)   // Smaller than all other retries to reduce SYN flood DoS duration 
....................  
.................... #define TCP_AUTO_TRANSMIT_TIMEOUT_VAL   (TICK_SECOND/25ull)   // Timeout before automatically transmitting unflushed data 
.................... #define TCP_WINDOW_UPDATE_TIMEOUT_VAL   (TICK_SECOND/5ull)   // Timeout before automatically transmitting a window update due to a TCPGet() or TCPGetArray() function call 
....................  
.................... #define TCP_SYN_QUEUE_MAX_ENTRIES   (3u)                // Number of TCP RX SYN packets to save if they cannot be serviced immediately 
.................... #define TCP_SYN_QUEUE_TIMEOUT      ((DWORD)TICK_SECOND*3)   // Timeout for when SYN queue entries are deleted if unserviceable 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCP Header Data Types 
....................   ***************************************************************************/ 
....................  
.................... #define FIN     (0x01)      // FIN Flag as defined in RFC 
.................... #define SYN     (0x02)      // SYN Flag as defined in RFC 
.................... #define RST     (0x04)      // Reset Flag as defined in RFC 
.................... #define PSH     (0x08)      // Push Flag as defined in RFC 
.................... #define ACK     (0x10)      // Acknowledge Flag as defined in RFC 
.................... #define URG     (0x20)      // Urgent Flag as defined in RFC 
....................  
.................... // TCP Header Data Structure 
.................... typedef struct 
.................... { 
....................    WORD    SourcePort;      // Local port number 
....................    WORD    DestPort;      // Remote port number 
....................    DWORD   SeqNumber;      // Local sequence number 
....................    DWORD   AckNumber;      // Acknowledging remote sequence number 
....................  
....................    struct 
....................    { 
....................       unsigned char Reserved3      : 4; 
....................       unsigned char Val            : 4; 
....................    } DataOffset;         // Data offset flags nibble 
....................  
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned char flagFIN    : 1; 
....................          unsigned char flagSYN    : 1; 
....................          unsigned char flagRST    : 1; 
....................          unsigned char flagPSH    : 1; 
....................          unsigned char flagACK    : 1; 
....................          unsigned char flagURG    : 1; 
....................          unsigned char Reserved2  : 2; 
....................       } bits; 
....................       BYTE byte; 
....................    } Flags;            // TCP Flags as defined in RFC 
....................  
....................    WORD    Window;         // Local free RX buffer window 
....................    WORD    Checksum;      // Data payload checksum 
....................    WORD    UrgentPointer;   // Urgent pointer 
.................... } TCP_HEADER; 
....................  
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00u)      // End of List TCP Option Flag 
.................... #define TCP_OPTIONS_NO_OP           (0x01u)      // No Op TCP Option 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02u)      // Maximum segment size TCP flag 
.................... typedef struct 
.................... { 
....................    BYTE        Kind;                     // Type of option 
....................    BYTE        Length;                     // Length 
....................    WORD_VAL    MaxSegSize;                  // Maximum segment size 
.................... } TCP_OPTIONS;                           // TCP Options data structure                      
....................  
.................... // Structure containing all the important elements of an incomming  
.................... // SYN packet in order to establish a connection at a future time  
.................... // if all sockets on the listening port are already connected to  
.................... // someone 
.................... typedef struct  
.................... { 
....................    NODE_INFO   niSourceAddress;// Remote IP address and MAC address 
....................    WORD      wSourcePort;   // Remote TCP port number that the response SYN needs to be sent to 
....................    DWORD      dwSourceSEQ;   // Remote TCP SEQuence number that must be ACKnowledged when we send our response SYN 
....................    WORD      wDestPort;      // Local TCP port which the original SYN was destined for 
....................    WORD      wTimestamp;      // Timer to expire old SYN packets that can't be serviced at all 
.................... } TCP_SYN_QUEUE; 
....................  
....................  
.................... #if defined(STACK_CLIENT_MODE) 
.................... static WORD NextPort __attribute__((persistent));   // Tracking variable for next local client port number 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // Determines the number of defined TCP sockets 
.................... //#define TCP_SOCKET_COUNT   (sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0])) 
.................... #define TCP_SOCKET_COUNT   TCP_CONFIGURATION    //ccs changed 
....................  
.................... #if defined(HI_TECH_C) 
....................    // The initializer forces this large array out of the bss section  
....................    // so we can link correctly. 
....................    #pragma psect bigdata=TCB_uRAM_BIG 
....................    #pragma psect data=TCB_uRAM 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT] = {'\0'};    
....................    #pragma psect data=ordinary_data_sect 
....................    #pragma psect bigdata=ordinary_data_sect_big 
.................... #else 
....................    // The TCB array is very large.  With the C18 compiler, one must  
....................    // modify the linker script to make an array that spans more than  
....................    // one memory bank.  To do this, make the necessary changes to your  
....................    // processor's linker script (.lkr).  Here is an example showing  
....................    // gpr11 and 128 bytes of gpr12 being combined into one 384 byte  
....................    // block used exclusively by the TCB_uRAM data section: 
....................    // ... 
....................    // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
....................    // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
....................    // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
....................    // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
....................    // ... 
....................    // SECTION    NAME=TCB_uRAM    RAM=gpr11b 
....................    // ... 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata TCB_uRAM 
....................    #endif 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT]; 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata               // Return to any other RAM section 
....................    #endif 
.................... #endif 
....................  
.................... static TCB MyTCB;                           // Currently loaded TCB 
.................... static TCP_SOCKET hCurrentTCP = INVALID_SOCKET;      // Current TCP socket 
.................... #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata SYN_QUEUE_RAM_SECT 
....................    #endif 
....................    static TCP_SYN_QUEUE SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES];   // Array of saved incoming SYN requests that need to be serviced later 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata 
....................    #endif 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static void TCPRAMCopy(PTR_BASE wDest, BYTE vDestType, PTR_BASE wSource, BYTE vSourceType, WORD wLength); 
....................  
.................... #if defined(__18CXX) 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength); 
.................... #else 
....................    #define TCPRAMCopyROM(a,b,c,d)   TCPRAMCopy(a,b,c,TCP_PIC_RAM,d) 
.................... #endif 
....................  
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags); 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len); 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote); 
.................... static void SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(void); 
.................... static void SyncTCB(void); 
....................  
.................... #if defined(WF_CS_TRIS) 
.................... UINT16 WFGetTCBSize(void); 
.................... #endif 
....................  
.................... // Indicates if this packet is a retransmission (no reset) or a new packet (reset required) 
.................... #define SENDTCP_RESET_TIMERS   0x01 
.................... // Instead of transmitting normal data, a garbage octet is transmitted according to RFC 1122 section 4.2.3.6 
.................... #define SENDTCP_KEEP_ALIVE      0x02 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Optimization Configuration 
....................   ***************************************************************************/ 
....................  
.................... #if defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    static TCB_STUB MyTCBStub; 
....................     
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    static void SyncTCBStub(TCP_SOCKET hTCP) 
....................    { 
....................       if(hCurrentTCP == hTCP) 
*
00A4A:  MOVLB  3
00A4C:  MOVF   xFE,W
00A4E:  MOVLB  1
00A50:  SUBWF  xA1,W
00A52:  BNZ   0A56
....................          return; 
00A54:  BRA    0AEE
....................     
....................       if(hCurrentTCP != INVALID_SOCKET) 
00A56:  MOVF   xA1,W
00A58:  SUBLW  FE
00A5A:  BZ    0A98
....................       { 
....................          // Save the current TCB stub 
....................          memcpy((void*)&TCBStubs[hCurrentTCP], (void*)&MyTCBStub, sizeof(MyTCBStub)); 
00A5C:  MOVF   xA1,W
00A5E:  MULLW  1C
00A60:  MOVF   FF3,W
00A62:  CLRF   03
00A64:  ADDLW  5E
00A66:  MOVWF  01
00A68:  MOVLW  01
00A6A:  ADDWFC 03,F
00A6C:  MOVFF  01,400
00A70:  MOVLB  4
00A72:  MOVFF  03,401
00A76:  MOVLW  01
00A78:  MOVWF  x03
00A7A:  MOVLW  DE
00A7C:  MOVFF  03,FEA
00A80:  MOVFF  01,FE9
00A84:  MOVFF  403,FE2
00A88:  MOVWF  FE1
00A8A:  MOVLW  1C
00A8C:  MOVWF  01
00A8E:  MOVFF  FE6,FEE
00A92:  DECFSZ 01,F
00A94:  BRA    0A8E
00A96:  MOVLB  1
....................       } 
....................     
....................       hCurrentTCP = hTCP; 
00A98:  MOVFF  3FE,1A1
....................     
....................       if(hTCP == INVALID_SOCKET) 
00A9C:  MOVLB  3
00A9E:  MOVF   xFE,W
00AA0:  SUBLW  FE
00AA2:  BNZ   0AAA
....................          return; 
00AA4:  MOVLB  1
00AA6:  BRA    0AEE
00AA8:  MOVLB  3
....................     
....................       // Load up the new TCB stub 
....................       memcpy((void*)&MyTCBStub, (void*)&TCBStubs[hTCP], sizeof(MyTCBStub)); 
00AAA:  MOVLW  01
00AAC:  MOVLB  4
00AAE:  MOVWF  x01
00AB0:  MOVLW  DE
00AB2:  MOVWF  x00
00AB4:  MOVLB  3
00AB6:  MOVF   xFE,W
00AB8:  MULLW  1C
00ABA:  MOVF   FF3,W
00ABC:  CLRF   03
00ABE:  ADDLW  5E
00AC0:  MOVWF  01
00AC2:  MOVLW  01
00AC4:  ADDWFC 03,F
00AC6:  MOVFF  01,402
00ACA:  MOVLB  4
00ACC:  MOVFF  03,403
00AD0:  MOVFF  401,FEA
00AD4:  MOVFF  400,FE9
00AD8:  MOVFF  03,FE2
00ADC:  MOVFF  01,FE1
00AE0:  MOVLW  1C
00AE2:  MOVWF  01
00AE4:  MOVFF  FE6,FEE
00AE8:  DECFSZ 01,F
00AEA:  BRA    0AE4
00AEC:  MOVLB  1
00AEE:  MOVLB  0
00AF0:  RETURN 0
....................    } 
.................... #else 
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    #define SyncTCBStub(a)   hCurrentTCP = (a) 
....................    // Alias to current TCP stub. 
....................    #define MyTCBStub      TCBStubs[hCurrentTCP] 
.................... #endif 
....................  
....................  
....................  
.................... // Flushes MyTCB cache and loads up the specified TCB. 
.................... // Does nothing on cache hit. 
.................... static void SyncTCB(void) 
.................... { 
....................    static TCP_SOCKET hLastTCB = INVALID_SOCKET; 
....................     
....................    if(hLastTCB == hCurrentTCP) 
*
01052:  MOVLB  1
01054:  MOVF   xA1,W
01056:  SUBWF  xFA,W
01058:  BNZ   105C
....................       return; 
0105A:  BRA    1126
....................  
....................    if(hLastTCB != INVALID_SOCKET) 
0105C:  MOVF   xFA,W
0105E:  SUBLW  FE
01060:  BZ    10E0
....................    { 
....................       // Save the current TCB 
....................       TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB)); 
01062:  MOVF   xFA,W
01064:  MULLW  1C
01066:  MOVF   FF3,W
01068:  MOVLB  4
0106A:  CLRF   x3F
0106C:  MOVWF  x3E
0106E:  MOVLW  5E
01070:  ADDWF  x3E,W
01072:  MOVWF  FE9
01074:  MOVLW  01
01076:  ADDWFC x3F,W
01078:  MOVWF  FEA
0107A:  MOVFF  FEC,441
0107E:  MOVF   FED,F
01080:  MOVFF  FEF,440
01084:  MOVLW  27
01086:  SUBWF  x40,F
01088:  MOVLW  00
0108A:  SUBWFB x41,F
0108C:  MOVLB  1
0108E:  MOVF   xFA,W
01090:  MULLW  1C
01092:  MOVF   FF3,W
01094:  MOVLB  4
01096:  CLRF   x43
01098:  MOVWF  x42
0109A:  MOVLW  1B
0109C:  ADDWF  x42,W
0109E:  MOVWF  01
010A0:  MOVLW  00
010A2:  ADDWFC x43,W
010A4:  MOVWF  03
010A6:  MOVF   01,W
010A8:  ADDLW  5E
010AA:  MOVWF  FE9
010AC:  MOVLW  01
010AE:  ADDWFC 03,W
010B0:  MOVWF  FEA
010B2:  MOVFF  FEF,442
010B6:  MOVLW  01
010B8:  MOVWF  x44
010BA:  MOVLW  7A
010BC:  MOVWF  x43
010BE:  MOVFF  441,446
010C2:  MOVFF  440,445
010C6:  MOVFF  442,447
010CA:  MOVFF  444,449
010CE:  MOVWF  x48
010D0:  MOVLW  01
010D2:  MOVWF  x4A
010D4:  CLRF   x4C
010D6:  MOVLW  27
010D8:  MOVWF  x4B
010DA:  MOVLB  0
010DC:  RCALL  0F6C
010DE:  MOVLB  1
....................    } 
....................  
....................    // Load up the new TCB 
....................    hLastTCB = hCurrentTCP; 
010E0:  MOVFF  1A1,1FA
....................    TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB)); 
010E4:  MOVLW  01
010E6:  MOVLB  4
010E8:  MOVWF  x3F
010EA:  MOVLW  7A
010EC:  MOVWF  x3E
010EE:  MOVLW  27
010F0:  MOVLB  1
010F2:  SUBWF  xDE,W
010F4:  MOVLB  4
010F6:  MOVWF  x40
010F8:  MOVLW  00
010FA:  MOVLB  1
010FC:  SUBWFB xDF,W
010FE:  MOVLB  4
01100:  MOVWF  x41
01102:  MOVFF  43F,446
01106:  MOVFF  43E,445
0110A:  MOVLW  01
0110C:  MOVWF  x47
0110E:  MOVFF  441,449
01112:  MOVFF  440,448
01116:  MOVFF  1F9,44A
0111A:  CLRF   x4C
0111C:  MOVLW  27
0111E:  MOVWF  x4B
01120:  MOVLB  0
01122:  RCALL  0F6C
01124:  MOVLB  1
01126:  MOVLB  0
01128:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPInit(void) 
....................  
....................   Summary: 
....................    Initializes the TCP module. 
....................  
....................   Description: 
....................    Initializes the TCP module.  This function sets up the TCP buffers 
....................    in memory and initializes each socket to the CLOSED state.  If 
....................    insufficient memory was allocated for the TCP sockets, the function 
....................    will hang here to be captured by the debugger. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TCPInit(void) 
*
011FC:  MOVLW  17
011FE:  MOVLB  3
01200:  MOVWF  xCA
01202:  MOVLW  C8
01204:  MOVWF  xC9
.................... { 
....................    BYTE i; 
....................    BYTE vSocketsAllocated; 
....................    WORD wTXSize, wRXSize; 
....................    PTR_BASE ptrBaseAddress; 
....................    BYTE vMedium; 
....................    #if TCP_ETH_RAM_SIZE > 0 
....................    WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_PIC_RAM_SIZE > 0 
....................    PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_SPI_RAM_SIZE > 0 
....................    WORD wCurrentSPIAddress = TCP_SPI_RAM_BASE_ADDRESS; 
....................    #endif 
....................  
....................    #if defined(STACK_CLIENT_MODE) 
....................       // Initialize NextPort to a random value if it is zero (such as after  
....................       // reset on a PIC32 or PIC18 when the static memory initializer is  
....................       // used).  By starting with a random number, we decrease the risk of  
....................       // reusing a port number that was previously used if the user power  
....................       // cycles the device. 
....................       if(NextPort == 0u) 
....................          NextPort = (((WORD)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER; 
....................    #endif 
....................  
....................  
....................    // Mark all SYN Queue entries as invalid by zeroing the memory 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................       memset((void*)SYNQueue, 0x00, sizeof(SYNQueue)); 
01206:  MOVLW  01
01208:  MOVWF  xCC
0120A:  MOVLW  A2
0120C:  MOVWF  xCB
0120E:  MOVFF  3CC,FEA
01212:  MOVWF  FE9
01214:  CLRF   00
01216:  CLRF   02
01218:  MOVLW  3C
0121A:  MOVWF  01
0121C:  MOVLB  0
0121E:  RCALL  0A30
....................    #endif 
....................     
....................    // Allocate all socket FIFO addresses 
....................    vSocketsAllocated = 0; 
01220:  MOVLB  3
01222:  CLRF   xC1
....................    for(i = 0; i < TCP_SOCKET_COUNT; i++) 
01224:  CLRF   xC0
01226:  MOVF   xC0,F
01228:  BTFSS  FD8.2
0122A:  BRA    1392
....................    { 
....................       // Generate all needed sockets of each type (TCP_PURPOSE_*) 
....................       SyncTCBStub(i); 
0122C:  MOVFF  3C0,3FE
01230:  MOVLB  0
01232:  RCALL  0A4A
....................     
....................       vMedium = TCPSocketInitializer[i].vMemoryMedium; 
01234:  MOVLB  3
01236:  MOVF   xC0,W
01238:  MULLW  06
0123A:  MOVF   FF3,W
0123C:  CLRF   xCC
0123E:  MOVWF  xCB
01240:  MOVLW  01
01242:  ADDWF  xCB,W
01244:  MOVWF  01
01246:  MOVLW  00
01248:  ADDWFC xCC,W
0124A:  MOVWF  03
0124C:  MOVF   01,W
0124E:  ADDLW  1D
01250:  MOVWF  FE9
01252:  MOVLW  00
01254:  ADDWFC 03,W
01256:  MOVWF  FEA
01258:  MOVFF  FEF,3C8
....................       wTXSize = TCPSocketInitializer[i].wTXBufferSize; 
0125C:  MOVF   xC0,W
0125E:  MULLW  06
01260:  MOVF   FF3,W
01262:  CLRF   xCC
01264:  MOVWF  xCB
01266:  MOVLW  02
01268:  ADDWF  xCB,W
0126A:  MOVWF  01
0126C:  MOVLW  00
0126E:  ADDWFC xCC,W
01270:  MOVWF  03
01272:  MOVF   01,W
01274:  ADDLW  1D
01276:  MOVWF  FE9
01278:  MOVLW  00
0127A:  ADDWFC 03,W
0127C:  MOVWF  FEA
0127E:  MOVFF  FEC,3C3
01282:  MOVF   FED,F
01284:  MOVFF  FEF,3C2
....................       wRXSize = TCPSocketInitializer[i].wRXBufferSize; 
01288:  MOVF   xC0,W
0128A:  MULLW  06
0128C:  MOVF   FF3,W
0128E:  CLRF   xCC
01290:  MOVWF  xCB
01292:  MOVLW  04
01294:  ADDWF  xCB,W
01296:  MOVWF  01
01298:  MOVLW  00
0129A:  ADDWFC xCC,W
0129C:  MOVWF  03
0129E:  MOVF   01,W
012A0:  ADDLW  1D
012A2:  MOVWF  FE9
012A4:  MOVLW  00
012A6:  ADDWFC 03,W
012A8:  MOVWF  FEA
012AA:  MOVFF  FEC,3C5
012AE:  MOVF   FED,F
012B0:  MOVFF  FEF,3C4
....................     
....................       switch(vMedium) 
012B4:  MOVF   xC8,W
012B6:  XORLW  00
012B8:  MOVLB  0
012BA:  BZ    12BE
012BC:  BRA    130C
....................       { 
....................          #if TCP_ETH_RAM_SIZE > 0 
....................          case TCP_ETH_RAM: 
....................             ptrBaseAddress = wCurrentETHAddress; 
012BE:  MOVFF  3CA,3C7
012C2:  MOVFF  3C9,3C6
....................             wCurrentETHAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
012C6:  MOVLW  27
012C8:  MOVLB  3
012CA:  ADDWF  xC2,W
012CC:  MOVWF  xCB
012CE:  MOVLW  00
012D0:  ADDWFC xC3,W
012D2:  MOVWF  xCC
012D4:  MOVLW  01
012D6:  ADDWF  xCB,F
012D8:  MOVLW  00
012DA:  ADDWFC xCC,F
012DC:  MOVF   xC4,W
012DE:  ADDWF  xCB,F
012E0:  MOVF   xC5,W
012E2:  ADDWFC xCC,F
012E4:  MOVLW  01
012E6:  ADDWF  xCB,W
012E8:  MOVWF  01
012EA:  MOVLW  00
012EC:  ADDWFC xCC,W
012EE:  MOVWF  03
012F0:  MOVF   01,W
012F2:  ADDWF  xC9,F
012F4:  MOVF   03,W
012F6:  ADDWFC xCA,F
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
.................... #if defined(WF_CS_TRIS) 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + WFGetTCBSize()/*TCP_ETH_RAM_SIZE*/); 
.................... #else 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + TCP_ETH_RAM_SIZE); 
012F8:  MOVF   xCA,W
012FA:  SUBLW  1E
012FC:  BC    1308
012FE:  XORLW  FF
01300:  BNZ   12F8
01302:  MOVF   xC9,W
01304:  SUBLW  FC
01306:  BNC   12F8
.................... #endif 
....................             break; 
01308:  BRA    1310
0130A:  MOVLB  0
....................          #endif 
....................              
....................          #if TCP_PIC_RAM_SIZE > 0 
....................          case TCP_PIC_RAM: 
....................             ptrBaseAddress = ptrCurrentPICAddress; 
....................             ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE); 
....................             break; 
....................          #endif 
....................              
....................          #if TCP_SPI_RAM_SIZE > 0 
....................          case TCP_SPI_RAM: 
....................             ptrBaseAddress = wCurrentSPIAddress; 
....................             wCurrentSPIAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(wCurrentSPIAddress > TCP_SPI_RAM_BASE_ADDRESS + TCP_SPI_RAM_SIZE); 
....................             break; 
....................          #endif 
....................           
....................          default: 
....................             while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations. 
0130C:  BRA    130C
0130E:  MOVLB  3
....................       } 
....................     
....................       MyTCBStub.vMemoryMedium = vMedium; 
01310:  MOVFF  3C8,1F9
....................       MyTCBStub.bufferTxStart   = ptrBaseAddress + sizeof(TCB); 
01314:  MOVLW  27
01316:  ADDWF  xC6,W
01318:  MOVLB  1
0131A:  MOVWF  xDE
0131C:  MOVLW  00
0131E:  MOVLB  3
01320:  ADDWFC xC7,W
01322:  MOVLB  1
01324:  MOVWF  xDF
....................       MyTCBStub.bufferRxStart   = MyTCBStub.bufferTxStart + wTXSize + 1; 
01326:  MOVLB  3
01328:  MOVF   xC2,W
0132A:  MOVLB  1
0132C:  ADDWF  xDE,W
0132E:  MOVLB  3
01330:  MOVWF  xCB
01332:  MOVF   xC3,W
01334:  MOVLB  1
01336:  ADDWFC xDF,W
01338:  MOVLB  3
0133A:  MOVWF  xCC
0133C:  MOVLW  01
0133E:  ADDWF  xCB,W
01340:  MOVLB  1
01342:  MOVWF  xE0
01344:  MOVLW  00
01346:  MOVLB  3
01348:  ADDWFC xCC,W
0134A:  MOVLB  1
0134C:  MOVWF  xE1
....................       MyTCBStub.bufferEnd      = MyTCBStub.bufferRxStart + wRXSize; 
0134E:  MOVLB  3
01350:  MOVF   xC4,W
01352:  MOVLB  1
01354:  ADDWF  xE0,W
01356:  MOVWF  xE2
01358:  MOVLB  3
0135A:  MOVF   xC5,W
0135C:  MOVLB  1
0135E:  ADDWFC xE1,W
01360:  MOVWF  xE3
....................       MyTCBStub.smState      = TCP_CLOSED; 
01362:  MOVLW  0D
01364:  MOVWF  xF4
....................       MyTCBStub.Flags.bServer   = FALSE; 
01366:  BCF    xF5.3
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................       #endif       
....................  
....................       SyncTCB(); 
01368:  MOVLB  0
0136A:  RCALL  1052
....................       MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose; 
0136C:  MOVLB  3
0136E:  MOVF   xC0,W
01370:  MULLW  06
01372:  MOVF   FF3,W
01374:  CLRF   xCC
01376:  MOVWF  xCB
01378:  MOVLW  1D
0137A:  ADDWF  xCB,W
0137C:  MOVWF  FE9
0137E:  MOVLW  00
01380:  ADDWFC xCC,W
01382:  MOVWF  FEA
01384:  MOVFF  FEF,1A0
....................       CloseSocket(); 
01388:  MOVLB  0
0138A:  RCALL  112A
0138C:  MOVLB  3
0138E:  INCF   xC0,F
01390:  BRA    1226
....................    } 
01392:  MOVLB  0
01394:  GOTO   1538 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Connection Management Functions 
....................   ***************************************************************************/ 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
....................      
....................   Summary: 
....................     Opens a TCP socket for listening or as a client. 
....................  
....................   Description: 
....................     Provides a unified method for opening TCP sockets. This function can 
....................     open both client and server sockets. For client sockets, it can accept 
....................     a host name string to query in DNS, an IP address as a string, an IP 
....................     address in binary form, or a previously resolved NODE_INFO structure 
....................     containing the remote IP address and associated MAC address. When a 
....................     host name or IP address only is provided, the TCP module will 
....................     internally perform the necessary DNS and/or ARP resolution steps before 
....................     reporting that the TCP socket is connected (via a call to 
....................     TCPISConnected returning TRUE). Server sockets ignore this destination 
....................     parameter and listen only on the indicated port. 
....................      
....................     The vSocketPurpose field allows sockets to be opened with varying 
....................     buffer size parameters and memory storage mediums. This field 
....................     corresponds to pre-defined sockets allocated in the 
....................     TCPSocketInitializer[] array in TCPIPConfig.h. The TCPIPConfig.h file 
....................     can be edited using the TCP/IP Configuration Wizard. 
....................      
....................     Sockets are statically allocated on boot, but can be claimed with this 
....................     \function and freed using TCPDisconnect or TCPClose (for client 
....................     sockets). Server sockets can be freed using TCPClose only (calls to 
....................     TCPDisconnect will return server sockets to the listening state, 
....................     allowing reuse). 
....................  
....................   Conditions: 
....................     TCP is initialized. 
....................  
....................   Input: 
....................     dwRemoteHost -     For client sockets only. Provide a pointer to a 
....................                        null\-terminated string of the remote host name (ex\: 
....................                        "www.microchip.com" or "192.168.1.123"), a literal 
....................                        destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR 
....................                        data type), or a pointer to a NODE_INFO structure 
....................                        with the remote IP address and remote node or gateway 
....................                        MAC address specified. If a string is provided, note 
....................                        that it must be statically allocated in memory and 
....................                        cannot be modified or deallocated until 
....................                        TCPIsConnected returns TRUE.<p />This parameter is 
....................                        ignored for server sockets. 
....................     vRemoteHostType -  Any one of the following flags to identify the 
....................                        meaning of the dwRemoteHost parameter\: 
....................                        * TCP_OPEN_SERVER &#45; Open a server socket and 
....................                          ignore the dwRemoteHost parameter. 
....................                        * TCP_OPEN_RAM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a RAM array. Ex\: 
....................                          "www.microchip.com" or "192.168.0.123" (BYTE&#42; 
....................                          type) 
....................                        * TCP_OPEN_ROM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a literal string or ROM 
....................                          array. Ex\: "www.microchip.com" or "192.168.0.123" 
....................                          (ROM BYTE&#42; type) 
....................                        * TCP_OPEN_IP_ADDRESS &#45; Open a client socket and 
....................                          connect it to a remote IP address. Ex\: 0x7B01A8C0 
....................                          for 192.168.1.123 (DWORD type). Note that the byte 
....................                          ordering is big endian. 
....................                        * TCP_OPEN_NODE_INFO &#45; Open a client socket and 
....................                          connect it to a remote IP and MAC addresses pair 
....................                          stored in a NODE_INFO structure. dwRemoteHost must be 
....................                          a pointer to the NODE_INFO structure. This option is 
....................                          provided for backwards compatibility with 
....................                          applications built against prior stack versions that 
....................                          only implemented the TCPConnect() function. It can 
....................                          also be used to skip DNS and ARP resolution steps if 
....................                          connecting to a remote node which you've already 
....................                          connected to and have cached addresses for. 
....................     wPort -            TCP port to listen on or connect to\: 
....................                        * Client sockets &#45; the remote TCP port to which a 
....................                          connection should be made. The local port for client 
....................                          sockets will be automatically picked by the TCP 
....................                          module. 
....................                        * Server sockets &#45; the local TCP port on which to 
....................                          listen for connections. 
....................     vSocketPurpose -   Any of the TCP_PURPOSE_* constants defined in 
....................                        TCPIPConfig.h or the TCPIPConfig utility (see 
....................                        TCPSocketInitializer[] array). 
....................  
....................   Return Values: 
....................     INVALID_SOCKET -  No sockets of the specified type were available to be 
....................                       opened. 
....................     Otherwise -       A TCP_SOCKET handle. Save this handle and use it when 
....................                       calling all other TCP APIs. 
....................  
....................   Remarks: 
....................     This function replaces the old TCPConnect and TCPListen functions. 
....................      
....................     If TCP_OPEN_RAM_HOST or TCP_OPEN_ROM_HOST are used for the destination 
....................     type, the DNS client module must also be enabled (STACK_USE_DNS must be 
....................     defined in TCPIPConfig.h). 
....................  
....................   Example: 
....................     \ \  
....................     <code> 
....................     // Open a server socket 
....................     skt = TCPOpen(NULL, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER); 
....................      
....................     // Open a client socket to www.microchip.com 
....................     // The double cast here prevents compiler warnings 
....................     skt = TCPOpen((DWORD)(PTR_BASE)"www.microchip.com", 
....................                     TCP_OPEN_ROM_HOST, 80, TCP_PURPOSE_DEFAULT); 
....................      
....................     // Reopen a client socket without repeating DNS or ARP 
....................     SOCKET_INFO cache = TCPGetSocketInfo(skt);  // Call with the old socket 
....................     skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO, 
....................                     cache.remotePort.Val, TCP_PURPOSE_DEFAULT); 
....................     </code>                                                     
....................   *****************************************************************************/ 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................  
....................    // Find an available socket that matches the specified socket type 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
013F4:  MOVLB  3
013F6:  CLRF   xCB
013F8:  MOVF   xCB,F
013FA:  BNZ   1462
....................    { 
....................       SyncTCBStub(hTCP); 
013FC:  MOVFF  3CB,3FE
01400:  MOVLB  0
01402:  CALL   0A4A
....................  
....................       // Sockets that are in use will be in a non-closed state 
....................       if(MyTCBStub.smState != TCP_CLOSED) 
01406:  MOVLB  1
01408:  MOVF   xF4,W
0140A:  SUBLW  0D
0140C:  BZ    1410
....................          continue; 
0140E:  BRA    145C
....................  
....................       SyncTCB(); 
01410:  MOVLB  0
01412:  RCALL  1052
....................  
....................       // See if this socket matches the desired type 
....................       if(MyTCB.vSocketPurpose != vSocketPurpose) 
01414:  MOVLB  3
01416:  MOVF   xCA,W
01418:  MOVLB  1
0141A:  SUBWF  xA0,W
0141C:  BZ    1420
....................          continue; 
0141E:  BRA    145C
....................  
....................       // Start out assuming worst case Maximum Segment Size (changes when MSS  
....................       // option is received from remote node) 
....................       MyTCB.wRemoteMSS = 536; 
01420:  MOVLW  02
01422:  MOVWF  x9E
01424:  MOVLW  18
01426:  MOVWF  x9D
....................  
....................       // See if this is a server socket 
....................       if(vRemoteHostType == TCP_OPEN_SERVER) 
01428:  MOVLB  3
0142A:  MOVF   xC7,F
0142C:  BNZ   144A
....................       { 
....................          MyTCB.localPort.Val = wPort; 
0142E:  MOVFF  3C9,18B
01432:  MOVFF  3C8,18A
....................          MyTCBStub.Flags.bServer = TRUE; 
01436:  MOVLB  1
01438:  BSF    xF5.3
....................          MyTCBStub.smState = TCP_LISTEN; 
0143A:  MOVLW  04
0143C:  MOVWF  xF4
....................          MyTCBStub.remoteHash.Val = wPort; 
0143E:  MOVFF  3C9,1F8
01442:  MOVFF  3C8,1F7
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          MyTCB.localSSLPort.Val = 0; 
....................          #endif 
....................       } 
01446:  BRA    1452
01448:  MOVLB  3
....................       // Handle all the client mode socket types 
....................       else 
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          { 
....................             // Each new socket that is opened by this node, gets the  
....................             // next sequential local port number. 
....................             if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER) 
....................                NextPort = LOCAL_PORT_START_NUMBER; 
....................              
....................             // Set the non-zero TCB fields 
....................             MyTCB.localPort.Val = NextPort++; 
....................             MyTCB.remotePort.Val = wPort; 
....................     
....................             // Flag to start the DNS, ARP, SYN processes 
....................             MyTCBStub.eventTime = TickGet(); 
....................             MyTCBStub.Flags.bTimerEnabled = 1; 
....................     
....................             switch(vRemoteHostType) 
....................             { 
....................                #if defined(STACK_USE_DNS) 
....................                case TCP_OPEN_RAM_HOST: 
....................                case TCP_OPEN_ROM_HOST: 
....................                   MyTCB.remote.dwRemoteHost = dwRemoteHost; 
....................                   MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST); 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                   break; 
....................                #endif 
....................        
....................                case TCP_OPEN_IP_ADDRESS: 
....................                   // dwRemoteHost is a literal IP address.  This  
....................                   // doesn't need DNS and can skip directly to the  
....................                   // Gateway ARPing step. 
....................                   MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val; 
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost; 
....................                   MyTCB.retryCount = 0; 
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                   break; 
....................        
....................                case TCP_OPEN_NODE_INFO: 
....................                   MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val; 
....................                   memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO)); 
....................                   MyTCBStub.smState = TCP_SYN_SENT; 
....................                   SendTCP(SYN, SENDTCP_RESET_TIMERS); 
....................                   break; 
....................             } 
....................          }       
....................          #else 
....................          { 
....................             return INVALID_SOCKET; 
0144A:  MOVLW  FE
0144C:  MOVWF  01
0144E:  BRA    1466
01450:  MOVLB  1
....................          }    
....................          #endif 
....................       } 
....................        
....................       return hTCP;       
01452:  MOVLB  3
01454:  MOVFF  3CB,01
01458:  BRA    1466
0145A:  MOVLB  1
0145C:  MOVLB  3
0145E:  INCF   xCB,F
01460:  BRA    13F8
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    return INVALID_SOCKET; 
01462:  MOVLW  FE
01464:  MOVWF  01
01466:  MOVLB  0
01468:  GOTO   14B6 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPWasReset(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Self-clearing semaphore inidicating socket reset. 
....................  
....................   Description: 
....................    This function is a self-clearing semaphore indicating whether or not 
....................    a socket has been disconnected since the previous call.  This function 
....................    works for all possible disconnections: a call to TCPDisconnect, a FIN  
....................    from the remote node, or an acknowledgement timeout caused by the loss 
....................    of a network link.  It also returns TRUE after the first call to TCPInit. 
....................    Applications should use this function to reset their state machines. 
....................     
....................    This function was added due to the possibility of an error when relying 
....................    on TCPIsConnected returing FALSE to check for a condition requiring a 
....................    state machine reset.  If a socket is closed (due to a FIN ACK) and then 
....................    immediately reopened (due to a the arrival of a new SYN) in the same 
....................    cycle of the stack, calls to TCPIsConnected by the application will  
....................    never return FALSE even though the socket has been disconnected.  This  
....................    can cause errors for protocols such as HTTP in which a client will  
....................    immediately open a new connection upon closing of a prior one.  Relying 
....................    on this function instead allows applications to trap those conditions  
....................    and properly reset their internal state for the new connection. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has been disconnected since the previous call. 
....................      FALSE - The socket has not been disconnected since the previous call. 
....................   ***************************************************************************/ 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return TRUE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.Flags.bSocketReset) 
....................    { 
....................       MyTCBStub.Flags.bSocketReset = 0; 
....................       return TRUE; 
....................    }    
....................     
....................    return FALSE; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsConnected(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a socket has an established connection. 
....................  
....................   Description: 
....................    This function determines if a socket has an established connection to  
....................    a remote node.  Call this function after calling TCPOpen to determine  
....................    when the connection is set up and ready for use.  This function was  
....................    historically used to check for disconnections, but TCPWasReset is now a 
....................    more appropriate solution.  
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has an established connection to a remote node. 
....................      FALSE - The socket is not currently connected. 
....................  
....................   Remarks: 
....................    A socket is said to be connected only if it is in the TCP_ESTABLISHED 
....................    state.  Sockets in the process of opening or closing will return FALSE. 
....................   ***************************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
06DB2:  MOVLB  3
06DB4:  MOVF   xCE,W
06DB6:  SUBLW  00
06DB8:  BC    6DC0
....................     { 
....................         return FALSE; 
06DBA:  MOVLW  00
06DBC:  MOVWF  01
06DBE:  BRA    6DDC
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
06DC0:  MOVFF  3CE,3FE
06DC4:  MOVLB  0
06DC6:  CALL   0A4A
....................    return (MyTCBStub.smState == TCP_ESTABLISHED); 
06DCA:  MOVLB  1
06DCC:  MOVF   xF4,W
06DCE:  SUBLW  07
06DD0:  BZ    6DD6
06DD2:  MOVLW  00
06DD4:  BRA    6DD8
06DD6:  MOVLW  01
06DD8:  MOVWF  01
06DDA:  MOVLB  3
06DDC:  MOVLB  0
06DDE:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDisconnect(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket. 
....................  
....................   Description: 
....................    This function closes a connection to a remote node by sending a FIN (if  
....................    currently connected). 
....................     
....................    The function can be called a second time to force a socket closed by  
....................    sending a RST packet.  This is useful when the application knows that  
....................    the remote node will not send an ACK (if it has crashed or lost its link), 
....................    or when the application needs to reuse the socket immediately regardless 
....................    of whether or not the remote node would like to transmit more data before 
....................    closing. 
....................     
....................    For client mode sockets, upon return, the hTCP handle is relinquished to  
....................    the TCP/IP stack and must no longer be used by the application (except for  
....................    an immediate subsequent call to TCPDisconnect() to force a RST  
....................    transmission, if needed).   
....................     
....................    For server mode sockets, upon return, the hTCP handle is NOT relinquished  
....................    to the TCP/IP stack.  After closing, the socket returns to the listening  
....................    state allowing future connection requests to be serviced.  This leaves the  
....................    hTCP handle in a valid state and must be retained for future operations on  
....................    the socket.  If you want to close the server and relinquish the socket back  
....................    to the TCP/IP stack, call the TCPClose() API instead of TCPDisconnect(). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle of the socket to disconnect. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted 
....................    first to allow the SSL session to be resumed at a later time. 
....................   ***************************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
03C3E:  MOVLB  3
03C40:  MOVF   xCE,W
03C42:  SUBLW  00
03C44:  BC    3C48
....................     { 
....................         return; 
03C46:  BRA    3D24
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
03C48:  MOVFF  3CE,3FE
03C4C:  MOVLB  0
03C4E:  CALL   0A4A
....................  
....................    // Delete all data in the RX FIFO 
....................    // In this stack's API, the application TCP handle is  
....................    // immediately invalid after calling this function, so there  
....................    // is no longer any way to receive data from the TCP RX FIFO,  
....................    // even though the data is still there.  Leaving the data there  
....................    // could interfere with the remote node sending us a FIN if our 
....................    // RX window is zero 
....................    MyTCBStub.rxTail = MyTCBStub.rxHead; 
03C52:  MOVFF  1E9,1EB
03C56:  MOVFF  1E8,1EA
....................  
....................    switch(MyTCBStub.smState) 
03C5A:  MOVLB  1
03C5C:  MOVF   xF4,W
03C5E:  XORLW  00
03C60:  MOVLB  0
03C62:  BZ    3C8E
03C64:  XORLW  02
03C66:  BZ    3C8E
03C68:  XORLW  01
03C6A:  BZ    3C8E
03C6C:  XORLW  06
03C6E:  BZ    3C8E
03C70:  XORLW  03
03C72:  BZ    3C94
03C74:  XORLW  01
03C76:  BZ    3C94
03C78:  XORLW  0C
03C7A:  BZ    3CCE
03C7C:  XORLW  05
03C7E:  BZ    3D08
03C80:  XORLW  06
03C82:  BZ    3D12
03C84:  XORLW  01
03C86:  BZ    3D12
03C88:  XORLW  05
03C8A:  BZ    3D12
03C8C:  BRA    3D12
....................    { 
....................       #if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS) 
....................       case TCP_DNS_RESOLVE: 
....................          DNSEndUsage();   // Release the DNS module, since the user is aborting 
....................          CloseSocket(); 
....................          break; 
....................       #endif 
....................  
....................       case TCP_GET_DNS_MODULE: 
....................       case TCP_GATEWAY_SEND_ARP: 
....................       case TCP_GATEWAY_GET_ARP: 
....................       case TCP_SYN_SENT: 
....................          CloseSocket(); 
03C8E:  CALL   112A
....................          break; 
03C92:  BRA    3D22
....................  
....................       case TCP_SYN_RECEIVED: 
....................       case TCP_ESTABLISHED: 
....................          #if defined(STACK_USE_SSL) 
....................          // When disconnecting SSL sockets, send a close_notify so we can resume later 
....................          if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          { 
....................             // Flush pending data and send close_notify 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, SSL_ALERT_CLOSE_NOTIFY); 
....................          } 
....................          #endif 
....................  
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
03C94:  MOVLW  11
03C96:  MOVLB  4
03C98:  MOVWF  x14
03C9A:  MOVLW  01
03C9C:  MOVWF  x15
03C9E:  MOVLB  0
03CA0:  RCALL  3620
....................             if(MyTCB.remoteWindow == 0u) 
03CA2:  MOVLB  1
03CA4:  MOVF   x8C,F
03CA6:  BNZ   3CAE
03CA8:  MOVF   x8D,F
03CAA:  BNZ   3CAE
....................                break; 
03CAC:  BRA    3CC6
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
03CAE:  MOVF   x86,W
03CB0:  SUBWF  xE4,W
03CB2:  BTFSC  FD8.2
03CB4:  BRA    3CBA
03CB6:  MOVLB  0
03CB8:  BRA    3C94
03CBA:  MOVF   x87,W
03CBC:  SUBWF  xE5,W
03CBE:  BTFSC  FD8.2
03CC0:  BRA    3CC6
03CC2:  MOVLB  0
03CC4:  BRA    3C94
....................           
....................          MyTCBStub.smState = TCP_FIN_WAIT_1; 
03CC6:  MOVLW  08
03CC8:  MOVWF  xF4
....................          break; 
03CCA:  MOVLB  0
03CCC:  BRA    3D22
....................  
....................       case TCP_CLOSE_WAIT: 
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
03CCE:  MOVLW  11
03CD0:  MOVLB  4
03CD2:  MOVWF  x14
03CD4:  MOVLW  01
03CD6:  MOVWF  x15
03CD8:  MOVLB  0
03CDA:  RCALL  3620
....................             if(MyTCB.remoteWindow == 0u) 
03CDC:  MOVLB  1
03CDE:  MOVF   x8C,F
03CE0:  BNZ   3CE8
03CE2:  MOVF   x8D,F
03CE4:  BNZ   3CE8
....................                break; 
03CE6:  BRA    3D00
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
03CE8:  MOVF   x86,W
03CEA:  SUBWF  xE4,W
03CEC:  BTFSC  FD8.2
03CEE:  BRA    3CF4
03CF0:  MOVLB  0
03CF2:  BRA    3CCE
03CF4:  MOVF   x87,W
03CF6:  SUBWF  xE5,W
03CF8:  BTFSC  FD8.2
03CFA:  BRA    3D00
03CFC:  MOVLB  0
03CFE:  BRA    3CCE
....................  
....................          MyTCBStub.smState = TCP_LAST_ACK; 
03D00:  MOVLW  0C
03D02:  MOVWF  xF4
....................          break; 
03D04:  MOVLB  0
03D06:  BRA    3D22
....................           
....................       // These states are all already closed or don't need explicit disconnecting -- they will disconnect by themselves after a while 
....................       //case TCP_CLOSED: 
....................       //case TCP_LISTEN: 
....................       //case TCP_CLOSING: 
....................       //case TCP_TIME_WAIT: 
....................       //   return; 
....................  
....................       case TCP_CLOSED_BUT_RESERVED: 
....................          MyTCBStub.smState = TCP_CLOSED; 
03D08:  MOVLW  0D
03D0A:  MOVLB  1
03D0C:  MOVWF  xF4
....................          break; 
03D0E:  MOVLB  0
03D10:  BRA    3D22
....................  
....................       // These states will close themselves after some delay, however,  
....................       // this is handled so that the user can call TCPDisconnect()  
....................       // twice to immediately close a socket (using an RST) without  
....................       // having to get an ACK back from the remote node.  This is  
....................       // great for instance when the application determines that  
....................       // the remote node has been physically disconnected and  
....................       // already knows that no ACK will be returned.  Alternatively,  
....................       // if the application needs to immediately reuse the socket  
....................       // regardless of what the other node's state is in (half open). 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_LAST_ACK: 
....................       default: 
....................          SendTCP(RST | ACK, 0); 
03D12:  MOVLW  14
03D14:  MOVLB  4
03D16:  MOVWF  x14
03D18:  CLRF   x15
03D1A:  MOVLB  0
03D1C:  RCALL  3620
....................          CloseSocket(); 
03D1E:  CALL   112A
....................          break; 
03D22:  MOVLB  3
....................    } 
03D24:  MOVLB  0
03D26:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPClose(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles. 
....................  
....................   Description: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles.  This function performs identically to the  
....................    TCPDisconnect() function, except that both client and server mode socket  
....................    handles are relinquished to the TCP/IP stack upon return. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle to the socket to disconnect and close. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPClose(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bServer = FALSE; 
....................    TCPDisconnect(hTCP); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Obtains information about a currently open socket. 
....................  
....................   Description: 
....................    Returns the SOCKET_INFO structure associated with this socket.  This  
....................    contains the NODE_INFO structure with IP and MAC address (or gateway 
....................    MAC) and the remote port. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The SOCKET_INFO structure associated with this socket.  This structure is  
....................    allocated statically by the function and is valid only until the next  
....................    time TCPGetRemoteInfo() is called. 
....................   ***************************************************************************/ 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
.................... { 
....................    static SOCKET_INFO   RemoteInfo; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................    memcpy((void*)&RemoteInfo.remote, (void*)&MyTCB.remote, sizeof(NODE_INFO)); 
....................    RemoteInfo.remotePort.Val = MyTCB.remotePort.Val; 
....................  
....................    return &RemoteInfo; 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Transmit Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPFlush(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Immediately transmits all pending TX data. 
....................  
....................   Description: 
....................    This function immediately transmits all pending TX data with a PSH  
....................    flag.  If this function is not called, data will automatically be sent 
....................    when either a) the TX buffer is half full or b) the  
....................    TCP_AUTO_TRANSMIT_TIMEOUT_VAL (default: 40ms) has elapsed. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose data is to be transmitted. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    SSL application data is automatically flushed, so this function has  
....................    no effect for SSL sockets. 
....................   ***************************************************************************/ 
.................... void TCPFlush(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
083A4:  MOVLB  3
083A6:  MOVF   xFC,W
083A8:  SUBLW  00
083AA:  BC    83AE
....................     { 
....................         return; 
083AC:  BRA    83DE
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
083AE:  MOVFF  3FC,3FE
083B2:  MOVLB  0
083B4:  CALL   0A4A
....................    SyncTCB(); 
083B8:  CALL   1052
....................  
....................    // NOTE: Pending SSL data will NOT be transferred here 
....................  
....................    if(MyTCBStub.txHead != MyTCB.txUnackedTail) 
083BC:  MOVLB  1
083BE:  MOVF   x86,W
083C0:  SUBWF  xE4,W
083C2:  BNZ   83CA
083C4:  MOVF   x87,W
083C6:  SUBWF  xE5,W
083C8:  BZ    83DC
....................    { 
....................       // Send the TCP segment with all unacked bytes 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
083CA:  MOVLW  10
083CC:  MOVLB  4
083CE:  MOVWF  x14
083D0:  MOVLW  01
083D2:  MOVWF  x15
083D4:  MOVLB  0
083D6:  CALL   3620
083DA:  MOVLB  1
083DC:  MOVLB  3
....................    } 
083DE:  MOVLB  0
083E0:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPIsPutReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how much free space is available in the TCP TX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be written to the  
....................    TCP TX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to transmit 
....................    more data. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be written in the TCP TX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
082F6:  MOVLB  3
082F8:  MOVF   xFC,W
082FA:  SUBLW  00
082FC:  BC    8306
....................     { 
....................         return 0; 
082FE:  MOVLW  00
08300:  MOVWF  01
08302:  MOVWF  02
08304:  BRA    83A0
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
08306:  MOVFF  3FC,3FE
0830A:  MOVLB  0
0830C:  CALL   0A4A
....................  
....................    i = MyTCBStub.smState; 
08310:  MOVFF  1F4,3FD
....................  
....................    // Unconnected sockets shouldn't be transmitting anything. 
....................    if(!( (i == (BYTE)TCP_ESTABLISHED) || (i == (BYTE)TCP_CLOSE_WAIT) )) 
08314:  MOVLB  3
08316:  MOVF   xFD,W
08318:  SUBLW  07
0831A:  BZ    832A
0831C:  MOVF   xFD,W
0831E:  SUBLW  0B
08320:  BZ    832A
....................       return 0; 
08322:  MOVLW  00
08324:  MOVWF  01
08326:  MOVWF  02
08328:  BRA    83A0
....................  
....................    // Calculate the free space in this socket's TX FIFO 
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    {// Use sslTxHead as the head pointer when SSL is active 
....................       WORD rem; 
....................        
....................       // Find out raw free space 
....................       if(MyTCBStub.sslTxHead >= MyTCBStub.txTail) 
....................          rem = (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.sslTxHead - MyTCBStub.txTail); 
....................       else 
....................          rem = MyTCBStub.txTail - MyTCBStub.sslTxHead - 1; 
....................           
....................       // Reserve space for a new MAC and header 
....................       if(rem > 22u) 
....................          return rem - 22; 
....................       else 
....................          return 0; 
....................    } 
....................    #endif 
....................     
....................    if(MyTCBStub.txHead >= MyTCBStub.txTail) 
0832A:  MOVLB  1
0832C:  MOVF   xE7,W
0832E:  SUBWF  xE5,W
08330:  BNC   837C
08332:  BNZ   833A
08334:  MOVF   xE6,W
08336:  SUBWF  xE4,W
08338:  BNC   837C
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail); 
0833A:  MOVF   xDE,W
0833C:  SUBWF  xE0,W
0833E:  MOVLB  3
08340:  MOVWF  xFE
08342:  MOVLB  1
08344:  MOVF   xDF,W
08346:  SUBWFB xE1,W
08348:  MOVLB  3
0834A:  MOVWF  xFF
0834C:  MOVLW  01
0834E:  SUBWF  xFE,F
08350:  MOVLW  00
08352:  SUBWFB xFF,F
08354:  MOVLB  1
08356:  MOVF   xE6,W
08358:  SUBWF  xE4,W
0835A:  MOVWF  00
0835C:  MOVF   xE7,W
0835E:  SUBWFB xE5,W
08360:  MOVWF  03
08362:  MOVF   00,W
08364:  MOVLB  3
08366:  SUBWF  xFE,W
08368:  MOVWF  00
0836A:  MOVF   03,W
0836C:  SUBWFB xFF,W
0836E:  MOVWF  03
08370:  MOVFF  00,01
08374:  MOVWF  02
08376:  BRA    83A0
08378:  BRA    83A0
0837A:  MOVLB  1
....................    else 
....................       return MyTCBStub.txTail - MyTCBStub.txHead - 1; 
0837C:  MOVF   xE4,W
0837E:  SUBWF  xE6,W
08380:  MOVLB  3
08382:  MOVWF  xFE
08384:  MOVLB  1
08386:  MOVF   xE5,W
08388:  SUBWFB xE7,W
0838A:  MOVLB  3
0838C:  MOVWF  xFF
0838E:  MOVLW  01
08390:  SUBWF  xFE,W
08392:  MOVWF  00
08394:  MOVLW  00
08396:  SUBWFB xFF,W
08398:  MOVWF  03
0839A:  MOVFF  00,01
0839E:  MOVWF  02
083A0:  MOVLB  0
083A2:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
....................  
....................   Description: 
....................    Writes a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    byte - The byte to write. 
....................  
....................   Return Values: 
....................    TRUE - The byte was written to the transmit buffer. 
....................    FALSE - The transmit buffer was full, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
.................... { 
....................    WORD wFreeTXSpace; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
083E2:  MOVLB  3
083E4:  MOVF   xF8,W
083E6:  SUBLW  00
083E8:  BC    83F0
....................     { 
....................         return 0; 
083EA:  MOVLW  00
083EC:  MOVWF  01
083EE:  BRA    8500
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
083F0:  MOVFF  3F8,3FE
083F4:  MOVLB  0
083F6:  CALL   0A4A
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
083FA:  MOVFF  3F8,3FC
083FE:  RCALL  82F6
08400:  MOVFF  02,3FB
08404:  MOVFF  01,3FA
....................    if(wFreeTXSpace == 0u) 
08408:  MOVLB  3
0840A:  MOVF   xFA,F
0840C:  BNZ   841A
0840E:  MOVF   xFB,F
08410:  BNZ   841A
....................       return FALSE; 
08412:  MOVLW  00
08414:  MOVWF  01
08416:  BRA    8500
08418:  BRA    842C
....................    else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster 
0841A:  DECFSZ xFA,W
0841C:  BRA    842C
0841E:  MOVF   xFB,F
08420:  BNZ   842C
....................       TCPFlush(hTCP);    
08422:  MOVFF  3F8,3FC
08426:  MOVLB  0
08428:  RCALL  83A4
0842A:  MOVLB  3
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
0842C:  MOVLB  1
0842E:  BTFSC  xF6.0
08430:  BRA    8476
08432:  MOVF   xDE,W
08434:  SUBWF  xE0,W
08436:  MOVLB  3
08438:  MOVWF  xFC
0843A:  MOVLB  1
0843C:  MOVF   xDF,W
0843E:  SUBWFB xE1,W
08440:  MOVLB  3
08442:  MOVWF  xFD
08444:  BCF    FD8.0
08446:  RRCF   xFD,W
08448:  MOVWF  03
0844A:  RRCF   xFC,W
0844C:  MOVWF  02
0844E:  MOVWF  01
08450:  MOVF   xFB,W
08452:  SUBWF  03,W
08454:  BTFSC  FD8.0
08456:  BRA    845C
08458:  MOVLB  1
0845A:  BRA    8476
0845C:  BNZ   846A
0845E:  MOVF   xFA,W
08460:  SUBWF  01,W
08462:  BTFSC  FD8.0
08464:  BRA    846A
08466:  MOVLB  1
08468:  BRA    8476
....................    { 
....................       TCPFlush(hTCP);    
0846A:  MOVFF  3F8,3FC
0846E:  MOVLB  0
08470:  RCALL  83A4
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
08472:  MOVLB  1
08474:  BSF    xF6.0
....................    } 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    else 
....................    { 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    #else 
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
08476:  MOVLW  03
08478:  MOVLB  3
0847A:  MOVWF  xFD
0847C:  MOVLW  F9
0847E:  MOVWF  xFC
08480:  MOVFF  1E5,446
08484:  MOVFF  1E4,445
08488:  MOVFF  1F9,447
0848C:  MOVFF  3FD,449
08490:  MOVFF  FE8,448
08494:  MOVLW  01
08496:  MOVLB  4
08498:  MOVWF  x4A
0849A:  CLRF   x4C
0849C:  MOVWF  x4B
0849E:  MOVLB  0
084A0:  CALL   0F6C
....................    if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
084A4:  MOVLB  1
084A6:  INCF   xE4,F
084A8:  BTFSC  FD8.2
084AA:  INCF   xE5,F
084AC:  MOVF   xE1,W
084AE:  SUBWF  xE5,W
084B0:  BNC   84C2
084B2:  BNZ   84BA
084B4:  MOVF   xE0,W
084B6:  SUBWF  xE4,W
084B8:  BNC   84C2
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
084BA:  MOVFF  1DF,1E5
084BE:  MOVFF  1DE,1E4
....................    #endif 
....................     
....................  
....................    // Send the last byte as a separate packet (likely will make the remote node send back ACK faster) 
....................    if(wFreeTXSpace == 1u) 
084C2:  MOVLB  3
084C4:  DECFSZ xFA,W
084C6:  BRA    84D6
084C8:  MOVF   xFB,F
084CA:  BNZ   84D6
....................    { 
....................       TCPFlush(hTCP); 
084CC:  MOVFF  3F8,3FC
084D0:  MOVLB  0
084D2:  RCALL  83A4
....................    } 
084D4:  BRA    84FA
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
084D6:  MOVLB  1
084D8:  BTFSC  xF5.5
084DA:  BRA    84F8
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
084DC:  BSF    xF5.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
084DE:  MOVLB  0
084E0:  CALL   2FD6
084E4:  MOVLW  03
084E6:  MOVLB  3
084E8:  ADDWF  00,W
084EA:  MOVLB  1
084EC:  MOVWF  xF0
084EE:  MOVLW  00
084F0:  MOVLB  3
084F2:  ADDWFC 01,W
084F4:  MOVLB  1
084F6:  MOVWF  xF1
084F8:  MOVLB  0
....................    } 
....................  
....................    return TRUE; 
084FA:  MOVLW  01
084FC:  MOVWF  01
084FE:  MOVLB  3
08500:  MOVLB  0
08502:  GOTO   8510 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from RAM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from ROM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................  
....................   Remarks: 
....................    This function is aliased to TCPPutArray on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from RAM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................   ***************************************************************************/ 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
.................... { 
....................    return data + TCPPutArray(hTCP, data, strlen((char*)data)); 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from ROM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................     
....................    This function is aliased to TCPPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
.................... { 
....................    return data + TCPPutROMArray(hTCP, data, strlenpgm((ROM char*)data)); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are pending in the TCP TX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    Number of bytes pending to be flushed in the TCP TX FIFO. 
....................   ***************************************************************************/ 
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
098B6:  MOVLB  3
098B8:  MOVF   xCE,W
098BA:  SUBLW  00
098BC:  BC    98C6
....................     { 
....................         return 0; 
098BE:  MOVLW  00
098C0:  MOVWF  01
098C2:  MOVWF  02
098C4:  BRA    9916
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
098C6:  MOVFF  3CE,3FE
098CA:  MOVLB  0
098CC:  CALL   0A4A
....................  
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1; 
098D0:  MOVLB  1
098D2:  MOVF   xDE,W
098D4:  SUBWF  xE0,W
098D6:  MOVLB  3
098D8:  MOVWF  xD3
098DA:  MOVLB  1
098DC:  MOVF   xDF,W
098DE:  SUBWFB xE1,W
098E0:  MOVLB  3
098E2:  MOVWF  xD4
098E4:  MOVLW  01
098E6:  SUBWF  xD3,W
098E8:  MOVWF  xD1
098EA:  MOVLW  00
098EC:  SUBWFB xD4,W
098EE:  MOVWF  xD2
....................  
....................    // Find out how many data bytes are free in the TX FIFO 
....................    wDataLen = TCPIsPutReady(hTCP); 
098F0:  MOVFF  3CE,3FC
098F4:  MOVLB  0
098F6:  CALL   82F6
098FA:  MOVFF  02,3D0
098FE:  MOVFF  01,3CF
....................  
....................    return wFIFOSize - wDataLen; 
09902:  MOVLB  3
09904:  MOVF   xCF,W
09906:  SUBWF  xD1,W
09908:  MOVWF  00
0990A:  MOVF   xD0,W
0990C:  SUBWFB xD2,W
0990E:  MOVWF  03
09910:  MOVFF  00,01
09914:  MOVWF  02
09916:  MOVLB  0
09918:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Receive Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDiscard(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Discards any pending data in the TCP RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose RX FIFO is to be cleared. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPDiscard(TCP_SOCKET hTCP) 
.................... { 
....................    if(TCPIsGetReady(hTCP)) 
*
08118:  MOVFF  3CE,3D3
0811C:  CALL   6DE0
08120:  MOVF   01,W
08122:  IORWF  02,W
08124:  BZ    8146
....................    { 
....................       SyncTCBStub(hTCP); 
08126:  MOVFF  3CE,3FE
0812A:  CALL   0A4A
....................     
....................       // Delete all data in the RX buffer 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
0812E:  MOVFF  1E9,1EB
08132:  MOVFF  1E8,1EA
....................     
....................       // Send a Window update message to the remote node 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
08136:  MOVLW  10
08138:  MOVLB  4
0813A:  MOVWF  x14
0813C:  MOVLW  01
0813E:  MOVWF  x15
08140:  MOVLB  0
08142:  CALL   3620
....................    } 
08146:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void WORD TCPIsGetReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes can be read from the TCP RX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be read from the  
....................    TCP RX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to wait for 
....................    more data to arrive. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be read from the TCP RX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
06DE0:  MOVLB  3
06DE2:  MOVF   xD3,W
06DE4:  SUBLW  00
06DE6:  BC    6DF0
....................     { 
....................         return 0; 
06DE8:  MOVLW  00
06DEA:  MOVWF  01
06DEC:  MOVWF  02
06DEE:  BRA    6E5C
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
06DF0:  MOVFF  3D3,3FE
06DF4:  MOVLB  0
06DF6:  CALL   0A4A
....................        
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
06DFA:  MOVLB  1
06DFC:  MOVF   xEB,W
06DFE:  SUBWF  xE9,W
06E00:  BNC   6E24
06E02:  BNZ   6E0A
06E04:  MOVF   xEA,W
06E06:  SUBWF  xE8,W
06E08:  BNC   6E24
....................       return MyTCBStub.rxHead - MyTCBStub.rxTail; 
06E0A:  MOVF   xEA,W
06E0C:  SUBWF  xE8,W
06E0E:  MOVWF  00
06E10:  MOVF   xEB,W
06E12:  SUBWFB xE9,W
06E14:  MOVWF  03
06E16:  MOVFF  00,01
06E1A:  MOVWF  02
06E1C:  MOVLB  3
06E1E:  BRA    6E5C
06E20:  BRA    6E5C
06E22:  MOVLB  1
....................    else 
....................       return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart); 
06E24:  MOVF   xEA,W
06E26:  SUBWF  xE2,W
06E28:  MOVLB  3
06E2A:  MOVWF  xD4
06E2C:  MOVLB  1
06E2E:  MOVF   xEB,W
06E30:  SUBWFB xE3,W
06E32:  MOVLB  3
06E34:  MOVWF  xD5
06E36:  MOVLW  01
06E38:  ADDWF  xD4,F
06E3A:  MOVLW  00
06E3C:  ADDWFC xD5,F
06E3E:  MOVLB  1
06E40:  MOVF   xE0,W
06E42:  SUBWF  xE8,W
06E44:  MOVWF  00
06E46:  MOVF   xE1,W
06E48:  SUBWFB xE9,W
06E4A:  MOVWF  03
06E4C:  MOVF   00,W
06E4E:  MOVLB  3
06E50:  ADDWF  xD4,W
06E52:  MOVWF  01
06E54:  MOVF   xD5,W
06E56:  ADDWFC 03,F
06E58:  MOVFF  03,02
06E5C:  MOVLB  0
06E5E:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
....................  
....................   Description: 
....................    Retrieves a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which to read. 
....................    byte - Pointer to location in which the read byte should be stored. 
....................  
....................   Return Values: 
....................    TRUE - A byte was read from the buffer. 
....................    FALSE - The buffer was empty, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
.................... { 
....................    WORD wGetReadyCount; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
06E60:  MOVFF  3CE,3D3
06E64:  RCALL  6DE0
06E66:  MOVFF  02,3D2
06E6A:  MOVFF  01,3D1
....................    if(wGetReadyCount == 0u) 
06E6E:  MOVLB  3
06E70:  MOVF   xD1,F
06E72:  BNZ   6E7E
06E74:  MOVF   xD2,F
06E76:  BNZ   6E7E
....................       return FALSE; 
06E78:  MOVLW  00
06E7A:  MOVWF  01
06E7C:  BRA    6F0C
....................  
....................    SyncTCBStub(hTCP); 
06E7E:  MOVFF  3CE,3FE
06E82:  MOVLB  0
06E84:  CALL   0A4A
....................     
....................    if(byte) 
06E88:  MOVLB  3
06E8A:  MOVF   xCF,W
06E8C:  IORWF  xD0,W
06E8E:  BZ    6EB6
....................       TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1); 
06E90:  MOVFF  3D0,446
06E94:  MOVFF  3CF,445
06E98:  MOVLW  01
06E9A:  MOVLB  4
06E9C:  MOVWF  x47
06E9E:  MOVFF  1EB,449
06EA2:  MOVFF  1EA,448
06EA6:  MOVFF  1F9,44A
06EAA:  CLRF   x4C
06EAC:  MOVWF  x4B
06EAE:  MOVLB  0
06EB0:  CALL   0F6C
06EB4:  MOVLB  3
....................    if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
06EB6:  MOVLB  1
06EB8:  INCF   xEA,F
06EBA:  BTFSC  FD8.2
06EBC:  INCF   xEB,F
06EBE:  MOVF   xE3,W
06EC0:  SUBWF  xEB,W
06EC2:  BNC   6ED4
06EC4:  BNZ   6ECC
06EC6:  MOVF   xEA,W
06EC8:  SUBWF  xE2,W
06ECA:  BC    6ED4
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
06ECC:  MOVFF  1E1,1EB
06ED0:  MOVFF  1E0,1EA
....................  
....................    // Send a window update if we've run out of data 
....................    if(wGetReadyCount == 1u) 
06ED4:  MOVLB  3
06ED6:  DECFSZ xD1,W
06ED8:  BRA    6EE4
06EDA:  MOVF   xD2,F
06EDC:  BNZ   6EE4
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
06EDE:  MOVLB  1
06EE0:  BSF    xF6.2
....................    } 
06EE2:  BRA    6F06
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
06EE4:  MOVLB  1
06EE6:  BTFSC  xF5.5
06EE8:  BRA    6F06
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
06EEA:  BSF    xF5.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
06EEC:  MOVLB  0
06EEE:  CALL   2FD6
06EF2:  MOVLW  0F
06EF4:  MOVLB  3
06EF6:  ADDWF  00,W
06EF8:  MOVLB  1
06EFA:  MOVWF  xF0
06EFC:  MOVLW  00
06EFE:  MOVLB  3
06F00:  ADDWFC 01,W
06F02:  MOVLB  1
06F04:  MOVWF  xF1
....................    } 
....................  
....................  
....................    return TRUE; 
06F06:  MOVLW  01
06F08:  MOVWF  01
06F0A:  MOVLB  3
06F0C:  MOVLB  0
06F0E:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
....................  
....................   Description: 
....................    Reads an array of data bytes from a TCP socket's receive FIFO.  The data  
....................    is removed from the FIFO in the process. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which data is to be read. 
....................    buffer - Pointer to the array to store data that was read. 
....................    len  - Number of bytes to be read. 
....................  
....................   Returns: 
....................    The number of bytes read from the socket.  If less than len, the 
....................    RX FIFO buffer became empty or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
.................... { 
....................    WORD wGetReadyCount; 
....................    WORD RightLen = 0; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
....................    if(wGetReadyCount == 0u) 
....................       return 0x0000u; 
....................  
....................    SyncTCBStub(hTCP); 
....................  
....................    // Make sure we don't try to read more data than is available 
....................    if(len > wGetReadyCount) 
....................       len = wGetReadyCount; 
....................  
....................    // See if we need a two part get 
....................    if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd) 
....................    { 
....................       RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1; 
....................       if(buffer) 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen); 
....................          buffer += RightLen; 
....................       } 
....................       len -= RightLen; 
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
....................    } 
....................  
....................    if(buffer) 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len); 
....................    MyTCBStub.rxTail += len; 
....................    len += RightLen; 
....................  
....................    // Send a window update if we've run low on data 
....................    if(wGetReadyCount - len <= len) 
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
....................    } 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are free in the RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes free in the TCP RX FIFO.  If zero, no additional  
....................    data can be received until the application removes some data using one 
....................    of the TCPGet family functions. 
....................   ***************************************************************************/ 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart; 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    { 
....................       PTR_BASE SSLtemp = MyTCBStub.rxHead; 
....................  
....................       // Move SSL pointer to determine full buffer size 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................  
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................        
....................       // Move SSL pointer back to proper location (if we changed it) 
....................       MyTCBStub.rxHead = SSLtemp; 
....................    } 
....................    #else 
....................    { 
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................    } 
....................    #endif 
....................     
....................    // Perform the calculation    
....................    return wFIFOSize - wDataLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
....................  
....................   Summary: 
....................      Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer. 
....................  
....................   Description: 
....................    Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer.  No TCP control actions are taken as a  
....................      result of this function (ex: no window update is sent to the remote node). 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    vBuffer - Destination to write the peeked data bytes. 
....................    wLen - Length of bytes to peak from the RX FIFO and copy to vBuffer. 
....................    wStart - Zero-indexed starting position within the FIFO to start peeking  
....................       from. 
....................  
....................   Return Values: 
....................    Number of bytes actually peeked from the stream and copied to vBuffer.   
....................    This value can be less than wLen if wStart + wLen is greater than the  
....................    deepest possible character in the RX FIFO. 
....................  
....................   Remarks: 
....................      None 
....................   ***************************************************************************/ 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD w; 
....................    WORD wBytesUntilWrap; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and decrease read length  
....................    // if the start offset + read length is beyond the end of the FIFO 
....................    w = TCPIsGetReady(hTCP); 
....................    if(wStart + wLen > w) 
....................       wLen = w - wStart; 
....................  
....................    // Find the read start location 
....................    ptrRead = MyTCBStub.rxTail + wStart; 
....................    if(ptrRead > MyTCBStub.bufferEnd) 
....................       ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................  
....................    // Calculate how many bytes can be read in a single go 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1; 
....................    if(wLen <= wBytesUntilWrap) 
....................    { 
....................       // Read all at once 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen); 
....................    } 
....................    else 
....................    { 
....................       // Read all bytes up to the wrap position and then read remaining bytes  
....................       // at the start of the buffer 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap); 
....................       TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap); 
....................    } 
....................     
....................    return wLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
....................  
....................   Summary: 
....................      Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................  
....................   Description: 
....................    Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    wStart - Zero-indexed starting position within the FIFO to peek from. 
....................  
....................   Return Values: 
....................    Byte peeked from the RX FIFO.  If there is no data in the buffer or an  
....................    illegal wStart starting offset is given, then an indeterminate value is  
....................    returned.  The caller must ensure that valid parameters are passed to avoid  
....................    (i.e ensure that TCPIsGetReady() returns a number that is less than wStart  
....................    before calling TCPPeek()). 
....................  
....................   Remarks: 
....................      Use the TCPPeekArray() function to read more than one byte.  It will  
....................      perform better than calling TCPPeek() in a loop. 
....................   ***************************************************************************/ 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
.................... { 
....................    BYTE i; 
....................     
....................    TCPPeekArray(hTCP, &i, 1, wStart); 
....................    return i; 
.................... } 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Search Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a ROM string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................     
....................    This function is aliased to TCPFindArrayEx on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    ROM BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, 
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a byte in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of a byte in the TCP RX 
....................    buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the cFind 
....................    byte is ' ', a value of 1 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFind - The byte to find in the buffer. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    return TCPFindArrayEx(hTCP, &cFind, sizeof(cFind), wStart, wSearchLen, bTextCompare); 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Data Processing Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPTick(void) 
....................  
....................   Summary: 
....................      Performs periodic TCP tasks. 
....................  
....................   Description: 
....................    This function performs any required periodic TCP tasks.  Each  
....................    socket's state machine is checked, and any elapsed timeout periods 
....................    are handled. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    BOOL bRetransmit; 
....................    BOOL bCloseSocket; 
....................    BYTE vFlags; 
....................    WORD w; 
....................  
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
03D28:  MOVLB  3
03D2A:  CLRF   xC9
03D2C:  MOVF   xC9,F
03D2E:  BTFSS  FD8.2
03D30:  BRA    43F6
....................    { 
....................       SyncTCBStub(hTCP); 
03D32:  MOVFF  3C9,3FE
03D36:  MOVLB  0
03D38:  CALL   0A4A
....................        
....................       // Handle any SSL Processing and Message Transmission 
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Handle any periodic tasks, such as RSA operations 
....................          SSLPeriodic(hTCP, MyTCBStub.sslStubID); 
....................           
....................          // If unsent data is waiting, transmit it as an application record 
....................          if(MyTCBStub.sslTxHead != MyTCBStub.txHead && TCPSSLGetPendingTxSize(hTCP) != 0u) 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................           
....................          // If an SSL message is requested, send it now 
....................          if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE) 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage); 
....................       } 
....................       #endif 
....................        
....................       vFlags = 0x00; 
03D3C:  MOVLB  3
03D3E:  CLRF   xCB
....................       bRetransmit = FALSE; 
03D40:  BCF    xCA.0
....................       bCloseSocket = FALSE; 
03D42:  BCF    xCA.1
....................  
....................       // Transmit ASAP data if the medium is available 
....................       if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset) 
03D44:  MOVLB  1
03D46:  BTFSC  xF6.1
03D48:  BRA    3D4E
03D4A:  BTFSS  xF6.2
03D4C:  BRA    3D6C
....................       { 
....................          if(MACIsTxReady()) 
03D4E:  MOVLB  0
03D50:  CALL   1786
03D54:  MOVF   01,F
03D56:  BZ    3D6E
....................          { 
....................             vFlags = ACK; 
03D58:  MOVLW  10
03D5A:  MOVLB  3
03D5C:  MOVWF  xCB
....................             bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset; 
03D5E:  BCF    xCA.0
03D60:  MOVLB  1
03D62:  BTFSS  xF6.2
03D64:  BRA    3D6C
03D66:  MOVLB  3
03D68:  BSF    xCA.0
03D6A:  MOVLB  1
03D6C:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // Perform any needed window updates and data transmissions 
....................       if(MyTCBStub.Flags.bTimer2Enabled) 
03D6E:  MOVLB  1
03D70:  BTFSS  xF5.5
03D72:  BRA    3DA4
....................       { 
....................          // See if the timeout has occured, and we need to send a new window update and pending data 
....................          if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0) 
03D74:  MOVLB  0
03D76:  CALL   2FD6
03D7A:  MOVF   00,W
03D7C:  MOVLB  1
03D7E:  SUBWF  xF0,W
03D80:  MOVWF  00
03D82:  MOVF   01,W
03D84:  SUBWFB xF1,W
03D86:  MOVWF  03
03D88:  MOVFF  00,3CE
03D8C:  MOVLB  3
03D8E:  MOVWF  xCF
03D90:  BTFSC  FE8.7
03D92:  BRA    3D9E
03D94:  MOVF   xCF,F
03D96:  BNZ   3DA2
03D98:  MOVF   xCE,W
03D9A:  SUBLW  00
03D9C:  BNC   3DA2
....................             vFlags = ACK; 
03D9E:  MOVLW  10
03DA0:  MOVWF  xCB
03DA2:  MOVLB  1
....................       } 
....................  
....................       // Process Delayed ACKnowledgement timer 
....................       if(MyTCBStub.Flags.bDelayedACKTimerEnabled) 
03DA4:  BTFSS  xF5.6
03DA6:  BRA    3DD8
....................       { 
....................          // See if the timeout has occured and delayed ACK needs to be sent 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
03DA8:  MOVLB  0
03DAA:  CALL   2FD6
03DAE:  MOVF   00,W
03DB0:  MOVLB  1
03DB2:  SUBWF  xF2,W
03DB4:  MOVWF  00
03DB6:  MOVF   01,W
03DB8:  SUBWFB xF3,W
03DBA:  MOVWF  03
03DBC:  MOVFF  00,3CE
03DC0:  MOVLB  3
03DC2:  MOVWF  xCF
03DC4:  BTFSC  FE8.7
03DC6:  BRA    3DD2
03DC8:  MOVF   xCF,F
03DCA:  BNZ   3DD6
03DCC:  MOVF   xCE,W
03DCE:  SUBLW  00
03DD0:  BNC   3DD6
....................             vFlags = ACK; 
03DD2:  MOVLW  10
03DD4:  MOVWF  xCB
03DD6:  MOVLB  1
....................       } 
....................        
....................       // Process TCP_CLOSE_WAIT timer 
....................       if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
03DD8:  MOVF   xF4,W
03DDA:  SUBLW  0B
03DDC:  BNZ   3E12
....................       { 
....................          // Automatically close the socket on our end if the application  
....................          // fails to call TCPDisconnect() is a reasonable amount of time. 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
03DDE:  MOVLB  0
03DE0:  CALL   2FD6
03DE4:  MOVF   00,W
03DE6:  MOVLB  1
03DE8:  SUBWF  xF2,W
03DEA:  MOVWF  00
03DEC:  MOVF   01,W
03DEE:  SUBWFB xF3,W
03DF0:  MOVWF  03
03DF2:  MOVFF  00,3CE
03DF6:  MOVLB  3
03DF8:  MOVWF  xCF
03DFA:  BTFSC  FE8.7
03DFC:  BRA    3E08
03DFE:  MOVF   xCF,F
03E00:  BNZ   3E14
03E02:  MOVF   xCE,W
03E04:  SUBLW  00
03E06:  BNC   3E14
....................          { 
....................             vFlags = FIN | ACK; 
03E08:  MOVLW  11
03E0A:  MOVWF  xCB
....................             MyTCBStub.smState = TCP_LAST_ACK; 
03E0C:  MOVLW  0C
03E0E:  MOVLB  1
03E10:  MOVWF  xF4
03E12:  MOVLB  3
....................          } 
....................       } 
....................  
....................       // Process listening server sockets that might have a SYN waiting in the SYNQueue[] 
....................       #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................          if(MyTCBStub.smState == TCP_LISTEN) 
03E14:  MOVLB  1
03E16:  MOVF   xF4,W
03E18:  SUBLW  04
03E1A:  BTFSS  FD8.2
03E1C:  BRA    40DE
....................          { 
....................             for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
03E1E:  MOVLB  3
03E20:  CLRF   xCD
03E22:  CLRF   xCC
03E24:  MOVF   xCD,F
03E26:  BTFSS  FD8.2
03E28:  BRA    40DC
03E2A:  MOVF   xCC,W
03E2C:  SUBLW  02
03E2E:  BTFSS  FD8.0
03E30:  BRA    40DC
....................             { 
....................                // Abort search if there are no more valid records 
....................                if(SYNQueue[w].wDestPort == 0u) 
03E32:  MOVFF  3CD,3FF
03E36:  MOVFF  3CC,3FE
03E3A:  MOVLB  4
03E3C:  CLRF   x01
03E3E:  MOVLW  14
03E40:  MOVWF  x00
03E42:  MOVLB  0
03E44:  CALL   2FFC
03E48:  MOVFF  01,3CE
03E4C:  MOVLW  10
03E4E:  MOVLB  3
03E50:  ADDWF  01,W
03E52:  MOVWF  01
03E54:  MOVLW  00
03E56:  ADDWFC 02,W
03E58:  MOVWF  03
03E5A:  MOVF   01,W
03E5C:  ADDLW  A2
03E5E:  MOVWF  FE9
03E60:  MOVLW  01
03E62:  ADDWFC 03,W
03E64:  MOVWF  FEA
03E66:  MOVFF  FEC,3CF
03E6A:  MOVF   FED,F
03E6C:  MOVFF  FEF,3CE
03E70:  MOVF   xCE,F
03E72:  BNZ   3E7A
03E74:  MOVF   xCF,F
03E76:  BNZ   3E7A
....................                   break; 
03E78:  BRA    40DC
....................                 
....................                // Stop searching if this SYN queue entry can be used by this socket 
....................                #if defined(STACK_USE_SSL_SERVER) 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead) 
....................                #else 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val) 
03E7A:  MOVFF  3CD,3FF
03E7E:  MOVFF  3CC,3FE
03E82:  MOVLB  4
03E84:  CLRF   x01
03E86:  MOVLW  14
03E88:  MOVWF  x00
03E8A:  MOVLB  0
03E8C:  CALL   2FFC
03E90:  MOVFF  01,3CE
03E94:  MOVLW  10
03E96:  MOVLB  3
03E98:  ADDWF  01,W
03E9A:  MOVWF  01
03E9C:  MOVLW  00
03E9E:  ADDWFC 02,W
03EA0:  MOVWF  03
03EA2:  MOVF   01,W
03EA4:  ADDLW  A2
03EA6:  MOVWF  FE9
03EA8:  MOVLW  01
03EAA:  ADDWFC 03,W
03EAC:  MOVWF  FEA
03EAE:  MOVFF  FEC,3CF
03EB2:  MOVF   FED,F
03EB4:  MOVFF  FEF,3CE
03EB8:  MOVLB  1
03EBA:  MOVF   xF7,W
03EBC:  MOVLB  3
03EBE:  SUBWF  xCE,W
03EC0:  BTFSS  FD8.2
03EC2:  BRA    40D4
03EC4:  MOVLB  1
03EC6:  MOVF   xF8,W
03EC8:  MOVLB  3
03ECA:  SUBWF  xCF,W
03ECC:  BTFSS  FD8.2
03ECE:  BRA    40D4
....................                #endif 
....................                { 
....................                   // Set up our socket and generate a reponse SYN+ACK packet 
....................                   SyncTCB(); 
03ED0:  MOVLB  0
03ED2:  CALL   1052
....................                    
....................                   #if defined(STACK_USE_SSL_SERVER) 
....................                   // If this matches the SSL port, make sure that can be configured 
....................                   // before continuing.  If not, break and leave this in the queue 
....................                   if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP)) 
....................                      break; 
....................                   #endif 
....................                    
....................                   memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO)); 
03ED6:  MOVLW  01
03ED8:  MOVLB  3
03EDA:  MOVWF  xCF
03EDC:  MOVLW  90
03EDE:  MOVWF  xCE
03EE0:  MOVFF  3CD,3FF
03EE4:  MOVFF  3CC,3FE
03EE8:  MOVLB  4
03EEA:  CLRF   x01
03EEC:  MOVLW  14
03EEE:  MOVWF  x00
03EF0:  MOVLB  0
03EF2:  CALL   2FFC
03EF6:  MOVFF  02,3D1
03EFA:  MOVFF  01,3D0
03EFE:  MOVLW  A2
03F00:  MOVLB  3
03F02:  ADDWF  01,W
03F04:  MOVWF  01
03F06:  MOVLW  01
03F08:  ADDWFC 02,W
03F0A:  MOVWF  03
03F0C:  MOVFF  01,3D2
03F10:  MOVWF  xD3
03F12:  MOVFF  3CF,FEA
03F16:  MOVFF  3CE,FE9
03F1A:  MOVWF  FE2
03F1C:  MOVFF  01,FE1
03F20:  MOVLW  0A
03F22:  MOVWF  01
03F24:  MOVFF  FE6,FEE
03F28:  DECFSZ 01,F
03F2A:  BRA    3F24
....................                   MyTCB.remotePort.Val = SYNQueue[w].wSourcePort; 
03F2C:  MOVFF  3CD,3FF
03F30:  MOVFF  3CC,3FE
03F34:  MOVLB  4
03F36:  CLRF   x01
03F38:  MOVLW  14
03F3A:  MOVWF  x00
03F3C:  MOVLB  0
03F3E:  CALL   2FFC
03F42:  MOVFF  01,3CE
03F46:  MOVLW  0A
03F48:  MOVLB  3
03F4A:  ADDWF  01,W
03F4C:  MOVWF  01
03F4E:  MOVLW  00
03F50:  ADDWFC 02,W
03F52:  MOVWF  03
03F54:  MOVF   01,W
03F56:  ADDLW  A2
03F58:  MOVWF  FE9
03F5A:  MOVLW  01
03F5C:  ADDWFC 03,W
03F5E:  MOVWF  FEA
03F60:  MOVFF  FEC,189
03F64:  MOVF   FED,F
03F66:  MOVFF  FEF,188
....................                   MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1; 
03F6A:  MOVFF  3CD,3FF
03F6E:  MOVFF  3CC,3FE
03F72:  MOVLB  4
03F74:  CLRF   x01
03F76:  MOVLW  14
03F78:  MOVWF  x00
03F7A:  MOVLB  0
03F7C:  CALL   2FFC
03F80:  MOVFF  01,3CE
03F84:  MOVLW  0C
03F86:  MOVLB  3
03F88:  ADDWF  01,W
03F8A:  MOVWF  01
03F8C:  MOVLW  00
03F8E:  ADDWFC 02,W
03F90:  MOVWF  03
03F92:  MOVF   01,W
03F94:  ADDLW  A2
03F96:  MOVWF  FE9
03F98:  MOVLW  01
03F9A:  ADDWFC 03,W
03F9C:  MOVWF  FEA
03F9E:  MOVFF  FEF,3CE
03FA2:  MOVFF  FEC,3CF
03FA6:  MOVFF  FEC,3D0
03FAA:  MOVFF  FEC,3D1
03FAE:  MOVLW  01
03FB0:  ADDWF  xCE,W
03FB2:  MOVLB  1
03FB4:  MOVWF  x82
03FB6:  MOVLW  00
03FB8:  MOVLB  3
03FBA:  ADDWFC xCF,W
03FBC:  MOVLB  1
03FBE:  MOVWF  x83
03FC0:  MOVLW  00
03FC2:  MOVLB  3
03FC4:  ADDWFC xD0,W
03FC6:  MOVLB  1
03FC8:  MOVWF  x84
03FCA:  MOVLW  00
03FCC:  MOVLB  3
03FCE:  ADDWFC xD1,W
03FD0:  MOVLB  1
03FD2:  MOVWF  x85
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
03FD4:  MOVF   x90,W
03FD6:  ADDWF  x92,W
03FD8:  MOVLB  3
03FDA:  MOVWF  xCE
03FDC:  MOVLB  1
03FDE:  MOVF   x91,W
03FE0:  ADDWFC x93,W
03FE2:  MOVLB  3
03FE4:  MOVWF  xCF
03FE6:  MOVLB  1
03FE8:  MOVF   x88,W
03FEA:  MOVLB  3
03FEC:  ADDWF  xCE,F
03FEE:  MOVLB  1
03FF0:  MOVF   x89,W
03FF2:  MOVLB  3
03FF4:  ADDWFC xCF,F
03FF6:  MOVF   xCE,W
03FF8:  MOVLB  1
03FFA:  XORWF  x8A,W
03FFC:  MOVWF  xF7
03FFE:  MOVLB  3
04000:  MOVF   xCF,W
04002:  MOVLB  1
04004:  XORWF  x8B,W
04006:  MOVWF  xF8
....................                   vFlags = SYN | ACK; 
04008:  MOVLW  12
0400A:  MOVLB  3
0400C:  MOVWF  xCB
....................                   MyTCBStub.smState = TCP_SYN_RECEIVED; 
0400E:  MOVLW  06
04010:  MOVLB  1
04012:  MOVWF  xF4
....................                    
....................                   // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................                   TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
04014:  MOVFF  3CD,3FF
04018:  MOVFF  3CC,3FE
0401C:  MOVLB  4
0401E:  CLRF   x01
04020:  MOVLW  14
04022:  MOVWF  x00
04024:  MOVLB  0
04026:  CALL   2FFC
0402A:  MOVFF  02,03
0402E:  MOVF   01,W
04030:  ADDLW  A2
04032:  MOVWF  01
04034:  MOVLW  01
04036:  ADDWFC 03,F
04038:  MOVFF  01,3CE
0403C:  MOVLB  3
0403E:  MOVFF  03,3CF
04042:  MOVLW  01
04044:  ADDWF  xCC,W
04046:  MOVWF  xD0
04048:  MOVLW  00
0404A:  ADDWFC xCD,W
0404C:  MOVWF  xD1
0404E:  MOVWF  xFF
04050:  MOVFF  3D0,3FE
04054:  MOVLB  4
04056:  CLRF   x01
04058:  MOVLW  14
0405A:  MOVWF  x00
0405C:  MOVLB  0
0405E:  CALL   2FFC
04062:  MOVFF  02,03
04066:  MOVF   01,W
04068:  ADDLW  A2
0406A:  MOVWF  01
0406C:  MOVLW  01
0406E:  ADDWFC 03,F
04070:  MOVFF  01,3D0
04074:  MOVLB  3
04076:  MOVFF  03,3D1
0407A:  MOVLW  02
0407C:  BSF    FD8.0
0407E:  SUBFWB xCC,W
04080:  MOVWF  xD2
04082:  MOVLW  00
04084:  SUBFWB xCD,W
04086:  MOVWF  xD3
04088:  MOVWF  xFF
0408A:  MOVFF  3D2,3FE
0408E:  MOVLB  4
04090:  CLRF   x01
04092:  MOVLW  14
04094:  MOVWF  x00
04096:  MOVLB  0
04098:  CALL   2FFC
0409C:  MOVFF  02,3D3
040A0:  MOVFF  01,3D2
040A4:  MOVFF  3CF,446
040A8:  MOVFF  3CE,445
040AC:  MOVLW  01
040AE:  MOVLB  4
040B0:  MOVWF  x47
040B2:  MOVFF  3D1,449
040B6:  MOVFF  3D0,448
040BA:  MOVWF  x4A
040BC:  MOVFF  02,44C
040C0:  MOVFF  01,44B
040C4:  MOVLB  0
040C6:  CALL   0F6C
....................                   SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
040CA:  MOVLB  1
040CC:  CLRF   xDB
040CE:  CLRF   xDA
....................     
....................                   break; 
040D0:  MOVLB  3
040D2:  BRA    40DC
....................                } 
040D4:  INCF   xCC,F
040D6:  BTFSC  FD8.2
040D8:  INCF   xCD,F
040DA:  BRA    3E24
040DC:  MOVLB  1
....................             } 
....................          } 
....................       #endif 
....................  
....................       if(vFlags) 
040DE:  MOVLB  3
040E0:  MOVF   xCB,F
040E2:  BZ    4100
....................          SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS); 
040E4:  BTFSS  xCA.0
040E6:  BRA    40EC
040E8:  MOVLW  00
040EA:  BRA    40EE
040EC:  MOVLW  01
040EE:  MOVWF  xCE
040F0:  MOVFF  3CB,414
040F4:  MOVFF  FE8,415
040F8:  MOVLB  0
040FA:  CALL   3620
040FE:  MOVLB  3
....................  
....................       // The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED  
....................       // state don't need any timeout events, so see if the timer is enabled 
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
04100:  MOVLB  1
04102:  BTFSC  xF5.4
04104:  BRA    41E0
....................       { 
....................          #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................             // Only the established state has any use for keep-alives 
....................             if(MyTCBStub.smState == TCP_ESTABLISHED) 
04106:  MOVF   xF4,W
04108:  SUBLW  07
0410A:  BNZ   41DA
....................             { 
....................                // If timeout has not occured, do not do anything. 
....................                if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
0410C:  MOVLB  0
0410E:  CALL   2424
04112:  MOVFF  03,3D1
04116:  MOVFF  02,3D0
0411A:  MOVFF  01,3CF
0411E:  MOVFF  00,3CE
04122:  MOVLB  1
04124:  MOVF   xEC,W
04126:  MOVLB  3
04128:  SUBWF  00,W
0412A:  MOVWF  00
0412C:  MOVLB  1
0412E:  MOVF   xED,W
04130:  MOVLB  3
04132:  SUBWFB 01,W
04134:  MOVWF  01
04136:  MOVLB  1
04138:  MOVF   xEE,W
0413A:  MOVLB  3
0413C:  SUBWFB 02,W
0413E:  MOVWF  02
04140:  MOVLB  1
04142:  MOVF   xEF,W
04144:  MOVLB  3
04146:  SUBWFB 03,W
04148:  MOVWF  03
0414A:  MOVWF  xD1
0414C:  MOVFF  02,3D0
04150:  MOVFF  01,3CF
04154:  MOVFF  00,3CE
04158:  BTFSS  FE8.7
0415A:  BRA    415E
....................                   continue; 
0415C:  BRA    43F2
....................        
....................                // If timeout has occured and the connection appears to be dead (no  
....................                // responses from remote node at all), close the connection so the  
....................                // application doesn't sit around indefinitely with a useless socket  
....................                // that it thinks is still open 
....................                if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES) 
0415E:  MOVLB  1
04160:  MOVF   xF5,W
04162:  ANDLW  07
04164:  SUBLW  06
04166:  BNZ   4198
....................                { 
....................                   vFlags = MyTCBStub.Flags.bServer; 
04168:  MOVLB  3
0416A:  CLRF   xCB
0416C:  MOVLB  1
0416E:  BTFSS  xF5.3
04170:  BRA    4178
04172:  MOVLB  3
04174:  INCF   xCB,F
04176:  MOVLB  1
....................  
....................                   // Force an immediate FIN and RST transmission 
....................                   // Double calling TCPDisconnect() will also place us  
....................                   // back in the listening state immediately if a server socket. 
....................                   TCPDisconnect(hTCP); 
04178:  MOVFF  3C9,3CE
0417C:  MOVLB  0
0417E:  RCALL  3C3E
....................                   TCPDisconnect(hTCP); 
04180:  MOVFF  3C9,3CE
04184:  RCALL  3C3E
....................                    
....................                   // Prevent client mode sockets from getting reused by other applications.   
....................                   // The application must call TCPDisconnect() with the handle to free this  
....................                   // socket (and the handle associated with it) 
....................                   if(!vFlags) 
04186:  MOVLB  3
04188:  MOVF   xCB,F
0418A:  BNZ   4194
....................                      MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED; 
0418C:  MOVLW  0E
0418E:  MOVLB  1
04190:  MOVWF  xF4
04192:  MOVLB  3
....................                    
....................                   continue; 
04194:  BRA    43F2
04196:  MOVLB  1
....................                } 
....................                 
....................                // Otherwise, if a timeout occured, simply send a keep-alive packet 
....................                SyncTCB(); 
04198:  MOVLB  0
0419A:  CALL   1052
....................                SendTCP(ACK, SENDTCP_KEEP_ALIVE); 
0419E:  MOVLW  10
041A0:  MOVLB  4
041A2:  MOVWF  x14
041A4:  MOVLW  02
041A6:  MOVWF  x15
041A8:  MOVLB  0
041AA:  CALL   3620
....................                MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
041AE:  CALL   2424
041B2:  MOVLW  EE
041B4:  MOVLB  3
041B6:  ADDWF  00,W
041B8:  MOVLB  1
041BA:  MOVWF  xEC
041BC:  MOVLW  FA
041BE:  MOVLB  3
041C0:  ADDWFC 01,W
041C2:  MOVLB  1
041C4:  MOVWF  xED
041C6:  MOVLW  02
041C8:  MOVLB  3
041CA:  ADDWFC 02,W
041CC:  MOVLB  1
041CE:  MOVWF  xEE
041D0:  MOVLW  00
041D2:  MOVLB  3
041D4:  ADDWFC 03,W
041D6:  MOVLB  1
041D8:  MOVWF  xEF
....................             } 
....................          #endif 
....................          continue; 
041DA:  MOVLB  3
041DC:  BRA    43F2
041DE:  MOVLB  1
....................       } 
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
041E0:  MOVLB  0
041E2:  CALL   2424
041E6:  MOVFF  03,3D1
041EA:  MOVFF  02,3D0
041EE:  MOVFF  01,3CF
041F2:  MOVFF  00,3CE
041F6:  MOVLB  1
041F8:  MOVF   xEC,W
041FA:  MOVLB  3
041FC:  SUBWF  00,W
041FE:  MOVWF  00
04200:  MOVLB  1
04202:  MOVF   xED,W
04204:  MOVLB  3
04206:  SUBWFB 01,W
04208:  MOVWF  01
0420A:  MOVLB  1
0420C:  MOVF   xEE,W
0420E:  MOVLB  3
04210:  SUBWFB 02,W
04212:  MOVWF  02
04214:  MOVLB  1
04216:  MOVF   xEF,W
04218:  MOVLB  3
0421A:  SUBWFB 03,W
0421C:  MOVWF  03
0421E:  MOVWF  xD1
04220:  MOVFF  02,3D0
04224:  MOVFF  01,3CF
04228:  MOVFF  00,3CE
0422C:  BTFSS  FE8.7
0422E:  BRA    4232
....................          continue; 
04230:  BRA    43F2
....................  
....................       // Load up extended TCB information 
....................       SyncTCB(); 
04232:  MOVLB  0
04234:  CALL   1052
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(MyTCBStub.smState) 
04238:  MOVLB  1
0423A:  MOVF   xF4,W
0423C:  XORLW  05
0423E:  MOVLB  0
04240:  BZ    4260
04242:  XORLW  03
04244:  BZ    4282
04246:  XORLW  01
04248:  BZ    42B0
0424A:  XORLW  0C
0424C:  BZ    42B0
0424E:  XORLW  03
04250:  BZ    42D2
04252:  XORLW  01
04254:  BZ    42F2
04256:  XORLW  03
04258:  BZ    42FE
0425A:  XORLW  06
0425C:  BZ    431E
0425E:  BRA    4340
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          #if defined(STACK_USE_DNS) 
....................          case TCP_GET_DNS_MODULE: 
....................             if(DNSBeginUsage()) 
....................             { 
....................                MyTCBStub.smState = TCP_DNS_RESOLVE; 
....................                if(MyTCB.flags.bRemoteHostIsROM) 
....................                   DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................                else 
....................                   DNSResolve((BYTE*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................             } 
....................             break; 
....................              
....................          case TCP_DNS_RESOLVE: 
....................          { 
....................             IP_ADDR ipResolvedDNSIP; 
....................  
....................             // See if DNS resolution has finished.  Note that if the DNS  
....................             // fails, the &ipResolvedDNSIP will be written with 0x00000000.  
....................             // MyTCB.remote.dwRemoteHost is unioned with  
....................             // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write  
....................             // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We  
....................             // must copy it over only if the DNS is resolution step was  
....................             // successful. 
....................             if(DNSIsResolved(&ipResolvedDNSIP)) 
....................             { 
....................                if(DNSEndUsage()) 
....................                { 
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val; 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
....................                   MyTCB.retryCount = 0; 
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
....................                } 
....................                else 
....................                { 
....................                   MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND; 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                } 
....................             } 
....................             break; 
....................          } 
....................          #endif // #if defined(STACK_USE_DNS) 
....................              
....................          case TCP_GATEWAY_SEND_ARP: 
....................             // Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................             MyTCBStub.eventTime2 = (WORD)TickGetDiv256(); 
....................             ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr); 
....................             MyTCBStub.smState = TCP_GATEWAY_GET_ARP; 
....................             break; 
....................  
....................          case TCP_GATEWAY_GET_ARP: 
....................             // Wait for the MAC address to finish being obtained 
....................             if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr)) 
....................             { 
....................                // Time out if too much time is spent in this state 
....................                // Note that this will continuously send out ARP  
....................                // requests for an infinite time if the Gateway  
....................                // never responds 
....................                if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval) 
....................                { 
....................                   // Exponentially increase timeout until we reach 6 attempts then stay constant 
....................                   if(MyTCB.retryCount < 6u) 
....................                   { 
....................                      MyTCB.retryCount++; 
....................                      MyTCB.retryInterval <<= 1; 
....................                   } 
....................  
....................                   // Retransmit ARP request 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                } 
....................                break; 
....................             } 
....................              
....................             // Send out SYN connection request to remote node 
....................             // This automatically disables the Timer from  
....................             // continuously firing for this socket 
....................             vFlags = SYN; 
....................             bRetransmit = FALSE; 
....................             MyTCBStub.smState = TCP_SYN_SENT; 
....................             break; 
....................          #endif // #if defined(STACK_CLIENT_MODE) 
....................           
....................          case TCP_SYN_SENT: 
....................             // Keep sending SYN until we hear from remote node. 
....................             // This may be for infinite time, in that case 
....................             // caller must detect it and do something. 
....................             vFlags = SYN; 
04260:  MOVLW  02
04262:  MOVLB  3
04264:  MOVWF  xCB
....................             bRetransmit = TRUE; 
04266:  BSF    xCA.0
....................  
....................             // Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant 
....................             if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1)) 
04268:  MOVLB  1
0426A:  MOVF   x9F,W
0426C:  SUBLW  03
0426E:  BC    4280
....................             { 
....................                MyTCB.retryCount = TCP_MAX_RETRIES - 1; 
04270:  MOVLW  04
04272:  MOVWF  x9F
....................                MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1); 
04274:  CLRF   x7D
04276:  MOVWF  x7C
04278:  MOVLW  C4
0427A:  MOVWF  x7B
0427C:  MOVLW  B0
0427E:  MOVWF  x7A
....................             } 
....................             break; 
04280:  BRA    4342
....................     
....................          case TCP_SYN_RECEIVED: 
....................             // We must receive ACK before timeout expires. 
....................             // If not, resend SYN+ACK. 
....................             // Abort, if maximum attempts counts are reached. 
....................             if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES) 
04282:  MOVLB  1
04284:  MOVF   x9F,W
04286:  SUBLW  01
04288:  BNC   4296
....................             { 
....................                vFlags = SYN | ACK; 
0428A:  MOVLW  12
0428C:  MOVLB  3
0428E:  MOVWF  xCB
....................                bRetransmit = TRUE; 
04290:  BSF    xCA.0
....................             } 
04292:  BRA    42AC
04294:  MOVLB  1
....................             else 
....................             { 
....................                if(MyTCBStub.Flags.bServer) 
04296:  BTFSS  xF5.3
04298:  BRA    42A6
....................                { 
....................                   vFlags = RST | ACK; 
0429A:  MOVLW  14
0429C:  MOVLB  3
0429E:  MOVWF  xCB
....................                   bCloseSocket = TRUE; 
042A0:  BSF    xCA.1
....................                } 
042A2:  BRA    42AC
042A4:  MOVLB  1
....................                else 
....................                { 
....................                   vFlags = SYN; 
042A6:  MOVLW  02
042A8:  MOVLB  3
042AA:  MOVWF  xCB
....................                } 
....................             } 
....................             break; 
042AC:  MOVLB  1
042AE:  BRA    4342
....................     
....................          case TCP_ESTABLISHED: 
....................          case TCP_CLOSE_WAIT: 
....................             // Retransmit any unacknowledged data 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
042B0:  MOVLB  1
042B2:  MOVF   x9F,W
042B4:  SUBLW  04
042B6:  BNC   42C4
....................             { 
....................                vFlags = ACK; 
042B8:  MOVLW  10
042BA:  MOVLB  3
042BC:  MOVWF  xCB
....................                bRetransmit = TRUE; 
042BE:  BSF    xCA.0
....................             } 
042C0:  BRA    42CE
042C2:  MOVLB  1
....................             else 
....................             { 
....................                // No response back for too long, close connection 
....................                // This could happen, for instance, if the communication  
....................                // medium was lost 
....................                MyTCBStub.smState = TCP_FIN_WAIT_1; 
042C4:  MOVLW  08
042C6:  MOVWF  xF4
....................                vFlags = FIN | ACK; 
042C8:  MOVLW  11
042CA:  MOVLB  3
042CC:  MOVWF  xCB
....................             } 
....................             break; 
042CE:  MOVLB  1
042D0:  BRA    4342
....................     
....................          case TCP_FIN_WAIT_1: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
042D2:  MOVLB  1
042D4:  MOVF   x9F,W
042D6:  SUBLW  04
042D8:  BNC   42E6
....................             { 
....................                // Send another FIN 
....................                vFlags = FIN | ACK; 
042DA:  MOVLW  11
042DC:  MOVLB  3
042DE:  MOVWF  xCB
....................                bRetransmit = TRUE; 
042E0:  BSF    xCA.0
....................             } 
042E2:  BRA    42EE
042E4:  MOVLB  1
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
042E6:  MOVLW  14
042E8:  MOVLB  3
042EA:  MOVWF  xCB
....................                bCloseSocket = TRUE; 
042EC:  BSF    xCA.1
....................             } 
....................             break; 
042EE:  MOVLB  1
042F0:  BRA    4342
....................     
....................          case TCP_FIN_WAIT_2: 
....................             // Close on our own, we can't seem to communicate  
....................             // with the remote node anymore 
....................             vFlags = RST | ACK; 
042F2:  MOVLW  14
042F4:  MOVLB  3
042F6:  MOVWF  xCB
....................             bCloseSocket = TRUE; 
042F8:  BSF    xCA.1
....................             break; 
042FA:  MOVLB  1
042FC:  BRA    4342
....................  
....................          case TCP_CLOSING: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
042FE:  MOVLB  1
04300:  MOVF   x9F,W
04302:  SUBLW  04
04304:  BNC   4312
....................             { 
....................                // Send another ACK+FIN (the FIN is retransmitted  
....................                // automatically since it hasn't been acknowledged by  
....................                // the remote node yet) 
....................                vFlags = ACK; 
04306:  MOVLW  10
04308:  MOVLB  3
0430A:  MOVWF  xCB
....................                bRetransmit = TRUE; 
0430C:  BSF    xCA.0
....................             } 
0430E:  BRA    431A
04310:  MOVLB  1
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
04312:  MOVLW  14
04314:  MOVLB  3
04316:  MOVWF  xCB
....................                bCloseSocket = TRUE; 
04318:  BSF    xCA.1
....................             } 
....................             break; 
0431A:  MOVLB  1
0431C:  BRA    4342
....................     
.................... //         case TCP_TIME_WAIT: 
.................... //            // Wait around for a while (2MSL) and then goto closed state 
.................... //            bCloseSocket = TRUE; 
.................... //            break; 
.................... //          
....................  
....................          case TCP_LAST_ACK: 
....................             // Send some more FINs or close anyway 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
0431E:  MOVLB  1
04320:  MOVF   x9F,W
04322:  SUBLW  04
04324:  BNC   4332
....................             { 
....................                vFlags = FIN | ACK; 
04326:  MOVLW  11
04328:  MOVLB  3
0432A:  MOVWF  xCB
....................                bRetransmit = TRUE; 
0432C:  BSF    xCA.0
....................             } 
0432E:  BRA    433A
04330:  MOVLB  1
....................             else 
....................             { 
....................                vFlags = RST | ACK; 
04332:  MOVLW  14
04334:  MOVLB  3
04336:  MOVWF  xCB
....................                bCloseSocket = TRUE; 
04338:  BSF    xCA.1
....................             } 
....................             break; 
0433A:  MOVLB  1
0433C:  BRA    4342
0433E:  MOVLB  0
....................           
....................          default: 
....................             break; 
04340:  MOVLB  1
....................       } 
....................  
....................       if(vFlags) 
04342:  MOVLB  3
04344:  MOVF   xCB,F
04346:  BZ    43E6
....................       { 
....................          // Transmit all unacknowledged data over again 
....................          if(bRetransmit) 
04348:  BTFSS  xCA.0
0434A:  BRA    43D4
....................          { 
....................             // Set the appropriate retry time 
....................             MyTCB.retryCount++; 
0434C:  MOVLB  1
0434E:  INCF   x9F,F
....................             MyTCB.retryInterval <<= 1; 
04350:  BCF    FD8.0
04352:  RLCF   x7A,F
04354:  RLCF   x7B,F
04356:  RLCF   x7C,F
04358:  RLCF   x7D,F
....................        
....................             // Calculate how many bytes we have to roll back and retransmit 
....................             w = MyTCB.txUnackedTail - MyTCBStub.txTail; 
0435A:  MOVF   xE6,W
0435C:  SUBWF  x86,W
0435E:  MOVLB  3
04360:  MOVWF  xCC
04362:  MOVLB  1
04364:  MOVF   xE7,W
04366:  SUBWFB x87,W
04368:  MOVLB  3
0436A:  MOVWF  xCD
....................             if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
0436C:  MOVLB  1
0436E:  MOVF   x87,W
04370:  SUBWF  xE7,W
04372:  BNC   4394
04374:  BNZ   437C
04376:  MOVF   xE6,W
04378:  SUBWF  x86,W
0437A:  BC    4394
....................                w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
0437C:  MOVF   xDE,W
0437E:  SUBWF  xE0,W
04380:  MOVWF  00
04382:  MOVF   xDF,W
04384:  SUBWFB xE1,W
04386:  MOVWF  03
04388:  MOVF   00,W
0438A:  MOVLB  3
0438C:  ADDWF  xCC,F
0438E:  MOVF   03,W
04390:  ADDWFC xCD,F
04392:  MOVLB  1
....................              
....................             // Perform roll back of local SEQuence counter, remote window  
....................             // adjustment, and cause all unacknowledged data to be  
....................             // retransmitted by moving the unacked tail pointer. 
....................             MyTCB.MySEQ -= w; 
04394:  MOVLB  3
04396:  MOVF   xCC,W
04398:  MOVLB  1
0439A:  SUBWF  x7E,F
0439C:  MOVLB  3
0439E:  MOVF   xCD,W
043A0:  MOVLB  1
043A2:  SUBWFB x7F,F
043A4:  MOVLW  00
043A6:  SUBWFB x80,F
043A8:  SUBWFB x81,F
....................             MyTCB.remoteWindow += w; 
043AA:  MOVLB  3
043AC:  MOVF   xCC,W
043AE:  MOVLB  1
043B0:  ADDWF  x8C,F
043B2:  MOVLB  3
043B4:  MOVF   xCD,W
043B6:  MOVLB  1
043B8:  ADDWFC x8D,F
....................             MyTCB.txUnackedTail = MyTCBStub.txTail;       
043BA:  MOVFF  1E7,187
043BE:  MOVFF  1E6,186
....................             SendTCP(vFlags, 0); 
043C2:  MOVFF  3CB,414
043C6:  MOVLB  4
043C8:  CLRF   x15
043CA:  MOVLB  0
043CC:  CALL   3620
....................          } 
043D0:  BRA    43E4
043D2:  MOVLB  3
....................          else 
....................             SendTCP(vFlags, SENDTCP_RESET_TIMERS); 
043D4:  MOVFF  3CB,414
043D8:  MOVLW  01
043DA:  MOVLB  4
043DC:  MOVWF  x15
043DE:  MOVLB  0
043E0:  CALL   3620
043E4:  MOVLB  3
....................  
....................       } 
....................        
....................       if(bCloseSocket) 
043E6:  BTFSS  xCA.1
043E8:  BRA    43F2
....................          CloseSocket(); 
043EA:  MOVLB  0
043EC:  CALL   112A
043F0:  MOVLB  3
....................    } 
....................     
....................     
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
043F2:  INCF   xC9,F
043F4:  BRA    3D2C
....................       // Process SYN Queue entry timeouts 
....................       for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
043F6:  CLRF   xCD
043F8:  CLRF   xCC
043FA:  MOVF   xCD,F
043FC:  BTFSS  FD8.2
043FE:  BRA    457A
04400:  MOVF   xCC,W
04402:  SUBLW  02
04404:  BTFSS  FD8.0
04406:  BRA    457A
....................       { 
....................          // Abort search if there are no more valid records 
....................          if(SYNQueue[w].wDestPort == 0u) 
04408:  MOVFF  3CD,3FF
0440C:  MOVFF  3CC,3FE
04410:  MOVLB  4
04412:  CLRF   x01
04414:  MOVLW  14
04416:  MOVWF  x00
04418:  MOVLB  0
0441A:  CALL   2FFC
0441E:  MOVFF  01,3CE
04422:  MOVLW  10
04424:  MOVLB  3
04426:  ADDWF  01,W
04428:  MOVWF  01
0442A:  MOVLW  00
0442C:  ADDWFC 02,W
0442E:  MOVWF  03
04430:  MOVF   01,W
04432:  ADDLW  A2
04434:  MOVWF  FE9
04436:  MOVLW  01
04438:  ADDWFC 03,W
0443A:  MOVWF  FEA
0443C:  MOVFF  FEC,3CF
04440:  MOVF   FED,F
04442:  MOVFF  FEF,3CE
04446:  MOVF   xCE,F
04448:  BNZ   4450
0444A:  MOVF   xCF,F
0444C:  BNZ   4450
....................             break; 
0444E:  BRA    457A
....................           
....................          // See if this SYN has timed out 
....................          if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull)) 
04450:  MOVLB  0
04452:  CALL   2FD6
04456:  MOVFF  01,3CF
0445A:  MOVFF  00,3CE
0445E:  MOVFF  3CD,3FF
04462:  MOVFF  3CC,3FE
04466:  MOVLB  4
04468:  CLRF   x01
0446A:  MOVLW  14
0446C:  MOVWF  x00
0446E:  MOVLB  0
04470:  CALL   2FFC
04474:  MOVFF  02,3D1
04478:  MOVFF  01,3D0
0447C:  MOVLW  12
0447E:  MOVLB  3
04480:  ADDWF  01,W
04482:  MOVWF  01
04484:  MOVLW  00
04486:  ADDWFC 02,W
04488:  MOVWF  03
0448A:  MOVF   01,W
0448C:  ADDLW  A2
0448E:  MOVWF  FE9
04490:  MOVLW  01
04492:  ADDWFC 03,W
04494:  MOVWF  FEA
04496:  MOVFF  FEC,03
0449A:  MOVF   FED,F
0449C:  MOVF   FEF,W
0449E:  SUBWF  xCE,F
044A0:  MOVF   03,W
044A2:  SUBWFB xCF,F
044A4:  BNZ   44AC
044A6:  MOVF   xCE,W
044A8:  SUBLW  E4
044AA:  BC    4572
....................          { 
....................             // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................             TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
044AC:  MOVFF  3CD,3FF
044B0:  MOVFF  3CC,3FE
044B4:  MOVLB  4
044B6:  CLRF   x01
044B8:  MOVLW  14
044BA:  MOVWF  x00
044BC:  MOVLB  0
044BE:  CALL   2FFC
044C2:  MOVFF  02,03
044C6:  MOVF   01,W
044C8:  ADDLW  A2
044CA:  MOVWF  01
044CC:  MOVLW  01
044CE:  ADDWFC 03,F
044D0:  MOVFF  01,3CE
044D4:  MOVLB  3
044D6:  MOVFF  03,3CF
044DA:  MOVLW  01
044DC:  ADDWF  xCC,W
044DE:  MOVWF  xD0
044E0:  MOVLW  00
044E2:  ADDWFC xCD,W
044E4:  MOVWF  xD1
044E6:  MOVWF  xFF
044E8:  MOVFF  3D0,3FE
044EC:  MOVLB  4
044EE:  CLRF   x01
044F0:  MOVLW  14
044F2:  MOVWF  x00
044F4:  MOVLB  0
044F6:  CALL   2FFC
044FA:  MOVFF  02,03
044FE:  MOVF   01,W
04500:  ADDLW  A2
04502:  MOVWF  01
04504:  MOVLW  01
04506:  ADDWFC 03,F
04508:  MOVFF  01,3D0
0450C:  MOVLB  3
0450E:  MOVFF  03,3D1
04512:  MOVLW  02
04514:  BSF    FD8.0
04516:  SUBFWB xCC,W
04518:  MOVWF  xD2
0451A:  MOVLW  00
0451C:  SUBFWB xCD,W
0451E:  MOVWF  xD3
04520:  MOVWF  xFF
04522:  MOVFF  3D2,3FE
04526:  MOVLB  4
04528:  CLRF   x01
0452A:  MOVLW  14
0452C:  MOVWF  x00
0452E:  MOVLB  0
04530:  CALL   2FFC
04534:  MOVFF  02,3D3
04538:  MOVFF  01,3D2
0453C:  MOVFF  3CF,446
04540:  MOVFF  3CE,445
04544:  MOVLW  01
04546:  MOVLB  4
04548:  MOVWF  x47
0454A:  MOVFF  3D1,449
0454E:  MOVFF  3D0,448
04552:  MOVWF  x4A
04554:  MOVFF  02,44C
04558:  MOVFF  01,44B
0455C:  MOVLB  0
0455E:  CALL   0F6C
....................             SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
04562:  MOVLB  1
04564:  CLRF   xDB
04566:  CLRF   xDA
....................     
....................             // Since we deleted an entry, we need to roll back one  
....................             // index so next loop will process the correct record 
....................             w--;    
04568:  MOVLB  3
0456A:  MOVF   xCC,W
0456C:  BTFSC  FD8.2
0456E:  DECF   xCD,F
04570:  DECF   xCC,F
....................          } 
04572:  INCF   xCC,F
04574:  BTFSC  FD8.2
04576:  INCF   xCD,F
04578:  BRA    43FA
....................       } 
....................    #endif 
0457A:  MOVLB  0
0457C:  GOTO   6C42 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
....................  
....................   Summary: 
....................      Handles incoming TCP segments. 
....................  
....................   Description: 
....................    This function handles incoming TCP segments.  When a segment arrives, it 
....................    is compared to open sockets using a hash of the remote port and IP.   
....................    On a match, the data is passed to HandleTCPSeg for further processing. 
....................  
....................   Precondition: 
....................    TCP is initialized and a TCP segment is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    remote - Remote NODE_INFO structure 
....................    localIP - This stack's IP address (for header checking) 
....................    len - Total length of the waiting TCP segment 
....................  
....................   Return Values: 
....................    TRUE - the segment was properly handled. 
....................    FALSE - otherwise 
....................   ***************************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
06736:  MOVLB  3
06738:  MOVFF  3C9,FE9
0673C:  MOVFF  3CA,FEA
06740:  MOVFF  FEF,00
06744:  MOVFF  FEC,01
06748:  MOVFF  FEC,02
0674C:  MOVFF  FEC,03
06750:  MOVFF  00,3E3
06754:  MOVFF  01,3E4
06758:  MOVFF  02,3E5
0675C:  MOVFF  03,3E6
....................    pseudoHeader.DestAddress        = *localIP; 
06760:  MOVFF  3CB,FE9
06764:  MOVFF  3CC,FEA
06768:  MOVFF  FEF,00
0676C:  MOVFF  FEC,01
06770:  MOVFF  FEC,02
06774:  MOVFF  FEC,03
06778:  MOVFF  00,3E7
0677C:  MOVFF  01,3E8
06780:  MOVFF  02,3E9
06784:  MOVFF  03,3EA
....................    pseudoHeader.Zero               = 0x0; 
06788:  CLRF   xEB
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
0678A:  MOVLW  06
0678C:  MOVWF  xEC
....................    pseudoHeader.Length             = len; 
0678E:  MOVFF  3CE,3EE
06792:  MOVFF  3CD,3ED
....................  
....................    SwapPseudoHeader(pseudoHeader); 
06796:  MOVFF  3EE,45E
0679A:  MOVFF  3ED,45D
0679E:  MOVLB  0
067A0:  CALL   1A24
067A4:  MOVFF  02,3EE
067A8:  MOVFF  01,3ED
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
067AC:  MOVLW  03
067AE:  MOVLB  3
067B0:  MOVWF  xF5
067B2:  MOVLW  E3
067B4:  MOVWF  xF4
067B6:  MOVFF  3F5,45A
067BA:  MOVFF  FE8,459
067BE:  MOVLB  4
067C0:  CLRF   x5C
067C2:  MOVLW  0C
067C4:  MOVWF  x5B
067C6:  MOVLB  0
067C8:  CALL   1B20
067CC:  MOVFF  01,3EF
067D0:  MOVLB  3
067D2:  COMF   xEF,F
067D4:  MOVFF  02,3F0
067D8:  COMF   xF0,F
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
067DA:  MOVFF  3CE,43F
067DE:  MOVFF  3CD,43E
067E2:  MOVLB  0
067E4:  CALL   34D8
067E8:  MOVFF  02,3F2
067EC:  MOVFF  01,3F1
....................  
....................    // Compare checksums. 
....................    if(checksum1.Val != checksum2.Val) 
067F0:  MOVLB  3
067F2:  MOVF   xF1,W
067F4:  SUBWF  xEF,W
067F6:  BNZ   67FE
067F8:  MOVF   xF2,W
067FA:  SUBWF  xF0,W
067FC:  BZ    680C
....................    { 
....................       MACDiscardRx(); 
067FE:  MOVLB  0
06800:  CALL   2602
....................       return TRUE; 
06804:  MOVLW  01
06806:  MOVWF  01
06808:  BRA    68B0
0680A:  MOVLB  3
....................    } 
....................  
.................... #if defined(DEBUG_GENERATE_RX_LOSS) 
....................    // Throw RX packets away randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_RX_LOSS) 
....................    { 
....................       MACDiscardRx(); 
....................       return TRUE; 
....................    } 
.................... #endif 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
0680C:  MOVLB  4
0680E:  CLRF   x19
06810:  CLRF   x18
06812:  MOVLB  0
06814:  CALL   24A2
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
06818:  MOVLW  03
0681A:  MOVLB  3
0681C:  MOVWF  xF5
0681E:  MOVLW  CF
06820:  MOVWF  xF4
06822:  MOVFF  3F5,461
06826:  MOVFF  FE8,460
0682A:  MOVLB  4
0682C:  CLRF   x63
0682E:  MOVLW  14
06830:  MOVWF  x62
06832:  MOVLB  0
06834:  CALL   0C14
....................    SwapTCPHeader(&TCPHeader); 
06838:  MOVLW  03
0683A:  MOVLB  4
0683C:  MOVWF  x3F
0683E:  MOVLW  CF
06840:  MOVWF  x3E
06842:  MOVLB  0
06844:  CALL   32B2
....................  
....................  
....................    // Skip over options to retrieve data bytes 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
06848:  MOVLB  3
0684A:  SWAPF  xDB,W
0684C:  ANDLW  0F
0684E:  MOVWF  00
06850:  RLCF   00,F
06852:  RLCF   00,F
06854:  MOVLW  FC
06856:  ANDWF  00,F
06858:  MOVF   00,W
0685A:  ADDLW  EC
0685C:  MOVWF  xF3
....................    len = len - optionsSize - sizeof(TCPHeader); 
0685E:  MOVF   xF3,W
06860:  SUBWF  xCD,W
06862:  MOVWF  xF4
06864:  MOVLW  00
06866:  SUBWFB xCE,W
06868:  MOVWF  xF5
0686A:  MOVLW  14
0686C:  SUBWF  xF4,W
0686E:  MOVWF  xCD
06870:  MOVLW  00
06872:  SUBWFB xF5,W
06874:  MOVWF  xCE
....................  
....................    // Find matching socket. 
....................    if(FindMatchingTCPSocket(&TCPHeader, remote)) 
06876:  MOVLW  03
06878:  MOVWF  xF5
0687A:  MOVLW  CF
0687C:  MOVWF  xF4
0687E:  MOVFF  3CA,3F7
06882:  MOVFF  3C9,3F6
06886:  MOVLB  0
06888:  GOTO   4D00
0688C:  MOVF   01,F
0688E:  BZ    68A8
....................    { 
....................       #if defined(STACK_USE_SSL) 
....................       PTR_BASE prevRxHead; 
....................       // For SSL connections, show HandleTCPSeg() the full data buffer 
....................       prevRxHead = MyTCBStub.rxHead; 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................       #endif 
....................        
....................       HandleTCPSeg(&TCPHeader, len); 
06890:  MOVLW  03
06892:  MOVLB  3
06894:  MOVWF  xF5
06896:  MOVLW  CF
06898:  MOVWF  xF4
0689A:  MOVFF  3CE,3F7
0689E:  MOVFF  3CD,3F6
068A2:  MOVLB  0
068A4:  GOTO   5468
....................        
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Restore the buffer state 
....................          MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          MyTCBStub.rxHead = prevRxHead; 
....................  
....................          // Process the new SSL data, using the currently loaded stub 
....................          TCPSSLHandleIncoming(hCurrentTCP); 
....................       } 
....................       #endif 
....................    } 
.................... //   else 
.................... //   { 
.................... //      // NOTE: RFC 793 specifies that if the socket is closed and a segment  
.................... //      // arrives, we should send back a RST if the RST bit in the incoming  
.................... //      // packet is not set.  Instead, we will just silently ignore such a  
.................... //      // packet since this is what firewalls do on purpose to enhance  
.................... //      // security. 
.................... //      //if(!TCPHeader.Flags.bits.flagRST) 
.................... //      //   SendTCP(RST, SENDTCP_RESET_TIMERS); 
.................... //   } 
....................  
....................    // Finished with this packet, discard it and free the Ethernet RAM for new packets 
....................    MACDiscardRx(); 
068A8:  CALL   2602
....................  
....................    return TRUE; 
068AC:  MOVLW  01
068AE:  MOVWF  01
068B0:  GOTO   6DAC (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
....................  
....................   Summary: 
....................    Transmits a TPC segment. 
....................  
....................   Description: 
....................    This function assembles and transmits a TCP segment, including any  
....................    pending data.  It also supports retransmissions, keep-alives, and  
....................    other packet types. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    vTCPFlags - Additional TCP flags to include 
....................    vSendFlags - Any combinations of SENDTCP_* constants to modify the 
....................              transmit behavior or contents. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
.................... { 
....................    WORD_VAL        wVal; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD          len; 
....................     
....................    SyncTCB(); 
*
03620:  CALL   1052
....................  
....................    // FINs must be handled specially 
....................    if(vTCPFlags & FIN) 
03624:  MOVLB  4
03626:  BTFSS  x14.0
03628:  BRA    3632
....................    { 
....................       MyTCBStub.Flags.bTXFIN = 1; 
0362A:  MOVLB  1
0362C:  BSF    xF6.3
....................       vTCPFlags &= ~FIN; 
0362E:  MOVLB  4
03630:  BCF    x14.0
....................    } 
....................  
....................    // Status will now be synched, disable automatic future  
....................    // status transmissions 
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
03632:  MOVLB  1
03634:  BCF    xF5.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
03636:  BCF    xF5.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
03638:  BCF    xF5.7
....................    MyTCBStub.Flags.bTXASAP = 0; 
0363A:  BCF    xF6.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
0363C:  BCF    xF6.2
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
0363E:  BCF    xF6.0
....................  
....................    //  Make sure that we can write to the MAC transmit area 
....................    while(!IPIsTxReady()); 
03640:  MOVLB  0
03642:  CALL   1786
03646:  MOVF   01,F
03648:  BZ    3642
....................  
....................    // Put all socket application data in the TX space 
....................    if(vTCPFlags & (SYN | RST)) 
0364A:  MOVLB  4
0364C:  MOVF   x14,W
0364E:  ANDLW  06
03650:  BZ    3658
....................    { 
....................       // Don't put any data in SYN and RST messages 
....................       len = 0; 
03652:  CLRF   x3D
03654:  CLRF   x3C
....................    } 
03656:  BRA    388A
....................    else 
....................    { 
....................       // Begin copying any application data over to the TX space 
....................       if(MyTCBStub.txHead == MyTCB.txUnackedTail) 
03658:  MOVLB  1
0365A:  MOVF   x86,W
0365C:  SUBWF  xE4,W
0365E:  BNZ   3670
03660:  MOVF   x87,W
03662:  SUBWF  xE5,W
03664:  BNZ   3670
....................       { 
....................          // All caught up on data TX, no real data for this packet 
....................          len = 0; 
03666:  MOVLB  4
03668:  CLRF   x3D
0366A:  CLRF   x3C
....................       } 
0366C:  BRA    385C
0366E:  MOVLB  1
....................       else if(MyTCBStub.txHead > MyTCB.txUnackedTail) 
03670:  MOVF   x87,W
03672:  SUBWF  xE5,W
03674:  BNC   3714
03676:  BNZ   367E
03678:  MOVF   xE4,W
0367A:  SUBWF  x86,W
0367C:  BC    3714
....................       { 
....................          len = MyTCBStub.txHead - MyTCB.txUnackedTail; 
0367E:  MOVF   x86,W
03680:  SUBWF  xE4,W
03682:  MOVLB  4
03684:  MOVWF  x3C
03686:  MOVLB  1
03688:  MOVF   x87,W
0368A:  SUBWFB xE5,W
0368C:  MOVLB  4
0368E:  MOVWF  x3D
....................  
....................          if(len > MyTCB.remoteWindow) 
03690:  MOVLB  1
03692:  MOVF   x8D,W
03694:  MOVLB  4
03696:  SUBWF  x3D,W
03698:  BNC   36B4
0369A:  BNZ   36AC
0369C:  MOVF   x3C,W
0369E:  MOVLB  1
036A0:  SUBWF  x8C,W
036A2:  BTFSS  FD8.0
036A4:  BRA    36AA
036A6:  MOVLB  4
036A8:  BRA    36B4
036AA:  MOVLB  4
....................             len = MyTCB.remoteWindow; 
036AC:  MOVFF  18D,43D
036B0:  MOVFF  18C,43C
....................  
....................          if(len > MyTCB.wRemoteMSS) 
036B4:  MOVLB  1
036B6:  MOVF   x9E,W
036B8:  MOVLB  4
036BA:  SUBWF  x3D,W
036BC:  BNC   36DE
036BE:  BNZ   36D0
036C0:  MOVF   x3C,W
036C2:  MOVLB  1
036C4:  SUBWF  x9D,W
036C6:  BTFSS  FD8.0
036C8:  BRA    36CE
036CA:  MOVLB  4
036CC:  BRA    36DE
036CE:  MOVLB  4
....................          { 
....................             len = MyTCB.wRemoteMSS; 
036D0:  MOVFF  19E,43D
036D4:  MOVFF  19D,43C
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
036D8:  MOVLB  1
036DA:  BSF    xF6.2
036DC:  MOVLB  4
....................          } 
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len); 
036DE:  MOVLW  12
036E0:  MOVWF  x46
036E2:  MOVLW  0D
036E4:  MOVWF  x45
036E6:  CLRF   x47
036E8:  MOVFF  187,449
036EC:  MOVFF  186,448
036F0:  MOVFF  1F9,44A
036F4:  MOVFF  43D,44C
036F8:  MOVFF  43C,44B
036FC:  MOVLB  0
036FE:  CALL   0F6C
....................          MyTCB.txUnackedTail += len; 
03702:  MOVLB  4
03704:  MOVF   x3C,W
03706:  MOVLB  1
03708:  ADDWF  x86,F
0370A:  MOVLB  4
0370C:  MOVF   x3D,W
0370E:  MOVLB  1
03710:  ADDWFC x87,F
....................       } 
03712:  BRA    385A
....................       else 
....................       { 
....................          pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail; 
03714:  MOVF   x86,W
03716:  SUBWF  xE0,W
03718:  MOVLB  4
0371A:  MOVWF  x3A
0371C:  MOVLB  1
0371E:  MOVF   x87,W
03720:  SUBWFB xE1,W
03722:  MOVLB  4
03724:  MOVWF  x3B
....................          len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart; 
03726:  MOVLB  1
03728:  MOVF   xE4,W
0372A:  MOVLB  4
0372C:  ADDWF  x3A,W
0372E:  MOVWF  x3E
03730:  MOVLB  1
03732:  MOVF   xE5,W
03734:  MOVLB  4
03736:  ADDWFC x3B,W
03738:  MOVWF  x3F
0373A:  MOVLB  1
0373C:  MOVF   xDE,W
0373E:  MOVLB  4
03740:  SUBWF  x3E,W
03742:  MOVWF  x3C
03744:  MOVLB  1
03746:  MOVF   xDF,W
03748:  MOVLB  4
0374A:  SUBWFB x3F,W
0374C:  MOVWF  x3D
....................  
....................          if(len > MyTCB.remoteWindow) 
0374E:  MOVLB  1
03750:  MOVF   x8D,W
03752:  MOVLB  4
03754:  SUBWF  x3D,W
03756:  BNC   3772
03758:  BNZ   376A
0375A:  MOVF   x3C,W
0375C:  MOVLB  1
0375E:  SUBWF  x8C,W
03760:  BTFSS  FD8.0
03762:  BRA    3768
03764:  MOVLB  4
03766:  BRA    3772
03768:  MOVLB  4
....................             len = MyTCB.remoteWindow; 
0376A:  MOVFF  18D,43D
0376E:  MOVFF  18C,43C
....................  
....................          if(len > MyTCB.wRemoteMSS) 
03772:  MOVLB  1
03774:  MOVF   x9E,W
03776:  MOVLB  4
03778:  SUBWF  x3D,W
0377A:  BNC   379C
0377C:  BNZ   378E
0377E:  MOVF   x3C,W
03780:  MOVLB  1
03782:  SUBWF  x9D,W
03784:  BTFSS  FD8.0
03786:  BRA    378C
03788:  MOVLB  4
0378A:  BRA    379C
0378C:  MOVLB  4
....................          { 
....................             len = MyTCB.wRemoteMSS; 
0378E:  MOVFF  19E,43D
03792:  MOVFF  19D,43C
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
03796:  MOVLB  1
03798:  BSF    xF6.2
0379A:  MOVLB  4
....................          } 
....................  
....................          if(pseudoHeader.Length > len) 
0379C:  MOVF   x3D,W
0379E:  SUBWF  x3B,W
037A0:  BNC   37B2
037A2:  BNZ   37AA
037A4:  MOVF   x3A,W
037A6:  SUBWF  x3C,W
037A8:  BC    37B2
....................             pseudoHeader.Length = len; 
037AA:  MOVFF  43D,43B
037AE:  MOVFF  43C,43A
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
037B2:  MOVLW  12
037B4:  MOVWF  x46
037B6:  MOVLW  0D
037B8:  MOVWF  x45
037BA:  CLRF   x47
037BC:  MOVFF  187,449
037C0:  MOVFF  186,448
037C4:  MOVFF  1F9,44A
037C8:  MOVFF  43B,44C
037CC:  MOVFF  43A,44B
037D0:  MOVLB  0
037D2:  CALL   0F6C
....................          pseudoHeader.Length = len - pseudoHeader.Length; 
037D6:  MOVLB  4
037D8:  MOVF   x3A,W
037DA:  SUBWF  x3C,W
037DC:  MOVWF  x3A
037DE:  MOVF   x3B,W
037E0:  SUBWFB x3D,W
037E2:  MOVWF  x3B
....................     
....................          // Copy any left over chunks of application data over 
....................          if(pseudoHeader.Length) 
037E4:  MOVF   x3A,W
037E6:  IORWF  x3B,W
037E8:  BZ    382A
....................          { 
....................             TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
037EA:  MOVLB  1
037EC:  MOVF   x86,W
037EE:  SUBWF  xE0,W
037F0:  MOVWF  00
037F2:  MOVF   x87,W
037F4:  SUBWFB xE1,W
037F6:  MOVWF  03
037F8:  MOVF   00,W
037FA:  ADDLW  0D
037FC:  MOVLB  4
037FE:  MOVWF  x3E
03800:  MOVLW  12
03802:  ADDWFC 03,W
03804:  MOVWF  x3F
03806:  MOVWF  x46
03808:  MOVFF  43E,445
0380C:  CLRF   x47
0380E:  MOVFF  1DF,449
03812:  MOVFF  1DE,448
03816:  MOVFF  1F9,44A
0381A:  MOVFF  43B,44C
0381E:  MOVFF  43A,44B
03822:  MOVLB  0
03824:  CALL   0F6C
03828:  MOVLB  4
....................          } 
....................  
....................          MyTCB.txUnackedTail += len; 
0382A:  MOVF   x3C,W
0382C:  MOVLB  1
0382E:  ADDWF  x86,F
03830:  MOVLB  4
03832:  MOVF   x3D,W
03834:  MOVLB  1
03836:  ADDWFC x87,F
....................          if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
03838:  MOVF   xE1,W
0383A:  SUBWF  x87,W
0383C:  BNC   385A
0383E:  BNZ   3846
03840:  MOVF   xE0,W
03842:  SUBWF  x86,W
03844:  BNC   385A
....................             MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart; 
03846:  MOVF   xDE,W
03848:  SUBWF  xE0,W
0384A:  MOVWF  00
0384C:  MOVF   xDF,W
0384E:  SUBWFB xE1,W
03850:  MOVWF  03
03852:  MOVF   00,W
03854:  SUBWF  x86,F
03856:  MOVF   03,W
03858:  SUBWFB x87,F
0385A:  MOVLB  4
....................       } 
....................  
....................       // If we are to transmit a FIN, make sure we can put one in this packet 
....................       if(MyTCBStub.Flags.bTXFIN) 
0385C:  MOVLB  1
0385E:  BTFSS  xF6.3
03860:  BRA    388C
....................       { 
....................          if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS)) 
03862:  MOVF   x8C,W
03864:  MOVLB  4
03866:  SUBWF  x3C,W
03868:  BNZ   3874
0386A:  MOVLB  1
0386C:  MOVF   x8D,W
0386E:  MOVLB  4
03870:  SUBWF  x3D,W
03872:  BZ    388A
03874:  MOVLB  1
03876:  MOVF   x9D,W
03878:  MOVLB  4
0387A:  SUBWF  x3C,W
0387C:  BNZ   3888
0387E:  MOVLB  1
03880:  MOVF   x9E,W
03882:  MOVLB  4
03884:  SUBWF  x3D,W
03886:  BZ    388A
....................             vTCPFlags |= FIN; 
03888:  BSF    x14.0
0388A:  MOVLB  1
....................       } 
....................    } 
....................  
....................    // Ensure that all packets with data of some kind are  
....................    // retransmitted by TCPTick() until acknowledged 
....................    // Pure ACK packets with no data are not ACKed back in TCP 
....................    if(len || (vTCPFlags & (SYN | FIN))) 
0388C:  MOVLB  4
0388E:  MOVF   x3C,W
03890:  IORWF  x3D,W
03892:  BNZ   389A
03894:  MOVF   x14,W
03896:  ANDLW  03
03898:  BZ    38FE
....................    { 
....................       // Transmitting data, update remote window variable to reflect smaller  
....................       // window. 
....................       MyTCB.remoteWindow -= len; 
0389A:  MOVF   x3C,W
0389C:  MOVLB  1
0389E:  SUBWF  x8C,F
038A0:  MOVLB  4
038A2:  MOVF   x3D,W
038A4:  MOVLB  1
038A6:  SUBWFB x8D,F
....................  
....................       // Push (PSH) all data for enhanced responsiveness on  
....................       // the remote end, especially with GUIs 
....................       if(len) 
038A8:  MOVLB  4
038AA:  MOVF   x3C,W
038AC:  IORWF  x3D,W
038AE:  BZ    38B2
....................          vTCPFlags |= PSH; 
038B0:  BSF    x14.3
....................  
....................       if(vSendFlags & SENDTCP_RESET_TIMERS) 
038B2:  BTFSS  x15.0
038B4:  BRA    38C8
....................       { 
....................          MyTCB.retryCount = 0; 
038B6:  MOVLB  1
038B8:  CLRF   x9F
....................          MyTCB.retryInterval = TCP_START_TIMEOUT_VAL; 
038BA:  CLRF   x7D
038BC:  CLRF   x7C
038BE:  MOVLW  4C
038C0:  MOVWF  x7B
038C2:  MOVLW  4B
038C4:  MOVWF  x7A
038C6:  MOVLB  4
....................       }    
....................  
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
038C8:  MOVLB  0
038CA:  CALL   2424
038CE:  MOVLB  1
038D0:  MOVF   x7A,W
038D2:  MOVLB  4
038D4:  ADDWF  00,W
038D6:  MOVLB  1
038D8:  MOVWF  xEC
038DA:  MOVF   x7B,W
038DC:  MOVLB  4
038DE:  ADDWFC 01,W
038E0:  MOVLB  1
038E2:  MOVWF  xED
038E4:  MOVF   x7C,W
038E6:  MOVLB  4
038E8:  ADDWFC 02,W
038EA:  MOVLB  1
038EC:  MOVWF  xEE
038EE:  MOVF   x7D,W
038F0:  MOVLB  4
038F2:  ADDWFC 03,W
038F4:  MOVLB  1
038F6:  MOVWF  xEF
....................       MyTCBStub.Flags.bTimerEnabled = 1; 
038F8:  BSF    xF5.4
....................    } 
038FA:  BRA    397A
038FC:  MOVLB  4
....................    else if(vSendFlags & SENDTCP_KEEP_ALIVE) 
038FE:  BTFSS  x15.1
03900:  BRA    392A
....................    { 
....................       // Increment Keep Alive TX counter to handle disconnection if not response is returned 
....................       MyTCBStub.Flags.vUnackedKeepalives++; 
03902:  MOVLB  1
03904:  MOVF   xF5,W
03906:  ADDLW  01
03908:  ANDLW  07
0390A:  MOVWF  00
0390C:  MOVLW  F8
0390E:  ANDWF  xF5,W
03910:  IORWF  00,W
03912:  MOVWF  xF5
....................        
....................       // Generate a dummy byte 
....................       MyTCB.MySEQ -= 1; 
03914:  MOVLW  01
03916:  SUBWF  x7E,F
03918:  MOVLW  00
0391A:  SUBWFB x7F,F
0391C:  SUBWFB x80,F
0391E:  SUBWFB x81,F
....................       len = 1; 
03920:  MOVLB  4
03922:  CLRF   x3D
03924:  MOVLW  01
03926:  MOVWF  x3C
....................    } 
03928:  BRA    397C
....................    else if(MyTCBStub.Flags.bTimerEnabled)  
0392A:  MOVLB  1
0392C:  BTFSS  xF5.4
0392E:  BRA    397A
....................    { 
....................       // If we have data to transmit, but the remote RX window is zero,  
....................       // so we aren't transmitting any right now then make sure to not  
....................       // extend the retry counter or timer.  This will stall our TX  
....................       // with a periodic ACK sent to the remote node. 
....................       if(!(vSendFlags & SENDTCP_RESET_TIMERS)) 
03930:  MOVLB  4
03932:  BTFSC  x15.0
03934:  BRA    394A
....................       { 
....................          // Roll back retry counters since we can't send anything,  
....................          // but only if we incremented it in the first place 
....................          if(MyTCB.retryCount) 
03936:  MOVLB  1
03938:  MOVF   x9F,F
0393A:  BZ    3948
....................          { 
....................             MyTCB.retryCount--; 
0393C:  DECF   x9F,F
....................             MyTCB.retryInterval >>= 1; 
0393E:  BCF    FD8.0
03940:  RRCF   x7D,F
03942:  RRCF   x7C,F
03944:  RRCF   x7B,F
03946:  RRCF   x7A,F
03948:  MOVLB  4
....................          } 
....................       } 
....................     
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
0394A:  MOVLB  0
0394C:  CALL   2424
03950:  MOVLB  1
03952:  MOVF   x7A,W
03954:  MOVLB  4
03956:  ADDWF  00,W
03958:  MOVLB  1
0395A:  MOVWF  xEC
0395C:  MOVF   x7B,W
0395E:  MOVLB  4
03960:  ADDWFC 01,W
03962:  MOVLB  1
03964:  MOVWF  xED
03966:  MOVF   x7C,W
03968:  MOVLB  4
0396A:  ADDWFC 02,W
0396C:  MOVLB  1
0396E:  MOVWF  xEE
03970:  MOVF   x7D,W
03972:  MOVLB  4
03974:  ADDWFC 03,W
03976:  MOVLB  1
03978:  MOVWF  xEF
0397A:  MOVLB  4
....................    } 
....................     
....................  
....................    header.SourcePort         = MyTCB.localPort.Val; 
0397C:  MOVFF  18B,419
03980:  MOVFF  18A,418
....................    header.DestPort            = MyTCB.remotePort.Val; 
03984:  MOVFF  189,41B
03988:  MOVFF  188,41A
....................    header.SeqNumber         = MyTCB.MySEQ; 
0398C:  MOVFF  181,41F
03990:  MOVFF  180,41E
03994:  MOVFF  17F,41D
03998:  MOVFF  17E,41C
....................    header.AckNumber         = MyTCB.RemoteSEQ; 
0399C:  MOVFF  185,423
039A0:  MOVFF  184,422
039A4:  MOVFF  183,421
039A8:  MOVFF  182,420
....................    header.Flags.bits.Reserved2   = 0; 
039AC:  MOVLW  3F
039AE:  ANDWF  x25,W
039B0:  MOVWF  x25
....................    header.DataOffset.Reserved3   = 0; 
039B2:  MOVLW  F0
039B4:  ANDWF  x24,W
039B6:  MOVWF  x24
....................    header.Flags.byte         = vTCPFlags; 
039B8:  MOVFF  414,425
....................    header.UrgentPointer        = 0; 
039BC:  CLRF   x2B
039BE:  CLRF   x2A
....................  
....................    // Update our send sequence number and ensure retransmissions  
....................    // of SYNs and FINs use the right sequence number 
....................    MyTCB.MySEQ += (DWORD)len; 
039C0:  MOVFF  43D,01
039C4:  CLRF   02
039C6:  CLRF   03
039C8:  MOVF   x3C,W
039CA:  MOVLB  1
039CC:  ADDWF  x7E,F
039CE:  MOVF   01,W
039D0:  ADDWFC x7F,F
039D2:  MOVF   02,W
039D4:  ADDWFC x80,F
039D6:  MOVF   03,W
039D8:  ADDWFC x81,F
....................    if(vTCPFlags & SYN) 
039DA:  MOVLB  4
039DC:  BTFSS  x14.1
039DE:  BRA    3A1C
....................    { 
....................       // SEG.ACK needs to be zero for the first SYN packet for compatibility  
....................       // with certain paranoid TCP/IP stacks, even though the ACK flag isn't  
....................       // set (indicating that the AckNumber field is unused). 
....................       if(!(vTCPFlags & ACK)) 
039E0:  BTFSC  x14.4
039E2:  BRA    39EC
....................          header.AckNumber = 0x00000000; 
039E4:  CLRF   x23
039E6:  CLRF   x22
039E8:  CLRF   x21
039EA:  CLRF   x20
....................  
....................       if(MyTCB.flags.bSYNSent) 
039EC:  MOVLB  1
039EE:  BTFSS  x9C.1
039F0:  BRA    3A08
....................          header.SeqNumber--; 
039F2:  MOVLW  FF
039F4:  MOVLB  4
039F6:  ADDWF  x1C,F
039F8:  BTFSS  FD8.0
039FA:  ADDWF  x1D,F
039FC:  BTFSS  FD8.0
039FE:  ADDWF  x1E,F
03A00:  BTFSS  FD8.0
03A02:  ADDWF  x1F,F
03A04:  BRA    3A1C
03A06:  MOVLB  1
....................       else 
....................       { 
....................          MyTCB.MySEQ++; 
03A08:  MOVLW  01
03A0A:  ADDWF  x7E,F
03A0C:  BTFSC  FD8.0
03A0E:  INCF   x7F,F
03A10:  BTFSC  FD8.2
03A12:  INCF   x80,F
03A14:  BTFSC  FD8.2
03A16:  INCF   x81,F
....................          MyTCB.flags.bSYNSent = 1; 
03A18:  BSF    x9C.1
03A1A:  MOVLB  4
....................       } 
....................    } 
....................    if(vTCPFlags & FIN) 
03A1C:  BTFSS  x14.0
03A1E:  BRA    3A26
....................    { 
....................         MyTCB.flags.bFINSent = 1;   // do not advance the seq no for FIN! 
03A20:  MOVLB  1
03A22:  BSF    x9C.0
03A24:  MOVLB  4
....................    } 
....................  
....................    // Calculate the amount of free space in the RX buffer area of this socket 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
03A26:  MOVLB  1
03A28:  MOVF   xEB,W
03A2A:  SUBWF  xE9,W
03A2C:  BNC   3A68
03A2E:  BNZ   3A36
03A30:  MOVF   xEA,W
03A32:  SUBWF  xE8,W
03A34:  BNC   3A68
....................       header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
03A36:  MOVF   xE0,W
03A38:  SUBWF  xE2,W
03A3A:  MOVLB  4
03A3C:  MOVWF  x3E
03A3E:  MOVLB  1
03A40:  MOVF   xE1,W
03A42:  SUBWFB xE3,W
03A44:  MOVLB  4
03A46:  MOVWF  x3F
03A48:  MOVLB  1
03A4A:  MOVF   xEA,W
03A4C:  SUBWF  xE8,W
03A4E:  MOVWF  00
03A50:  MOVF   xEB,W
03A52:  SUBWFB xE9,W
03A54:  MOVWF  03
03A56:  MOVF   00,W
03A58:  MOVLB  4
03A5A:  SUBWF  x3E,W
03A5C:  MOVWF  x26
03A5E:  MOVF   03,W
03A60:  SUBWFB x3F,W
03A62:  MOVWF  x27
03A64:  BRA    3A86
03A66:  MOVLB  1
....................    else 
....................       header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
03A68:  MOVF   xE8,W
03A6A:  SUBWF  xEA,W
03A6C:  MOVLB  4
03A6E:  MOVWF  x3E
03A70:  MOVLB  1
03A72:  MOVF   xE9,W
03A74:  SUBWFB xEB,W
03A76:  MOVLB  4
03A78:  MOVWF  x3F
03A7A:  MOVLW  01
03A7C:  SUBWF  x3E,W
03A7E:  MOVWF  x26
03A80:  MOVLW  00
03A82:  SUBWFB x3F,W
03A84:  MOVWF  x27
....................  
....................    // Calculate the amount of free space in the MAC RX buffer area and adjust window if needed 
....................    wVal.Val = MACGetFreeRxSize(); 
03A86:  MOVLB  0
03A88:  GOTO   3024
03A8C:  MOVFF  02,417
03A90:  MOVFF  01,416
....................    if(wVal.Val < 64) 
03A94:  MOVLB  4
03A96:  MOVF   x17,F
03A98:  BNZ   3AA6
03A9A:  MOVF   x16,W
03A9C:  SUBLW  3F
03A9E:  BNC   3AA6
....................     { 
....................       wVal.Val = 0; 
03AA0:  CLRF   x17
03AA2:  CLRF   x16
....................     } 
03AA4:  BRA    3AAE
....................     else 
....................     { 
....................       wVal.Val -= 64; 
03AA6:  MOVLW  40
03AA8:  SUBWF  x16,F
03AAA:  MOVLW  00
03AAC:  SUBWFB x17,F
....................     } 
....................    // Force the remote node to throttle back if we are running low on general RX buffer space 
....................    if(header.Window > wVal.Val) 
03AAE:  MOVF   x17,W
03AB0:  SUBWF  x27,W
03AB2:  BNC   3AC4
03AB4:  BNZ   3ABC
03AB6:  MOVF   x26,W
03AB8:  SUBWF  x16,W
03ABA:  BC    3AC4
....................       header.Window = wVal.Val; 
03ABC:  MOVFF  417,427
03AC0:  MOVFF  416,426
....................  
....................    SwapTCPHeader(&header); 
03AC4:  MOVLW  04
03AC6:  MOVWF  x3F
03AC8:  MOVLW  18
03ACA:  MOVWF  x3E
03ACC:  MOVLB  0
03ACE:  CALL   32B2
....................  
....................  
....................    len += sizeof(header); 
03AD2:  MOVLW  14
03AD4:  MOVLB  4
03AD6:  ADDWF  x3C,F
03AD8:  MOVLW  00
03ADA:  ADDWFC x3D,F
....................    header.DataOffset.Val   = sizeof(header) >> 2; 
03ADC:  MOVLW  0F
03ADE:  ANDWF  x24,W
03AE0:  IORLW  50
03AE2:  MOVWF  x24
....................  
....................    // Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet 
....................    if(vTCPFlags & SYN) 
03AE4:  BTFSS  x14.1
03AE6:  BRA    3B16
....................    { 
....................       len += sizeof(options); 
03AE8:  MOVLW  04
03AEA:  ADDWF  x3C,F
03AEC:  MOVLW  00
03AEE:  ADDWFC x3D,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
03AF0:  MOVLW  02
03AF2:  MOVWF  x2C
....................       options.Length = 0x04; 
03AF4:  MOVLW  04
03AF6:  MOVWF  x2D
....................  
....................       // Load MSS and swap to big endian 
....................       options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8); 
03AF8:  MOVLW  18
03AFA:  MOVWF  x2F
03AFC:  MOVLW  02
03AFE:  MOVWF  x2E
....................  
....................      #if defined(__PCD__)  //__PCD__ __PCH__ __CCS__ bug 
....................       unsigned int8 scr8; 
....................       scr8 = header.DataOffset.Val; 
....................       scr8 += sizeof(options) >> 2; 
....................       header.DataOffset.Val = scr8; 
....................      #else  //standard code 
....................       header.DataOffset.Val   += sizeof(options) >> 2; 
03B00:  SWAPF  x24,W
03B02:  ANDLW  0F
03B04:  ADDLW  01
03B06:  MOVWF  00
03B08:  SWAPF  00,W
03B0A:  ANDLW  F0
03B0C:  MOVWF  00
03B0E:  MOVLW  0F
03B10:  ANDWF  x24,W
03B12:  IORWF  00,W
03B14:  MOVWF  x24
....................      #endif 
....................    } 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
03B16:  MOVFF  26,433
03B1A:  MOVFF  25,432
03B1E:  MOVFF  24,431
03B22:  MOVFF  23,430
....................    pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr; 
03B26:  MOVFF  193,437
03B2A:  MOVFF  192,436
03B2E:  MOVFF  191,435
03B32:  MOVFF  190,434
....................    pseudoHeader.Zero           = 0x0; 
03B36:  CLRF   x38
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
03B38:  MOVLW  06
03B3A:  MOVWF  x39
....................    pseudoHeader.Length         = len; 
03B3C:  MOVFF  43D,43B
03B40:  MOVFF  43C,43A
....................    SwapPseudoHeader(pseudoHeader); 
03B44:  MOVFF  43B,45E
03B48:  MOVFF  43A,45D
03B4C:  MOVLB  0
03B4E:  CALL   1A24
03B52:  MOVFF  02,43B
03B56:  MOVFF  01,43A
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader)); 
03B5A:  MOVLW  04
03B5C:  MOVLB  4
03B5E:  MOVWF  x3F
03B60:  MOVLW  30
03B62:  MOVWF  x3E
03B64:  MOVFF  43F,45A
03B68:  MOVWF  x59
03B6A:  CLRF   x5C
03B6C:  MOVLW  0C
03B6E:  MOVWF  x5B
03B70:  MOVLB  0
03B72:  CALL   1B20
03B76:  MOVFF  01,428
03B7A:  MOVLB  4
03B7C:  COMF   x28,F
03B7E:  MOVFF  02,429
03B82:  COMF   x29,F
....................  
....................    // Write IP header 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
03B84:  MOVLW  11
03B86:  MOVWF  x4E
03B88:  MOVLW  E5
03B8A:  MOVWF  x4D
03B8C:  MOVLB  0
03B8E:  CALL   0AF2
....................    IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len); 
03B92:  MOVLW  01
03B94:  MOVLB  4
03B96:  MOVWF  x3F
03B98:  MOVLW  90
03B9A:  MOVWF  x3E
03B9C:  MOVLW  06
03B9E:  MOVWF  x40
03BA0:  MOVFF  43D,442
03BA4:  MOVFF  43C,441
03BA8:  MOVLB  0
03BAA:  CALL   1CCE
....................    MACPutArray((BYTE*)&header, sizeof(header)); 
03BAE:  MOVLW  04
03BB0:  MOVLB  4
03BB2:  MOVWF  x3F
03BB4:  MOVLW  18
03BB6:  MOVWF  x3E
03BB8:  MOVFF  43F,463
03BBC:  MOVWF  x62
03BBE:  CLRF   x65
03BC0:  MOVLW  14
03BC2:  MOVWF  x64
03BC4:  MOVLB  0
03BC6:  CALL   0B62
....................    if(vTCPFlags & SYN) 
03BCA:  MOVLB  4
03BCC:  BTFSS  x14.1
03BCE:  BRA    3BEC
....................       MACPutArray((BYTE*)&options, sizeof(options)); 
03BD0:  MOVLW  04
03BD2:  MOVWF  x3F
03BD4:  MOVLW  2C
03BD6:  MOVWF  x3E
03BD8:  MOVFF  43F,463
03BDC:  MOVWF  x62
03BDE:  CLRF   x65
03BE0:  MOVLW  04
03BE2:  MOVWF  x64
03BE4:  MOVLB  0
03BE6:  CALL   0B62
03BEA:  MOVLB  4
....................  
....................    // Update the TCP checksum 
....................    MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)); 
03BEC:  MOVLW  11
03BEE:  MOVWF  x4E
03BF0:  MOVLW  F9
03BF2:  MOVWF  x4D
03BF4:  MOVLB  0
03BF6:  CALL   0BA8
....................    wVal.Val = CalcIPBufferChecksum(len); 
03BFA:  MOVFF  43D,43F
03BFE:  MOVFF  43C,43E
03C02:  RCALL  34D8
03C04:  MOVFF  02,417
03C08:  MOVFF  01,416
.................... #if defined(DEBUG_GENERATE_TX_LOSS) 
....................    // Damage TCP checksums on TX packets randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_TX_LOSS) 
....................    { 
....................       wVal.Val++; 
....................    } 
.................... #endif 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16); 
03C0C:  MOVLW  12
03C0E:  MOVLB  4
03C10:  MOVWF  x4E
03C12:  MOVLW  09
03C14:  MOVWF  x4D
03C16:  MOVLB  0
03C18:  CALL   0AF2
....................    MACPutArray((BYTE*)&wVal, sizeof(WORD)); 
03C1C:  MOVLW  04
03C1E:  MOVLB  4
03C20:  MOVWF  x3F
03C22:  MOVLW  16
03C24:  MOVWF  x3E
03C26:  MOVFF  43F,463
03C2A:  MOVWF  x62
03C2C:  CLRF   x65
03C2E:  MOVLW  02
03C30:  MOVWF  x64
03C32:  MOVLB  0
03C34:  CALL   0B62
....................  
....................    // Physically start the packet transmission over the network 
....................    MACFlush(); 
03C38:  CALL   1DB8
03C3C:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
....................  
....................   Summary: 
....................    Finds a suitable socket for a TCP segment. 
....................  
....................   Description: 
....................    This function searches through the sockets and attempts to match one with 
....................    a given TCP header and NODE_INFO structure.  If a socket is found, its  
....................    index is saved in hCurrentTCP and the associated MyTCBStub and MyTCB are 
....................    loaded. Otherwise, INVALID_SOCKET is placed in hCurrentTCP. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    h - TCP header to be matched against 
....................    remote - The remote node who sent this header 
....................  
....................   Return Values: 
....................    TRUE - A match was found and is loaded in hCurrentTCP 
....................    FALSE - No suitable socket was found and hCurrentTCP is INVALID_SOCKET 
....................   ***************************************************************************/ 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    TCP_SOCKET partialMatch; 
....................    WORD hash; 
....................  
....................    // Prevent connections on invalid port 0 
....................    if(h->DestPort == 0u) 
*
04D00:  MOVLW  02
04D02:  MOVLB  3
04D04:  ADDWF  xF4,W
04D06:  MOVWF  FE9
04D08:  MOVLW  00
04D0A:  ADDWFC xF5,W
04D0C:  MOVWF  FEA
04D0E:  MOVFF  FEC,3FF
04D12:  MOVF   FED,F
04D14:  MOVFF  FEF,3FE
04D18:  MOVF   xFE,F
04D1A:  BNZ   4D26
04D1C:  MOVF   xFF,F
04D1E:  BNZ   4D26
....................       return FALSE; 
04D20:  MOVLW  00
04D22:  MOVWF  01
04D24:  BRA    5344
....................  
....................    partialMatch = INVALID_SOCKET; 
04D26:  MOVLW  FE
04D28:  MOVWF  xF9
....................    hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort; 
04D2A:  MOVLW  02
04D2C:  ADDWF  xF6,W
04D2E:  MOVWF  FE9
04D30:  MOVLW  00
04D32:  ADDWFC xF7,W
04D34:  MOVWF  FEA
04D36:  MOVFF  FEC,3FF
04D3A:  MOVF   FED,F
04D3C:  MOVFF  FEF,3FE
04D40:  MOVFF  3F6,FE9
04D44:  MOVFF  3F7,FEA
04D48:  MOVFF  FEC,03
04D4C:  MOVF   FED,F
04D4E:  MOVF   FEF,W
04D50:  ADDWF  xFE,F
04D52:  MOVF   03,W
04D54:  ADDWFC xFF,F
04D56:  MOVFF  3F4,FE9
04D5A:  MOVFF  3F5,FEA
04D5E:  MOVFF  FEC,03
04D62:  MOVF   FED,F
04D64:  MOVF   FEF,W
04D66:  ADDWF  xFE,F
04D68:  MOVF   03,W
04D6A:  ADDWFC xFF,F
04D6C:  MOVLW  02
04D6E:  ADDWF  xF4,W
04D70:  MOVWF  FE9
04D72:  MOVLW  00
04D74:  ADDWFC xF5,W
04D76:  MOVWF  FEA
04D78:  MOVFF  FEC,03
04D7C:  MOVF   FED,F
04D7E:  MOVF   FEF,W
04D80:  XORWF  xFE,W
04D82:  MOVWF  xFA
04D84:  MOVF   03,W
04D86:  XORWF  xFF,W
04D88:  MOVWF  xFB
....................  
....................    // Loop through all sockets looking for a socket that is expecting this  
....................    // packet or can handle it. 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ ) 
04D8A:  CLRF   xF8
04D8C:  MOVF   xF8,F
04D8E:  BTFSS  FD8.2
04D90:  BRA    4EA2
....................    { 
....................       SyncTCBStub(hTCP); 
04D92:  MOVFF  3F8,3FE
04D96:  MOVLB  0
04D98:  CALL   0A4A
....................  
....................       if(MyTCBStub.smState == TCP_CLOSED) 
04D9C:  MOVLB  1
04D9E:  MOVF   xF4,W
04DA0:  SUBLW  0D
04DA2:  BNZ   4DA8
....................       { 
....................          continue; 
04DA4:  BRA    4E9C
....................       } 
04DA6:  BRA    4DEE
....................       else if(MyTCBStub.smState == TCP_LISTEN) 
04DA8:  MOVF   xF4,W
04DAA:  SUBLW  04
04DAC:  BNZ   4DD8
....................       {// For listening ports, check if this is the correct port 
....................          if(MyTCBStub.remoteHash.Val == h->DestPort) 
04DAE:  MOVLW  02
04DB0:  MOVLB  3
04DB2:  ADDWF  xF4,W
04DB4:  MOVWF  FE9
04DB6:  MOVLW  00
04DB8:  ADDWFC xF5,W
04DBA:  MOVWF  FEA
04DBC:  MOVFF  FEC,03
04DC0:  MOVF   FED,F
04DC2:  MOVF   FEF,W
04DC4:  MOVLB  1
04DC6:  SUBWF  xF7,W
04DC8:  BNZ   4DD4
04DCA:  MOVF   03,W
04DCC:  SUBWF  xF8,W
04DCE:  BNZ   4DD4
....................             partialMatch = hTCP; 
04DD0:  MOVFF  3F8,3F9
....................           
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          // Check the SSL port as well for SSL Servers 
....................          // 0 is defined as an invalid port number 
....................          if(MyTCBStub.sslTxHead == h->DestPort) 
....................             partialMatch = hTCP; 
....................          #endif 
....................           
....................          continue; 
04DD4:  BRA    4E9C
....................       } 
04DD6:  BRA    4DEE
....................       else if(MyTCBStub.remoteHash.Val != hash) 
04DD8:  MOVLB  3
04DDA:  MOVF   xFA,W
04DDC:  MOVLB  1
04DDE:  SUBWF  xF7,W
04DE0:  BNZ   4DEC
04DE2:  MOVLB  3
04DE4:  MOVF   xFB,W
04DE6:  MOVLB  1
04DE8:  SUBWF  xF8,W
04DEA:  BZ    4DEE
....................       {// Ignore if the hash doesn't match 
....................          continue; 
04DEC:  BRA    4E9C
....................       } 
....................  
....................       SyncTCB(); 
04DEE:  MOVLB  0
04DF0:  CALL   1052
....................       if(   h->DestPort == MyTCB.localPort.Val && 
....................          h->SourcePort == MyTCB.remotePort.Val && 
....................          remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val) 
04DF4:  MOVLW  02
04DF6:  MOVLB  3
04DF8:  ADDWF  xF4,W
04DFA:  MOVWF  FE9
04DFC:  MOVLW  00
04DFE:  ADDWFC xF5,W
04E00:  MOVWF  FEA
04E02:  MOVFF  FEC,3FF
04E06:  MOVF   FED,F
04E08:  MOVFF  FEF,3FE
04E0C:  MOVLB  1
04E0E:  MOVF   x8A,W
04E10:  MOVLB  3
04E12:  SUBWF  xFE,W
04E14:  BNZ   4E9A
04E16:  MOVLB  1
04E18:  MOVF   x8B,W
04E1A:  MOVLB  3
04E1C:  SUBWF  xFF,W
04E1E:  BNZ   4E9A
04E20:  MOVFF  3F4,FE9
04E24:  MOVFF  3F5,FEA
04E28:  MOVFF  FEC,3FF
04E2C:  MOVF   FED,F
04E2E:  MOVFF  FEF,3FE
04E32:  MOVLB  1
04E34:  MOVF   x88,W
04E36:  MOVLB  3
04E38:  SUBWF  xFE,W
04E3A:  BNZ   4E9A
04E3C:  MOVLB  1
04E3E:  MOVF   x89,W
04E40:  MOVLB  3
04E42:  SUBWF  xFF,W
04E44:  BNZ   4E9A
04E46:  MOVFF  3F6,FE9
04E4A:  MOVFF  3F7,FEA
04E4E:  MOVFF  FEF,3FE
04E52:  MOVFF  FEC,3FF
04E56:  MOVFF  FEC,400
04E5A:  MOVFF  FEC,401
04E5E:  MOVLB  1
04E60:  MOVF   x90,W
04E62:  MOVLB  3
04E64:  SUBWF  xFE,W
04E66:  BNZ   4E9A
04E68:  MOVLB  1
04E6A:  MOVF   x91,W
04E6C:  MOVLB  3
04E6E:  SUBWF  xFF,W
04E70:  BNZ   4E9A
04E72:  MOVLB  1
04E74:  MOVF   x92,W
04E76:  MOVLB  4
04E78:  SUBWF  x00,W
04E7A:  BTFSC  FD8.2
04E7C:  BRA    4E82
04E7E:  MOVLB  3
04E80:  BRA    4E9A
04E82:  MOVLB  1
04E84:  MOVF   x93,W
04E86:  MOVLB  4
04E88:  SUBWF  x01,W
04E8A:  BTFSC  FD8.2
04E8C:  BRA    4E92
04E8E:  MOVLB  3
04E90:  BRA    4E9A
....................       { 
....................          return TRUE; 
04E92:  MOVLW  01
04E94:  MOVWF  01
04E96:  MOVLB  3
04E98:  BRA    5344
04E9A:  MOVLB  1
....................       } 
04E9C:  MOVLB  3
04E9E:  INCF   xF8,F
04EA0:  BRA    4D8C
....................    } 
....................  
....................  
....................    // If there is a partial match, then a listening socket is currently  
....................    // available.  Set up the extended TCB with the info needed  
....................    // to establish a connection and return this socket to the  
....................    // caller. 
....................    if(partialMatch != INVALID_SOCKET) 
04EA2:  MOVF   xF9,W
04EA4:  SUBLW  FE
04EA6:  BZ    4F1C
....................    { 
....................       SyncTCBStub(partialMatch); 
04EA8:  MOVFF  3F9,3FE
04EAC:  MOVLB  0
04EAE:  CALL   0A4A
....................       SyncTCB(); 
04EB2:  CALL   1052
....................     
....................       // For SSL ports, begin the SSL Handshake 
....................       #if defined(STACK_USE_SSL_SERVER) 
....................       if(MyTCBStub.sslTxHead == h->DestPort) 
....................       { 
....................          // Try to start an SSL session.  If no stubs are available, 
....................          // we can't service this request right now, so ignore it. 
....................          if(!TCPStartSSLServer(partialMatch)) 
....................             partialMatch = INVALID_SOCKET; 
....................       } 
....................       #endif 
....................     
....................       // Make sure the above check didn't fail (this is unfortunately  
....................       // redundant for non-SSL sockets).  Otherwise, fall out to below 
....................       // and add to the SYN queue. 
....................       if(partialMatch != INVALID_SOCKET) 
04EB6:  MOVLB  3
04EB8:  MOVF   xF9,W
04EBA:  SUBLW  FE
04EBC:  BZ    4F1C
....................       { 
....................          MyTCBStub.remoteHash.Val = hash; 
04EBE:  MOVFF  3FB,1F8
04EC2:  MOVFF  3FA,1F7
....................        
....................          memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO)); 
04EC6:  MOVLW  01
04EC8:  MOVWF  xFF
04ECA:  MOVLW  90
04ECC:  MOVFF  3FF,FEA
04ED0:  MOVWF  FE9
04ED2:  MOVFF  3F7,FE2
04ED6:  MOVFF  3F6,FE1
04EDA:  MOVLW  0A
04EDC:  MOVWF  01
04EDE:  MOVFF  FE6,FEE
04EE2:  DECFSZ 01,F
04EE4:  BRA    4EDE
....................          MyTCB.remotePort.Val = h->SourcePort; 
04EE6:  MOVFF  3F4,FE9
04EEA:  MOVFF  3F5,FEA
04EEE:  MOVFF  FEC,189
04EF2:  MOVF   FED,F
04EF4:  MOVFF  FEF,188
....................          MyTCB.localPort.Val = h->DestPort; 
04EF8:  MOVLW  02
04EFA:  ADDWF  xF4,W
04EFC:  MOVWF  FE9
04EFE:  MOVLW  00
04F00:  ADDWFC xF5,W
04F02:  MOVWF  FEA
04F04:  MOVFF  FEC,18B
04F08:  MOVF   FED,F
04F0A:  MOVFF  FEF,18A
....................          MyTCB.txUnackedTail   = MyTCBStub.bufferTxStart; 
04F0E:  MOVFF  1DF,187
04F12:  MOVFF  1DE,186
....................        
....................          // All done, and we have a match 
....................          return TRUE; 
04F16:  MOVLW  01
04F18:  MOVWF  01
04F1A:  BRA    5344
....................       } 
....................    } 
....................  
....................    // No available sockets are listening on this port.  (Or, for 
....................    // SSL requests, perhaps no SSL sessions were available.  However, 
....................    // there may be a server socket which is currently busy but  
....................    // could handle this packet, so we should check. 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    { 
....................       WORD wQueueInsertPos; 
....................        
....................       // See if this is a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
04F1C:  MOVLW  0D
04F1E:  ADDWF  xF4,W
04F20:  MOVWF  FE9
04F22:  MOVLW  00
04F24:  ADDWFC xF5,W
04F26:  MOVWF  FEA
04F28:  BTFSC  FEF.1
04F2A:  BRA    4F32
....................          return FALSE; 
04F2C:  MOVLW  00
04F2E:  MOVWF  01
04F30:  BRA    5344
....................  
....................       // See if there is space in our SYN queue 
....................       if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort) 
04F32:  MOVLB  1
04F34:  MOVF   xDA,W
04F36:  IORWF  xDB,W
04F38:  BZ    4F44
....................          return FALSE; 
04F3A:  MOVLW  00
04F3C:  MOVWF  01
04F3E:  MOVLB  3
04F40:  BRA    5344
04F42:  MOVLB  1
....................        
....................       // See if we have this SYN already in our SYN queue. 
....................       // If not already in the queue, find out where we  
....................       // should insert this SYN to the queue 
....................       for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++) 
04F44:  MOVLB  3
04F46:  CLRF   xFD
04F48:  CLRF   xFC
04F4A:  MOVF   xFD,F
04F4C:  BTFSS  FD8.2
04F4E:  BRA    512A
04F50:  MOVF   xFC,W
04F52:  SUBLW  02
04F54:  BTFSS  FD8.0
04F56:  BRA    512A
....................       { 
....................          // Exit loop if we found a free record 
....................          if(SYNQueue[wQueueInsertPos].wDestPort == 0u) 
04F58:  MOVFF  3FD,3FF
04F5C:  MOVFF  3FC,3FE
04F60:  MOVLB  4
04F62:  CLRF   x01
04F64:  MOVLW  14
04F66:  MOVWF  x00
04F68:  MOVLB  0
04F6A:  CALL   2FFC
04F6E:  MOVFF  01,3FE
04F72:  MOVLW  10
04F74:  MOVLB  3
04F76:  ADDWF  01,W
04F78:  MOVWF  01
04F7A:  MOVLW  00
04F7C:  ADDWFC 02,W
04F7E:  MOVWF  03
04F80:  MOVF   01,W
04F82:  ADDLW  A2
04F84:  MOVWF  FE9
04F86:  MOVLW  01
04F88:  ADDWFC 03,W
04F8A:  MOVWF  FEA
04F8C:  MOVFF  FEC,3FF
04F90:  MOVF   FED,F
04F92:  MOVFF  FEF,3FE
04F96:  MOVF   xFE,F
04F98:  BNZ   4FA0
04F9A:  MOVF   xFF,F
04F9C:  BNZ   4FA0
....................             break; 
04F9E:  BRA    512A
....................  
....................          // Check if this SYN packet is already in the SYN queue 
....................          if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort) 
04FA0:  MOVFF  3FD,3FF
04FA4:  MOVFF  3FC,3FE
04FA8:  MOVLB  4
04FAA:  CLRF   x01
04FAC:  MOVLW  14
04FAE:  MOVWF  x00
04FB0:  MOVLB  0
04FB2:  CALL   2FFC
04FB6:  MOVFF  01,3FE
04FBA:  MOVLW  10
04FBC:  MOVLB  3
04FBE:  ADDWF  01,W
04FC0:  MOVWF  01
04FC2:  MOVLW  00
04FC4:  ADDWFC 02,W
04FC6:  MOVWF  03
04FC8:  MOVF   01,W
04FCA:  ADDLW  A2
04FCC:  MOVWF  FE9
04FCE:  MOVLW  01
04FD0:  ADDWFC 03,W
04FD2:  MOVWF  FEA
04FD4:  MOVFF  FEC,3FF
04FD8:  MOVF   FED,F
04FDA:  MOVFF  FEF,3FE
04FDE:  MOVLW  02
04FE0:  ADDWF  xF4,W
04FE2:  MOVWF  FE9
04FE4:  MOVLW  00
04FE6:  ADDWFC xF5,W
04FE8:  MOVWF  FEA
04FEA:  MOVFF  FEC,03
04FEE:  MOVF   FED,F
04FF0:  MOVF   FEF,W
04FF2:  SUBWF  xFE,W
04FF4:  BNZ   4FFC
04FF6:  MOVF   03,W
04FF8:  SUBWF  xFF,W
04FFA:  BZ    4FFE
....................             continue; 
04FFC:  BRA    5122
....................          if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort) 
04FFE:  MOVFF  3FD,3FF
05002:  MOVFF  3FC,3FE
05006:  MOVLB  4
05008:  CLRF   x01
0500A:  MOVLW  14
0500C:  MOVWF  x00
0500E:  MOVLB  0
05010:  CALL   2FFC
05014:  MOVFF  01,3FE
05018:  MOVLW  0A
0501A:  MOVLB  3
0501C:  ADDWF  01,W
0501E:  MOVWF  01
05020:  MOVLW  00
05022:  ADDWFC 02,W
05024:  MOVWF  03
05026:  MOVF   01,W
05028:  ADDLW  A2
0502A:  MOVWF  FE9
0502C:  MOVLW  01
0502E:  ADDWFC 03,W
05030:  MOVWF  FEA
05032:  MOVFF  FEC,3FF
05036:  MOVF   FED,F
05038:  MOVFF  FEF,3FE
0503C:  MOVFF  3F4,FE9
05040:  MOVFF  3F5,FEA
05044:  MOVFF  FEC,03
05048:  MOVF   FED,F
0504A:  MOVF   FEF,W
0504C:  SUBWF  xFE,W
0504E:  BNZ   5056
05050:  MOVF   03,W
05052:  SUBWF  xFF,W
05054:  BZ    5058
....................             continue; 
05056:  BRA    5122
....................          if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val) 
05058:  MOVFF  3FD,3FF
0505C:  MOVFF  3FC,3FE
05060:  MOVLB  4
05062:  CLRF   x01
05064:  MOVLW  14
05066:  MOVWF  x00
05068:  MOVLB  0
0506A:  CALL   2FFC
0506E:  MOVFF  02,3FF
05072:  MOVFF  01,3FE
05076:  MOVLW  A2
05078:  MOVLB  3
0507A:  ADDWF  01,W
0507C:  MOVWF  FE9
0507E:  MOVLW  01
05080:  ADDWFC 02,W
05082:  MOVWF  FEA
05084:  MOVFF  FEF,400
05088:  MOVFF  FEC,401
0508C:  MOVFF  FEC,402
05090:  MOVFF  FEC,403
05094:  MOVFF  3F6,FE9
05098:  MOVFF  3F7,FEA
0509C:  MOVFF  FEF,00
050A0:  MOVFF  FEC,01
050A4:  MOVFF  FEC,02
050A8:  MOVFF  FEC,03
050AC:  MOVF   00,W
050AE:  MOVLB  4
050B0:  SUBWF  x00,W
050B2:  BNZ   50C6
050B4:  MOVF   01,W
050B6:  SUBWF  x01,W
050B8:  BNZ   50C6
050BA:  MOVF   02,W
050BC:  SUBWF  x02,W
050BE:  BNZ   50C6
050C0:  MOVF   03,W
050C2:  SUBWF  x03,W
050C4:  BZ    50CC
....................             continue; 
050C6:  MOVLB  3
050C8:  BRA    5122
050CA:  MOVLB  4
....................  
....................          // SYN matches SYN queue entry.  Update timestamp and do nothing. 
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
050CC:  MOVFF  3FD,3FF
050D0:  MOVFF  3FC,3FE
050D4:  CLRF   x01
050D6:  MOVLW  14
050D8:  MOVWF  x00
050DA:  MOVLB  0
050DC:  CALL   2FFC
050E0:  MOVFF  01,3FE
050E4:  MOVLW  12
050E6:  MOVLB  3
050E8:  ADDWF  01,W
050EA:  MOVWF  01
050EC:  MOVLW  00
050EE:  ADDWFC 02,W
050F0:  MOVWF  03
050F2:  MOVF   01,W
050F4:  ADDLW  A2
050F6:  MOVWF  01
050F8:  MOVLW  01
050FA:  ADDWFC 03,F
050FC:  MOVFF  01,3FE
05100:  MOVFF  03,3FF
05104:  MOVLB  0
05106:  CALL   2FD6
0510A:  MOVFF  3FF,FEA
0510E:  MOVFF  3FE,FE9
05112:  MOVFF  00,FEF
05116:  MOVFF  01,FEC
....................          return FALSE; 
0511A:  MOVLW  00
0511C:  MOVWF  01
0511E:  MOVLB  3
05120:  BRA    5344
05122:  INCF   xFC,F
05124:  BTFSC  FD8.2
05126:  INCF   xFD,F
05128:  BRA    4F4A
....................       } 
....................        
....................       // Check to see if we have any server sockets which  
....................       // are currently connected, but could handle this SYN  
....................       // request at a later time if the client disconnects. 
....................       for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
0512A:  CLRF   xF8
0512C:  MOVF   xF8,F
0512E:  BTFSS  FD8.2
05130:  BRA    5340
....................       { 
....................          SyncTCBStub(hTCP); 
05132:  MOVFF  3F8,3FE
05136:  MOVLB  0
05138:  CALL   0A4A
....................          if(!MyTCBStub.Flags.bServer) 
0513C:  MOVLB  1
0513E:  BTFSC  xF5.3
05140:  BRA    5144
....................             continue; 
05142:  BRA    533A
....................  
....................          SyncTCB(); 
05144:  MOVLB  0
05146:  CALL   1052
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort)) 
....................          #else 
....................          if(MyTCB.localPort.Val != h->DestPort) 
0514A:  MOVLW  02
0514C:  MOVLB  3
0514E:  ADDWF  xF4,W
05150:  MOVWF  FE9
05152:  MOVLW  00
05154:  ADDWFC xF5,W
05156:  MOVWF  FEA
05158:  MOVFF  FEC,03
0515C:  MOVF   FED,F
0515E:  MOVF   FEF,W
05160:  MOVLB  1
05162:  SUBWF  x8A,W
05164:  BNZ   516C
05166:  MOVF   03,W
05168:  SUBWF  x8B,W
0516A:  BZ    516E
....................          #endif 
....................             continue; 
0516C:  BRA    533A
....................  
....................          // Generate the SYN queue entry 
....................          memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO)); 
0516E:  MOVFF  3FD,3FF
05172:  MOVFF  3FC,3FE
05176:  MOVLB  4
05178:  CLRF   x01
0517A:  MOVLW  14
0517C:  MOVWF  x00
0517E:  MOVLB  0
05180:  CALL   2FFC
05184:  MOVFF  02,3FF
05188:  MOVFF  01,3FE
0518C:  MOVLW  A2
0518E:  MOVLB  3
05190:  ADDWF  01,W
05192:  MOVWF  01
05194:  MOVLW  01
05196:  ADDWFC 02,W
05198:  MOVWF  03
0519A:  MOVFF  01,400
0519E:  MOVLB  4
051A0:  MOVWF  x01
051A2:  MOVWF  FEA
051A4:  MOVFF  01,FE9
051A8:  MOVFF  3F7,FE2
051AC:  MOVFF  3F6,FE1
051B0:  MOVLW  0A
051B2:  MOVWF  01
051B4:  MOVFF  FE6,FEE
051B8:  DECFSZ 01,F
051BA:  BRA    51B4
....................          SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort; 
051BC:  MOVFF  3FD,3FF
051C0:  MOVFF  3FC,3FE
051C4:  CLRF   x01
051C6:  MOVLW  14
051C8:  MOVWF  x00
051CA:  MOVLB  0
051CC:  CALL   2FFC
051D0:  MOVFF  01,3FE
051D4:  MOVLW  0A
051D6:  MOVLB  3
051D8:  ADDWF  01,W
051DA:  MOVWF  01
051DC:  MOVLW  00
051DE:  ADDWFC 02,W
051E0:  MOVWF  03
051E2:  MOVF   01,W
051E4:  ADDLW  A2
051E6:  MOVWF  01
051E8:  MOVLW  01
051EA:  ADDWFC 03,F
051EC:  MOVFF  03,3FF
051F0:  MOVFF  3F4,FE9
051F4:  MOVFF  3F5,FEA
051F8:  MOVFF  FEC,03
051FC:  MOVF   FED,F
051FE:  MOVFF  FEF,400
05202:  MOVLB  4
05204:  MOVFF  3FF,FEA
05208:  MOVFF  01,FE9
0520C:  MOVFF  03,FEC
05210:  MOVF   FED,F
05212:  MOVFF  400,FEF
....................          SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber; 
05216:  MOVFF  3FD,3FF
0521A:  MOVFF  3FC,3FE
0521E:  CLRF   x01
05220:  MOVLW  14
05222:  MOVWF  x00
05224:  MOVLB  0
05226:  CALL   2FFC
0522A:  MOVFF  01,3FE
0522E:  MOVLW  0C
05230:  MOVLB  3
05232:  ADDWF  01,W
05234:  MOVWF  01
05236:  MOVLW  00
05238:  ADDWFC 02,W
0523A:  MOVWF  03
0523C:  MOVF   01,W
0523E:  ADDLW  A2
05240:  MOVWF  01
05242:  MOVLW  01
05244:  ADDWFC 03,F
05246:  MOVFF  01,3FE
0524A:  MOVFF  03,3FF
0524E:  MOVLW  04
05250:  ADDWF  xF4,W
05252:  MOVWF  FE9
05254:  MOVLW  00
05256:  ADDWFC xF5,W
05258:  MOVWF  FEA
0525A:  MOVFF  FEF,00
0525E:  MOVFF  FEC,01
05262:  MOVFF  FEC,02
05266:  MOVFF  FEC,03
0526A:  MOVFF  3FF,FEA
0526E:  MOVFF  3FE,FE9
05272:  MOVFF  00,FEF
05276:  MOVFF  01,FEC
0527A:  MOVFF  02,FEC
0527E:  MOVFF  03,FEC
....................          SYNQueue[wQueueInsertPos].wDestPort = h->DestPort; 
05282:  MOVFF  3FD,3FF
05286:  MOVFF  3FC,3FE
0528A:  MOVLB  4
0528C:  CLRF   x01
0528E:  MOVLW  14
05290:  MOVWF  x00
05292:  MOVLB  0
05294:  CALL   2FFC
05298:  MOVFF  01,3FE
0529C:  MOVLW  10
0529E:  MOVLB  3
052A0:  ADDWF  01,W
052A2:  MOVWF  01
052A4:  MOVLW  00
052A6:  ADDWFC 02,W
052A8:  MOVWF  03
052AA:  MOVF   01,W
052AC:  ADDLW  A2
052AE:  MOVWF  01
052B0:  MOVLW  01
052B2:  ADDWFC 03,F
052B4:  MOVFF  03,3FF
052B8:  MOVLW  02
052BA:  ADDWF  xF4,W
052BC:  MOVWF  FE9
052BE:  MOVLW  00
052C0:  ADDWFC xF5,W
052C2:  MOVWF  FEA
052C4:  MOVFF  FEC,03
052C8:  MOVF   FED,F
052CA:  MOVFF  FEF,400
052CE:  MOVLB  4
052D0:  MOVFF  3FF,FEA
052D4:  MOVFF  01,FE9
052D8:  MOVFF  03,FEC
052DC:  MOVF   FED,F
052DE:  MOVFF  400,FEF
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
052E2:  MOVFF  3FD,3FF
052E6:  MOVFF  3FC,3FE
052EA:  CLRF   x01
052EC:  MOVLW  14
052EE:  MOVWF  x00
052F0:  MOVLB  0
052F2:  CALL   2FFC
052F6:  MOVFF  01,3FE
052FA:  MOVLW  12
052FC:  MOVLB  3
052FE:  ADDWF  01,W
05300:  MOVWF  01
05302:  MOVLW  00
05304:  ADDWFC 02,W
05306:  MOVWF  03
05308:  MOVF   01,W
0530A:  ADDLW  A2
0530C:  MOVWF  01
0530E:  MOVLW  01
05310:  ADDWFC 03,F
05312:  MOVFF  01,3FE
05316:  MOVFF  03,3FF
0531A:  MOVLB  0
0531C:  CALL   2FD6
05320:  MOVFF  3FF,FEA
05324:  MOVFF  3FE,FE9
05328:  MOVFF  00,FEF
0532C:  MOVFF  01,FEC
....................  
....................          return FALSE; 
05330:  MOVLW  00
05332:  MOVWF  01
05334:  MOVLB  3
05336:  BRA    5344
05338:  MOVLB  1
0533A:  MOVLB  3
0533C:  INCF   xF8,F
0533E:  BRA    512C
....................       } 
....................    } 
....................    #endif 
....................        
....................    return FALSE; 
05340:  MOVLW  00
05342:  MOVWF  01
05344:  MOVLB  0
05346:  GOTO   688C (RETURN)
....................  
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SwapTCPHeader(TCP_HEADER* header) 
....................  
....................   Summary: 
....................    Swaps endian-ness of a TCP header. 
....................  
....................   Description: 
....................    This function swaps the endian-ness of a given TCP header for comparison. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    header - The TCP header that is to be swapped 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................    header->SourcePort      = swaps(header->SourcePort); 
*
032B2:  MOVLB  4
032B4:  MOVFF  43E,01
032B8:  MOVFF  43F,03
032BC:  MOVFF  43E,440
032C0:  MOVFF  43F,441
032C4:  MOVFF  43E,FE9
032C8:  MOVFF  43F,FEA
032CC:  MOVFF  FEC,443
032D0:  MOVF   FED,F
032D2:  MOVFF  FEF,442
032D6:  MOVFF  443,45E
032DA:  MOVFF  442,45D
032DE:  MOVLB  0
032E0:  CALL   1A24
032E4:  MOVFF  441,FEA
032E8:  MOVFF  440,FE9
032EC:  MOVFF  02,FEC
032F0:  MOVF   FED,F
032F2:  MOVFF  01,FEF
....................    header->DestPort        = swaps(header->DestPort); 
032F6:  MOVLW  02
032F8:  MOVLB  4
032FA:  ADDWF  x3E,W
032FC:  MOVWF  01
032FE:  MOVLW  00
03300:  ADDWFC x3F,W
03302:  MOVWF  03
03304:  MOVFF  01,440
03308:  MOVWF  x41
0330A:  MOVLW  02
0330C:  ADDWF  x3E,W
0330E:  MOVWF  FE9
03310:  MOVLW  00
03312:  ADDWFC x3F,W
03314:  MOVWF  FEA
03316:  MOVFF  FEC,443
0331A:  MOVF   FED,F
0331C:  MOVFF  FEF,442
03320:  MOVFF  443,45E
03324:  MOVFF  442,45D
03328:  MOVLB  0
0332A:  CALL   1A24
0332E:  MOVFF  441,FEA
03332:  MOVFF  440,FE9
03336:  MOVFF  02,FEC
0333A:  MOVF   FED,F
0333C:  MOVFF  01,FEF
....................    header->SeqNumber       = swapl(header->SeqNumber); 
03340:  MOVLW  04
03342:  MOVLB  4
03344:  ADDWF  x3E,W
03346:  MOVWF  01
03348:  MOVLW  00
0334A:  ADDWFC x3F,W
0334C:  MOVWF  03
0334E:  MOVFF  01,440
03352:  MOVWF  x41
03354:  MOVLW  04
03356:  ADDWF  x3E,W
03358:  MOVWF  FE9
0335A:  MOVLW  00
0335C:  ADDWFC x3F,W
0335E:  MOVWF  FEA
03360:  MOVFF  FEF,442
03364:  MOVFF  FEC,443
03368:  MOVFF  FEC,444
0336C:  MOVFF  FEC,445
03370:  MOVFF  445,449
03374:  MOVFF  444,448
03378:  MOVFF  443,447
0337C:  MOVFF  442,446
03380:  MOVLB  0
03382:  RCALL  313C
03384:  MOVFF  441,FEA
03388:  MOVFF  440,FE9
0338C:  MOVFF  00,FEF
03390:  MOVFF  01,FEC
03394:  MOVFF  02,FEC
03398:  MOVFF  03,FEC
....................    header->AckNumber       = swapl(header->AckNumber); 
0339C:  MOVLW  08
0339E:  MOVLB  4
033A0:  ADDWF  x3E,W
033A2:  MOVWF  01
033A4:  MOVLW  00
033A6:  ADDWFC x3F,W
033A8:  MOVWF  03
033AA:  MOVFF  01,440
033AE:  MOVWF  x41
033B0:  MOVLW  08
033B2:  ADDWF  x3E,W
033B4:  MOVWF  FE9
033B6:  MOVLW  00
033B8:  ADDWFC x3F,W
033BA:  MOVWF  FEA
033BC:  MOVFF  FEF,442
033C0:  MOVFF  FEC,443
033C4:  MOVFF  FEC,444
033C8:  MOVFF  FEC,445
033CC:  MOVFF  445,449
033D0:  MOVFF  444,448
033D4:  MOVFF  443,447
033D8:  MOVFF  442,446
033DC:  MOVLB  0
033DE:  RCALL  313C
033E0:  MOVFF  441,FEA
033E4:  MOVFF  440,FE9
033E8:  MOVFF  00,FEF
033EC:  MOVFF  01,FEC
033F0:  MOVFF  02,FEC
033F4:  MOVFF  03,FEC
....................    header->Window          = swaps(header->Window); 
033F8:  MOVLW  0E
033FA:  MOVLB  4
033FC:  ADDWF  x3E,W
033FE:  MOVWF  01
03400:  MOVLW  00
03402:  ADDWFC x3F,W
03404:  MOVWF  03
03406:  MOVFF  01,440
0340A:  MOVWF  x41
0340C:  MOVLW  0E
0340E:  ADDWF  x3E,W
03410:  MOVWF  FE9
03412:  MOVLW  00
03414:  ADDWFC x3F,W
03416:  MOVWF  FEA
03418:  MOVFF  FEC,443
0341C:  MOVF   FED,F
0341E:  MOVFF  FEF,442
03422:  MOVFF  443,45E
03426:  MOVFF  442,45D
0342A:  MOVLB  0
0342C:  CALL   1A24
03430:  MOVFF  441,FEA
03434:  MOVFF  440,FE9
03438:  MOVFF  02,FEC
0343C:  MOVF   FED,F
0343E:  MOVFF  01,FEF
....................    header->Checksum        = swaps(header->Checksum); 
03442:  MOVLW  10
03444:  MOVLB  4
03446:  ADDWF  x3E,W
03448:  MOVWF  01
0344A:  MOVLW  00
0344C:  ADDWFC x3F,W
0344E:  MOVWF  03
03450:  MOVFF  01,440
03454:  MOVWF  x41
03456:  MOVLW  10
03458:  ADDWF  x3E,W
0345A:  MOVWF  FE9
0345C:  MOVLW  00
0345E:  ADDWFC x3F,W
03460:  MOVWF  FEA
03462:  MOVFF  FEC,443
03466:  MOVF   FED,F
03468:  MOVFF  FEF,442
0346C:  MOVFF  443,45E
03470:  MOVFF  442,45D
03474:  MOVLB  0
03476:  CALL   1A24
0347A:  MOVFF  441,FEA
0347E:  MOVFF  440,FE9
03482:  MOVFF  02,FEC
03486:  MOVF   FED,F
03488:  MOVFF  01,FEF
....................    header->UrgentPointer   = swaps(header->UrgentPointer); 
0348C:  MOVLW  12
0348E:  MOVLB  4
03490:  ADDWF  x3E,W
03492:  MOVWF  01
03494:  MOVLW  00
03496:  ADDWFC x3F,W
03498:  MOVWF  03
0349A:  MOVFF  01,440
0349E:  MOVWF  x41
034A0:  MOVLW  12
034A2:  ADDWF  x3E,W
034A4:  MOVWF  FE9
034A6:  MOVLW  00
034A8:  ADDWFC x3F,W
034AA:  MOVWF  FEA
034AC:  MOVFF  FEC,443
034B0:  MOVF   FED,F
034B2:  MOVFF  FEF,442
034B6:  MOVFF  443,45E
034BA:  MOVFF  442,45D
034BE:  MOVLB  0
034C0:  CALL   1A24
034C4:  MOVFF  441,FEA
034C8:  MOVFF  440,FE9
034CC:  MOVFF  02,FEC
034D0:  MOVF   FED,F
034D2:  MOVFF  01,FEF
034D6:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void CloseSocket(void) 
....................  
....................   Summary: 
....................    Closes a TCP socket. 
....................  
....................   Description: 
....................    This function closes a TCP socket.  All socket state information is  
....................    reset, and any buffered bytes are discarded.  The socket is no longer 
....................    accessible by the application after this point. 
....................  
....................   Precondition: 
....................    The TCPStub corresponding to the socket to be closed is synced. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void CloseSocket(void) 
.................... { 
....................    SyncTCB(); 
*
0112A:  RCALL  1052
....................  
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
0112C:  MOVFF  18B,1F8
01130:  MOVFF  18A,1F7
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
01134:  MOVFF  1DF,1E5
01138:  MOVFF  1DE,1E4
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
0113C:  MOVFF  1DF,1E7
01140:  MOVFF  1DE,1E6
....................    MyTCBStub.rxHead = MyTCBStub.bufferRxStart; 
01144:  MOVFF  1E1,1E9
01148:  MOVFF  1E0,1E8
....................    MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
0114C:  MOVFF  1E1,1EB
01150:  MOVFF  1E0,1EA
....................    MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED; 
01154:  MOVLB  1
01156:  BTFSS  xF5.3
01158:  BRA    115E
0115A:  MOVLW  04
0115C:  BRA    1160
0115E:  MOVLW  0D
01160:  MOVWF  xF4
....................    MyTCBStub.Flags.vUnackedKeepalives = 0; 
01162:  MOVLW  F8
01164:  ANDWF  xF5,W
01166:  MOVWF  xF5
....................    MyTCBStub.Flags.bTimerEnabled = 0; 
01168:  BCF    xF5.4
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
0116A:  BCF    xF5.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
0116C:  BCF    xF5.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
0116E:  BCF    xF5.7
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
01170:  BCF    xF6.0
....................    MyTCBStub.Flags.bTXASAP = 0; 
01172:  BCF    xF6.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
01174:  BCF    xF6.2
....................    MyTCBStub.Flags.bTXFIN = 0; 
01176:  BCF    xF6.3
....................    MyTCBStub.Flags.bSocketReset = 1; 
01178:  BSF    xF6.4
....................  
....................    #if defined(STACK_USE_SSL) 
....................    // If SSL is active, then we need to close it 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       SSLTerminate(MyTCBStub.sslStubID); 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................  
....................       // Swap the SSL port and local port back to proper values 
....................       MyTCBStub.remoteHash.Val = MyTCB.localSSLPort.Val; 
....................       MyTCB.localSSLPort.Val = MyTCB.localPort.Val; 
....................       MyTCB.localPort.Val = MyTCBStub.remoteHash.Val; 
....................    } 
....................  
....................    // Reset the SSL buffer pointers 
....................    MyTCBStub.sslRxHead = MyTCBStub.bufferRxStart; 
....................    MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SSL_SERVER) 
....................    MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val; 
....................    #endif 
....................  
....................    MyTCB.flags.bFINSent = 0; 
0117A:  BCF    x9C.0
....................    MyTCB.flags.bSYNSent = 0; 
0117C:  BCF    x9C.1
....................    MyTCB.flags.bRXNoneACKed1 = 0; 
0117E:  BCF    x9C.3
....................    MyTCB.flags.bRXNoneACKed2 = 0; 
01180:  BCF    x9C.4
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
01182:  MOVFF  1DF,187
01186:  MOVFF  1DE,186
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand(); 
0118A:  MOVLW  01
0118C:  MOVLB  4
0118E:  MOVWF  x15
01190:  MOVLW  7E
01192:  MOVWF  x14
01194:  MOVWF  01
01196:  MOVFF  415,03
0119A:  MOVWF  x16
0119C:  MOVFF  415,417
011A0:  MOVLB  0
011A2:  CALL   030E
011A6:  MOVFF  417,FEA
011AA:  MOVFF  416,FE9
011AE:  MOVFF  02,FEC
011B2:  MOVF   FED,F
011B4:  MOVFF  01,FEF
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand(); 
011B8:  MOVLW  01
011BA:  MOVLB  4
011BC:  MOVWF  x15
011BE:  MOVLW  7E
011C0:  MOVWF  x14
011C2:  MOVLW  02
011C4:  ADDWF  x14,W
011C6:  MOVWF  01
011C8:  MOVLW  00
011CA:  ADDWFC x15,W
011CC:  MOVWF  03
011CE:  MOVFF  01,416
011D2:  MOVWF  x17
011D4:  MOVLB  0
011D6:  CALL   030E
011DA:  MOVFF  417,FEA
011DE:  MOVFF  416,FE9
011E2:  MOVFF  02,FEC
011E6:  MOVF   FED,F
011E8:  MOVFF  01,FEF
....................    MyTCB.sHoleSize = -1; 
011EC:  MOVLB  1
011EE:  SETF   x9B
011F0:  SETF   x9A
....................    MyTCB.remoteWindow = 1; 
011F2:  CLRF   x8D
011F4:  MOVLW  01
011F6:  MOVWF  x8C
011F8:  MOVLB  0
011FA:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static WORD GetMaxSegSizeOption(void) 
....................  
....................   Summary: 
....................    Obtains the Maximum Segment Size (MSS) TCP Option out of the TCP header  
....................    for the current socket. 
....................  
....................   Description: 
....................    Parses the current TCP packet header and extracts the Maximum Segment Size  
....................    option.   
....................  
....................   Precondition: 
....................    Must be called while a TCP packet is present and being processed via  
....................    HandleTCPSeg() and only if the the TCP SYN flag is set. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    Maximum segment size option value.  If illegal or not present, a failsafe  
....................    value of 536 is returned.  If the option is larger than the  
....................    TCP_MAX_SEG_SIZE_TX upper limit, then TCP_MAX_SEG_SIZE_TX is returned. 
....................  
....................   Remarks: 
....................    The internal MAC Read Pointer is moved but not restored. 
....................   ***************************************************************************/ 
.................... static WORD GetMaxSegSizeOption(void) 
.................... { 
....................    BYTE vOptionsBytes; 
....................    BYTE vOption; 
....................    WORD wMSS; 
....................  
....................    // Find out how many options bytes are in this packet. 
....................    IPSetRxBuffer(2+2+4+4);   // Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4) 
*
0534A:  MOVLB  4
0534C:  CLRF   x19
0534E:  MOVLW  0C
05350:  MOVWF  x18
05352:  MOVLB  0
05354:  CALL   24A2
....................    vOptionsBytes = MACGet(); 
05358:  CALL   0C8A
0535C:  MOVFF  01,414
....................    vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER); 
05360:  MOVLB  4
05362:  MOVF   x14,W
05364:  ANDLW  F0
05366:  MOVWF  00
05368:  RRCF   00,F
0536A:  RRCF   00,F
0536C:  MOVLW  3F
0536E:  ANDWF  00,F
05370:  MOVF   00,W
05372:  ADDLW  EC
05374:  MOVWF  x14
....................  
....................    // Return minimum Maximum Segment Size value of 536 bytes if none are  
....................    // present 
....................    if(vOptionsBytes == 0u) 
05376:  MOVF   x14,F
05378:  BNZ   5384
....................       return 536; 
0537A:  MOVLW  18
0537C:  MOVWF  01
0537E:  MOVLW  02
05380:  MOVWF  02
05382:  BRA    5464
....................        
....................    // Seek to beginning of options 
....................    MACGetArray(NULL, 7); 
05384:  CLRF   x61
05386:  CLRF   x60
05388:  CLRF   x63
0538A:  MOVLW  07
0538C:  MOVWF  x62
0538E:  MOVLB  0
05390:  CALL   0C14
....................  
....................    // Search for the Maximum Segment Size option    
....................    while(vOptionsBytes--) 
05394:  MOVLB  4
05396:  MOVF   x14,W
05398:  DECF   x14,F
0539A:  XORLW  00
0539C:  BTFSC  FD8.2
0539E:  BRA    545C
....................    { 
....................       vOption = MACGet(); 
053A0:  MOVLB  0
053A2:  CALL   0C8A
053A6:  MOVFF  01,415
....................        
....................       if(vOption == 0u)   // End of Options list 
053AA:  MOVLB  4
053AC:  MOVF   x15,F
053AE:  BNZ   53B2
....................          break; 
053B0:  BRA    545C
....................        
....................       if(vOption == 1u)   // NOP option 
053B2:  DECFSZ x15,W
053B4:  BRA    53B8
....................          continue; 
053B6:  BRA    5396
....................           
....................       if(vOption == 2u)   // Maximum Segment Size option 
053B8:  MOVF   x15,W
053BA:  SUBLW  02
053BC:  BNZ   5428
....................       { 
....................          if(vOptionsBytes < 3u) 
053BE:  MOVF   x14,W
053C0:  SUBLW  02
053C2:  BNC   53C6
....................             break; 
053C4:  BRA    545C
....................  
....................          wMSS = 0; 
053C6:  CLRF   x17
053C8:  CLRF   x16
....................              
....................          // Get option length 
....................          vOption = MACGet(); 
053CA:  MOVLB  0
053CC:  CALL   0C8A
053D0:  MOVFF  01,415
....................          if(vOption == 4u) 
053D4:  MOVLB  4
053D6:  MOVF   x15,W
053D8:  SUBLW  04
053DA:  BNZ   53F0
....................          {// Retrieve MSS and swap value to little endian 
....................             ((BYTE*)&wMSS)[1] = MACGet(); 
053DC:  MOVLB  0
053DE:  CALL   0C8A
053E2:  MOVFF  01,417
....................             ((BYTE*)&wMSS)[0] = MACGet(); 
053E6:  CALL   0C8A
053EA:  MOVFF  01,416
053EE:  MOVLB  4
....................          } 
....................           
....................          if(wMSS < 536u) 
053F0:  MOVF   x17,W
053F2:  SUBLW  02
053F4:  BNC   5400
053F6:  BNZ   53FE
053F8:  MOVF   x16,W
053FA:  SUBLW  17
053FC:  BNC   5400
....................             break; 
053FE:  BRA    545C
....................          if(wMSS > TCP_MAX_SEG_SIZE_TX) 
05400:  MOVF   x17,W
05402:  SUBLW  04
05404:  BC    541C
05406:  XORLW  FF
05408:  BNZ   5410
0540A:  MOVF   x16,W
0540C:  SUBLW  B4
0540E:  BC    541C
....................             return TCP_MAX_SEG_SIZE_TX; 
05410:  MOVLW  B4
05412:  MOVWF  01
05414:  MOVLW  05
05416:  MOVWF  02
05418:  BRA    5464
0541A:  BRA    5426
....................          else  
....................             return wMSS; 
0541C:  MOVFF  416,01
05420:  MOVFF  417,02
05424:  BRA    5464
....................       } 
05426:  BRA    545A
....................       else 
....................       { // Assume this is a multi byte option and throw it way 
....................          if(vOptionsBytes < 2u) 
05428:  MOVF   x14,W
0542A:  SUBLW  01
0542C:  BNC   5430
....................             break; 
0542E:  BRA    545C
....................          vOption = MACGet(); 
05430:  MOVLB  0
05432:  CALL   0C8A
05436:  MOVFF  01,415
....................          if(vOptionsBytes < vOption) 
0543A:  MOVLB  4
0543C:  MOVF   x15,W
0543E:  SUBWF  x14,W
05440:  BC    5444
....................             break; 
05442:  BRA    545C
....................          MACGetArray(NULL, vOption); 
05444:  CLRF   x61
05446:  CLRF   x60
05448:  CLRF   x63
0544A:  MOVFF  415,462
0544E:  MOVLB  0
05450:  CALL   0C14
....................          vOptionsBytes -= vOption; 
05454:  MOVLB  4
05456:  MOVF   x15,W
05458:  SUBWF  x14,F
....................       } 
0545A:  BRA    5396
....................        
....................    } 
....................     
....................    // Did not find MSS option, return worst case default 
....................    return 536; 
0545C:  MOVLW  18
0545E:  MOVWF  01
05460:  MOVLW  02
05462:  MOVWF  02
05464:  MOVLB  0
05466:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
....................  
....................   Summary: 
....................    Processes an incoming TCP segment. 
....................  
....................   Description: 
....................    Once an incoming segment has been matched to a socket, this function 
....................    performs the necessary processing with the data.  Depending on the  
....................    segment and the state, this may include copying data to the TCP buffer, 
....................    re-assembling out-of order packets, continuing an initialization or  
....................    closing handshake, or closing the socket altogether. 
....................  
....................   Precondition: 
....................    TCP is initialized and the current TCP stub is already synced. 
....................  
....................   Parameters: 
....................    h - The TCP header for this packet 
....................    len - The total buffer length of this segment 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
.................... { 
....................    DWORD dwTemp; 
....................    PTR_BASE wTemp; 
....................    LONG lMissingBytes; 
....................    WORD wMissingBytes; 
....................    WORD wFreeSpace; 
....................    BYTE localHeaderFlags; 
....................    DWORD localAckNumber; 
....................    DWORD localSeqNumber; 
....................    WORD wSegmentLength; 
....................    BOOL bSegmentAcceptable; 
....................    WORD wNewWindow; 
....................  
....................  
....................    // Cache a few variables in local RAM.   
....................    // PIC18s take a fair amount of code and execution time to  
....................    // dereference pointers frequently. 
....................    localHeaderFlags = h->Flags.byte; 
05468:  MOVLW  0D
0546A:  MOVLB  3
0546C:  ADDWF  xF4,W
0546E:  MOVWF  FE9
05470:  MOVLW  00
05472:  ADDWFC xF5,W
05474:  MOVWF  FEA
05476:  MOVFF  FEF,406
....................    localAckNumber = h->AckNumber; 
0547A:  MOVLW  08
0547C:  ADDWF  xF4,W
0547E:  MOVWF  FE9
05480:  MOVLW  00
05482:  ADDWFC xF5,W
05484:  MOVWF  FEA
05486:  MOVFF  FEF,407
0548A:  MOVFF  FEC,408
0548E:  MOVFF  FEC,409
05492:  MOVFF  FEC,40A
....................    localSeqNumber = h->SeqNumber; 
05496:  MOVLW  04
05498:  ADDWF  xF4,W
0549A:  MOVWF  FE9
0549C:  MOVLW  00
0549E:  ADDWFC xF5,W
054A0:  MOVWF  FEA
054A2:  MOVFF  FEF,40B
054A6:  MOVFF  FEC,40C
054AA:  MOVFF  FEC,40D
054AE:  MOVFF  FEC,40E
....................  
....................    // We received a packet, reset the keep alive timer and count 
....................    #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................       MyTCBStub.Flags.vUnackedKeepalives = 0; 
054B2:  MOVLW  F8
054B4:  MOVLB  1
054B6:  ANDWF  xF5,W
054B8:  MOVWF  xF5
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
054BA:  BTFSC  xF5.4
054BC:  BRA    54EC
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
054BE:  MOVLB  0
054C0:  CALL   2424
054C4:  MOVLW  EE
054C6:  MOVLB  4
054C8:  ADDWF  00,W
054CA:  MOVLB  1
054CC:  MOVWF  xEC
054CE:  MOVLW  FA
054D0:  MOVLB  4
054D2:  ADDWFC 01,W
054D4:  MOVLB  1
054D6:  MOVWF  xED
054D8:  MOVLW  02
054DA:  MOVLB  4
054DC:  ADDWFC 02,W
054DE:  MOVLB  1
054E0:  MOVWF  xEE
054E2:  MOVLW  00
054E4:  MOVLB  4
054E6:  ADDWFC 03,W
054E8:  MOVLB  1
054EA:  MOVWF  xEF
....................    #endif 
....................  
....................    // Handle TCP_LISTEN and TCP_SYN_SENT states 
....................    // Both of these states will return, so code following this  
....................    // state machine need not check explicitly for these two  
....................    // states. 
....................    switch(MyTCBStub.smState) 
054EC:  MOVF   xF4,W
054EE:  XORLW  04
054F0:  MOVLB  0
054F2:  BZ    54FA
054F4:  XORLW  01
054F6:  BZ    5594
054F8:  BRA    56CA
....................    { 
....................       case TCP_LISTEN: 
....................          // First: check RST flag 
....................          if(localHeaderFlags & RST) 
054FA:  MOVLB  4
054FC:  BTFSS  x06.2
054FE:  BRA    550C
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
05500:  MOVLB  0
05502:  CALL   112A
....................             return; 
05506:  GOTO   672E
0550A:  MOVLB  4
....................          } 
....................  
....................          // Second: check ACK flag, which would be invalid 
....................          if(localHeaderFlags & ACK) 
0550C:  BTFSS  x06.4
0550E:  BRA    5536
....................          { 
....................             // Use a believable sequence number and reset the remote node 
....................             MyTCB.MySEQ = localAckNumber; 
05510:  MOVFF  40A,181
05514:  MOVFF  409,180
05518:  MOVFF  408,17F
0551C:  MOVFF  407,17E
....................             SendTCP(RST, 0); 
05520:  MOVLW  04
05522:  MOVWF  x14
05524:  CLRF   x15
05526:  MOVLB  0
05528:  CALL   3620
....................             CloseSocket();   // Unbind remote IP address/port info 
0552C:  CALL   112A
....................             return; 
05530:  GOTO   672E
05534:  MOVLB  4
....................          } 
....................  
....................          // Third: check for SYN flag, which is what we're looking for 
....................          if(localHeaderFlags & SYN) 
05536:  BTFSS  x06.1
05538:  BRA    5586
....................          { 
....................             // We now have a sequence number for the remote node 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
0553A:  MOVLW  01
0553C:  ADDWF  x0B,W
0553E:  MOVLB  1
05540:  MOVWF  x82
05542:  MOVLW  00
05544:  MOVLB  4
05546:  ADDWFC x0C,W
05548:  MOVLB  1
0554A:  MOVWF  x83
0554C:  MOVLW  00
0554E:  MOVLB  4
05550:  ADDWFC x0D,W
05552:  MOVLB  1
05554:  MOVWF  x84
05556:  MOVLW  00
05558:  MOVLB  4
0555A:  ADDWFC x0E,W
0555C:  MOVLB  1
0555E:  MOVWF  x85
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
05560:  MOVLB  0
05562:  RCALL  534A
05564:  MOVFF  02,19E
05568:  MOVFF  01,19D
....................  
....................             // Set Initial Send Sequence (ISS) number 
....................             // Nothing to do on this step... ISS already set in CloseSocket() 
....................              
....................             // Respond with SYN + ACK 
....................             SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
0556C:  MOVLW  12
0556E:  MOVLB  4
05570:  MOVWF  x14
05572:  MOVLW  01
05574:  MOVWF  x15
05576:  MOVLB  0
05578:  CALL   3620
....................             MyTCBStub.smState = TCP_SYN_RECEIVED; 
0557C:  MOVLW  06
0557E:  MOVLB  1
05580:  MOVWF  xF4
....................          } 
05582:  BRA    558E
05584:  MOVLB  4
....................          else 
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
05586:  MOVLB  0
05588:  CALL   112A
0558C:  MOVLB  1
....................          } 
....................  
....................          // Fourth: check for other text and control 
....................          // Nothing to do since we don't support this 
....................          return; 
0558E:  MOVLB  0
05590:  GOTO   672E
....................  
....................       case TCP_SYN_SENT: 
....................          // Second: check the RST bit 
....................          // This is out of order because this stack has no API for  
....................          // notifying the application that the connection seems to  
....................          // be failing.  Instead, the application must time out and  
....................          // the stack will just keep trying in the mean time. 
....................          if(localHeaderFlags & RST) 
05594:  MOVLB  4
05596:  BTFSS  x06.2
05598:  BRA    55A2
....................             return; 
0559A:  MOVLB  0
0559C:  GOTO   672E
055A0:  MOVLB  4
....................  
....................          // First: check ACK bit 
....................          if(localHeaderFlags & ACK) 
055A2:  BTFSS  x06.4
055A4:  BRA    5612
....................          { 
....................             if(localAckNumber != MyTCB.MySEQ) 
055A6:  MOVLB  1
055A8:  MOVF   x7E,W
055AA:  MOVLB  4
055AC:  SUBWF  x07,W
055AE:  BNZ   55CE
055B0:  MOVLB  1
055B2:  MOVF   x7F,W
055B4:  MOVLB  4
055B6:  SUBWF  x08,W
055B8:  BNZ   55CE
055BA:  MOVLB  1
055BC:  MOVF   x80,W
055BE:  MOVLB  4
055C0:  SUBWF  x09,W
055C2:  BNZ   55CE
055C4:  MOVLB  1
055C6:  MOVF   x81,W
055C8:  MOVLB  4
055CA:  SUBWF  x0A,W
055CC:  BZ    5612
....................             { 
....................                // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................                // number for arivial of any other SYN+ACK packets 
....................                localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
055CE:  MOVFF  181,40E
055D2:  MOVFF  180,40D
055D6:  MOVFF  17F,40C
055DA:  MOVFF  17E,40B
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
055DE:  MOVFF  40A,181
055E2:  MOVFF  409,180
055E6:  MOVFF  408,17F
055EA:  MOVFF  407,17E
....................                SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
055EE:  MOVLW  04
055F0:  MOVWF  x14
055F2:  MOVLW  01
055F4:  MOVWF  x15
055F6:  MOVLB  0
055F8:  CALL   3620
....................                MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
055FC:  MOVFF  40E,181
05600:  MOVFF  40D,180
05604:  MOVFF  40C,17F
05608:  MOVFF  40B,17E
....................                return; 
0560C:  GOTO   672E
05610:  MOVLB  4
....................             } 
....................          } 
....................  
....................          // Third: check the security and precedence 
....................          // No such feature in this stack.  We want to accept all connections. 
....................  
....................          // Fourth: check the SYN bit 
....................          if(localHeaderFlags & SYN) 
05612:  BTFSS  x06.1
05614:  BRA    56C4
....................          { 
....................             // We now have an initial sequence number and window size 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
05616:  MOVLW  01
05618:  ADDWF  x0B,W
0561A:  MOVLB  1
0561C:  MOVWF  x82
0561E:  MOVLW  00
05620:  MOVLB  4
05622:  ADDWFC x0C,W
05624:  MOVLB  1
05626:  MOVWF  x83
05628:  MOVLW  00
0562A:  MOVLB  4
0562C:  ADDWFC x0D,W
0562E:  MOVLB  1
05630:  MOVWF  x84
05632:  MOVLW  00
05634:  MOVLB  4
05636:  ADDWFC x0E,W
05638:  MOVLB  1
0563A:  MOVWF  x85
....................             MyTCB.remoteWindow = h->Window; 
0563C:  MOVLW  0E
0563E:  MOVLB  3
05640:  ADDWF  xF4,W
05642:  MOVWF  FE9
05644:  MOVLW  00
05646:  ADDWFC xF5,W
05648:  MOVWF  FEA
0564A:  MOVFF  FEC,18D
0564E:  MOVF   FED,F
05650:  MOVFF  FEF,18C
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
05654:  MOVLB  0
05656:  RCALL  534A
05658:  MOVFF  02,19E
0565C:  MOVFF  01,19D
....................  
....................             if(localHeaderFlags & ACK) 
05660:  MOVLB  4
05662:  BTFSS  x06.4
05664:  BRA    56AE
....................             { 
....................                SendTCP(ACK, SENDTCP_RESET_TIMERS); 
05666:  MOVLW  10
05668:  MOVWF  x14
0566A:  MOVLW  01
0566C:  MOVWF  x15
0566E:  MOVLB  0
05670:  CALL   3620
....................                MyTCBStub.smState = TCP_ESTABLISHED; 
05674:  MOVLW  07
05676:  MOVLB  1
05678:  MOVWF  xF4
....................                // Set up keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
0567A:  MOVLB  0
0567C:  CALL   2424
05680:  MOVLW  EE
05682:  MOVLB  4
05684:  ADDWF  00,W
05686:  MOVLB  1
05688:  MOVWF  xEC
0568A:  MOVLW  FA
0568C:  MOVLB  4
0568E:  ADDWFC 01,W
05690:  MOVLB  1
05692:  MOVWF  xED
05694:  MOVLW  02
05696:  MOVLB  4
05698:  ADDWFC 02,W
0569A:  MOVLB  1
0569C:  MOVWF  xEE
0569E:  MOVLW  00
056A0:  MOVLB  4
056A2:  ADDWFC 03,W
056A4:  MOVLB  1
056A6:  MOVWF  xEF
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
056A8:  BCF    xF5.4
....................             } 
056AA:  BRA    56C2
056AC:  MOVLB  4
....................             else 
....................             { 
....................                SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
056AE:  MOVLW  12
056B0:  MOVWF  x14
056B2:  MOVLW  01
056B4:  MOVWF  x15
056B6:  MOVLB  0
056B8:  CALL   3620
....................                MyTCBStub.smState = TCP_SYN_RECEIVED; 
056BC:  MOVLW  06
056BE:  MOVLB  1
056C0:  MOVWF  xF4
056C2:  MOVLB  4
....................             } 
....................          } 
....................  
....................          // Fifth: drop the segment if neither SYN or RST is set 
....................          return; 
056C4:  MOVLB  0
056C6:  GOTO   672E
....................  
....................       default: 
....................          break; 
....................    } 
....................  
....................    // 
....................    // First: check the sequence number 
....................    // 
....................    wSegmentLength = len; 
056CA:  MOVFF  3F7,410
056CE:  MOVFF  3F6,40F
....................    if(localHeaderFlags & FIN) 
056D2:  MOVLB  4
056D4:  BTFSS  x06.0
056D6:  BRA    56DE
....................       wSegmentLength++; 
056D8:  INCF   x0F,F
056DA:  BTFSC  FD8.2
056DC:  INCF   x10,F
....................    if(localHeaderFlags & SYN) 
056DE:  BTFSS  x06.1
056E0:  BRA    56E8
....................       wSegmentLength++; 
056E2:  INCF   x0F,F
056E4:  BTFSC  FD8.2
056E6:  INCF   x10,F
....................  
....................    // Calculate the RX FIFO space 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
056E8:  MOVLB  1
056EA:  MOVF   xEB,W
056EC:  SUBWF  xE9,W
056EE:  BNC   572A
056F0:  BNZ   56F8
056F2:  MOVF   xEA,W
056F4:  SUBWF  xE8,W
056F6:  BNC   572A
....................       wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
056F8:  MOVF   xE0,W
056FA:  SUBWF  xE2,W
056FC:  MOVLB  4
056FE:  MOVWF  x14
05700:  MOVLB  1
05702:  MOVF   xE1,W
05704:  SUBWFB xE3,W
05706:  MOVLB  4
05708:  MOVWF  x15
0570A:  MOVLB  1
0570C:  MOVF   xEA,W
0570E:  SUBWF  xE8,W
05710:  MOVWF  00
05712:  MOVF   xEB,W
05714:  SUBWFB xE9,W
05716:  MOVWF  03
05718:  MOVF   00,W
0571A:  MOVLB  4
0571C:  SUBWF  x14,W
0571E:  MOVWF  x04
05720:  MOVF   03,W
05722:  SUBWFB x15,W
05724:  MOVWF  x05
05726:  BRA    5748
05728:  MOVLB  1
....................    else 
....................       wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
0572A:  MOVF   xE8,W
0572C:  SUBWF  xEA,W
0572E:  MOVLB  4
05730:  MOVWF  x14
05732:  MOVLB  1
05734:  MOVF   xE9,W
05736:  SUBWFB xEB,W
05738:  MOVLB  4
0573A:  MOVWF  x15
0573C:  MOVLW  01
0573E:  SUBWF  x14,W
05740:  MOVWF  x04
05742:  MOVLW  00
05744:  SUBWFB x15,W
05746:  MOVWF  x05
....................  
....................    // Calculate the number of bytes ahead of our head pointer this segment skips 
....................    lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ; 
05748:  MOVLB  1
0574A:  MOVF   x82,W
0574C:  MOVLB  4
0574E:  SUBWF  x0B,W
05750:  MOVWF  00
05752:  MOVLB  1
05754:  MOVF   x83,W
05756:  MOVLB  4
05758:  SUBWFB x0C,W
0575A:  MOVWF  01
0575C:  MOVLB  1
0575E:  MOVF   x84,W
05760:  MOVLB  4
05762:  SUBWFB x0D,W
05764:  MOVWF  02
05766:  MOVLB  1
05768:  MOVF   x85,W
0576A:  MOVLB  4
0576C:  SUBWFB x0E,W
0576E:  MOVWF  x01
05770:  MOVFF  02,400
05774:  MOVFF  01,3FF
05778:  MOVFF  00,3FE
....................    wMissingBytes = (WORD)lMissingBytes; 
0577C:  MOVFF  3FF,403
05780:  MOVFF  3FE,402
....................     
....................    // Run TCP acceptability tests to verify that this packet has a valid sequence number 
....................    bSegmentAcceptable = FALSE; 
05784:  BCF    x11.0
....................    if(wSegmentLength) 
05786:  MOVF   x0F,W
05788:  IORWF  x10,W
0578A:  BTFSC  FD8.2
0578C:  BRA    58D2
....................    { 
....................       // Check to see if we have free space, and if so, if any of the data falls within the freespace 
....................       if(wFreeSpace) 
0578E:  MOVF   x04,W
05790:  IORWF  x05,W
05792:  BTFSC  FD8.2
05794:  BRA    58D0
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
05796:  BTFSC  x01.7
05798:  BRA    57C2
0579A:  MOVF   x01,F
0579C:  BNZ   57C2
0579E:  MOVF   x00,F
057A0:  BNZ   57C2
057A2:  MOVLB  3
057A4:  MOVF   xFF,W
057A6:  MOVLB  4
057A8:  SUBWF  x05,W
057AA:  BNC   57C2
057AC:  BNZ   57BE
057AE:  MOVF   x04,W
057B0:  MOVLB  3
057B2:  SUBWF  xFE,W
057B4:  BTFSS  FD8.0
057B6:  BRA    57BC
057B8:  MOVLB  4
057BA:  BRA    57C2
057BC:  MOVLB  4
....................             bSegmentAcceptable = TRUE; 
057BE:  BSF    x11.0
057C0:  BRA    5866
....................          else 
....................          { 
....................             // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND 
....................             if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength))) 
057C2:  MOVFF  40F,00
057C6:  MOVFF  410,01
057CA:  CLRF   02
057CC:  CLRF   03
057CE:  MOVF   x0F,W
057D0:  MOVLB  3
057D2:  ADDWF  xFE,W
057D4:  MOVLB  4
057D6:  MOVWF  x14
057D8:  MOVF   x10,W
057DA:  MOVLB  3
057DC:  ADDWFC xFF,W
057DE:  MOVLB  4
057E0:  MOVWF  x15
057E2:  MOVF   02,W
057E4:  ADDWFC x00,W
057E6:  MOVWF  x16
057E8:  MOVF   03,W
057EA:  ADDWFC x01,W
057EC:  MOVWF  x17
057EE:  BTFSC  FE8.7
057F0:  BRA    5866
057F2:  MOVF   x17,F
057F4:  BNZ   5804
057F6:  MOVF   x16,F
057F8:  BNZ   5804
057FA:  MOVF   x15,F
057FC:  BNZ   5804
057FE:  MOVF   x14,W
05800:  SUBLW  00
05802:  BC    5866
05804:  MOVF   x0F,W
05806:  SUBWF  x04,W
05808:  MOVWF  00
0580A:  MOVF   x10,W
0580C:  SUBWFB x05,W
0580E:  MOVWF  03
05810:  MOVF   00,W
05812:  MOVFF  03,01
05816:  CLRF   02
05818:  CLRF   03
0581A:  BTFSS  01.7
0581C:  BRA    5822
0581E:  DECF   02,F
05820:  DECF   03,F
05822:  BTFSS  x01.7
05824:  BRA    582C
05826:  BTFSS  03.7
05828:  BRA    5864
0582A:  BRA    5830
0582C:  BTFSC  03.7
0582E:  BRA    5866
05830:  MOVF   x01,W
05832:  SUBWF  03,W
05834:  BNC   5866
05836:  BNZ   5864
05838:  MOVF   x00,W
0583A:  SUBWF  02,W
0583C:  BNC   5866
0583E:  BNZ   5864
05840:  MOVLB  3
05842:  MOVF   xFF,W
05844:  SUBWF  01,W
05846:  BTFSC  FD8.0
05848:  BRA    584E
0584A:  MOVLB  4
0584C:  BRA    5866
0584E:  BTFSC  FD8.2
05850:  BRA    5856
05852:  MOVLB  4
05854:  BRA    5864
05856:  MOVF   xFE,W
05858:  SUBWF  00,W
0585A:  BTFSC  FD8.0
0585C:  BRA    5862
0585E:  MOVLB  4
05860:  BRA    5866
05862:  MOVLB  4
....................                bSegmentAcceptable = TRUE; 
05864:  BSF    x11.0
....................          } 
....................           
....................          if((lMissingBytes < (LONG)wFreeSpace) && ((SHORT)wMissingBytes + (SHORT)wSegmentLength > (SHORT)0)) 
05866:  MOVFF  404,00
0586A:  MOVFF  405,01
0586E:  CLRF   02
05870:  CLRF   03
05872:  BTFSS  x01.7
05874:  BRA    587C
05876:  BTFSS  03.7
05878:  BRA    58B4
0587A:  BRA    5880
0587C:  BTFSC  03.7
0587E:  BRA    58D0
05880:  MOVF   x01,W
05882:  SUBWF  03,W
05884:  BNC   58D0
05886:  BNZ   58B4
05888:  MOVF   x00,W
0588A:  SUBWF  02,W
0588C:  BNC   58D0
0588E:  BNZ   58B4
05890:  MOVLB  3
05892:  MOVF   xFF,W
05894:  SUBWF  01,W
05896:  BTFSC  FD8.0
05898:  BRA    589E
0589A:  MOVLB  4
0589C:  BRA    58D0
0589E:  BTFSC  FD8.2
058A0:  BRA    58A6
058A2:  MOVLB  4
058A4:  BRA    58B4
058A6:  MOVF   00,W
058A8:  SUBWF  xFE,W
058AA:  BTFSS  FD8.0
058AC:  BRA    58B2
058AE:  MOVLB  4
058B0:  BRA    58D0
058B2:  MOVLB  4
058B4:  MOVF   x0F,W
058B6:  ADDWF  x02,W
058B8:  MOVWF  x14
058BA:  MOVF   x10,W
058BC:  ADDWFC x03,W
058BE:  MOVWF  x15
058C0:  BTFSC  FE8.7
058C2:  BRA    58D0
058C4:  MOVF   x15,F
058C6:  BNZ   58CE
058C8:  MOVF   x14,W
058CA:  SUBLW  00
058CC:  BC    58D0
....................             bSegmentAcceptable = TRUE; 
058CE:  BSF    x11.0
....................       } 
....................       // Segments with data are not acceptable if we have no free space 
....................    } 
058D0:  BRA    5924
....................    else 
....................    { 
....................       // Zero length packets are acceptable if they fall within our free space window 
....................       // SEG.SEQ = RCV.NXT 
....................       if(lMissingBytes == 0) 
058D2:  MOVLB  3
058D4:  MOVF   xFE,F
058D6:  BNZ   58F8
058D8:  MOVF   xFF,F
058DA:  BNZ   58F8
058DC:  MOVLB  4
058DE:  MOVF   x00,F
058E0:  BTFSC  FD8.2
058E2:  BRA    58E8
058E4:  MOVLB  3
058E6:  BRA    58F8
058E8:  MOVF   x01,F
058EA:  BTFSC  FD8.2
058EC:  BRA    58F2
058EE:  MOVLB  3
058F0:  BRA    58F8
....................       { 
....................          bSegmentAcceptable = TRUE; 
058F2:  BSF    x11.0
....................       } 
058F4:  BRA    5924
058F6:  MOVLB  3
....................       else 
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
058F8:  MOVLB  4
058FA:  BTFSC  x01.7
058FC:  BRA    5924
058FE:  MOVF   x01,F
05900:  BNZ   5924
05902:  MOVF   x00,F
05904:  BNZ   5924
05906:  MOVLB  3
05908:  MOVF   xFF,W
0590A:  MOVLB  4
0590C:  SUBWF  x05,W
0590E:  BNC   5924
05910:  BNZ   5922
05912:  MOVF   x04,W
05914:  MOVLB  3
05916:  SUBWF  xFE,W
05918:  BTFSS  FD8.0
0591A:  BRA    5920
0591C:  MOVLB  4
0591E:  BRA    5924
05920:  MOVLB  4
....................             bSegmentAcceptable = TRUE; 
05922:  BSF    x11.0
....................       } 
....................    } 
....................     
....................    if(!bSegmentAcceptable) 
05924:  BTFSC  x11.0
05926:  BRA    5944
....................    { 
....................       // Unacceptable segment, drop it and respond appropriately 
....................       if(!(localHeaderFlags & RST))  
05928:  BTFSC  x06.2
0592A:  BRA    593C
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
0592C:  MOVLW  10
0592E:  MOVWF  x14
05930:  MOVLW  01
05932:  MOVWF  x15
05934:  MOVLB  0
05936:  CALL   3620
0593A:  MOVLB  4
....................       return; 
0593C:  MOVLB  0
0593E:  GOTO   672E
05942:  MOVLB  4
....................    } 
....................  
....................  
....................    // 
....................    // Second: check the RST bit 
....................    // 
....................    // 
....................    // Fourth: check the SYN bit 
....................    // 
....................    // Note, that since the third step is not implemented, we can  
....................    // combine this second and fourth step into a single operation. 
....................    if(localHeaderFlags & (RST | SYN)) 
05944:  MOVF   x06,W
05946:  ANDLW  06
05948:  BZ    5956
....................    { 
....................       CloseSocket(); 
0594A:  MOVLB  0
0594C:  CALL   112A
....................       return; 
05950:  GOTO   672E
05954:  MOVLB  4
....................    } 
....................  
....................    // 
....................    // Third: check the security and precedence 
....................    // 
....................    // Feature not supported.  Let's process this segment. 
....................  
....................    // 
....................    // Fifth: check the ACK bit 
....................    // 
....................    if(!(localHeaderFlags & ACK)) 
05956:  BTFSC  x06.4
05958:  BRA    5962
....................       return; 
0595A:  MOVLB  0
0595C:  GOTO   672E
05960:  MOVLB  4
....................  
....................    switch(MyTCBStub.smState) 
05962:  MOVLB  1
05964:  MOVF   xF4,W
05966:  XORLW  06
05968:  MOVLB  0
0596A:  BZ    5988
0596C:  XORLW  01
0596E:  BZ    59FC
05970:  XORLW  0F
05972:  BZ    59FC
05974:  XORLW  01
05976:  BZ    59FC
05978:  XORLW  02
0597A:  BZ    59FC
0597C:  XORLW  01
0597E:  BZ    59FC
05980:  XORLW  06
05982:  BTFSC  FD8.2
05984:  BRA    5F68
05986:  BRA    5FB6
....................    { 
....................       case TCP_SYN_RECEIVED: 
....................          if(localAckNumber != MyTCB.MySEQ) 
05988:  MOVLB  1
0598A:  MOVF   x7E,W
0598C:  MOVLB  4
0598E:  SUBWF  x07,W
05990:  BNZ   59B0
05992:  MOVLB  1
05994:  MOVF   x7F,W
05996:  MOVLB  4
05998:  SUBWF  x08,W
0599A:  BNZ   59B0
0599C:  MOVLB  1
0599E:  MOVF   x80,W
059A0:  MOVLB  4
059A2:  SUBWF  x09,W
059A4:  BNZ   59B0
059A6:  MOVLB  1
059A8:  MOVF   x81,W
059AA:  MOVLB  4
059AC:  SUBWF  x0A,W
059AE:  BZ    59F4
....................          { 
....................             // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................             // number for arivial of any other correct packets 
....................             localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
059B0:  MOVFF  181,40E
059B4:  MOVFF  180,40D
059B8:  MOVFF  17F,40C
059BC:  MOVFF  17E,40B
....................             MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
059C0:  MOVFF  40A,181
059C4:  MOVFF  409,180
059C8:  MOVFF  408,17F
059CC:  MOVFF  407,17E
....................             SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
059D0:  MOVLW  04
059D2:  MOVWF  x14
059D4:  MOVLW  01
059D6:  MOVWF  x15
059D8:  MOVLB  0
059DA:  CALL   3620
....................             MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
059DE:  MOVFF  40E,181
059E2:  MOVFF  40D,180
059E6:  MOVFF  40C,17F
059EA:  MOVFF  40B,17E
....................             return; 
059EE:  GOTO   672E
059F2:  MOVLB  4
....................          } 
....................          MyTCBStub.smState = TCP_ESTABLISHED; 
059F4:  MOVLW  07
059F6:  MOVLB  1
059F8:  MOVWF  xF4
059FA:  MOVLB  0
....................          // No break 
....................  
....................       case TCP_ESTABLISHED: 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSE_WAIT: 
....................       case TCP_CLOSING: 
....................          // Calculate what the highest possible SEQ number in our TX FIFO is 
....................          wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail; 
059FC:  MOVLB  1
059FE:  MOVF   x86,W
05A00:  SUBWF  xE4,W
05A02:  MOVLB  3
05A04:  MOVWF  xFC
05A06:  MOVLB  1
05A08:  MOVF   x87,W
05A0A:  SUBWFB xE5,W
05A0C:  MOVLB  3
05A0E:  MOVWF  xFD
....................          if((SHORT)wTemp < (SHORT)0) 
05A10:  BTFSS  xFD.7
05A12:  BRA    5A2C
....................             wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
05A14:  MOVLB  1
05A16:  MOVF   xDE,W
05A18:  SUBWF  xE0,W
05A1A:  MOVWF  00
05A1C:  MOVF   xDF,W
05A1E:  SUBWFB xE1,W
05A20:  MOVWF  03
05A22:  MOVF   00,W
05A24:  MOVLB  3
05A26:  ADDWF  xFC,F
05A28:  MOVF   03,W
05A2A:  ADDWFC xFD,F
....................          dwTemp = MyTCB.MySEQ + (DWORD)wTemp; 
05A2C:  CLRF   02
05A2E:  CLRF   03
05A30:  MOVF   xFC,W
05A32:  MOVLB  1
05A34:  ADDWF  x7E,W
05A36:  MOVLB  3
05A38:  MOVWF  xF8
05A3A:  MOVF   xFD,W
05A3C:  MOVLB  1
05A3E:  ADDWFC x7F,W
05A40:  MOVLB  3
05A42:  MOVWF  xF9
05A44:  MOVF   02,W
05A46:  MOVLB  1
05A48:  ADDWFC x80,W
05A4A:  MOVLB  3
05A4C:  MOVWF  xFA
05A4E:  MOVF   03,W
05A50:  MOVLB  1
05A52:  ADDWFC x81,W
05A54:  MOVLB  3
05A56:  MOVWF  xFB
....................  
....................          // Drop the packet if it ACKs something we haven't sent 
....................             dwTemp = (LONG)localAckNumber - (LONG)dwTemp; 
05A58:  MOVF   xF8,W
05A5A:  MOVLB  4
05A5C:  SUBWF  x07,W
05A5E:  MOVWF  00
05A60:  MOVLB  3
05A62:  MOVF   xF9,W
05A64:  MOVLB  4
05A66:  SUBWFB x08,W
05A68:  MOVWF  01
05A6A:  MOVLB  3
05A6C:  MOVF   xFA,W
05A6E:  MOVLB  4
05A70:  SUBWFB x09,W
05A72:  MOVWF  02
05A74:  MOVLB  3
05A76:  MOVF   xFB,W
05A78:  MOVLB  4
05A7A:  SUBWFB x0A,W
05A7C:  MOVFF  FE8,3FB
05A80:  MOVFF  02,3FA
05A84:  MOVFF  01,3F9
05A88:  MOVFF  00,3F8
....................             if((LONG)dwTemp > 0) 
05A8C:  MOVLB  3
05A8E:  BTFSC  xFB.7
05A90:  BRA    5AFC
05A92:  MOVF   xFB,F
05A94:  BNZ   5AA4
05A96:  MOVF   xFA,F
05A98:  BNZ   5AA4
05A9A:  MOVF   xF9,F
05A9C:  BNZ   5AA4
05A9E:  MOVF   xF8,W
05AA0:  SUBLW  00
05AA2:  BC    5AFC
....................             {   // acknowledged more than we've sent?? 
....................                 if(!MyTCB.flags.bFINSent || dwTemp != 1) 
05AA4:  MOVLB  1
05AA6:  BTFSS  x9C.0
05AA8:  BRA    5AD0
05AAA:  MOVLB  3
05AAC:  DECFSZ xF8,W
05AAE:  BRA    5AB2
05AB0:  BRA    5AB6
05AB2:  MOVLB  1
05AB4:  BRA    5AD0
05AB6:  MOVF   xF9,F
05AB8:  BTFSC  FD8.2
05ABA:  BRA    5AC0
05ABC:  MOVLB  1
05ABE:  BRA    5AD0
05AC0:  MOVF   xFA,F
05AC2:  BTFSC  FD8.2
05AC4:  BRA    5ACA
05AC6:  MOVLB  1
05AC8:  BRA    5AD0
05ACA:  MOVF   xFB,F
05ACC:  BZ    5AE6
05ACE:  MOVLB  1
....................                 { 
....................                     SendTCP(ACK, 0); 
05AD0:  MOVLW  10
05AD2:  MOVLB  4
05AD4:  MOVWF  x14
05AD6:  CLRF   x15
05AD8:  MOVLB  0
05ADA:  CALL   3620
....................                     return; 
05ADE:  GOTO   672E
....................                 } 
05AE2:  BRA    5AFA
05AE4:  MOVLB  3
....................                 else 
....................                 { 
....................                     localAckNumber--;   // since we don't count the FIN anyway 
05AE6:  MOVLW  FF
05AE8:  MOVLB  4
05AEA:  ADDWF  x07,F
05AEC:  BTFSS  FD8.0
05AEE:  ADDWF  x08,F
05AF0:  BTFSS  FD8.0
05AF2:  ADDWF  x09,F
05AF4:  BTFSS  FD8.0
05AF6:  ADDWF  x0A,F
05AF8:  MOVLB  0
05AFA:  MOVLB  3
....................                 } 
....................             } 
....................  
....................          // Throw away all ACKnowledged TX data: 
....................          // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent) 
....................          dwTemp = MyTCB.MySEQ - (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
05AFC:  MOVLB  1
05AFE:  MOVF   xE6,W
05B00:  SUBWF  x86,W
05B02:  MOVWF  00
05B04:  MOVF   xE7,W
05B06:  SUBWFB x87,W
05B08:  MOVWF  03
05B0A:  MOVF   00,W
05B0C:  MOVFF  03,01
05B10:  CLRF   02
05B12:  CLRF   03
05B14:  BTFSS  01.7
05B16:  BRA    5B1C
05B18:  DECF   02,F
05B1A:  DECF   03,F
05B1C:  MOVF   00,W
05B1E:  SUBWF  x7E,W
05B20:  MOVWF  00
05B22:  MOVF   01,W
05B24:  SUBWFB x7F,W
05B26:  MOVWF  01
05B28:  MOVF   02,W
05B2A:  SUBWFB x80,W
05B2C:  MOVWF  02
05B2E:  MOVF   03,W
05B30:  SUBWFB x81,W
05B32:  MOVFF  FE8,3FB
05B36:  MOVFF  02,3FA
05B3A:  MOVFF  01,3F9
05B3E:  MOVFF  00,3F8
....................          if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
05B42:  MOVF   x87,W
05B44:  SUBWF  xE7,W
05B46:  BNC   5B6E
05B48:  BNZ   5B50
05B4A:  MOVF   xE6,W
05B4C:  SUBWF  x86,W
05B4E:  BC    5B6E
....................             dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
05B50:  MOVF   xDE,W
05B52:  SUBWF  xE0,W
05B54:  MOVWF  00
05B56:  MOVF   xDF,W
05B58:  SUBWFB xE1,W
05B5A:  MOVWF  03
05B5C:  MOVF   00,W
05B5E:  MOVLB  3
05B60:  SUBWF  xF8,F
05B62:  MOVF   03,W
05B64:  SUBWFB xF9,F
05B66:  MOVLW  00
05B68:  SUBWFB xFA,F
05B6A:  SUBWFB xFB,F
05B6C:  MOVLB  1
....................     
....................          // Calcluate how many bytes were ACKed with this packet 
....................          dwTemp = localAckNumber - dwTemp; 
05B6E:  MOVLB  3
05B70:  MOVF   xF8,W
05B72:  MOVLB  4
05B74:  SUBWF  x07,W
05B76:  MOVLB  3
05B78:  MOVWF  xF8
05B7A:  MOVF   xF9,W
05B7C:  MOVLB  4
05B7E:  SUBWFB x08,W
05B80:  MOVLB  3
05B82:  MOVWF  xF9
05B84:  MOVF   xFA,W
05B86:  MOVLB  4
05B88:  SUBWFB x09,W
05B8A:  MOVLB  3
05B8C:  MOVWF  xFA
05B8E:  MOVF   xFB,W
05B90:  MOVLB  4
05B92:  SUBWFB x0A,W
05B94:  MOVLB  3
05B96:  MOVWF  xFB
....................          if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart)) 
05B98:  BTFSC  xFB.7
05B9A:  BRA    5CF4
05B9C:  MOVF   xFB,F
05B9E:  BNZ   5BB0
05BA0:  MOVF   xFA,F
05BA2:  BNZ   5BB0
05BA4:  MOVF   xF9,F
05BA6:  BNZ   5BB0
05BA8:  MOVF   xF8,W
05BAA:  SUBLW  00
05BAC:  BTFSC  FD8.0
05BAE:  BRA    5CF4
05BB0:  MOVLB  1
05BB2:  MOVF   xDE,W
05BB4:  SUBWF  xE0,W
05BB6:  MOVWF  00
05BB8:  MOVF   xDF,W
05BBA:  SUBWFB xE1,W
05BBC:  MOVWF  03
05BBE:  MOVFF  00,01
05BC2:  MOVLB  3
05BC4:  MOVF   xFB,F
05BC6:  BTFSS  FD8.2
05BC8:  BRA    5CF4
05BCA:  MOVF   xFA,F
05BCC:  BTFSS  FD8.2
05BCE:  BRA    5CF4
05BD0:  MOVF   xF9,W
05BD2:  SUBWF  03,W
05BD4:  BTFSS  FD8.0
05BD6:  BRA    5CF4
05BD8:  BNZ   5BE2
05BDA:  MOVF   xF8,W
05BDC:  SUBWF  01,W
05BDE:  BTFSS  FD8.0
05BE0:  BRA    5CF4
....................          { 
....................             MyTCB.flags.bRXNoneACKed1 = 0; 
05BE2:  MOVLB  1
05BE4:  BCF    x9C.3
....................             MyTCB.flags.bRXNoneACKed2 = 0; 
05BE6:  BCF    x9C.4
....................             MyTCBStub.Flags.bHalfFullFlush = FALSE; 
05BE8:  BCF    xF6.0
....................     
....................             // Bytes ACKed, free up the TX FIFO space 
....................             wTemp = MyTCBStub.txTail; 
05BEA:  MOVFF  1E7,3FD
05BEE:  MOVFF  1E6,3FC
....................             MyTCBStub.txTail += dwTemp; 
05BF2:  MOVLB  3
05BF4:  MOVF   xF8,W
05BF6:  MOVLB  1
05BF8:  ADDWF  xE6,F
05BFA:  MOVLB  3
05BFC:  MOVF   xF9,W
05BFE:  MOVLB  1
05C00:  ADDWFC xE7,F
....................             if(MyTCB.txUnackedTail >= wTemp) 
05C02:  MOVLB  3
05C04:  MOVF   xFD,W
05C06:  MOVLB  1
05C08:  SUBWF  x87,W
05C0A:  BNC   5C4A
05C0C:  BNZ   5C18
05C0E:  MOVLB  3
05C10:  MOVF   xFC,W
05C12:  MOVLB  1
05C14:  SUBWF  x86,W
05C16:  BNC   5C4A
....................             { 
....................                if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
05C18:  MOVF   x87,W
05C1A:  SUBWF  xE7,W
05C1C:  BNC   5C48
05C1E:  BNZ   5C26
05C20:  MOVF   xE6,W
05C22:  SUBWF  x86,W
05C24:  BC    5C48
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - MyTCB.txUnackedTail; 
05C26:  MOVF   x86,W
05C28:  SUBWF  xE6,W
05C2A:  MOVWF  00
05C2C:  MOVF   x87,W
05C2E:  SUBWFB xE7,W
05C30:  MOVWF  03
05C32:  MOVF   00,W
05C34:  ADDWF  x7E,F
05C36:  MOVF   03,W
05C38:  ADDWFC x7F,F
05C3A:  MOVLW  00
05C3C:  ADDWFC x80,F
05C3E:  ADDWFC x81,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
05C40:  MOVFF  1E7,187
05C44:  MOVFF  1E6,186
....................                } 
....................             } 
05C48:  BRA    5CAC
....................             else 
....................             { 
....................                wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
05C4A:  MOVF   xDE,W
05C4C:  SUBWF  xE0,W
05C4E:  MOVWF  00
05C50:  MOVF   xDF,W
05C52:  SUBWFB xE1,W
05C54:  MOVWF  03
05C56:  MOVF   00,W
05C58:  ADDWF  x86,W
05C5A:  MOVLB  3
05C5C:  MOVWF  xFC
05C5E:  MOVF   03,W
05C60:  MOVLB  1
05C62:  ADDWFC x87,W
05C64:  MOVLB  3
05C66:  MOVWF  xFD
....................                if(wTemp < MyTCBStub.txTail) 
05C68:  MOVF   xFD,W
05C6A:  MOVLB  1
05C6C:  SUBWF  xE7,W
05C6E:  BNC   5CAC
05C70:  BNZ   5C82
05C72:  MOVF   xE6,W
05C74:  MOVLB  3
05C76:  SUBWF  xFC,W
05C78:  BTFSS  FD8.0
05C7A:  BRA    5C80
05C7C:  MOVLB  1
05C7E:  BRA    5CAC
05C80:  MOVLB  1
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - wTemp; 
05C82:  MOVLB  3
05C84:  MOVF   xFC,W
05C86:  MOVLB  1
05C88:  SUBWF  xE6,W
05C8A:  MOVWF  00
05C8C:  MOVLB  3
05C8E:  MOVF   xFD,W
05C90:  MOVLB  1
05C92:  SUBWFB xE7,W
05C94:  MOVWF  03
05C96:  MOVF   00,W
05C98:  ADDWF  x7E,F
05C9A:  MOVF   03,W
05C9C:  ADDWFC x7F,F
05C9E:  MOVLW  00
05CA0:  ADDWFC x80,F
05CA2:  ADDWFC x81,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
05CA4:  MOVFF  1E7,187
05CA8:  MOVFF  1E6,186
....................                } 
....................             } 
....................             if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart) 
05CAC:  MOVF   xE1,W
05CAE:  SUBWF  xE7,W
05CB0:  BNC   5CCE
05CB2:  BNZ   5CBA
05CB4:  MOVF   xE0,W
05CB6:  SUBWF  xE6,W
05CB8:  BNC   5CCE
....................                MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
05CBA:  MOVF   xDE,W
05CBC:  SUBWF  xE0,W
05CBE:  MOVWF  00
05CC0:  MOVF   xDF,W
05CC2:  SUBWFB xE1,W
05CC4:  MOVWF  03
05CC6:  MOVF   00,W
05CC8:  SUBWF  xE6,F
05CCA:  MOVF   03,W
05CCC:  SUBWFB xE7,F
....................             if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
05CCE:  MOVF   xE1,W
05CD0:  SUBWF  x87,W
05CD2:  BNC   5CF0
05CD4:  BNZ   5CDC
05CD6:  MOVF   xE0,W
05CD8:  SUBWF  x86,W
05CDA:  BNC   5CF0
....................                MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
05CDC:  MOVF   xDE,W
05CDE:  SUBWF  xE0,W
05CE0:  MOVWF  00
05CE2:  MOVF   xDF,W
05CE4:  SUBWFB xE1,W
05CE6:  MOVWF  03
05CE8:  MOVF   00,W
05CEA:  SUBWF  x86,F
05CEC:  MOVF   03,W
05CEE:  SUBWFB x87,F
....................          } 
05CF0:  BRA    5DAA
05CF2:  MOVLB  3
....................          else 
....................          { 
....................             // See if we have outstanding TX data that is waiting for an ACK 
....................             if(MyTCBStub.txTail != MyTCB.txUnackedTail) 
05CF4:  MOVLB  1
05CF6:  MOVF   x86,W
05CF8:  SUBWF  xE6,W
05CFA:  BNZ   5D02
05CFC:  MOVF   x87,W
05CFE:  SUBWF  xE7,W
05D00:  BZ    5DAA
....................             { 
....................                if(MyTCB.flags.bRXNoneACKed1) 
05D02:  BTFSS  x9C.3
05D04:  BRA    5DA8
....................                { 
....................                   if(MyTCB.flags.bRXNoneACKed2) 
05D06:  BTFSS  x9C.4
05D08:  BRA    5DA6
....................                   { 
....................                      // Set up to perform a fast retransmission 
....................                      // Roll back unacknowledged TX tail pointer to cause retransmit to occur 
....................                      MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
05D0A:  MOVF   xE6,W
05D0C:  SUBWF  x86,W
05D0E:  MOVWF  00
05D10:  MOVF   xE7,W
05D12:  SUBWFB x87,W
05D14:  MOVWF  03
05D16:  MOVF   00,W
05D18:  MOVFF  03,01
05D1C:  CLRF   02
05D1E:  CLRF   03
05D20:  BTFSS  01.7
05D22:  BRA    5D28
05D24:  DECF   02,F
05D26:  DECF   03,F
05D28:  MOVF   00,W
05D2A:  SUBWF  x7E,W
05D2C:  MOVWF  00
05D2E:  MOVF   01,W
05D30:  SUBWFB x7F,W
05D32:  MOVWF  01
05D34:  MOVF   02,W
05D36:  SUBWFB x80,W
05D38:  MOVWF  02
05D3A:  MOVF   03,W
05D3C:  SUBWFB x81,W
05D3E:  MOVWF  x81
05D40:  MOVFF  02,180
05D44:  MOVFF  01,17F
05D48:  MOVFF  00,17E
....................                      if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
05D4C:  MOVF   x87,W
05D4E:  SUBWF  xE7,W
05D50:  BNC   5D9C
05D52:  BNZ   5D5A
05D54:  MOVF   xE6,W
05D56:  SUBWF  x86,W
05D58:  BC    5D9C
....................                         MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
05D5A:  MOVF   xDE,W
05D5C:  SUBWF  xE0,W
05D5E:  MOVWF  00
05D60:  MOVF   xDF,W
05D62:  SUBWFB xE1,W
05D64:  MOVWF  03
05D66:  MOVF   00,W
05D68:  MOVFF  03,01
05D6C:  CLRF   02
05D6E:  CLRF   03
05D70:  BTFSS  01.7
05D72:  BRA    5D78
05D74:  DECF   02,F
05D76:  DECF   03,F
05D78:  MOVF   00,W
05D7A:  SUBWF  x7E,W
05D7C:  MOVWF  00
05D7E:  MOVF   01,W
05D80:  SUBWFB x7F,W
05D82:  MOVWF  01
05D84:  MOVF   02,W
05D86:  SUBWFB x80,W
05D88:  MOVWF  02
05D8A:  MOVF   03,W
05D8C:  SUBWFB x81,W
05D8E:  MOVWF  x81
05D90:  MOVFF  02,180
05D94:  MOVFF  01,17F
05D98:  MOVFF  00,17E
....................                      MyTCB.txUnackedTail = MyTCBStub.txTail; 
05D9C:  MOVFF  1E7,187
05DA0:  MOVFF  1E6,186
....................                      MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
05DA4:  BSF    xF6.2
....................                   } 
....................                   MyTCB.flags.bRXNoneACKed2 = 1; 
05DA6:  BSF    x9C.4
....................                } 
....................                MyTCB.flags.bRXNoneACKed1 = 1; 
05DA8:  BSF    x9C.3
....................             } 
....................          } 
....................  
....................          // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore 
....................          if(MyTCBStub.txTail == MyTCBStub.txHead) 
05DAA:  MOVF   xE4,W
05DAC:  SUBWF  xE6,W
05DAE:  BNZ   5E1C
05DB0:  MOVF   xE5,W
05DB2:  SUBWF  xE7,W
05DB4:  BNZ   5E1C
....................          { 
....................             // Make sure there isn't a "FIN byte in our TX FIFO" 
....................             if(MyTCBStub.Flags.bTXFIN == 0u) 
05DB6:  BTFSC  xF6.3
05DB8:  BRA    5DEC
....................             { 
....................                // Convert retransmission timer to keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
05DBA:  MOVLB  0
05DBC:  CALL   2424
05DC0:  MOVLW  EE
05DC2:  MOVLB  4
05DC4:  ADDWF  00,W
05DC6:  MOVLB  1
05DC8:  MOVWF  xEC
05DCA:  MOVLW  FA
05DCC:  MOVLB  4
05DCE:  ADDWFC 01,W
05DD0:  MOVLB  1
05DD2:  MOVWF  xED
05DD4:  MOVLW  02
05DD6:  MOVLB  4
05DD8:  ADDWFC 02,W
05DDA:  MOVLB  1
05DDC:  MOVWF  xEE
05DDE:  MOVLW  00
05DE0:  MOVLB  4
05DE2:  ADDWFC 03,W
05DE4:  MOVLB  1
05DE6:  MOVWF  xEF
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
05DE8:  BCF    xF5.4
....................             } 
05DEA:  BRA    5E1C
....................             else 
....................             { 
....................                // "Throw away" FIN byte from our TX FIFO if it has been ACKed 
....................                if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
05DEC:  MOVLB  4
05DEE:  MOVF   x07,W
05DF0:  MOVLB  1
05DF2:  SUBWF  x7E,W
05DF4:  BNZ   5E1C
05DF6:  MOVLB  4
05DF8:  MOVF   x08,W
05DFA:  MOVLB  1
05DFC:  SUBWF  x7F,W
05DFE:  BNZ   5E1C
05E00:  MOVLB  4
05E02:  MOVF   x09,W
05E04:  MOVLB  1
05E06:  SUBWF  x80,W
05E08:  BNZ   5E1C
05E0A:  MOVLB  4
05E0C:  MOVF   x0A,W
05E0E:  MOVLB  1
05E10:  SUBWF  x81,W
05E12:  BNZ   5E1C
05E14:  BTFSS  x9C.0
05E16:  BRA    5E1C
....................                { 
....................                   MyTCBStub.Flags.bTimerEnabled = 0; 
05E18:  BCF    xF5.4
....................                   MyTCBStub.Flags.bTXFIN = 0; 
05E1A:  BCF    xF6.3
....................                } 
....................             } 
....................          } 
....................  
....................          // The window size advirtised in this packet is adjusted to account  
....................          // for any bytes that we have transmitted but haven't been ACKed yet  
....................          // by this segment. 
....................          wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber)); 
05E1C:  MOVLW  0E
05E1E:  MOVLB  3
05E20:  ADDWF  xF4,W
05E22:  MOVWF  FE9
05E24:  MOVLW  00
05E26:  ADDWFC xF5,W
05E28:  MOVWF  FEA
05E2A:  MOVFF  FEC,415
05E2E:  MOVF   FED,F
05E30:  MOVFF  FEF,414
05E34:  MOVLB  4
05E36:  MOVF   x07,W
05E38:  MOVLB  1
05E3A:  SUBWF  x7E,W
05E3C:  MOVWF  00
05E3E:  MOVLB  4
05E40:  MOVF   x08,W
05E42:  MOVLB  1
05E44:  SUBWFB x7F,W
05E46:  MOVWF  01
05E48:  MOVLB  4
05E4A:  MOVF   x09,W
05E4C:  MOVLB  1
05E4E:  SUBWFB x80,W
05E50:  MOVLB  4
05E52:  MOVF   x0A,W
05E54:  MOVLB  1
05E56:  SUBWFB x81,W
05E58:  MOVF   00,W
05E5A:  MOVLB  4
05E5C:  SUBWF  x14,W
05E5E:  MOVWF  x12
05E60:  MOVF   01,W
05E62:  SUBWFB x15,W
05E64:  MOVWF  x13
....................  
....................          // Update the local stored copy of the RemoteWindow. 
....................          // If previously we had a zero window, and now we don't, then  
....................          // immediately send whatever was pending. 
....................          if((MyTCB.remoteWindow == 0u) && wNewWindow) 
05E66:  MOVLB  1
05E68:  MOVF   x8C,F
05E6A:  BNZ   5E82
05E6C:  MOVF   x8D,F
05E6E:  BNZ   5E82
05E70:  MOVLB  4
05E72:  MOVF   x12,W
05E74:  IORWF  x13,W
05E76:  BTFSS  FD8.2
05E78:  BRA    5E7E
05E7A:  MOVLB  1
05E7C:  BRA    5E82
....................             MyTCBStub.Flags.bTXASAP = 1; 
05E7E:  MOVLB  1
05E80:  BSF    xF6.1
....................          MyTCB.remoteWindow = wNewWindow; 
05E82:  MOVFF  413,18D
05E86:  MOVFF  412,18C
....................  
....................          // A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more 
....................          if(MyTCBStub.smState == TCP_FIN_WAIT_1) 
05E8A:  MOVF   xF4,W
05E8C:  SUBLW  08
05E8E:  BNZ   5EF2
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
05E90:  MOVLB  4
05E92:  MOVF   x07,W
05E94:  MOVLB  1
05E96:  SUBWF  x7E,W
05E98:  BNZ   5EF0
05E9A:  MOVLB  4
05E9C:  MOVF   x08,W
05E9E:  MOVLB  1
05EA0:  SUBWF  x7F,W
05EA2:  BNZ   5EF0
05EA4:  MOVLB  4
05EA6:  MOVF   x09,W
05EA8:  MOVLB  1
05EAA:  SUBWF  x80,W
05EAC:  BNZ   5EF0
05EAE:  MOVLB  4
05EB0:  MOVF   x0A,W
05EB2:  MOVLB  1
05EB4:  SUBWF  x81,W
05EB6:  BNZ   5EF0
05EB8:  BTFSS  x9C.0
05EBA:  BRA    5EF0
....................             { 
....................                // Reset our timer for forced closure if the remote node  
....................                // doesn't send us a FIN in a timely manner. 
....................                MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT; 
05EBC:  MOVLB  0
05EBE:  CALL   2424
05EC2:  MOVLW  77
05EC4:  MOVLB  4
05EC6:  ADDWF  00,W
05EC8:  MOVLB  1
05ECA:  MOVWF  xEC
05ECC:  MOVLW  7D
05ECE:  MOVLB  4
05ED0:  ADDWFC 01,W
05ED2:  MOVLB  1
05ED4:  MOVWF  xED
05ED6:  MOVLW  01
05ED8:  MOVLB  4
05EDA:  ADDWFC 02,W
05EDC:  MOVLB  1
05EDE:  MOVWF  xEE
05EE0:  MOVLW  00
05EE2:  MOVLB  4
05EE4:  ADDWFC 03,W
05EE6:  MOVLB  1
05EE8:  MOVWF  xEF
....................                MyTCBStub.Flags.bTimerEnabled = 1; 
05EEA:  BSF    xF5.4
....................                MyTCBStub.smState = TCP_FIN_WAIT_2; 
05EEC:  MOVLW  09
05EEE:  MOVWF  xF4
....................             } 
....................          } 
05EF0:  BRA    5F64
....................          else if(MyTCBStub.smState == TCP_FIN_WAIT_2) 
05EF2:  MOVF   xF4,W
05EF4:  SUBLW  09
05EF6:  BNZ   5F28
....................          { 
....................             // RFC noncompliance: 
....................             // The remote node should not keep sending us data  
....................             // indefinitely after we send a FIN to it.   
....................             // However, some bad stacks may still keep sending  
....................             // us data indefinitely after ACKing our FIN.  To  
....................             // prevent this from locking up our socket, let's  
....................             // send a RST right now and close forcefully on  
....................             // our side. 
....................             if(!(localHeaderFlags & FIN)) 
05EF8:  MOVLB  4
05EFA:  BTFSC  x06.0
05EFC:  BRA    5F24
....................             { 
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
05EFE:  MOVFF  40A,181
05F02:  MOVFF  409,180
05F06:  MOVFF  408,17F
05F0A:  MOVFF  407,17E
....................                SendTCP(RST | ACK, 0); 
05F0E:  MOVLW  14
05F10:  MOVWF  x14
05F12:  CLRF   x15
05F14:  MOVLB  0
05F16:  CALL   3620
....................                CloseSocket(); 
05F1A:  CALL   112A
....................                return; 
05F1E:  GOTO   672E
05F22:  MOVLB  4
....................             } 
....................          } 
05F24:  BRA    5F66
05F26:  MOVLB  1
....................          else if(MyTCBStub.smState == TCP_CLOSING) 
05F28:  MOVF   xF4,W
05F2A:  SUBLW  0A
05F2C:  BNZ   5F64
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if(MyTCB.MySEQ == localAckNumber) 
05F2E:  MOVLB  4
05F30:  MOVF   x07,W
05F32:  MOVLB  1
05F34:  SUBWF  x7E,W
05F36:  BNZ   5F5E
05F38:  MOVLB  4
05F3A:  MOVF   x08,W
05F3C:  MOVLB  1
05F3E:  SUBWF  x7F,W
05F40:  BNZ   5F5E
05F42:  MOVLB  4
05F44:  MOVF   x09,W
05F46:  MOVLB  1
05F48:  SUBWF  x80,W
05F4A:  BNZ   5F5E
05F4C:  MOVLB  4
05F4E:  MOVF   x0A,W
05F50:  MOVLB  1
05F52:  SUBWF  x81,W
05F54:  BNZ   5F5E
....................             { 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                CloseSocket(); 
05F56:  MOVLB  0
05F58:  CALL   112A
05F5C:  MOVLB  1
....................             } 
....................  
....................             return; 
05F5E:  MOVLB  0
05F60:  GOTO   672E
05F64:  MOVLB  4
....................          } 
....................  
....................          break; 
05F66:  BRA    5FB8
....................  
....................       case TCP_LAST_ACK: 
....................          // Check to see if our FIN has been ACKnowledged 
....................          if(MyTCB.MySEQ + 1 == localAckNumber) 
05F68:  MOVLW  01
05F6A:  MOVLB  1
05F6C:  ADDWF  x7E,W
05F6E:  MOVLB  4
05F70:  MOVWF  x14
05F72:  MOVLW  00
05F74:  MOVLB  1
05F76:  ADDWFC x7F,W
05F78:  MOVLB  4
05F7A:  MOVWF  x15
05F7C:  MOVLW  00
05F7E:  MOVLB  1
05F80:  ADDWFC x80,W
05F82:  MOVLB  4
05F84:  MOVWF  x16
05F86:  MOVLW  00
05F88:  MOVLB  1
05F8A:  ADDWFC x81,W
05F8C:  MOVLB  4
05F8E:  MOVWF  x17
05F90:  MOVF   x07,W
05F92:  SUBWF  x14,W
05F94:  BNZ   5FB0
05F96:  MOVF   x08,W
05F98:  SUBWF  x15,W
05F9A:  BNZ   5FB0
05F9C:  MOVF   x09,W
05F9E:  SUBWF  x16,W
05FA0:  BNZ   5FB0
05FA2:  MOVF   x0A,W
05FA4:  SUBWF  x17,W
05FA6:  BNZ   5FB0
....................             CloseSocket(); 
05FA8:  MOVLB  0
05FAA:  CALL   112A
05FAE:  MOVLB  4
....................          return; 
05FB0:  MOVLB  0
05FB2:  GOTO   672E
....................  
.................... //      case TCP_TIME_WAIT: 
.................... //         // Nothing is supposed to arrive here.  If it does, reset the quiet timer. 
.................... //         SendTCP(ACK, SENDTCP_RESET_TIMERS); 
.................... //         return; 
....................  
....................       default: 
....................          break; 
05FB6:  MOVLB  4
....................    } 
....................  
....................    // 
....................    // Sixth: Check the URG bit 
....................    // 
....................    // Urgent packets are not supported in this stack, so we 
....................    // will throw them away instead 
....................    if(localHeaderFlags & URG) 
05FB8:  BTFSS  x06.5
05FBA:  BRA    5FC4
....................       return; 
05FBC:  MOVLB  0
05FBE:  GOTO   672E
05FC2:  MOVLB  4
....................  
....................    // 
....................    // Seventh: Process the segment text 
....................    // 
....................    // Throw data away if in a state that doesn't accept data 
....................    if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
05FC4:  MOVLB  1
05FC6:  MOVF   xF4,W
05FC8:  SUBLW  0B
05FCA:  BNZ   5FD4
....................       return; 
05FCC:  MOVLB  0
05FCE:  GOTO   672E
05FD2:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_CLOSING) 
05FD4:  MOVF   xF4,W
05FD6:  SUBLW  0A
05FD8:  BNZ   5FE2
....................       return; 
05FDA:  MOVLB  0
05FDC:  GOTO   672E
05FE0:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_LAST_ACK) 
05FE2:  MOVF   xF4,W
05FE4:  SUBLW  0C
05FE6:  BNZ   5FF0
....................       return; 
05FE8:  MOVLB  0
05FEA:  GOTO   672E
05FEE:  MOVLB  1
.................... //   if(MyTCBStub.smState == TCP_TIME_WAIT) 
.................... //      return; 
....................  
....................    // Copy any valid segment data into our RX FIFO, if any 
....................    if(len) 
05FF0:  MOVLB  3
05FF2:  MOVF   xF6,W
05FF4:  IORWF  xF7,W
05FF6:  BTFSC  FD8.2
05FF8:  BRA    659A
....................    { 
....................       // See if there are bytes we must skip 
....................       if((SHORT)wMissingBytes <= 0) 
05FFA:  MOVLB  4
05FFC:  BTFSC  x03.7
05FFE:  BRA    600E
06000:  MOVF   x03,F
06002:  BTFSS  FD8.2
06004:  BRA    6242
06006:  MOVF   x02,W
06008:  SUBLW  00
0600A:  BTFSS  FD8.0
0600C:  BRA    6242
....................       { 
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes); 
0600E:  MOVLW  0C
06010:  MOVLB  3
06012:  ADDWF  xF4,W
06014:  MOVWF  FE9
06016:  MOVLW  00
06018:  ADDWFC xF5,W
0601A:  MOVWF  FEA
0601C:  MOVFF  FEF,00
06020:  SWAPF  00,W
06022:  ANDLW  0F
06024:  MOVWF  00
06026:  RLCF   00,F
06028:  RLCF   00,F
0602A:  MOVLW  FC
0602C:  ANDWF  00,F
0602E:  MOVF   00,W
06030:  BSF    FD8.0
06032:  MOVLB  4
06034:  SUBFWB x02,W
06036:  MOVWF  x14
06038:  MOVLW  00
0603A:  SUBFWB x03,W
0603C:  MOVWF  x15
0603E:  MOVWF  x19
06040:  MOVFF  414,418
06044:  MOVLB  0
06046:  CALL   24A2
....................          len += wMissingBytes;       
0604A:  MOVLB  4
0604C:  MOVF   x02,W
0604E:  MOVLB  3
06050:  ADDWF  xF6,F
06052:  MOVLB  4
06054:  MOVF   x03,W
06056:  MOVLB  3
06058:  ADDWFC xF7,F
....................     
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          // and request a retransmit by sending a duplicate ACK 
....................          if(len > wFreeSpace) 
0605A:  MOVLB  4
0605C:  MOVF   x05,W
0605E:  MOVLB  3
06060:  SUBWF  xF7,W
06062:  BNC   607E
06064:  BNZ   6076
06066:  MOVF   xF6,W
06068:  MOVLB  4
0606A:  SUBWF  x04,W
0606C:  BTFSS  FD8.0
0606E:  BRA    6074
06070:  MOVLB  3
06072:  BRA    607E
06074:  MOVLB  3
....................             len = wFreeSpace; 
06076:  MOVFF  405,3F7
0607A:  MOVFF  404,3F6
....................     
....................          MyTCB.RemoteSEQ += (DWORD)len; 
0607E:  MOVFF  3F7,01
06082:  CLRF   02
06084:  CLRF   03
06086:  MOVF   xF6,W
06088:  MOVLB  1
0608A:  ADDWF  x82,F
0608C:  MOVF   01,W
0608E:  ADDWFC x83,F
06090:  MOVF   02,W
06092:  ADDWFC x84,F
06094:  MOVF   03,W
06096:  ADDWFC x85,F
....................        
....................          // Copy the application data from the packet into the socket RX FIFO 
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd) 
06098:  MOVLB  3
0609A:  MOVF   xF6,W
0609C:  MOVLB  1
0609E:  ADDWF  xE8,W
060A0:  MOVLB  4
060A2:  MOVWF  x14
060A4:  MOVLB  3
060A6:  MOVF   xF7,W
060A8:  MOVLB  1
060AA:  ADDWFC xE9,W
060AC:  MOVLB  4
060AE:  MOVWF  x15
060B0:  MOVLB  1
060B2:  MOVF   xE3,W
060B4:  MOVLB  4
060B6:  SUBWF  x15,W
060B8:  BNC   6166
060BA:  BNZ   60CC
060BC:  MOVF   x14,W
060BE:  MOVLB  1
060C0:  SUBWF  xE2,W
060C2:  BTFSS  FD8.0
060C4:  BRA    60CA
060C6:  MOVLB  4
060C8:  BRA    6166
060CA:  MOVLB  4
....................          { 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1; 
060CC:  MOVLB  1
060CE:  MOVF   xE8,W
060D0:  SUBWF  xE2,W
060D2:  MOVLB  4
060D4:  MOVWF  x14
060D6:  MOVLB  1
060D8:  MOVF   xE9,W
060DA:  SUBWFB xE3,W
060DC:  MOVLB  4
060DE:  MOVWF  x15
060E0:  MOVLW  01
060E2:  ADDWF  x14,W
060E4:  MOVLB  3
060E6:  MOVWF  xFC
060E8:  MOVLW  00
060EA:  MOVLB  4
060EC:  ADDWFC x15,W
060EE:  MOVLB  3
060F0:  MOVWF  xFD
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
060F2:  MOVFF  1E9,446
060F6:  MOVFF  1E8,445
060FA:  MOVFF  1F9,447
060FE:  MOVLB  4
06100:  SETF   x49
06102:  SETF   x48
06104:  CLRF   x4A
06106:  MOVFF  3FD,44C
0610A:  MOVFF  3FC,44B
0610E:  MOVLB  0
06110:  CALL   0F6C
....................             TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
06114:  MOVLB  3
06116:  MOVF   xFC,W
06118:  SUBWF  xF6,W
0611A:  MOVLB  4
0611C:  MOVWF  x14
0611E:  MOVLB  3
06120:  MOVF   xFD,W
06122:  SUBWFB xF7,W
06124:  MOVLB  4
06126:  MOVWF  x15
06128:  MOVFF  1E1,446
0612C:  MOVFF  1E0,445
06130:  MOVFF  1F9,447
06134:  SETF   x49
06136:  SETF   x48
06138:  CLRF   x4A
0613A:  MOVWF  x4C
0613C:  MOVFF  414,44B
06140:  MOVLB  0
06142:  CALL   0F6C
....................             MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp); 
06146:  MOVLB  3
06148:  MOVF   xFC,W
0614A:  SUBWF  xF6,W
0614C:  MOVWF  00
0614E:  MOVF   xFD,W
06150:  SUBWFB xF7,W
06152:  MOVWF  03
06154:  MOVF   00,W
06156:  MOVLB  1
06158:  ADDWF  xE0,W
0615A:  MOVWF  xE8
0615C:  MOVF   03,W
0615E:  ADDWFC xE1,W
06160:  MOVWF  xE9
....................          } 
06162:  BRA    6196
06164:  MOVLB  4
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
06166:  MOVFF  1E9,446
0616A:  MOVFF  1E8,445
0616E:  MOVFF  1F9,447
06172:  SETF   x49
06174:  SETF   x48
06176:  CLRF   x4A
06178:  MOVFF  3F7,44C
0617C:  MOVFF  3F6,44B
06180:  MOVLB  0
06182:  CALL   0F6C
....................             MyTCBStub.rxHead += len; 
06186:  MOVLB  3
06188:  MOVF   xF6,W
0618A:  MOVLB  1
0618C:  ADDWF  xE8,F
0618E:  MOVLB  3
06190:  MOVF   xF7,W
06192:  MOVLB  1
06194:  ADDWFC xE9,F
....................          } 
....................        
....................          // See if we have a hole and other data waiting already in the RX FIFO 
....................          if(MyTCB.sHoleSize != -1) 
06196:  INCFSZ x9A,W
06198:  BRA    61A0
0619A:  INCFSZ x9B,W
0619C:  BRA    61A0
0619E:  BRA    623E
....................          { 
....................             MyTCB.sHoleSize -= len; 
061A0:  MOVLB  3
061A2:  MOVF   xF6,W
061A4:  MOVLB  1
061A6:  SUBWF  x9A,F
061A8:  MOVLB  3
061AA:  MOVF   xF7,W
061AC:  MOVLB  1
061AE:  SUBWFB x9B,F
....................             wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize; 
061B0:  MOVF   x9A,W
061B2:  ADDWF  x8E,W
061B4:  MOVWF  01
061B6:  MOVF   x9B,W
061B8:  ADDWFC x8F,W
061BA:  MOVFF  01,3FC
061BE:  MOVLB  3
061C0:  MOVWF  xFD
....................        
....................             // See if we just closed up a hole, and if so, advance head pointer 
....................             if((SHORT)wTemp < (SHORT)0) 
061C2:  BTFSS  xFD.7
061C4:  BRA    61CE
....................             { 
....................                MyTCB.sHoleSize = -1; 
061C6:  MOVLB  1
061C8:  SETF   x9B
061CA:  SETF   x9A
....................             } 
061CC:  BRA    623E
....................             else if(MyTCB.sHoleSize <= 0) 
061CE:  MOVLB  1
061D0:  BTFSC  x9B.7
061D2:  BRA    61DE
061D4:  MOVF   x9B,F
061D6:  BNZ   623E
061D8:  MOVF   x9A,W
061DA:  SUBLW  00
061DC:  BNC   623E
....................             { 
....................                MyTCB.RemoteSEQ += wTemp; 
061DE:  MOVLB  3
061E0:  MOVF   xFC,W
061E2:  MOVLB  1
061E4:  ADDWF  x82,F
061E6:  MOVLB  3
061E8:  MOVF   xFD,W
061EA:  MOVLB  1
061EC:  ADDWFC x83,F
061EE:  MOVLW  00
061F0:  ADDWFC x84,F
061F2:  ADDWFC x85,F
....................                MyTCBStub.rxHead += wTemp; 
061F4:  MOVLB  3
061F6:  MOVF   xFC,W
061F8:  MOVLB  1
061FA:  ADDWF  xE8,F
061FC:  MOVLB  3
061FE:  MOVF   xFD,W
06200:  MOVLB  1
06202:  ADDWFC xE9,F
....................                if(MyTCBStub.rxHead > MyTCBStub.bufferEnd) 
06204:  MOVF   xE3,W
06206:  SUBWF  xE9,W
06208:  BNC   623A
0620A:  BNZ   6212
0620C:  MOVF   xE8,W
0620E:  SUBWF  xE2,W
06210:  BC    623A
....................                   MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;                      
06212:  MOVF   xE0,W
06214:  SUBWF  xE2,W
06216:  MOVLB  4
06218:  MOVWF  x14
0621A:  MOVLB  1
0621C:  MOVF   xE1,W
0621E:  SUBWFB xE3,W
06220:  MOVLB  4
06222:  MOVWF  x15
06224:  MOVLW  01
06226:  ADDWF  x14,W
06228:  MOVWF  01
0622A:  MOVLW  00
0622C:  ADDWFC x15,W
0622E:  MOVWF  03
06230:  MOVF   01,W
06232:  MOVLB  1
06234:  SUBWF  xE8,F
06236:  MOVF   03,W
06238:  SUBWFB xE9,F
....................                MyTCB.sHoleSize = -1; 
0623A:  SETF   x9B
0623C:  SETF   x9A
....................             } 
....................          } 
....................       } // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it 
0623E:  BRA    6596
06240:  MOVLB  4
....................       else if((SHORT)wMissingBytes > 0) 
06242:  BTFSC  x03.7
06244:  BRA    6598
06246:  MOVF   x03,F
06248:  BNZ   6252
0624A:  MOVF   x02,W
0624C:  SUBLW  00
0624E:  BTFSC  FD8.0
06250:  BRA    6598
....................       { 
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          if(len + wMissingBytes > wFreeSpace) 
06252:  MOVF   x02,W
06254:  MOVLB  3
06256:  ADDWF  xF6,W
06258:  MOVLB  4
0625A:  MOVWF  x14
0625C:  MOVF   x03,W
0625E:  MOVLB  3
06260:  ADDWFC xF7,W
06262:  MOVLB  4
06264:  MOVWF  x15
06266:  MOVF   x05,W
06268:  SUBWF  x15,W
0626A:  BNC   6288
0626C:  BNZ   6274
0626E:  MOVF   x14,W
06270:  SUBWF  x04,W
06272:  BC    6288
....................             len = wFreeSpace - wMissingBytes; 
06274:  MOVF   x02,W
06276:  SUBWF  x04,W
06278:  MOVLB  3
0627A:  MOVWF  xF6
0627C:  MOVLB  4
0627E:  MOVF   x03,W
06280:  SUBWFB x05,W
06282:  MOVLB  3
06284:  MOVWF  xF7
06286:  MOVLB  4
....................        
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer(h->DataOffset.Val << 2); 
06288:  MOVLW  0C
0628A:  MOVLB  3
0628C:  ADDWF  xF4,W
0628E:  MOVWF  FE9
06290:  MOVLW  00
06292:  ADDWFC xF5,W
06294:  MOVWF  FEA
06296:  MOVFF  FEF,00
0629A:  SWAPF  00,W
0629C:  ANDLW  0F
0629E:  MOVWF  00
062A0:  RLCF   00,W
062A2:  MOVLB  4
062A4:  MOVWF  x14
062A6:  RLCF   x14,F
062A8:  MOVLW  FC
062AA:  ANDWF  x14,F
062AC:  CLRF   x19
062AE:  MOVFF  414,418
062B2:  MOVLB  0
062B4:  CALL   24A2
....................     
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd) 
062B8:  MOVLB  4
062BA:  MOVF   x02,W
062BC:  MOVLB  1
062BE:  ADDWF  xE8,W
062C0:  MOVLB  4
062C2:  MOVWF  x14
062C4:  MOVF   x03,W
062C6:  MOVLB  1
062C8:  ADDWFC xE9,W
062CA:  MOVLB  4
062CC:  MOVWF  x15
062CE:  MOVLB  3
062D0:  MOVF   xF6,W
062D2:  MOVLB  4
062D4:  ADDWF  x14,F
062D6:  MOVLB  3
062D8:  MOVF   xF7,W
062DA:  MOVLB  4
062DC:  ADDWFC x15,F
062DE:  MOVLB  1
062E0:  MOVF   xE3,W
062E2:  MOVLB  4
062E4:  SUBWF  x15,W
062E6:  BTFSS  FD8.0
062E8:  BRA    63FA
062EA:  BNZ   62FC
062EC:  MOVF   x14,W
062EE:  MOVLB  1
062F0:  SUBWF  xE2,W
062F2:  BTFSS  FD8.0
062F4:  BRA    62FA
062F6:  MOVLB  4
062F8:  BRA    63FA
062FA:  MOVLB  4
....................          { 
....................             // Calculate number of data bytes to copy before wraparound 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes; 
062FC:  MOVLB  1
062FE:  MOVF   xE8,W
06300:  SUBWF  xE2,W
06302:  MOVLB  4
06304:  MOVWF  x14
06306:  MOVLB  1
06308:  MOVF   xE9,W
0630A:  SUBWFB xE3,W
0630C:  MOVLB  4
0630E:  MOVWF  x15
06310:  MOVLW  01
06312:  ADDWF  x14,F
06314:  MOVLW  00
06316:  ADDWFC x15,F
06318:  MOVF   x02,W
0631A:  SUBWF  x14,W
0631C:  MOVLB  3
0631E:  MOVWF  xFC
06320:  MOVLB  4
06322:  MOVF   x03,W
06324:  SUBWFB x15,W
06326:  MOVLB  3
06328:  MOVWF  xFD
....................             if((SHORT)wTemp >= 0) 
0632A:  BTFSC  xFD.7
0632C:  BRA    6398
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
0632E:  MOVLB  4
06330:  MOVF   x02,W
06332:  MOVLB  1
06334:  ADDWF  xE8,W
06336:  MOVLB  4
06338:  MOVWF  x14
0633A:  MOVF   x03,W
0633C:  MOVLB  1
0633E:  ADDWFC xE9,W
06340:  MOVLB  4
06342:  MOVWF  x15
06344:  MOVWF  x46
06346:  MOVFF  414,445
0634A:  MOVFF  1F9,447
0634E:  SETF   x49
06350:  SETF   x48
06352:  CLRF   x4A
06354:  MOVFF  3FD,44C
06358:  MOVFF  3FC,44B
0635C:  MOVLB  0
0635E:  CALL   0F6C
....................                TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
06362:  MOVLB  3
06364:  MOVF   xFC,W
06366:  SUBWF  xF6,W
06368:  MOVLB  4
0636A:  MOVWF  x14
0636C:  MOVLB  3
0636E:  MOVF   xFD,W
06370:  SUBWFB xF7,W
06372:  MOVLB  4
06374:  MOVWF  x15
06376:  MOVFF  1E1,446
0637A:  MOVFF  1E0,445
0637E:  MOVFF  1F9,447
06382:  SETF   x49
06384:  SETF   x48
06386:  CLRF   x4A
06388:  MOVWF  x4C
0638A:  MOVFF  414,44B
0638E:  MOVLB  0
06390:  CALL   0F6C
....................             } 
06394:  BRA    63F6
06396:  MOVLB  3
....................             else 
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
06398:  MOVLB  4
0639A:  MOVF   x02,W
0639C:  MOVLB  1
0639E:  ADDWF  xE8,W
063A0:  MOVLB  4
063A2:  MOVWF  x14
063A4:  MOVF   x03,W
063A6:  MOVLB  1
063A8:  ADDWFC xE9,W
063AA:  MOVLB  4
063AC:  MOVWF  x15
063AE:  MOVLB  1
063B0:  MOVF   xE0,W
063B2:  SUBWF  xE2,W
063B4:  MOVLB  4
063B6:  MOVWF  x16
063B8:  MOVLB  1
063BA:  MOVF   xE1,W
063BC:  SUBWFB xE3,W
063BE:  MOVLB  4
063C0:  MOVWF  x17
063C2:  MOVLW  01
063C4:  ADDWF  x16,W
063C6:  MOVWF  01
063C8:  MOVLW  00
063CA:  ADDWFC x17,W
063CC:  MOVWF  03
063CE:  MOVF   01,W
063D0:  SUBWF  x14,F
063D2:  MOVF   03,W
063D4:  SUBWFB x15,F
063D6:  MOVFF  415,446
063DA:  MOVFF  414,445
063DE:  MOVFF  1F9,447
063E2:  SETF   x49
063E4:  SETF   x48
063E6:  CLRF   x4A
063E8:  MOVFF  3F7,44C
063EC:  MOVFF  3F6,44B
063F0:  MOVLB  0
063F2:  CALL   0F6C
....................             } 
....................          } 
063F6:  BRA    642C
063F8:  MOVLB  4
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
063FA:  MOVF   x02,W
063FC:  MOVLB  1
063FE:  ADDWF  xE8,W
06400:  MOVLB  4
06402:  MOVWF  x14
06404:  MOVF   x03,W
06406:  MOVLB  1
06408:  ADDWFC xE9,W
0640A:  MOVLB  4
0640C:  MOVWF  x15
0640E:  MOVWF  x46
06410:  MOVFF  414,445
06414:  MOVFF  1F9,447
06418:  SETF   x49
0641A:  SETF   x48
0641C:  CLRF   x4A
0641E:  MOVFF  3F7,44C
06422:  MOVFF  3F6,44B
06426:  MOVLB  0
06428:  CALL   0F6C
....................          } 
....................        
....................          // Record the hole is here 
....................          if(MyTCB.sHoleSize == -1) 
0642C:  MOVLB  1
0642E:  INCFSZ x9A,W
06430:  BRA    6448
06432:  INCFSZ x9B,W
06434:  BRA    6448
....................          { 
....................             MyTCB.sHoleSize = wMissingBytes; 
06436:  MOVFF  403,19B
0643A:  MOVFF  402,19A
....................             MyTCB.wFutureDataSize = len; 
0643E:  MOVFF  3F7,18F
06442:  MOVFF  3F6,18E
....................          } 
06446:  BRA    6596
....................          else 
....................          { 
....................             // We already have a hole, see if we can shrink the hole  
....................             // or extend the future data size 
....................             if(wMissingBytes < (WORD)MyTCB.sHoleSize) 
06448:  MOVLB  4
0644A:  MOVF   x03,W
0644C:  MOVLB  1
0644E:  SUBWF  x9B,W
06450:  BNC   6502
06452:  BNZ   6464
06454:  MOVF   x9A,W
06456:  MOVLB  4
06458:  SUBWF  x02,W
0645A:  BTFSS  FD8.0
0645C:  BRA    6462
0645E:  MOVLB  1
06460:  BRA    6502
06462:  MOVLB  1
....................             { 
....................                if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize)) 
06464:  MOVLB  3
06466:  MOVF   xF6,W
06468:  MOVLB  4
0646A:  ADDWF  x02,W
0646C:  MOVWF  x14
0646E:  MOVLB  3
06470:  MOVF   xF7,W
06472:  MOVLB  4
06474:  ADDWFC x03,W
06476:  MOVWF  x15
06478:  MOVLB  1
0647A:  MOVF   x8E,W
0647C:  ADDWF  x9A,W
0647E:  MOVWF  01
06480:  MOVF   x8F,W
06482:  ADDWFC x9B,W
06484:  MOVWF  03
06486:  MOVF   03,W
06488:  MOVLB  4
0648A:  SUBWF  x15,W
0648C:  BNC   6496
0648E:  BNZ   64C6
06490:  MOVF   x14,W
06492:  SUBWF  01,W
06494:  BNC   64C6
06496:  MOVLB  3
06498:  MOVF   xF6,W
0649A:  MOVLB  4
0649C:  ADDWF  x02,W
0649E:  MOVWF  x14
064A0:  MOVLB  3
064A2:  MOVF   xF7,W
064A4:  MOVLB  4
064A6:  ADDWFC x03,W
064A8:  MOVWF  x15
064AA:  MOVLB  1
064AC:  SUBWF  x9B,W
064AE:  BNC   64D2
064B0:  BTFSC  FD8.2
064B2:  BRA    64B8
064B4:  MOVLB  4
064B6:  BRA    64C6
064B8:  MOVF   x9A,W
064BA:  MOVLB  4
064BC:  SUBWF  x14,W
064BE:  BTFSS  FD8.0
064C0:  BRA    64C6
064C2:  MOVLB  1
064C4:  BRA    64D2
....................                   MyTCB.wFutureDataSize = len; 
064C6:  MOVFF  3F7,18F
064CA:  MOVFF  3F6,18E
064CE:  BRA    64F8
064D0:  MOVLB  1
....................                else 
....................                   MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes; 
064D2:  MOVF   x8E,W
064D4:  ADDWF  x9A,W
064D6:  MOVLB  4
064D8:  MOVWF  x14
064DA:  MOVLB  1
064DC:  MOVF   x8F,W
064DE:  ADDWFC x9B,W
064E0:  MOVLB  4
064E2:  MOVWF  x15
064E4:  MOVF   x02,W
064E6:  SUBWF  x14,W
064E8:  MOVLB  1
064EA:  MOVWF  x8E
064EC:  MOVLB  4
064EE:  MOVF   x03,W
064F0:  SUBWFB x15,W
064F2:  MOVLB  1
064F4:  MOVWF  x8F
064F6:  MOVLB  4
....................                MyTCB.sHoleSize = wMissingBytes; 
064F8:  MOVFF  403,19B
064FC:  MOVFF  402,19A
....................             } 
06500:  BRA    6598
....................             else if(wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
06502:  MOVLB  3
06504:  MOVF   xF6,W
06506:  MOVLB  4
06508:  ADDWF  x02,W
0650A:  MOVWF  x14
0650C:  MOVLB  3
0650E:  MOVF   xF7,W
06510:  MOVLB  4
06512:  ADDWFC x03,W
06514:  MOVWF  x15
06516:  MOVLB  1
06518:  MOVF   x8E,W
0651A:  ADDWF  x9A,W
0651C:  MOVWF  01
0651E:  MOVF   x8F,W
06520:  ADDWFC x9B,W
06522:  MOVWF  03
06524:  MOVF   03,W
06526:  MOVLB  4
06528:  SUBWF  x15,W
0652A:  BNC   6598
0652C:  BNZ   6534
0652E:  MOVF   x14,W
06530:  SUBWF  01,W
06532:  BC    6598
....................             { 
....................                // Make sure that there isn't a second hole between  
....................                // our future data and this TCP segment's future data 
....................                if(wMissingBytes <= (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
06534:  MOVLB  1
06536:  MOVF   x8E,W
06538:  ADDWF  x9A,W
0653A:  MOVWF  01
0653C:  MOVF   x8F,W
0653E:  ADDWFC x9B,W
06540:  MOVWF  03
06542:  MOVF   01,W
06544:  MOVLB  4
06546:  MOVF   x03,W
06548:  SUBWF  03,W
0654A:  BNC   6598
0654C:  BNZ   6554
0654E:  MOVF   x02,W
06550:  SUBWF  01,W
06552:  BNC   6598
....................                   MyTCB.wFutureDataSize += wMissingBytes + len - (WORD)MyTCB.sHoleSize - MyTCB.wFutureDataSize; 
06554:  MOVLB  3
06556:  MOVF   xF6,W
06558:  MOVLB  4
0655A:  ADDWF  x02,W
0655C:  MOVWF  x14
0655E:  MOVLB  3
06560:  MOVF   xF7,W
06562:  MOVLB  4
06564:  ADDWFC x03,W
06566:  MOVWF  x15
06568:  MOVLB  1
0656A:  MOVF   x9A,W
0656C:  MOVLB  4
0656E:  SUBWF  x14,F
06570:  MOVLB  1
06572:  MOVF   x9B,W
06574:  MOVLB  4
06576:  SUBWFB x15,F
06578:  MOVLB  1
0657A:  MOVF   x8E,W
0657C:  MOVLB  4
0657E:  SUBWF  x14,W
06580:  MOVWF  00
06582:  MOVLB  1
06584:  MOVF   x8F,W
06586:  MOVLB  4
06588:  SUBWFB x15,W
0658A:  MOVWF  03
0658C:  MOVF   00,W
0658E:  MOVLB  1
06590:  ADDWF  x8E,F
06592:  MOVF   03,W
06594:  ADDWFC x8F,F
06596:  MOVLB  4
06598:  MOVLB  3
....................             } 
....................              
....................          } 
....................       } 
....................    } 
....................  
....................    // Send back an ACK of the data (+SYN | FIN) we just received,  
....................    // if any.  To minimize bandwidth waste, we are implementing  
....................    // the delayed acknowledgement algorithm here, only sending  
....................    // back an immediate ACK if this is the second segment received.   
....................    // Otherwise, a 200ms timer will cause the ACK to be transmitted. 
....................    if(wSegmentLength) 
0659A:  MOVLB  4
0659C:  MOVF   x0F,W
0659E:  IORWF  x10,W
065A0:  BZ    65F4
....................    { 
....................       // For non-established sockets, let's delete all data in  
....................       // the RX buffer immediately after receiving it.  This is  
....................       // not really how TCP was intended to operate since a  
....................       // socket cannot receive any response after it sends a FIN, 
....................       // but our TCP application API doesn't readily accomodate 
....................       // receiving data after calling TCPDisconnect(), which  
....................       // invalidates the application TCP handle.  By deleting all  
....................       // data, we'll ensure that the RX window is nonzero and  
....................       // the remote node will be able to send us a FIN response,  
....................       // which needs an RX window of at least 1. 
....................       if(MyTCBStub.smState != TCP_ESTABLISHED) 
065A2:  MOVLB  1
065A4:  MOVF   xF4,W
065A6:  SUBLW  07
065A8:  BZ    65B2
....................          MyTCBStub.rxTail = MyTCBStub.rxHead; 
065AA:  MOVFF  1E9,1EB
065AE:  MOVFF  1E8,1EA
....................  
....................       if(MyTCBStub.Flags.bOneSegmentReceived) 
065B2:  BTFSS  xF5.7
065B4:  BRA    65CE
....................       { 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
065B6:  MOVLW  10
065B8:  MOVLB  4
065BA:  MOVWF  x14
065BC:  MOVLW  01
065BE:  MOVWF  x15
065C0:  MOVLB  0
065C2:  CALL   3620
....................          SyncTCB(); 
065C6:  CALL   1052
....................          // bOneSegmentReceived is cleared in SendTCP(), so no need here 
....................       } 
065CA:  BRA    65F2
065CC:  MOVLB  1
....................       else 
....................       { 
....................          MyTCBStub.Flags.bOneSegmentReceived = TRUE;    
065CE:  BSF    xF5.7
....................        
....................          // Do not send an ACK immediately back.  Instead, we will  
....................          // perform delayed acknowledgements.  To do this, we will  
....................          // just start a timer 
....................          if(!MyTCBStub.Flags.bDelayedACKTimerEnabled) 
065D0:  BTFSC  xF5.6
065D2:  BRA    65F0
....................          { 
....................             MyTCBStub.Flags.bDelayedACKTimerEnabled = 1; 
065D4:  BSF    xF5.6
....................             MyTCBStub.OverlappedTimers.delayedACKTime = (WORD)TickGetDiv256() + (WORD)((TCP_DELAYED_ACK_TIMEOUT)>>8); 
065D6:  MOVLB  0
065D8:  CALL   2FD6
065DC:  MOVLW  07
065DE:  MOVLB  4
065E0:  ADDWF  00,W
065E2:  MOVLB  1
065E4:  MOVWF  xF2
065E6:  MOVLW  00
065E8:  MOVLB  4
065EA:  ADDWFC 01,W
065EC:  MOVLB  1
065EE:  MOVWF  xF3
065F0:  MOVLB  0
065F2:  MOVLB  4
....................          } 
....................       } 
....................    } 
....................  
....................    // 
....................    // Eighth: check the FIN bit 
....................    // 
....................    if(localHeaderFlags & FIN) 
065F4:  BTFSS  x06.0
065F6:  BRA    6730
....................    { 
....................       // Note: Since we don't have a good means of storing "FIN bytes"  
....................       // in our TCP RX FIFO, we must ensure that FINs are processed  
....................       // in-order. 
....................       if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength) 
065F8:  MOVLW  01
065FA:  MOVLB  1
065FC:  ADDWF  x82,W
065FE:  MOVLB  4
06600:  MOVWF  x14
06602:  MOVLW  00
06604:  MOVLB  1
06606:  ADDWFC x83,W
06608:  MOVLB  4
0660A:  MOVWF  x15
0660C:  MOVLW  00
0660E:  MOVLB  1
06610:  ADDWFC x84,W
06612:  MOVLB  4
06614:  MOVWF  x16
06616:  MOVLW  00
06618:  MOVLB  1
0661A:  ADDWFC x85,W
0661C:  MOVLB  4
0661E:  MOVWF  x17
06620:  MOVFF  40F,00
06624:  MOVFF  410,01
06628:  CLRF   02
0662A:  CLRF   03
0662C:  MOVF   x0B,W
0662E:  ADDWF  00,F
06630:  MOVF   x0C,W
06632:  ADDWFC 01,F
06634:  MOVF   x0D,W
06636:  ADDWFC 02,F
06638:  MOVF   x0E,W
0663A:  ADDWFC 03,F
0663C:  MOVF   00,W
0663E:  SUBWF  x14,W
06640:  BTFSS  FD8.2
06642:  BRA    6730
06644:  MOVF   01,W
06646:  SUBWF  x15,W
06648:  BTFSS  FD8.2
0664A:  BRA    6730
0664C:  MOVF   02,W
0664E:  SUBWF  x16,W
06650:  BTFSS  FD8.2
06652:  BRA    6730
06654:  MOVF   03,W
06656:  SUBWF  x17,W
06658:  BTFSS  FD8.2
0665A:  BRA    6730
....................       { 
....................          // FINs are treated as one byte of data for ACK sequencing 
....................          MyTCB.RemoteSEQ++; 
0665C:  MOVLW  01
0665E:  MOVLB  1
06660:  ADDWF  x82,F
06662:  BTFSC  FD8.0
06664:  INCF   x83,F
06666:  BTFSC  FD8.2
06668:  INCF   x84,F
0666A:  BTFSC  FD8.2
0666C:  INCF   x85,F
....................           
....................          switch(MyTCBStub.smState) 
0666E:  MOVF   xF4,W
06670:  XORLW  06
06672:  MOVLB  0
06674:  BZ    6684
06676:  XORLW  01
06678:  BZ    669C
0667A:  XORLW  0F
0667C:  BZ    66BE
0667E:  XORLW  01
06680:  BZ    6708
06682:  BRA    671C
....................          { 
....................             case TCP_SYN_RECEIVED: 
....................                // RFC in exact: Our API has no need for the user  
....................                // to explicitly close a socket that never really  
....................                // got opened fully in the first place, so just  
....................                // transmit a FIN automatically and jump to  
....................                // TCP_LAST_ACK 
....................                MyTCBStub.smState = TCP_LAST_ACK; 
06684:  MOVLW  0C
06686:  MOVLB  1
06688:  MOVWF  xF4
....................                SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
0668A:  MOVLW  11
0668C:  MOVLB  4
0668E:  MOVWF  x14
06690:  MOVLW  01
06692:  MOVWF  x15
06694:  MOVLB  0
06696:  CALL   3620
....................                return; 
0669A:  BRA    672E
....................  
....................             case TCP_ESTABLISHED: 
....................                // Go to TCP_CLOSE_WAIT state 
....................                MyTCBStub.smState = TCP_CLOSE_WAIT; 
0669C:  MOVLW  0B
0669E:  MOVLB  1
066A0:  MOVWF  xF4
....................                 
....................                // For legacy applications that don't call  
....................                // TCPDisconnect() as needed and expect the TCP/IP  
....................                // Stack to automatically close sockets when the  
....................                // remote node sends a FIN, let's start a timer so  
....................                // that we will eventually close the socket automatically 
....................                MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8); 
066A2:  MOVLB  0
066A4:  CALL   2FD6
066A8:  MOVLW  0F
066AA:  MOVLB  4
066AC:  ADDWF  00,W
066AE:  MOVLB  1
066B0:  MOVWF  xF2
066B2:  MOVLW  00
066B4:  MOVLB  4
066B6:  ADDWFC 01,W
066B8:  MOVLB  1
066BA:  MOVWF  xF3
....................                break; 
066BC:  BRA    671E
....................     
....................             case TCP_FIN_WAIT_1: 
....................                if(MyTCB.MySEQ == localAckNumber) 
066BE:  MOVLB  4
066C0:  MOVF   x07,W
066C2:  MOVLB  1
066C4:  SUBWF  x7E,W
066C6:  BNZ   66FE
066C8:  MOVLB  4
066CA:  MOVF   x08,W
066CC:  MOVLB  1
066CE:  SUBWF  x7F,W
066D0:  BNZ   66FE
066D2:  MOVLB  4
066D4:  MOVF   x09,W
066D6:  MOVLB  1
066D8:  SUBWF  x80,W
066DA:  BNZ   66FE
066DC:  MOVLB  4
066DE:  MOVF   x0A,W
066E0:  MOVLB  1
066E2:  SUBWF  x81,W
066E4:  BNZ   66FE
....................                { 
....................                   // RFC not recommended: We should be going to  
....................                   // the TCP_TIME_WAIT state right here and  
....................                   // starting a 2MSL timer, but since we have so  
....................                   // few precious sockets, we can't afford to  
....................                   // leave a socket waiting around doing nothing  
....................                   // for a long time.  If the remote node does  
....................                   // not recieve this ACK, it'll have to figure  
....................                   // out on it's own that the connection is now  
....................                   // closed. 
....................                   SendTCP(ACK, 0); 
066E6:  MOVLW  10
066E8:  MOVLB  4
066EA:  MOVWF  x14
066EC:  CLRF   x15
066EE:  MOVLB  0
066F0:  CALL   3620
....................                   CloseSocket(); 
066F4:  CALL   112A
....................                   return; 
066F8:  BRA    672E
....................                } 
066FA:  BRA    6704
066FC:  MOVLB  1
....................                else 
....................                { 
....................                   MyTCBStub.smState = TCP_CLOSING; 
066FE:  MOVLW  0A
06700:  MOVWF  xF4
06702:  MOVLB  0
....................                } 
....................                break; 
06704:  MOVLB  1
06706:  BRA    671E
....................     
....................             case TCP_FIN_WAIT_2: 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                SendTCP(ACK, 0); 
06708:  MOVLW  10
0670A:  MOVLB  4
0670C:  MOVWF  x14
0670E:  CLRF   x15
06710:  MOVLB  0
06712:  CALL   3620
....................                CloseSocket(); 
06716:  CALL   112A
....................                return; 
0671A:  BRA    672E
....................  
....................             default: 
....................                break; 
0671C:  MOVLB  1
....................          } 
....................  
....................          // Acknowledge receipt of FIN 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
0671E:  MOVLW  10
06720:  MOVLB  4
06722:  MOVWF  x14
06724:  MOVLW  01
06726:  MOVWF  x15
06728:  MOVLB  0
0672A:  CALL   3620
0672E:  MOVLB  4
....................       } 
....................    } 
06730:  MOVLB  0
06732:  GOTO   68A8 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Buffer Management Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize,  
....................                      WORD wMinTXSize, BYTE vFlags) 
....................  
....................   Summary: 
....................    Adjusts the relative sizes of the RX and TX buffers. 
....................  
....................   Description: 
....................    This function can be used to adjust the relative sizes of the RX and 
....................    TX FIFO depending on the immediate needs of an application.  Since a  
....................    larger FIFO can allow more data to be sent in a given packet, adjusting  
....................    the relative sizes on the fly can allow for optimal transmission speed  
....................    for one-sided application protocols.  For example, HTTP typically  
....................    begins by receiving large amounts of data from the client, then switches 
....................    to serving large amounts of data back.  Adjusting the FIFO at these  
....................    points can increase performance substantially.  Once the FIFO is 
....................    adjusted, a window update is sent. 
....................     
....................    If neither or both of TCP_ADJUST_GIVE_REST_TO_TX and  
....................    TCP_ADJUST_GIVE_REST_TO_RX are set, the function distributes the 
....................    remaining space equally. 
....................     
....................    Received data can be preserved as long as the buffer is expanding and  
....................    has not wrapped. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - The socket to be adjusted 
....................    wMinRXSize   - Minimum number of byte for the RX FIFO 
....................    wMinTXSize    - Minimum number of bytes for the RX FIFO 
....................    vFlags      - Any combination of TCP_ADJUST_GIVE_REST_TO_RX,  
....................               TCP_ADJUST_GIVE_REST_TO_TX, TCP_ADJUST_PRESERVE_RX. 
....................               TCP_ADJUST_PRESERVE_TX is not currently supported. 
....................  
....................   Return Values: 
....................    TRUE - The FIFOs were adjusted successfully 
....................    FALSE - Minimum RX, Minimum TX, or flags couldn't be accommodated and 
....................          therefore the socket was left unchanged. 
....................  
....................   Side Effects: 
....................    Any unacknowledged or untransmitted data in the TX FIFO is always 
....................    deleted. 
....................  
....................   Remarks: 
....................    At least one byte must always be allocated to the RX buffer so that 
....................    a FIN can be received.  The function automatically corrects for this. 
....................   ***************************************************************************/ 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags) 
.................... { 
....................    PTR_BASE ptrTemp, ptrHead; 
....................    WORD wTXAllocation; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    // Load up info on this socket 
....................    SyncTCBStub(hTCP); 
....................  
....................    // RX has to be at least 1 byte to receive SYN and FIN bytes  
....................    // from the remote node, even if they aren't stored in the RX FIFO 
....................    if(wMinRXSize == 0u) 
....................       wMinRXSize = 1; 
....................        
....................    // SSL connections need to be able to send or receive at least  
....................    // a full Alert record, MAC, and FIN 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP) && wMinRXSize < 25u) 
....................       wMinRXSize = 25; 
....................    if(TCPIsSSL(hTCP) && wMinTXSize < 25u) 
....................       wMinTXSize = 25; 
....................    #endif 
....................     
....................    // Make sure space is available for minimums 
....................    ptrTemp = MyTCBStub.bufferEnd - MyTCBStub.bufferTxStart - 1; 
....................    if(wMinRXSize + wMinTXSize > ptrTemp) 
....................       return FALSE; 
....................  
....................    SyncTCB(); 
....................  
....................    // Set both allocation flags if none set 
....................    if(!(vFlags & (TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX))) 
....................       vFlags |= TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX; 
....................        
....................  
....................    // Allocate minimums 
....................    wTXAllocation = wMinTXSize; 
....................    ptrTemp -= wMinRXSize + wMinTXSize; 
....................  
....................    // Allocate extra 
....................    if(vFlags & TCP_ADJUST_GIVE_REST_TO_TX) 
....................    { 
....................       if(vFlags & TCP_ADJUST_GIVE_REST_TO_RX) 
....................       { 
....................          // Do a 50%/50% split with any odd byte always going to the RX FIFO 
....................          wTXAllocation += ptrTemp>>1; 
....................       } 
....................       else 
....................       { 
....................          wTXAllocation += ptrTemp; 
....................       } 
....................    } 
....................  
....................    // Calculate new bufferRxStart pointer 
....................    ptrTemp = MyTCBStub.bufferTxStart + wTXAllocation + 1; 
....................  
....................    // Find the head pointer to use 
....................    ptrHead = MyTCBStub.rxHead; 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       ptrHead = MyTCBStub.sslRxHead; 
....................    #endif 
....................     
....................    // If there's out-of-order data pending, adjust the head pointer to compensate 
....................    if(MyTCB.sHoleSize != -1) 
....................    { 
....................       ptrHead += MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................       if(ptrHead > MyTCBStub.bufferEnd) 
....................          ptrHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    } 
....................  
....................    // Determine if resizing will lose any RX data 
....................    if(MyTCBStub.rxTail < ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.rxTail) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................  
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else if(MyTCBStub.rxTail > ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.bufferRxStart) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................              
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       // No data to preserve, but we may need to move  
....................       // the pointers to stay in the RX space 
....................       MyTCBStub.rxTail = ptrTemp; 
....................       MyTCBStub.rxHead = ptrTemp; 
....................        
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslRxHead = ptrTemp; 
....................       #endif 
....................    } 
....................     
....................    // If we need to preserve data that wrapped in the ring, we must copy 
....................    if(ptrHead < MyTCBStub.rxTail && (vFlags & TCP_ADJUST_PRESERVE_RX)) 
....................    { 
....................       TCPRAMCopy(ptrTemp, MyTCBStub.vMemoryMedium,  
....................          MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, 
....................          ptrHead - MyTCBStub.bufferRxStart); 
....................  
....................       // Move the pointers if they were in front of the tail 
....................       #if defined(STACK_USE_SSL) 
....................       if(TCPIsSSL(hTCP) && MyTCBStub.sslRxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.sslRxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................       #endif 
....................       if(MyTCBStub.rxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.rxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................    } 
....................     
....................    // Move the RX buffer pointer - it's the one that divides the two 
....................    MyTCBStub.bufferRxStart = ptrTemp; 
....................  
....................    // Empty the TX buffer 
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       MyTCBStub.sslTxHead = MyTCBStub.txHead + 5; 
....................    #endif 
....................     
....................    // Send a window update to notify remote node of change 
....................    if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
....................  
....................    return TRUE; 
....................  
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource,  
....................                      BYTE vSourceType, WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM). 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    ptrDest      - Address to write to 
....................    vDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    ptrSource   - Address to copy from 
....................    vSourceType - Source medium (TCP_PIC_RAM, TCP_ETH_RAM, or TCP_SPI_RAM) 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer.  However, if they do  
....................    overlap there must be at least 4 bytes of non-overlap to ensure correct  
....................    results due to hardware DMA requirements. 
....................   ***************************************************************************/ 
.................... static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, BYTE vSourceType, WORD wLength) 
.................... { 
....................    #if defined(SPIRAM_CS_TRIS) 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................    #endif 
....................        
....................    switch(vSourceType) 
*
00F6C:  MOVLB  4
00F6E:  MOVF   x4A,W
00F70:  XORLW  01
00F72:  MOVLB  0
00F74:  BZ    0F7C
00F76:  XORLW  01
00F78:  BZ    0FEE
00F7A:  BRA    1050
....................    { 
....................       case TCP_PIC_RAM: 
....................          switch(vDestType) 
00F7C:  MOVLB  4
00F7E:  MOVF   x47,W
00F80:  XORLW  01
00F82:  MOVLB  0
00F84:  BZ    0F8C
00F86:  XORLW  01
00F88:  BZ    0FBE
00F8A:  BRA    0FEC
....................          { 
....................             case TCP_PIC_RAM: 
....................                memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength); 
00F8C:  MOVFF  446,FEA
00F90:  MOVFF  445,FE9
00F94:  MOVFF  449,FE2
00F98:  MOVFF  448,FE1
00F9C:  MOVFF  44C,02
00FA0:  MOVFF  44B,01
00FA4:  MOVF   01,F
00FA6:  BZ    0FAC
00FA8:  INCF   02,F
00FAA:  BRA    0FB0
00FAC:  MOVF   02,F
00FAE:  BZ    0FBC
00FB0:  MOVFF  FE6,FEE
00FB4:  DECFSZ 01,F
00FB6:  BRA    0FB0
00FB8:  DECFSZ 02,F
00FBA:  BRA    0FB0
....................                break; 
00FBC:  BRA    0FEC
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
00FBE:  MOVLB  4
00FC0:  INCFSZ x45,W
00FC2:  BRA    0FCA
00FC4:  INCFSZ x46,W
00FC6:  BRA    0FCA
00FC8:  BRA    0FD8
....................                   MACSetWritePtr(ptrDest); 
00FCA:  MOVFF  446,44E
00FCE:  MOVFF  445,44D
00FD2:  MOVLB  0
00FD4:  RCALL  0AF2
00FD6:  MOVLB  4
....................                MACPutArray((BYTE*)ptrSource, wLength); 
00FD8:  MOVFF  449,463
00FDC:  MOVFF  448,462
00FE0:  MOVFF  44C,465
00FE4:  MOVFF  44B,464
00FE8:  MOVLB  0
00FEA:  RCALL  0B62
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                SPIRAMPutArray(ptrDest, (BYTE*)ptrSource, wLength); 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
00FEC:  BRA    1050
....................     
....................       case TCP_ETH_RAM: 
....................          switch(vDestType) 
00FEE:  MOVLB  4
00FF0:  MOVF   x47,W
00FF2:  XORLW  01
00FF4:  MOVLB  0
00FF6:  BZ    0FFE
00FF8:  XORLW  01
00FFA:  BZ    102E
00FFC:  BRA    104E
....................          { 
....................             case TCP_PIC_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
00FFE:  MOVLB  4
01000:  INCFSZ x48,W
01002:  BRA    100A
01004:  INCFSZ x49,W
01006:  BRA    100A
01008:  BRA    1018
....................                   MACSetReadPtr(ptrSource); 
0100A:  MOVFF  449,44E
0100E:  MOVFF  448,44D
01012:  MOVLB  0
01014:  RCALL  0BA8
01016:  MOVLB  4
....................                MACGetArray((BYTE*)ptrDest, wLength); 
01018:  MOVFF  446,461
0101C:  MOVFF  445,460
01020:  MOVFF  44C,463
01024:  MOVFF  44B,462
01028:  MOVLB  0
0102A:  RCALL  0C14
....................                break; 
0102C:  BRA    104E
....................     
....................             case TCP_ETH_RAM: 
....................                MACMemCopyAsync(ptrDest, ptrSource, wLength); 
0102E:  MOVFF  446,44E
01032:  MOVFF  445,44D
01036:  MOVFF  449,450
0103A:  MOVFF  448,44F
0103E:  MOVFF  44C,452
01042:  MOVFF  44B,451
01046:  RCALL  0CB4
....................                while(!MACIsMemCopyDone()); 
01048:  RCALL  0F44
0104A:  MOVF   01,F
0104C:  BZ    1048
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
....................                   MACSetReadPtr(ptrSource); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   MACGetArray(vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
0104E:  BRA    1050
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          switch(vDestType) 
....................          { 
....................             case TCP_PIC_RAM: 
....................                SPIRAMGetArray(ptrSource, (BYTE*)ptrDest, wLength); 
....................                break; 
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
....................                   MACSetWritePtr(ptrDest); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   ptrSource += w; 
....................                   MACPutArray(vBuffer, w); 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................     
....................             case TCP_SPI_RAM: 
....................                // Copy all of the data over in chunks 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                       
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrSource += w; 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................          } 
....................          break; 
....................       #endif          
....................    } 
01050:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource,  
....................                         WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM).  This function is to be used when  
....................    copying from ROM. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    wDest      - Address to write to 
....................    wDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    wSource      - Address to copy from 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer. 
....................     
....................    This function is aliased to TCPRAMCopy on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength) 
.................... { 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................     
....................    switch(wDestType) 
....................    { 
....................       case TCP_PIC_RAM: 
....................          memcpypgm2ram((void*)(BYTE*)wDest, (ROM void*)wSource, wLength); 
....................          break; 
....................     
....................       case TCP_ETH_RAM: 
....................          if(wDest!=(PTR_BASE)-1) 
....................             MACSetWritePtr(wDest); 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             MACPutArray(vBuffer, w); 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             SPIRAMPutArray(wDest, vBuffer, w); 
....................             wDest += w; 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................       #endif 
....................    } 
.................... } 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    SSL Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    host      - Expected host name on certificate (currently ignored) 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, BYTE * buffer, BYTE suppDataType) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP         - TCP connection to secure 
....................    host         - Expected host name on certificate (currently ignored) 
....................    buffer         - Buffer for supplementary data return 
....................    suppDataType    - Type of supplementary data to copy 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, buffer, suppDataType); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Begins an SSL server session. 
....................  
....................   Description: 
....................    This function sets up an SSL server session when a new connection is 
....................    established on an SSL port. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................  
....................   Return Values: 
....................    TRUE      - an SSL connection was initiated 
....................    FALSE      - Insufficient SSL resources (stubs) were available 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return TRUE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Swap the localPort and localSSLPort 
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
....................    MyTCB.localPort.Val = MyTCB.localSSLPort.Val; 
....................    MyTCB.localSSLPort.Val = MyTCBStub.remoteHash.Val;    
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_NO_MESSAGE; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
....................  
....................   Summary: 
....................    Listens for SSL connection on a specific port. 
....................  
....................   Description: 
....................    This function adds an additional listening port to a TCP connection.   
....................    Connections made on this alternate port will be secured via SSL. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is listening. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    port      - SSL port to listen on 
....................  
....................   Return Values: 
....................    TRUE      - SSL port was added. 
....................    FALSE      - The socket was not a listening socket. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.smState != TCP_LISTEN) 
....................       return FALSE; 
....................     
....................    SyncTCB(); 
....................     
....................    MyTCB.localSSLPort.Val = port; 
....................    MyTCBStub.sslTxHead = port; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif // SSL Server 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
....................  
....................   Summary: 
....................    Requests an SSL message to be transmitted. 
....................  
....................   Description: 
....................    This function is called to request that a specific SSL message be 
....................    transmitted.  This message should only be called by the SSL module. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to use 
....................    msg         - One of the SSL_MESSAGE types to transmit. 
....................  
....................   Return Values: 
....................    TRUE      - The message was requested. 
....................    FALSE      - Another message is already pending transmission. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(msg == SSL_NO_MESSAGE || MyTCBStub.sslReqMessage == SSL_NO_MESSAGE) 
....................    { 
....................       MyTCBStub.sslReqMessage = msg; 
....................       return TRUE; 
....................    } 
....................     
....................    return FALSE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if an SSL session is still handshaking. 
....................  
....................   Description: 
....................    Call this function after calling TCPStartSSLClient until FALSE is 
....................    returned.  Then your application may continue with its normal data 
....................    transfer (which is now secured). 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - SSL handshake is still progressing 
....................    FALSE      - SSL handshake has completed 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    return MyTCBStub.Flags.bSSLHandshaking;    
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsSSL(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a TCP connection is secured with SSL. 
....................  
....................   Description: 
....................    Call this function to determine whether or not a TCP connection is  
....................    secured with SSL. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - Connection is secured via SSL 
....................    FALSE      - Connection is not secured 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    return TRUE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Clears the SSL handshake flag. 
....................  
....................   Description: 
....................    This function clears the flag indicating that an SSL handshake is 
....................    complete. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to set 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bSSLHandshaking = 0; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
....................  
....................   Summary: 
....................    Decrypts and MACs data arriving via SSL. 
....................  
....................   Description: 
....................    This function decrypts data in the TCP buffer and calculates the MAC over 
....................    the data.  All data is left in the exact same location in the TCP buffer. 
....................    It is called to help process incoming SSL records. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to decrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    len       - Number of bytes to crypt 
....................    inPlace      - TRUE to write back in place, FALSE to write at end of 
....................                currently visible data. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
.................... { 
....................    PTR_BASE wSrc, wDest, wBlockLen, wTemp; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    wSrc = MyTCBStub.rxTail; 
....................    wDest = wSrc; 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       wBlockLen = sizeof(buffer); 
....................       if(wBlockLen > len) // Don't do more than we should 
....................          wBlockLen = len; 
....................        
....................       // Read those bytes to a buffer 
....................       if(wSrc + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part read 
....................          wTemp = MyTCBStub.bufferEnd - wSrc + 1; 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wTemp); 
....................          TCPRAMCopy((PTR_BASE)buffer+wTemp, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wBlockLen - wTemp); 
....................          wSrc = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wBlockLen); 
....................          wSrc += wBlockLen; 
....................       } 
....................        
....................       // Decrypt and hash 
....................       ARCFOURCrypt(ctx, buffer, wBlockLen); 
....................       SSLMACAdd(buffer, wBlockLen); 
....................        
....................       // Write decrypted bytes back 
....................       if(wDest + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part write 
....................          wTemp = MyTCBStub.bufferEnd - wDest + 1; 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wTemp); 
....................          TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer+wTemp, TCP_PIC_RAM, wBlockLen - wTemp); 
....................          wDest = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wBlockLen); 
....................          wDest += wBlockLen; 
....................       } 
....................        
....................       // Update the length remaining 
....................       len -= wBlockLen; 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx,  
....................                            BYTE* MACSecret, WORD len) 
....................  
....................   Summary: 
....................    Encrypts and MACs data in place in the TCP TX buffer. 
....................  
....................   Description: 
....................    This function encrypts data in the TCP buffer while calcuating a MAC.   
....................    When encryption is finished, the MAC is appended to the buffer and  
....................    the record will be ready to transmit. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to encrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    MACSecret   - MAC encryption secret to use 
....................    len       - Number of bytes to crypt 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len) 
.................... { 
....................    PTR_BASE pos; 
....................    WORD blockLen; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    pos = MyTCBStub.txHead; 
....................    for(blockLen = 0; blockLen < 5u; blockLen++) 
....................    {// Skips first 5 bytes for the header 
....................       if(++pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       blockLen = sizeof(buffer); 
....................       if(blockLen > len) // Don't do more than we should 
....................          blockLen = len; 
....................       if(blockLen > MyTCBStub.bufferRxStart - pos) // Don't pass the end 
....................          blockLen = MyTCBStub.bufferRxStart - pos; 
....................        
....................       // Read those bytes to a buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, pos, MyTCBStub.vMemoryMedium, blockLen); 
....................        
....................       // Hash and encrypt 
....................       SSLMACAdd(buffer, blockLen); 
....................       ARCFOURCrypt(ctx, buffer, blockLen); 
....................        
....................       // Put them back 
....................       TCPRAMCopy(pos, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................        
....................       // Update the pointers 
....................       pos += blockLen; 
....................       len -= blockLen; 
....................       if(pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Calculate and add the MAC 
....................    SSLMACCalc(MACSecret, buffer); 
....................    ARCFOURCrypt(ctx, buffer, 16); 
....................  
....................    // Write the MAC to the TX FIFO 
....................    // Can't use TCPPutArray here because TCPIsPutReady() saves 16 bytes for the MAC 
....................    // TCPPut* functions use this to prevent writing too much data.  Therefore, the 
....................    // functionality is duplicated here. 
....................     
....................    len = 16; 
....................    blockLen = 0; 
....................    // See if we need a two part put 
....................    if(MyTCBStub.sslTxHead + len >= MyTCBStub.bufferRxStart) 
....................    { 
....................       blockLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................       len -= blockLen; 
....................       MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&buffer[blockLen], TCP_PIC_RAM, len); 
....................    MyTCBStub.sslTxHead += len; 
....................  
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
....................  
....................   Summary: 
....................    Writes an SSL record header and sends an SSL record. 
....................  
....................   Description: 
....................    This function writes an SSL record header to the pending TCP SSL data,  
....................    then indicates that the data is ready to be sent by moving the txHead 
....................    pointer. 
....................     
....................    If the record is complete, set recDone to TRUE.  The sslTxHead  
....................    pointer will be moved forward 5 bytes to leave space for a future  
....................    record header.  If the record is only partially sent, use FALSE and 
....................    to leave the pointer where it is so that more data can be added 
....................    to the record.  Partial records can only be used for the  
....................    SERVER_CERTIFICATE handshake message. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to write the header and transmit with 
....................    hdr         - Record header (5 bytes) to send or NULL to just  
....................               move the pointerctx 
....................    recDone      - TRUE if the record is done, FALSE otherwise 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................     
....................    // Write the header if needed 
....................    if(hdr) 
....................    {// This is a new record, so insert the header 
....................       for(i = 0; i < 5u; i++) 
....................       { 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)hdr+i, TCP_PIC_RAM, sizeof(BYTE)); 
....................          if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
....................     
....................    // Move the txHead pointer to indicate what data is ready 
....................    // Also, flush just the header, then all the data.  This shotguns two  
....................    // packets down the line, therefore causing immediate ACKs by the  
....................    // remote node.  Reconnect handshakes are as much as 60% faster now. 
....................    TCPFlush(hTCP); 
....................    MyTCBStub.txHead = MyTCBStub.sslTxHead; 
....................    TCPFlush(hTCP); 
....................     
....................    // If this record is done, move the sslTxHead forward 
....................    // to accomodate the next record header 
....................    if(recDone) 
....................    { 
....................       for(i = 0; i < 5u; i++) 
....................       {// Skip first 5 bytes in TX for the record header 
....................          if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes are pending for a future SSL record. 
....................  
....................   Description: 
....................    This function determines how many bytes are pending for a future SSL 
....................    record. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL connection. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Non-SSL connections have no pending SSL data 
....................    //if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................    //   return 0; 
....................           
....................    // Determine how many bytes are waiting to be written in this record 
....................    if(MyTCBStub.sslTxHead > MyTCBStub.txHead) 
....................       return MyTCBStub.sslTxHead - MyTCBStub.txHead - 5; 
....................    else 
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.sslTxHead - 1) - 5; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Hands newly arrive TCP data to the SSL module for processing. 
....................  
....................   Description: 
....................    This function processes incoming TCP data as an SSL record and  
....................    performs any necessary repositioning and decrypting. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to handle incoming data on 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
.................... { 
....................    PTR_BASE prevRxTail, nextRxHead, startRxTail, wSrc, wDest; 
....................    WORD wToMove, wLen, wSSLBytesThatPoofed, wDecryptedBytes; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Sync the stub 
....................    SyncTCBStub(hTCP); 
....................  
....................    // If new data is waiting 
....................    if(MyTCBStub.sslRxHead != MyTCBStub.rxHead) 
....................    { 
....................       // Reconfigure pointers for SSL use 
....................       prevRxTail = MyTCBStub.rxTail; 
....................       nextRxHead = MyTCBStub.rxHead; 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
....................       MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................        
....................       do 
....................       { 
....................          startRxTail = MyTCBStub.rxTail; 
....................  
....................          // Handle incoming data.  This function performs deframing of the  
....................          // SSL records, decryption, and MAC verification. 
....................          wSSLBytesThatPoofed = TCPIsGetReady(hTCP); 
....................          wDecryptedBytes = SSLRxRecord(hTCP, MyTCBStub.sslStubID); 
....................          wSSLBytesThatPoofed -= TCPIsGetReady(hTCP); 
....................  
....................          // Now need to move data to fill the SSL header/MAC/padding hole,  
....................          // if there is one 
....................          if(wSSLBytesThatPoofed) 
....................          {    
....................             // Sync the TCP so we can see if there is a TCP hole 
....................             SyncTCB(); 
....................  
....................             // Calculate how big the SSL hole is 
....................             if(MyTCB.sHoleSize == -1) 
....................             {// Just need to move pending SSL data 
....................                wToMove = TCPIsGetReady(hTCP); 
....................             } 
....................             else 
....................             {// A TCP hole exists, so move all data 
....................                wToMove = TCPIsGetReady(hTCP) + MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................             } 
....................              
....................             // Start with the destination as the startRxTail and source as current rxTail 
....................             wDest = startRxTail; 
....................             wSrc = MyTCBStub.rxTail; 
....................              
....................             // If data exists between the end of the buffer and  
....................             // the destination, then move it forward 
....................             if(wSrc > wDest) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wSrc + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest += wLen; 
....................                wSrc = MyTCBStub.bufferRxStart; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data remains to be moved, fill in to end of buffer 
....................             if(wToMove) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wDest + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest = MyTCBStub.bufferRxStart; 
....................                wSrc += wLen; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data still remains, copy from from front + len to front 
....................             if(wToMove) 
....................             { 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
....................                         wSrc, MyTCBStub.vMemoryMedium, wToMove); 
....................             } 
....................  
....................             // Since bytes poofed, we need to move the head pointers  
....................             // backwards by an equal amount. 
....................             MyTCBStub.rxHead -= wSSLBytesThatPoofed; 
....................             if(MyTCBStub.rxHead < MyTCBStub.bufferRxStart) 
....................                MyTCBStub.rxHead += MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................             MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          } 
....................              
....................          // Move tail pointer forward by the number of decrypted bytes ready  
....................          // for the application (but not poofed bytes) 
....................          MyTCBStub.rxTail = startRxTail + wDecryptedBytes; 
....................          if(MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
....................             MyTCBStub.rxTail -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................          nextRxHead += wDecryptedBytes; 
....................           
....................          // Loop until SSLRxRecord() runs out of data and stops doing  
....................          // anything 
....................       } while(wSSLBytesThatPoofed || (startRxTail != MyTCBStub.rxTail)); 
....................  
....................       // Restore TCP buffer pointers to point to the decrypted application data  
....................       // only 
....................       if(nextRxHead > MyTCBStub.bufferEnd) 
....................          nextRxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................       MyTCBStub.rxTail = prevRxTail; 
....................       MyTCBStub.rxHead = nextRxHead; 
....................    } 
.................... }    
.................... #endif 
....................  
....................  
.................... #endif //#if defined(STACK_USE_TCP) 
....................  
....................     
....................    void TCPTouch(TCP_SOCKET s) 
....................    { 
....................       SyncTCBStub(s); 
....................       if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       { 
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
....................          SyncTCB(); 
....................       } 
....................    } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "_DNS.c" //ccs had to rename this driver to not conflict an s7600 driver in the default include path - a bug in the compiler 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "MPFS.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Microchip File System (MPFS) File Access API 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides single API for accessing web pages and other files  
....................  *    from internal program memory or an external serial EEPROM memory 
....................  *    -Reference: AN833 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MPFS.c 
....................  * Dependencies:    SPIEEPROM 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01     Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     3/31/05      Changed MPFS_ENTRY and mpfs_Flags for C30 
....................  * Darren Rook/CCS      4/13/11     When using CCS and program memory,  
....................                                        MPFS_Start[] is not defined/extern'd. 
....................                                        Instead CCS will use #import. 
....................  * Darren Rook/CCS      4/13/11     typedefing MPFS as rom* is causing CCS 
....................                                        compiler problems.  So it was 
....................                                        typedef'd to __address__.  That means 
....................                                        places where it was dereferencing MPFS 
....................                                        was replaced with read_program_memory(). 
....................  * Darren Rook/CCS      4/13/11     MPFSFormat() not included if using program 
....................                                        memory. 
....................  * Darren Rook/CCS      4/13/11     Added MPFS_RETURN_OFFSET option. 
....................  * Darren Rook/CCS      4/13/11     MPFSPutEnd() added SPIFlashStopWrite(). 
....................  * Darren Rook/CCS      5/18/11     When using PCD, not using  
....................  *                                     ReadProgramMemory() algo because 
....................  *                                     CCS is using #import() and the  
....................  *                                     data gets aligned differently. 
.................... ********************************************************************/ 
.................... #ifndef __MPFS_C 
.................... #define __MPFS_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_MPFS) 
....................  
.................... #ifndef debug_mpfs 
....................    #define debug_mpfs(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) 
....................    #define debug_mpfs_putc(c) 
.................... #endif 
....................  
.................... // This file system supports short file names i.e. 8 + 3. 
.................... #define MAX_FILE_NAME_LEN   (12u) 
....................  
.................... #define MPFS_DATA          (0x00u) 
.................... #define MPFS_DELETED       (0x01u) 
.................... #define MPFS_DLE           (0x03u) 
.................... #define MPFS_ETX           (0x04u) 
....................  
.................... /* 
....................    If you want the entries in the MPFS .bin file to not have any offset, and 
....................    instead have MPFSOpen() return the entry with MPFS_Start start added to it, 
....................    then define MPFS_RETURN_OFFSET.  CCS added this option so that a universal 
....................    .bin could be created that would be portable to several different memory 
....................    types. 
....................     
....................    If you do not define this option, then you have to use the /r option with 
....................    the MPFS generator tool to add the offset in entry. 
.................... */ 
.................... #define MPFS_RETURN_OFFSET 
....................  
.................... /* 
....................  * MPFS Structure: 
....................  * 
....................  * MPFS_Start: 
....................  *      <MPFS_DATA><Address1><FileName1> 
....................  *      <MPFS_DATA><Address2><FileName2> 
....................  *      ... 
....................  *      <MPFS_ETX><Addressn><FileNamen> 
....................  * Address1: 
....................  *      <Data1>[<Data2>...<Datan>]<MPFS_ETX><MPFS_INVALID> 
....................  *      ... 
....................  * 
....................  * Note: If File data contains either MPFS_DLE or MPFS_ETX 
....................  *       extra MPFS_DLE is stuffed before that byte. 
....................  */ 
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) || defined(__PCD__) 
....................    /* __CCS__ __PCD__ change - when using program memory also pack it, i  
....................       am guessing their tool for putting image into const array in C/progmemory 
....................       also stores it unpacked */ 
....................  #if defined(__PCD__) //__PCH__ __PCD__ __CCS__ change 
....................    typedef struct __attribute__((__packed__)) _MPFS_ENTRY 
....................    { 
....................        BYTE Flag; 
....................        MPFS Address; 
....................        BYTE Name[MAX_FILE_NAME_LEN]; 
....................    } MPFS_ENTRY; 
....................    static DWORD ReadProgramMemory(DWORD address); 
....................  #else 
....................    typedef struct  _MPFS_ENTRY 
....................    { 
....................        BYTE Flag __attribute__((__packed__)); 
....................        MPFS Address __attribute__((__packed__)); 
....................        BYTE Name[MAX_FILE_NAME_LEN] __attribute__((__packed__)); 
....................    } MPFS_ENTRY; 
....................  #endif 
.................... #else   //Use program memory 
....................    typedef struct  _MPFS_ENTRY 
....................    { 
....................        BYTE Flag; 
....................        MPFS Address; 
....................        BYTE Name[MAX_FILE_NAME_LEN]; 
....................    } MPFS_ENTRY; 
....................    #if defined(__C30__) 
....................       static DWORD ReadProgramMemory(DWORD address); 
....................    #endif 
.................... #endif 
....................  
.................... static union 
.................... { 
....................     struct 
....................     { 
....................         unsigned char bNotAvailable : 1; 
....................     } bits; 
....................     BYTE Val; 
.................... } mpfsFlags; 
....................  
.................... BYTE mpfsOpenCount; 
....................  
.................... #if !defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH) 
....................    // An address where MPFS data starts in program memory. 
....................   #if !defined(__PCH__) && !defined(__PCD__) //ccs will use #import 
....................     extern ROM MPFS_ENTRY MPFS_Start[]; 
....................   #endif 
.................... #else 
....................    #define MPFS_Start     MPFS_RESERVE_BLOCK 
.................... #endif 
....................  
.................... MPFS _currentHandle; 
.................... MPFS _currentFile; 
.................... WORD _currentCount; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE, if MPFS Storage access is initialized and 
....................  *                          MPFS is ready to be used. 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL MPFSInit(void) 
.................... { 
....................    debug_mpfs(debug_mpfs_putc, "\r\nMPFSInit()"); 
....................     mpfsOpenCount = 0; 
....................     mpfsFlags.Val = 0; 
....................  
.................... #if defined(MPFS_USE_EEPROM) 
....................     // Initialize the EEPROM access routines. 
....................     XEEInit(); 
.................... #elif defined(MPFS_USE_SPI_FLASH) 
....................    // Initialize the SPI Flash access routines. 
....................    SPIFlashInit(); 
.................... #endif 
....................  
....................     return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSOpen(BYTE* file) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           file        - NULL terminated file name. 
....................  * 
....................  * Output:          A handle if file is found 
....................  *                  MPFS_INVALID if file is not found. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... MPFS MPFSOpen(BYTE* file) 
.................... { 
....................     MPFS_ENTRY entry; 
....................     MPFS FAT; 
....................     BYTE fileNameLen; 
....................      
....................     debug_mpfs(debug_mpfs_putc, "\r\nMPFSOpen() '%s' ", file); 
....................  
....................     if( mpfsFlags.bits.bNotAvailable ) 
*
07A88:  MOVLB  2
07A8A:  BTFSS  x07.0
07A8C:  BRA    7A98
....................     { 
....................         debug_mpfs(debug_mpfs_putc, "NOT AVAILABLE"); 
....................         return MPFS_NOT_AVAILABLE; 
07A8E:  CLRF   00
07A90:  CLRF   01
07A92:  CLRF   02
07A94:  CLRF   03
07A96:  BRA    7C02
....................     } 
....................  
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) 
....................     FAT = MPFS_Start; 
.................... #else 
....................     FAT = (MPFS)MPFS_Start; 
07A98:  MOVLB  4
07A9A:  CLRF   x00
07A9C:  MOVLW  01
07A9E:  MOVLB  3
07AA0:  MOVWF  xFF
07AA2:  MOVLW  66
07AA4:  MOVWF  xFE
07AA6:  MOVLW  E4
07AA8:  MOVWF  xFD
.................... #endif 
....................  
....................     // If string is empty, do not attempt to find it in FAT. 
....................     if ( *file == '\0' ) 
07AAA:  MOVFF  3EB,03
07AAE:  MOVFF  3EA,FE9
07AB2:  MOVFF  3EB,FEA
07AB6:  MOVF   FEF,F
07AB8:  BNZ   7AC8
....................         return MPFS_INVALID; 
07ABA:  SETF   00
07ABC:  SETF   01
07ABE:  SETF   02
07AC0:  SETF   03
07AC2:  MOVLB  2
07AC4:  BRA    7C02
07AC6:  MOVLB  3
....................  
....................     //debug_mpfs("p1='%s'0x%LX ", file, file); 
....................  
....................     file = (BYTE*)strupr((char*)file); 
07AC8:  MOVFF  3EB,407
07ACC:  MOVFF  3EA,406
07AD0:  MOVLB  0
07AD2:  BRA    7940
07AD4:  MOVFF  02,3EB
07AD8:  MOVFF  01,3EA
....................      
....................     //debug_mpfs("p2='%s'0x%LX ", file, file); 
....................  
....................     debug_mpfs(debug_mpfs_putc, "START=0x%LX ", FAT); 
....................  
....................     for(;;) 
....................     { 
....................         // Bring current FAT entry into RAM. 
....................       #if defined(MPFS_USE_EEPROM) 
....................            XEEReadArray(FAT, (unsigned char*)&entry, sizeof(entry)); 
....................       #elif defined(MPFS_USE_SPI_FLASH) 
....................            SPIFlashReadArray(FAT, (BYTE*)&entry, sizeof(entry)); 
....................       #else 
....................          #if defined(__C30__) 
....................               memcpypgm2ram(&entry, (ROM void*)(WORD)FAT, sizeof(entry)); 
....................          #else 
....................               memcpypgm2ram(&entry, (ROM void*)FAT, sizeof(entry)); 
07ADC:  MOVLW  03
07ADE:  MOVLB  4
07AE0:  MOVWF  x07
07AE2:  MOVLW  EC
07AE4:  MOVWF  x06
07AE6:  MOVFF  400,40B
07AEA:  MOVFF  3FF,40A
07AEE:  MOVFF  3FE,409
07AF2:  MOVFF  3FD,408
07AF6:  CLRF   x0D
07AF8:  MOVLW  11
07AFA:  MOVWF  x0C
07AFC:  MOVLB  0
07AFE:  RCALL  79D2
....................          #endif 
....................       #endif 
....................  
....................        debug_mpfs(debug_mpfs_putc, "FLAG=0x%X ", entry.Flag); 
....................  
....................         // Make sure that it is a valid entry. 
....................         if (entry.Flag == MPFS_DATA) 
07B00:  MOVLB  3
07B02:  MOVF   xEC,F
07B04:  BNZ   7B96
....................         { 
....................             // Does the file name match ? 
....................             fileNameLen = strlen((char*)file); 
07B06:  MOVFF  3EB,407
07B0A:  MOVFF  3EA,406
07B0E:  MOVLB  0
07B10:  RCALL  75AE
07B12:  MOVFF  01,401
....................              
....................             if ( fileNameLen > MAX_FILE_NAME_LEN ) 
07B16:  MOVLB  4
07B18:  MOVF   x01,W
07B1A:  SUBLW  0C
07B1C:  BC    7B22
....................                 fileNameLen = MAX_FILE_NAME_LEN; 
07B1E:  MOVLW  0C
07B20:  MOVWF  x01
....................  
....................             //debug_mpfs("f='%s' (%u) vs '%s' ", entry.Name, fileNameLen, file); 
....................  
....................             if( memcmp((void*)file, (void*)entry.Name, fileNameLen) == 0 ) 
07B22:  MOVLW  03
07B24:  MOVWF  x07
07B26:  MOVLW  F1
07B28:  MOVWF  x06
07B2A:  MOVFF  3EB,409
07B2E:  MOVFF  3EA,408
07B32:  MOVFF  407,40B
07B36:  MOVWF  x0A
07B38:  CLRF   x0D
07B3A:  MOVFF  401,40C
07B3E:  MOVLB  0
07B40:  BRA    79F8
07B42:  MOVF   01,F
07B44:  BNZ   7B82
....................             { 
....................              #if defined(__PCD__) 
....................                #warning 4.121 temporary bug fix 
....................                memcpy(&_currentFile, &entry.Address, 4); 
....................               #if defined(MPFS_RETURN_OFFSET) 
....................                 _currentFile += MPFS_Start; 
....................               #endif 
....................                 mpfsOpenCount++; 
....................                 debug_mpfs(debug_mpfs_putc, "found_0x%LX ", _currentFile); 
....................                 return _currentFile; 
....................              #else 
....................               #if defined(MPFS_RETURN_OFFSET) 
....................                 entry.Address += MPFS_Start; 
07B46:  MOVLW  E4
07B48:  MOVLB  3
07B4A:  ADDWF  xED,F
07B4C:  MOVLW  66
07B4E:  ADDWFC xEE,F
07B50:  MOVLW  01
07B52:  ADDWFC xEF,F
07B54:  MOVLW  00
07B56:  ADDWFC xF0,F
....................               #endif 
....................                 _currentFile = (MPFS)entry.Address; 
07B58:  MOVFF  3F0,20B
07B5C:  MOVFF  3EF,20A
07B60:  MOVFF  3EE,209
07B64:  MOVFF  3ED,208
....................                 mpfsOpenCount++; 
07B68:  MOVLB  0
07B6A:  INCF   xFC,F
....................                 debug_mpfs(debug_mpfs_putc, "found_0x%LX ", _currentFile); 
....................                 return entry.Address; 
07B6C:  MOVFF  3ED,00
07B70:  MOVFF  3EE,01
07B74:  MOVFF  3EF,02
07B78:  MOVFF  3F0,03
07B7C:  MOVLB  2
07B7E:  BRA    7C02
07B80:  MOVLB  0
....................              #endif 
....................             } 
....................  
....................             // File does not match.  Try next entry... 
....................             FAT += sizeof(entry); 
07B82:  MOVLW  11
07B84:  MOVLB  3
07B86:  ADDWF  xFD,F
07B88:  MOVLW  00
07B8A:  ADDWFC xFE,F
07B8C:  ADDWFC xFF,F
07B8E:  MOVLB  4
07B90:  ADDWFC x00,F
....................         } 
07B92:  BRA    7BF2
07B94:  MOVLB  3
....................         else if ( entry.Flag == MPFS_ETX ) 
07B96:  MOVF   xEC,W
07B98:  SUBLW  04
07B9A:  BNZ   7BE4
....................         { 
....................             #warning 4.121 temporary bug fix 
....................             unsigned int32 entry_Address; 
....................             memcpy(&entry_Address, &entry.Address, 4); 
07B9C:  MOVLW  04
07B9E:  MOVWF  FEA
07BA0:  MOVLW  02
07BA2:  MOVWF  FE9
07BA4:  MOVLW  03
07BA6:  MOVWF  FE2
07BA8:  MOVLW  ED
07BAA:  MOVWF  FE1
07BAC:  MOVLW  04
07BAE:  MOVWF  01
07BB0:  MOVFF  FE6,FEE
07BB4:  DECFSZ 01,F
07BB6:  BRA    7BB0
....................             if ( entry_Address != (MPFS)MPFS_INVALID ) 
07BB8:  MOVLB  4
07BBA:  INCFSZ x02,W
07BBC:  BRA    7BCC
07BBE:  INCFSZ x03,W
07BC0:  BRA    7BCC
07BC2:  INCFSZ x04,W
07BC4:  BRA    7BCC
07BC6:  INCFSZ x05,W
07BC8:  BRA    7BCC
07BCA:  BRA    7BDE
....................             { 
....................                 FAT = (MPFS)entry_Address; //original, doesn't work 4.121 pcd 
07BCC:  MOVFF  405,400
07BD0:  MOVFF  404,3FF
07BD4:  MOVFF  403,3FE
07BD8:  MOVFF  402,3FD
....................                 debug_mpfs(debug_mpfs_putc, "(etx 0x%LX) ", FAT); 
....................             } 
07BDC:  BRA    7BE0
....................             else 
....................             { 
....................                 debug_mpfs(debug_mpfs_putc, "invalid_etx "); 
....................                 break; 
07BDE:  BRA    7BF8
....................             } 
....................         } 
07BE0:  BRA    7BF2
07BE2:  MOVLB  3
....................        else 
....................        { 
....................            debug_mpfs(debug_mpfs_putc, "invalid_flag "); 
....................            return (MPFS)MPFS_INVALID; 
07BE4:  SETF   00
07BE6:  SETF   01
07BE8:  SETF   02
07BEA:  SETF   03
07BEC:  MOVLB  2
07BEE:  BRA    7C02
07BF0:  MOVLB  4
....................        } 
07BF2:  MOVLB  0
07BF4:  BRA    7ADC
07BF6:  MOVLB  4
....................     } 
....................     debug_mpfs(debug_mpfs_putc, "not_found "); 
....................     return (MPFS)MPFS_INVALID; 
07BF8:  SETF   00
07BFA:  SETF   01
07BFC:  SETF   02
07BFE:  SETF   03
07C00:  MOVLB  2
07C02:  MOVLB  0
07C04:  RETURN 0
.................... } 
....................  
.................... MPFS MPFSOpenROM(ROM BYTE* file)  
.................... { 
....................    BYTE nameRAM[MAX_FILE_NAME_LEN+1]; 
....................     
....................    memcpypgm2ram(nameRAM, (ROM void*)file, strlenpgm((ROM char*)file)); 
....................    nameRAM[strlenpgm((ROM char*)file)] = '\0'; 
....................     
....................    return MPFSOpen(nameRAM); 
.................... }    
....................  
.................... /********************************************************************* 
....................  * Function:        void MPFSClose(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           handle      - File handle to be closed 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void MPFSClose(void) 
.................... { 
....................     debug_mpfs(debug_mpfs_putc, "\r\nMPFSClose()"); 
....................     _currentCount = 0; 
*
0792E:  MOVLB  2
07930:  CLRF   x0D
07932:  CLRF   x0C
....................     mpfsFlags.bits.bNotAvailable = FALSE; 
07934:  BCF    x07.0
....................     if ( mpfsOpenCount ) 
07936:  MOVLB  0
07938:  MOVF   xFC,F
0793A:  BZ    793E
....................         mpfsOpenCount--; 
0793C:  DECF   xFC,F
0793E:  RETURN 0
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSGetBegin(MPFS hFile) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  * 
....................  * Input:           hFile      - handle of file that is to be read 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS storage media for subsequent reads. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
.................... BOOL MPFSGetBegin(MPFS hFile) 
.................... { 
....................     _currentHandle = hFile; 
....................     return (XEEBeginRead(hFile) == XEE_SUCCESS); 
.................... } 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE MPFSGet(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  *                  MPFSGetBegin() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Data byte from current address. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Reads a byte from current address. 
....................  * 
....................  * Note:            Caller must call MPFSIsEOF() to check for end of 
....................  *                  file condition 
....................  ********************************************************************/ 
.................... BYTE MPFSGet(void) 
.................... { 
....................     BYTE t; 
....................      
....................    #if defined(MPFS_USE_EEPROM) 
....................       t = XEERead(); 
....................       _currentHandle++; 
....................    #elif defined(MPFS_USE_SPI_FLASH) 
....................       //SPIFlashReadArray(_currentHandle++, (BYTE*)&t, 1);  //orig 
....................       SPIFlashReadArray(_currentHandle, (BYTE*)&t, 1);   //ccs workaround 
....................       _currentHandle++; //ccs workaround 
....................    #else 
....................       #if defined(__C30__) && !defined(__PCD__) //__CCS__ change 
....................          { 
....................             DWORD_VAL i; 
....................     
....................             // The uppermost byte, ((DWORD_VAL*)&_currentHandle)->v[3]), is the byte lane to read from. 
....................             // 16 bit PICs have a 24 bit wide Flash program word.  Bytes 0-2 are the actual address, but  
....................             // odd addresses aren't implemented. 
....................             i.Val = ReadProgramMemory(_currentHandle & 0x00FFFFFF); 
....................             t = i.v[((DWORD_VAL*)&_currentHandle)->v[3]++]; 
....................             if(((DWORD_VAL*)&_currentHandle)->v[3] >= 3) 
....................             { 
....................                _currentHandle = (_currentHandle + 2) & 0x00FFFFFF; 
....................             } 
....................          } 
....................       #else 
....................           //t = (BYTE)*_currentHandle; //__ccs__ change because MPFS isn't rom pointer 
....................           memcpypgm2ram(&t, _currentHandle, 1); //__ccs__ change because MPFS isn't rom pointer 
*
088BA:  MOVLW  03
088BC:  MOVLB  4
088BE:  MOVWF  x07
088C0:  MOVLW  F7
088C2:  MOVWF  x06
088C4:  MOVFF  100,40B
088C8:  MOVFF  FF,40A
088CC:  MOVFF  FE,409
088D0:  MOVFF  FD,408
088D4:  CLRF   x0D
088D6:  MOVLW  01
088D8:  MOVWF  x0C
088DA:  MOVLB  0
088DC:  CALL   79D2
....................           _currentHandle++; 
088E0:  MOVLW  01
088E2:  ADDWF  xFD,F
088E4:  BTFSC  FD8.0
088E6:  INCF   xFE,F
088E8:  BTFSC  FD8.2
088EA:  INCF   xFF,F
088EC:  BTFSS  FD8.2
088EE:  BRA    88F6
088F0:  MOVLB  1
088F2:  INCF   x00,F
088F4:  MOVLB  0
....................       #endif 
....................    #endif 
....................  
....................     if(t == MPFS_DLE) 
088F6:  MOVLB  3
088F8:  MOVF   xF7,W
088FA:  SUBLW  03
088FC:  BNZ   893E
....................     { 
....................       #if defined(MPFS_USE_EEPROM) 
....................           t = XEERead(); 
....................           _currentHandle++; 
....................       #elif defined(MPFS_USE_SPI_FLASH) 
....................          //SPIFlashReadArray(_currentHandle++, (BYTE*)&t, 1); //orig 
....................          SPIFlashReadArray(_currentHandle, (BYTE*)&t, 1);   //ccs workaround 
....................          _currentHandle++; //ccs workaround 
....................       #else 
....................          #if defined(__C30__) && !defined(__PCD__) //__CCS__ change 
....................             { 
....................                DWORD_VAL i; 
....................        
....................             // The uppermost byte, ((DWORD_VAL*)&_currentHandle)->v[3]), is the byte lane to read from. 
....................             // 16 bit PICs have a 24 bit wide Flash program word.  Bytes 0-2 are the actual address, but  
....................             // odd addresses aren't implemented. 
....................             i.Val = ReadProgramMemory(_currentHandle & 0x00FFFFFF); 
....................             t = i.v[((DWORD_VAL*)&_currentHandle)->v[3]++]; 
....................             if(((DWORD_VAL*)&_currentHandle)->v[3] >= 3) 
....................             { 
....................                _currentHandle = (_currentHandle + 2) & 0x00FFFFFF; 
....................             } 
....................             } 
....................          #else 
....................              //t = (BYTE)*_currentHandle; //__ccs__ change because MPFS isn't rom pointer 
....................              memcpypgm2ram(&t, _currentHandle, 1); //__ccs__ change because MPFS isn't rom pointer 
088FE:  MOVLW  03
08900:  MOVLB  4
08902:  MOVWF  x07
08904:  MOVLW  F7
08906:  MOVWF  x06
08908:  MOVFF  100,40B
0890C:  MOVFF  FF,40A
08910:  MOVFF  FE,409
08914:  MOVFF  FD,408
08918:  CLRF   x0D
0891A:  MOVLW  01
0891C:  MOVWF  x0C
0891E:  MOVLB  0
08920:  CALL   79D2
....................              _currentHandle++; 
08924:  MOVLW  01
08926:  ADDWF  xFD,F
08928:  BTFSC  FD8.0
0892A:  INCF   xFE,F
0892C:  BTFSC  FD8.2
0892E:  INCF   xFF,F
08930:  BTFSS  FD8.2
08932:  BRA    893A
08934:  MOVLB  1
08936:  INCF   x00,F
08938:  MOVLB  0
....................          #endif 
....................       #endif 
....................     } 
0893A:  BRA    8950
0893C:  MOVLB  3
....................     else if(t == MPFS_ETX) 
0893E:  MOVF   xF7,W
08940:  SUBLW  04
08942:  BNZ   8952
....................     { 
....................         _currentHandle = MPFS_INVALID; 
08944:  MOVLB  1
08946:  SETF   x00
08948:  MOVLB  0
0894A:  SETF   xFF
0894C:  SETF   xFE
0894E:  SETF   xFD
08950:  MOVLB  3
....................     } 
....................  
....................    //printf(UserPutc, " ret=%X\r\n", t); 
....................     return t; 
08952:  MOVFF  3F7,01
08956:  MOVLB  0
08958:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(__C30__) && !defined(MPFS_USE_EEPROM) 
.................... /********************************************************************* 
....................  * Function:        static DWORD ReadProgramMemory(DWORD address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Program memory address to read from.  Should be  
....................  *               an even number. 
....................  * 
....................  * Output:          Program word at the specified address.  For the  
....................  *               PIC24, dsPIC, etc. which have a 24 bit program  
....................  *               word size, the upper byte is 0x00. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Modifies and restores TBLPAG.  Make sure that if  
....................  *               using interrupts and the PSV feature of the CPU  
....................  *               in an ISR that the TBLPAG register is preloaded  
....................  *               with the correct value (rather than assuming  
....................  *               TBLPAG is always pointing to the .const section. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static DWORD ReadProgramMemory(DWORD address)  
.................... { 
....................    DWORD dwResult; 
....................    WORD wTBLPAGSave; 
....................  
....................    wTBLPAGSave = TBLPAG; 
....................    TBLPAG = ((WORD*)&address)[1]; 
....................    ((WORD*)&dwResult)[1] = __builtin_tblrdh((WORD)address); 
....................    ((WORD*)&dwResult)[0] = __builtin_tblrdl((WORD)address); 
....................    TBLPAG = wTBLPAGSave; 
....................  
.................... //printf("[0x%LX=%LX] ", address, dwResult); 
....................  
....................    return dwResult; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSGetEnd(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  *                  MPFSGetBegin() = TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current mpfs handle. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Ends on-going read cycle. 
....................  *                  MPFS handle that is returned must be used 
....................  *                  for subsequent begin gets.. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
.................... MPFS MPFSGetEnd(void) 
.................... { 
....................     XEEEndRead(); 
....................     return _currentHandle; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSFormat(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A valid MPFS handle that can be used for MPFSPut 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS image to get re-written 
....................  *                  Declares MPFS as in use. 
....................  * 
....................  * Note:            MPFS will be unaccessible until MPFSClose is 
....................  *                  called. 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) //ccs added this condition 
.................... MPFS MPFSFormat(void) 
.................... { 
....................    debug_mpfs(debug_mpfs_putc, "\r\nMPFSFormat() "); 
....................     mpfsFlags.bits.bNotAvailable = TRUE; 
....................    #if defined(MPFS_USE_SPI_FLASH) 
....................       SPIFlashBeginWrite(MPFS_RESERVE_BLOCK); 
....................    #endif 
....................     return (MPFS)MPFS_RESERVE_BLOCK; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSPutBegin(MPFS handle) 
....................  * 
....................  * PreCondition:    MPFSInit() and MPFSFormat() are already called. 
....................  * 
....................  * Input:           handle  - handle to where put to begin 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS image to get re-written 
....................  * 
....................  * Note:            MPFS will be unaccessible until MPFSClose is 
....................  *                  called. 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
.................... BOOL MPFSPutBegin(MPFS handle) 
.................... { 
....................     //_currentCount = 0; 
....................     _currentHandle = handle; 
....................     _currentCount = (BYTE)handle; 
....................     _currentCount &= (MPFS_WRITE_PAGE_SIZE-1); 
....................     return (XEEBeginWrite(handle) == XEE_SUCCESS); 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSPut(BYTE b) 
....................  * 
....................  * PreCondition:    MPFSFormat() or MPFSCreate() must be called 
....................  *                  MPFSPutBegin() is already called. 
....................  * 
....................  * Input:           b       - data to write. 
....................  * 
....................  * Output:          TRUE if successfull 
....................  *                  !TRUE if failed. 
....................  * 
....................  * Side Effects:    Original MPFS handle is no longer valid. 
....................  *                  Updated MPFS handle must be obtained by calling 
....................  *                  MPFSPutEnd(). 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Actual write may not get started until internal 
....................  *                  write page is full.  To ensure that previously 
....................  *                  data gets written, caller must call MPFSPutEnd() 
....................  *                  after last call to MPFSPut(). 
....................  ********************************************************************/ 
.................... BOOL MPFSPut(BYTE b) 
.................... { 
.................... #if defined(MPFS_USE_EEPROM) 
....................     if ( XEEWrite(b) ) 
....................         return FALSE; 
....................  
....................     _currentCount++; 
....................     _currentHandle++; 
....................     if ( _currentCount >= MPFS_WRITE_PAGE_SIZE ) 
....................     { 
....................         MPFSPutEnd(); 
....................         XEEBeginWrite(_currentHandle); 
....................     } 
.................... #elif defined(MPFS_USE_SPI_FLASH) 
....................    SPIFlashWrite(b); 
.................... #endif 
....................     return TRUE; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSPutEnd(void) 
....................  * 
....................  * PreCondition:    MPFSPutBegin() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Up-to-date MPFS handle 
....................  * 
....................  * Side Effects:    Original MPFS handle is no longer valid. 
....................  *                  Updated MPFS handle must be obtained by calling 
....................  *                  MPFSPutEnd(). 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Actual write may not get started until internal 
....................  *                  write page is full.  To ensure that previously 
....................  *                  data gets written, caller must call MPFSPutEnd() 
....................  *                  after last call to MPFSPut(). 
....................  ********************************************************************/ 
.................... MPFS MPFSPutEnd(void) 
.................... { 
....................    debug_mpfs(debug_mpfs_putc, "\r\nMPFSPutEnd() "); 
.................... #if defined(MPFS_USE_EEPROM) 
....................     _currentCount = 0; 
....................     XEEEndWrite(); 
....................     while(XEEIsBusy()); 
.................... #elif defined(MPFS_USE_SPI_FLASH) 
....................    SPIFlashStopWrite(); 
.................... #endif 
....................     return _currentHandle; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSSeek(MPFS offset) 
....................  * 
....................  * PreCondition:    MPFSGetBegin() is already called. 
....................  * 
....................  * Input:           offset      - Offset from current pointer 
....................  * 
....................  * Output:          New MPFS handle located to given offset 
....................  * 
....................  * Side Effects:    None. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None. 
....................  ********************************************************************/ 
.................... MPFS MPFSSeek(MPFS offset) 
.................... { 
....................     MPFS i; 
....................  
....................     MPFSGetBegin(_currentFile); 
....................  
....................     i = (MPFS)0; 
....................     while(i++ != offset) 
....................         MPFSGet(); 
....................  
....................     MPFSGetEnd(); 
....................  
....................     return _currentHandle; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSGetLong(DWORD *ul) 
....................  * 
....................  * PreCondition:    MPFSOpen() and MPFSBeginGet() 
....................  * 
....................  * Input:           ul: pointer to an DWORD to read 
....................  * 
....................  * Output:          TRUE on success 
....................  *               FALSE on EOF 
....................  *  
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Reads an DWORD value from an MPFS file 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL MPFSGetLong(DWORD *ul) 
.................... { 
....................    BYTE* b = (BYTE*)ul; 
....................    *(b) = MPFSGet();    
....................    if(MPFSIsEOF()) 
....................       return FALSE; 
....................    *(b+1) = MPFSGet();    
....................    *(b+2) = MPFSGet();    
....................    *(b+3) = MPFSGet();    
....................  
....................    return TRUE; 
.................... } 
....................  
.................... #endif //#if defined(STACK_USE_MPFS) 
.................... #endif //__MPFS_C 
....................  
.................... #endif 
....................  
.................... #if (defined(STACK_USE_HTTP2) || defined(STACK_USE_HTTP2_SERVER)) && !defined(__HTTP2_C) 
....................     #include "HTTP2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP) || defined(STACK_USE_HTTP_SERVER) 
....................     #include "HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.c" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///                              HTTP2.C 
.................... /// 
.................... /// Simple webserver for the Microchip TCP/IP stack. Using web pages 
.................... /// stored on a MultiMediaCard. 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES 
.................... /// 
.................... /// **** CONFIGURATION **** 
.................... /// 
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c 
.................... ///        in your application.  Defining this to be true will cause 
.................... ///        the stack to include the HTTP portion and execute the init 
.................... ///        and process any HTTP tasks. 
.................... /// 
.................... /// 
.................... /// STACK_USE_HTTP2 - Same as STACK_USE_HTTP except this will cause 
.................... ///         web pages to be loaded from files stored on the MMC, not 
.................... ///        stored in program memory. 
.................... /// 
.................... /// HTTP_USE_AUTHENTICATION - If set to TRUE (default is FALSE), you can 
.................... ///      have some websites password protected.  In your file system (FAT 
.................... ///      or MPFS) create a new file at the root called 'htaccess.txt'.  The 
.................... ///      format of this file should be as follows: 
.................... ///         user|password|file1|file2|file3 
.................... ///      You can password protect entire directories (if your file system  
.................... ///      provides directory support).  To password protect the entire file 
.................... ///      system then use / as your filename.  Even though you can provide a 
.................... ///      user name and password into htaccess.txt file, the HTTP stack will also 
.................... ///      call http_check_authentication() to verify the username and password. 
.................... ///      It will check both locations, and if the username/password from the 
.................... ///      file matches the user input, or http_check_authentication() returns 
.................... ///      TRUE then authentication is granted.  The reason it checks both is in 
.................... ///      case you want ot password protect a file in the field without having 
.................... ///      to re-program the firmware, you just have to modify htaccess.txt to 
.................... ///      add authentication.  If you want to have the HTTP stack ignore the 
.................... ///      username/password from htaccess.txt then leave those fields blank. 
.................... /// 
.................... ///      If authentication fails the webserver will display the error401.htm 
.................... ///      page. 
.................... /// 
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP 
.................... ///        connections. 
.................... /// 
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the 
.................... ///        HTTP server.  You probably will be fine with just 1.  The 
.................... ///        more sockets you use the more RAM is used to hold buffers 
.................... ///        and state configuration. 
.................... /// 
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several 
.................... ///        buffers.  This limits the size of your GET or POST requests 
.................... ///        and all CGI POST data: 
.................... ///            If using GET, then max amount of cgi data is this value 
.................... ///            minus everything else on the initial GET command (which 
.................... ///            also includes the filename).  I believe the max specified 
.................... ///            by W3C is 255. 
.................... ///            If using POST, then this is the maximum size for one 
.................... ///            key=value pair (including the '=' sign). 
.................... ///        These values do not inlude any escape characters. 
.................... /// 
.................... /// HTTP_ESCAPED_STR_SIZE - Size allocated, per socket, for http_format_char() 
.................... ///         results. 
.................... /// 
.................... /// 
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape 
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have 
.................... ///      two escape characters after the %.  An example of each: 
.................... ///         If FALSE: %A 
.................... ///         If TRUE: %0A 
.................... /// 
.................... /// 
.................... /// **** HOW IT WORKS **** 
.................... /// 
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will 
.................... /// then listen for GET or POST requests.  When it gets a GET or POST 
.................... /// request it passes the page request to the callback function 
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or 
.................... /// a pointer to the constant memory area that holds the page in program 
.................... /// memory.  If it was a POST request it waits until the HTTP header is 
.................... /// done and then saves the POST data into a buffer, and passes the 
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will 
.................... /// parse the CGI post data and act upon it.  When done, the HTTP 
.................... /// server then responds by sending the page.  If the page is to have 
.................... /// variable data, it can be represented by an escape code - %0 or %1 
.................... /// for example.  When the HTTP stack sees such an escape code it calls 
.................... /// the callback function http_format_char() to format the escape code 
.................... /// into the needed variable data (such as ADC readings).  After the 
.................... /// HTTP stack is done sending the request it will close the port. 
.................... /// If the page didn't exist it will send a 404 File 
.................... /// not found error.  If there was a problem/timeout parsing the request 
.................... /// the HTTP stack will send a 500 Internal Server Error response. 
.................... /// 
.................... /// **** CALL BACK FUNCTIONS **** 
.................... /// 
.................... /// Your main application must provide the following callback functions to 
.................... /// fill application dependent needs: 
.................... /// 
.................... /// http_exec_cgi(char* file, char *key, char *val); 
.................... ///    A call-back function provided by your application that processes incoming 
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is 
.................... ///    the file name. 
.................... /// 
.................... /// int http_format_char(char* file, char id, char *str, int8 max_ret); 
.................... ///    Given an escaped character in the HTML file, convert to 
.................... ///    variable data.  id is the escaped character, *str is where to save the 
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str. 
.................... ///    Returns the number of bytes written to *str.  file is 
.................... ///    the file name. 
.................... /// 
.................... /// int1 http_check_authentication(char *fileName, char *user, char *pwd); 
.................... ///   If someone has tried to access a password protected file, the http server 
.................... ///   will call this function so the application can determine if the user has 
.................... ///   access.  fileName is the requested file, user is the username the user 
.................... ///   entered, and pwd is the password the user entered.  The function should 
.................... ///   return TRUE if access is granted, FALSE if not.  This function is only 
.................... ///   needed if HTTP_USE_AUTHENTICATION is defined as TRUE. 
.................... /// 
.................... /// **** LIMITATIONS **** 
.................... /// 
.................... /// When creating web pages with forms, keep your form names (keys) simple 
.................... /// because the HTTP stack does not format the escape characters.  For example, 
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord". 
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving 
.................... /// the value, but not the key.  Therefore keep your keys simple. 
.................... /// 
.................... /// 
.................... /// **** FILE SUPPORT *** 
.................... /// Two file systems are supported--FAT on an MMC and Microchip's MPFS on the 
.................... /// external eeprom chip. 
.................... ///  
.................... /// Three files must be supplied on the MMC or MPFS image.  Error404.htm will 
.................... /// be called when the file requested in the URL does not exist.Error500.htm will 
.................... /// be called on an internal server error or timeout.  Internet Exploder requires 
.................... /// that custom error pages be greater than 512 bytes in length or the browser 
.................... /// will insert its own error page in its place.  Index.htm will be called 
.................... /// when no file is explicitly specified in the URL. Other files may be included 
.................... /// on the mmc or MPFS image.  File types that are supported are .htm, .html, 
.................... /// .xml, .txt, .jpg, .png, and .gif. Filenames should be in DOS 8.3 format.  
.................... /// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// * Author         Date           Comment 
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... /// 
.................... /// * Darren Rook    Apr 12 2007    Added HTTP_USE_AUTHENTICATION. 
.................... ///                                 If file system is missing, will display a 
.................... ///                                 500 error file from memory. 
.................... ///                                 If client gets root (/) and index.htm is 
.................... ///                                 missing, show 404 page. 
.................... ///                                 Fixed bug in TCPPutFileParseConst() where 
.................... ///                                 it was checking for EOF after reading a  
.................... ///                                 char, it should check for EOF before reading 
.................... ///                                 from stream. 
.................... /// 
.................... /// * Nick LaBonte   Feb 22 2007    Added support for MPFS 
.................... /// 
.................... /// * Nick LaBonte   Jan 2007       Added MMC file support, removed HTTP_USE_CHUNKS 
.................... /// 
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST 
.................... /// 
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix 
.................... ///                                 many bugs.  The biggest bug is that 
.................... ///                                 it can send pages and receive CGI that 
.................... ///                                 is larger than 1 TCP packet.  Also 
.................... ///                                 added the HTTP_USE_CHUNKS, 
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and 
.................... ///                                 HTTP_USE_CONTENT_TYPE parameters. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef debug_html 
....................  #define debug_html_putc(c) 
....................  #define debug_html(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #else 
....................  #define __DO_DEBUG_HTML 
.................... #endif 
....................  
.................... #ifndef debug_mpfs2 
.................... #define debug_mpfs2(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #error Must define a file system to use 
.................... #endif 
....................  
.................... #ifndef HTTP_ESCAPED_STR_SIZE 
.................... #define HTTP_ESCAPED_STR_SIZE 40 
.................... #endif 
....................  
.................... #ifndef HTTP_SEND_BYTES_PER_CHUNK 
.................... #define HTTP_SEND_BYTES_PER_CHUNK   128 
.................... #endif 
....................  
.................... #ifndef HTTP_INTERRUPT_TASKS 
.................... #define HTTP_INTERRUPT_TASKS() 
.................... #endif 
....................  
.................... #define HTTP_404_ERROR_FNAME "error404.htm" 
.................... #define HTTP_500_ERROR_FNAME "error500.htm" 
.................... #define HTML_INDEX_FNAME "index.htm" 
....................  
.................... #ifndef HTTP_SERVER_HTACCESS_FILE 
.................... #define HTTP_SERVER_HTACCESS_FILE "htaccess.txt" 
.................... #endif 
....................  
.................... //this will be displayed if the http_500_error[] file cannot be found on the 
.................... //file system.  useful if the file system has crashed. 
.................... #define HTML_500_FILE_CONTENTS "<html><body><h1>500 Error</h1><hr><p>Internal server error.</p></body></html>" 
....................  
.................... /* 
.................... Very similar to standard strncpy(), but it adds a null termination on n+1, and n 
.................... is the entire size of the string including null termination. 
.................... */ 
.................... void _strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................    strncpy(s1,s2,n-1); 
*
07CE6:  MOVLW  01
07CE8:  MOVLB  3
07CEA:  SUBWF  xD6,W
07CEC:  MOVWF  xD8
07CEE:  MOVLW  00
07CF0:  SUBWFB xD7,W
07CF2:  MOVWF  xD9
07CF4:  MOVFF  3D3,402
07CF8:  MOVFF  3D2,401
07CFC:  MOVFF  3D5,404
07D00:  MOVFF  3D4,403
07D04:  MOVFF  FE8,406
07D08:  MOVFF  3D8,405
07D0C:  MOVLB  0
07D0E:  RCALL  7C54
....................    s1[n-1]=0; 
07D10:  MOVLW  01
07D12:  MOVLB  3
07D14:  SUBWF  xD6,W
07D16:  MOVWF  xD8
07D18:  MOVLW  00
07D1A:  SUBWFB xD7,W
07D1C:  MOVWF  xD9
07D1E:  MOVF   xD2,W
07D20:  ADDWF  xD8,W
07D22:  MOVWF  FE9
07D24:  MOVF   xD3,W
07D26:  ADDWFC xD9,W
07D28:  MOVWF  FEA
07D2A:  CLRF   FEF
07D2C:  MOVLB  0
07D2E:  GOTO   9D8C (RETURN)
.................... } 
....................  
.................... //static int1 FTPWriteMMC = 0; 
....................  
.................... //key=val pair string, & delimited 
.................... void http_parse_cgi_str(char* file, char *cgistr); 
....................  
.................... unsigned int8 http_socket[HTTP_NUM_SOCKETS]; 
....................  
.................... enum { 
....................    HTTP_IGNORE = 0, 
....................    HTTP_LISTEN_WAIT, 
....................    HTTP_CONNECTED, 
....................    HTTP_GET_HEADERS, 
....................    HTTP_CHECK_AUTHENTICATION, 
....................    HTTP_GET_POST, 
....................    HTTP_GET_POST_CONTINUE, 
....................    HTTP_SEND_RESPONSE, 
....................    HTTP_SEND_RESPONSE_CONTINUE, 
....................    HTTP_CLOSE, 
....................    HTTP_CLOSE_WAITING, 
....................    HTTP_CLOSED, 
....................    HTTP_DISABLED = 0xFF, 
.................... } http_state[HTTP_NUM_SOCKETS]; 
....................  
.................... unsigned int FileExists(char *file) 
*
07C06:  MOVLB  3
07C08:  CLRF   xE5
07C0A:  CLRF   xE4
.................... { 
....................    unsigned int ret=FALSE; 
....................    MPFS handle; 
....................   
....................    handle=MPFSOpen(file); 
07C0C:  MOVFF  3E3,3EB
07C10:  MOVFF  3E2,3EA
07C14:  MOVLB  0
07C16:  RCALL  7A88
07C18:  MOVFF  03,3E9
07C1C:  MOVFF  02,3E8
07C20:  MOVFF  01,3E7
07C24:  MOVFF  00,3E6
....................    if (handle != MPFS_INVALID) 
07C28:  MOVLB  3
07C2A:  INCFSZ xE6,W
07C2C:  BRA    7C3C
07C2E:  INCFSZ xE7,W
07C30:  BRA    7C3C
07C32:  INCFSZ xE8,W
07C34:  BRA    7C3C
07C36:  INCFSZ xE9,W
07C38:  BRA    7C3C
07C3A:  BRA    7C48
....................    { 
....................       ret=TRUE; 
07C3C:  CLRF   xE5
07C3E:  MOVLW  01
07C40:  MOVWF  xE4
....................       MPFSGetEnd();  
....................       MPFSClose(); 
07C42:  MOVLB  0
07C44:  RCALL  792E
07C46:  MOVLB  3
....................    } 
....................   
....................    return(ret); 
07C48:  MOVFF  3E4,01
07C4C:  MOVFF  3E5,02
07C50:  MOVLB  0
07C52:  RETURN 0
.................... } 
....................  
.................... #if HTTP_USE_AUTHENTICATION 
....................    char http_401_error[]="error401.htm"; 
....................  
....................  
.................... /* 
.................... src holds a string in base64 (null terminated), this will convert that string  
.................... to ascii and save to dest (null terminated).  if src is NULL, then it will use 
.................... dest for the source and save the result over source. 
.................... */ 
.................... void Base64ToString(char *dest, char *src) 
.................... { 
....................    unsigned int32 j; 
....................    unsigned int8 i,scr; 
....................     
....................    if (!src) 
....................       src=dest; 
....................     
....................    while(*src) 
....................    { 
....................       j=0; 
....................       for (i=0;i<4;i++) 
....................       { 
....................          scr=*src; 
....................          //printf("'%c'->",scr); 
....................          if (scr) 
....................             src++; 
....................          if ((scr>='A')&&(scr<='Z')) 
....................             scr-='A'; 
....................          else if ((scr>='a')&&(scr<='z')) 
....................             scr+=26-'a'; 
....................          else if ((scr>='0')&&(scr<='9')) 
....................             scr+=52-'0'; 
....................          else if (scr==' ') 
....................             scr=62; 
....................          else if (scr=='/') 
....................             scr=63; 
....................          else 
....................             scr=0; 
....................              
....................          j *= (int32)64; //bit shift left 6 times 
....................          j &= (int32)0xFFFFFFC0; 
....................          j |= scr; 
....................          //printf("%U [%LX]\r\n", scr,j); 
....................       } 
....................       dest[0]=make8(j,2); 
....................       dest[1]=make8(j,1); 
....................       dest[2]=make8(j,0); 
....................       //printf("APPEND: '%c%c%c'\r\n", dest[0],dest[1],dest[2]); 
....................       dest+=3; 
....................    } 
....................    *dest=0; 
.................... } 
....................  
.................... /* 
.................... Reads the htaccess file (already opened in fHandle), saving max chars to 
.................... *result.  If it reads a '|' then it returns FALSE, if it hits EOF then it  
.................... returns TRUE.  If result is NULL then it won't save, it will just point the  
.................... file to the next element. 
.................... */ 
.................... static unsigned int8 HTTPParseHtaccess(MPFS *pFHandle, char *result, unsigned int16 max) 
.................... { 
....................    char c; 
....................    unsigned int8 ret=FALSE; 
....................     
....................    max--;   //save one for null termination 
....................     
....................    do 
....................    { 
....................       if (MPFSIsEOF()) 
....................       { 
....................          ret=TRUE; 
....................          break; 
....................       } 
....................       c =  MPFSGet(); 
....................       if (result && max && (c!='|') && (c>=' ')) 
....................       { 
....................          *result++ = c; 
....................          max--; 
....................       } 
....................    } while(c!='|'); 
....................     
....................    if (result) 
....................       *result = 0; 
....................     
....................    return(ret); 
.................... }    
....................  
.................... /* 
.................... Upon request of a file, this function should be called before serving the file 
.................... to the user.  It checks to see if the file requires authentication, and if it 
.................... does it sees if the user provided username/password combination passes.  *page 
.................... contains the requested page, *user contains the username/password combination 
.................... from the HTTP header (in base64).  If the user hasn't provided a  
.................... username/password then user will be set to NULL.  This function will return  
.................... TRUE if authentication fails, in which case the server will respond with  
.................... Error 401. 
.................... If you are using MPFS, it must be free at this time and be able to open a file 
.................... else the results will be TRUE.   
.................... If the htaccess format is not valid this will always return TRUE. 
.................... If it cannot find htaccess file it will assume that no file requires  
.................... authentication. 
.................... */ 
.................... unsigned int8 HTTPRequiresAuthentication(char *page, char *user) 
.................... { 
....................    static char htaccess[] = HTTP_SERVER_HTACCESS_FILE; 
....................    static char token[]=":"; 
....................    char *pwd; 
....................    MPFS fHandle; 
....................    char userFromFile[30], pwdFromFile[30], fileToCheck[30]; 
....................    unsigned int8 eof,i; 
....................    unsigned int8 ret=TRUE; 
....................  
....................  
....................    //printf("\r\nCHECK FILE '%s'\r\n", page); 
....................    
....................   //#if STACK_USE_MPFS 
....................   #if 0 
....................    if (MPFSIsInUse()) 
....................    { 
....................       //printf("\r\nMPFSINUSE\r\n"); 
....................       return(TRUE); 
....................    } 
....................   #endif 
....................     
....................    fHandle = MPFSOpen(htaccess); 
....................    if (fHandle == MPFS_INVALID) 
....................    { 
....................       //printf("\r\nNOHTACCESS '%s'\r\n", htaccess); 
....................       return(FALSE); 
....................    } 
....................     
....................    MPFSGetBegin(fHandle); 
....................     
....................    if (HTTPParseHtaccess(&fHandle, userFromFile, sizeof(userFromFile))) 
....................       goto __HTTPRequiresAuthentication_Cleanup; 
....................    if (HTTPParseHtaccess(&fHandle, pwdFromFile, sizeof(pwdFromFile))) 
....................       goto __HTTPRequiresAuthentication_Cleanup; 
....................    
....................    for(;;) 
....................    { 
....................       //printf("\r\nFINDING FILE\r\n"); 
....................       eof = HTTPParseHtaccess(&fHandle, fileToCheck, sizeof(fileToCheck)); 
....................             
....................       strupr(fileToCheck); 
....................        
....................       //strip any any whitespace chars at the end of the file 
....................       i=strlen(fileToCheck); 
....................       while(i--) 
....................       { 
....................          if (fileToCheck[i] <= ' ') 
....................             fileToCheck[i]=0; 
....................          else 
....................             break; 
....................       } 
....................  
....................       //printf("\r\nFILE (%U) = '%s'\r\n", eof, fileToCheck); 
....................       if ( 
....................             (fileToCheck[0] == '*') || //wildcard, match all files 
....................             (strcmp(fileToCheck, page)==0) ||  //file is a perfect match 
....................             (  //check for subdirectory 
....................                (fileToCheck[i]=='/') &&   //if file ends in /, it is a directory 
....................                (strstr(page, fileToCheck)==page) 
....................             ) 
....................          ) 
....................       { 
....................          //printf("\r\nCONVERTING 64: '%s'->", user); 
....................          Base64ToString(user, NULL);          
....................          //printf("'%s'\r\n", user); 
....................          user=strtok(user,token); 
....................          pwd=strtok(0,token); 
....................          return 
....................             ( 
....................                !( 
....................                   ( 
....................                      strlen(userFromFile) &&  
....................                      strlen(pwdFromFile) &&  
....................                      (stricmp(userFromFile,user)==0) && 
....................                      (stricmp(pwdFromFile,pwd)==0) 
....................                   ) || 
....................                   http_check_authentication(page,user,pwd) 
....................                 ) 
....................             ); 
....................          //if (user && pwd && (strcmp(user,validUser)==0) && (strcmp(pwd,validPwd)==0)) 
....................          //   ret=FALSE; 
....................          break; 
....................       } 
....................        
....................       if (eof) 
....................       { 
....................          ret=FALSE; 
....................          break; 
....................       }       
....................    } 
....................  
.................... __HTTPRequiresAuthentication_Cleanup: 
....................    MPFSGetEnd(); 
....................    MPFSClose(); 
....................    return(ret); 
.................... } 
.................... #endif //HTTP_USE_AUTHENTICATION 
....................  
.................... //strips out any escape characters that the HTTP client may have inserted. 
.................... // (+ is replaced with space) 
.................... // (%xx is replaced with character representation of xx) 
.................... void http_escape_chars(char *str) 
.................... { 
....................    char new[3]; 
....................    char c; 
....................    char val; 
....................  
....................    new[2]=0; 
*
076D0:  MOVLB  3
076D2:  CLRF   xE3
....................  
....................    while((c=*str) != 0) 
076D4:  MOVFF  3E0,03
076D8:  MOVFF  3DF,FE9
076DC:  MOVFF  3E0,FEA
076E0:  MOVFF  FEF,3E4
076E4:  MOVF   xE4,F
076E6:  BZ    77AE
....................    { 
....................       if (c=='+') 
076E8:  MOVF   xE4,W
076EA:  SUBLW  2B
076EC:  BNZ   7706
....................          *str++=' '; 
076EE:  MOVFF  3E0,03
076F2:  MOVF   xDF,W
076F4:  INCF   xDF,F
076F6:  BTFSC  FD8.2
076F8:  INCF   xE0,F
076FA:  MOVWF  FE9
076FC:  MOVFF  03,FEA
07700:  MOVLW  20
07702:  MOVWF  FEF
07704:  BRA    77AA
....................       else if (c=='%') 
07706:  MOVF   xE4,W
07708:  SUBLW  25
0770A:  BNZ   77A4
....................       { 
....................          memcpy(new, str + 1, 2); 
0770C:  MOVLW  01
0770E:  ADDWF  xDF,W
07710:  MOVWF  xE6
07712:  MOVLW  00
07714:  ADDWFC xE0,W
07716:  MOVWF  xE7
07718:  MOVLW  03
0771A:  MOVWF  FEA
0771C:  MOVLW  E1
0771E:  MOVWF  FE9
07720:  MOVFF  3E7,FE2
07724:  MOVFF  3E6,FE1
07728:  MOVLW  02
0772A:  MOVWF  01
0772C:  MOVFF  FE6,FEE
07730:  DECFSZ 01,F
07732:  BRA    772C
....................          val = strtoul(new, 0, 16); 
07734:  MOVLW  03
07736:  MOVWF  xE7
07738:  MOVLW  E1
0773A:  MOVWF  xE6
0773C:  CLRF   xE9
0773E:  CLRF   xE8
07740:  CLRF   xEB
07742:  MOVLW  10
07744:  MOVWF  xEA
07746:  MOVLB  0
07748:  BRA    719A
0774A:  MOVFF  00,3E5
....................          *str++ = val; 
0774E:  MOVLB  3
07750:  MOVFF  3E0,03
07754:  MOVF   xDF,W
07756:  INCF   xDF,F
07758:  BTFSC  FD8.2
0775A:  INCF   xE0,F
0775C:  MOVWF  FE9
0775E:  MOVFF  03,FEA
07762:  MOVFF  3E5,FEF
....................          memmove(str, str + 2, strlen(str) - 1); 
07766:  MOVLW  02
07768:  ADDWF  xDF,W
0776A:  MOVWF  xE6
0776C:  MOVLW  00
0776E:  ADDWFC xE0,W
07770:  MOVWF  xE7
07772:  MOVFF  3E0,407
07776:  MOVFF  3DF,406
0777A:  MOVLB  0
0777C:  RCALL  75AE
0777E:  MOVLW  01
07780:  SUBWF  01,W
07782:  MOVLB  3
07784:  MOVWF  xE8
07786:  MOVFF  3E0,405
0778A:  MOVFF  3DF,404
0778E:  MOVFF  3E7,407
07792:  MOVFF  3E6,406
07796:  MOVLB  4
07798:  CLRF   x09
0779A:  MOVWF  x08
0779C:  MOVLB  0
0779E:  RCALL  75E8
....................       } 
077A0:  BRA    77AA
077A2:  MOVLB  3
....................       else 
....................          str++; 
077A4:  INCF   xDF,F
077A6:  BTFSC  FD8.2
077A8:  INCF   xE0,F
077AA:  MOVLB  3
077AC:  BRA    76D4
....................    } 
077AE:  MOVLB  0
077B0:  RETURN 0
.................... } 
....................  
.................... void http_parse_cgi_string(char* file, char *ptr) 
.................... { 
....................    char *pKey, *pValue, c; 
....................  
....................    pKey=ptr; 
*
07D32:  MOVFF  3D9,3DB
07D36:  MOVFF  3D8,3DA
....................  
....................    for(;;) 
....................    { 
....................       c = *ptr; 
07D3A:  MOVLB  3
07D3C:  MOVFF  3D8,FE9
07D40:  MOVFF  3D9,FEA
07D44:  MOVFF  FEF,3DE
....................       if ((c=='&') || (c==0)) 
07D48:  MOVF   xDE,W
07D4A:  SUBLW  26
07D4C:  BZ    7D52
07D4E:  MOVF   xDE,F
07D50:  BNZ   7DA4
....................       { 
....................          *ptr=0; 
07D52:  MOVFF  3D8,FE9
07D56:  MOVFF  3D9,FEA
07D5A:  CLRF   FEF
....................          http_escape_chars(pKey); 
07D5C:  MOVFF  3DB,3E0
07D60:  MOVFF  3DA,3DF
07D64:  MOVLB  0
07D66:  RCALL  76D0
....................          http_escape_chars(pValue); 
07D68:  MOVFF  3DD,3E0
07D6C:  MOVFF  3DC,3DF
07D70:  RCALL  76D0
....................          http_exec_cgi(file, pKey, pValue); 
07D72:  MOVFF  3D7,3E0
07D76:  MOVFF  3D6,3DF
07D7A:  MOVFF  3DB,3E2
07D7E:  MOVFF  3DA,3E1
07D82:  MOVFF  3DD,3E4
07D86:  MOVFF  3DC,3E3
07D8A:  GOTO   0004
....................          pKey=ptr+1; 
07D8E:  MOVLW  01
07D90:  MOVLB  3
07D92:  ADDWF  xD8,W
07D94:  MOVWF  xDA
07D96:  MOVLW  00
07D98:  ADDWFC xD9,W
07D9A:  MOVWF  xDB
....................          if (c==0) 
07D9C:  MOVF   xDE,F
07D9E:  BNZ   7DA2
....................             break; 
07DA0:  BRA    7DC8
....................       } 
07DA2:  BRA    7DC0
....................       else if (c=='=') 
07DA4:  MOVF   xDE,W
07DA6:  SUBLW  3D
07DA8:  BNZ   7DC0
....................       { 
....................          *ptr=0; 
07DAA:  MOVFF  3D8,FE9
07DAE:  MOVFF  3D9,FEA
07DB2:  CLRF   FEF
....................          pValue=ptr+1; 
07DB4:  MOVLW  01
07DB6:  ADDWF  xD8,W
07DB8:  MOVWF  xDC
07DBA:  MOVLW  00
07DBC:  ADDWFC xD9,W
07DBE:  MOVWF  xDD
....................       } 
....................       ptr++; 
07DC0:  INCF   xD8,F
07DC2:  BTFSC  FD8.2
07DC4:  INCF   xD9,F
07DC6:  BRA    7D3C
....................    } 
07DC8:  MOVLB  0
07DCA:  RETURN 0
.................... } 
....................  
.................... unsigned int8 g_HttpCurrSocket; 
.................... unsigned int8 g_HttpCurrConn; 
....................  
.................... #define tcp_http_tx_left()  TCPIsPutReady(g_HttpCurrSocket) 
....................  
.................... unsigned int tcp_http_putc(char c) 
.................... { 
....................    //putc(c); 
....................    return(TCPPut(g_HttpCurrSocket,c)); 
*
08506:  MOVFF  210,3F8
0850A:  MOVFF  3F7,3F9
0850E:  BRA    83E2
08510:  CLRF   03
08512:  MOVFF  03,02
08516:  RETURN 0
.................... } 
....................  
.................... MPFS lastHTTPPutConstPos[HTTP_NUM_SOCKETS]; 
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS]; 
....................  
.................... typedef enum 
.................... { 
....................    MIME_TYPE_HTM, 
....................    MIME_TYPE_HTML, 
....................    MIME_TYPE_TXT, 
....................    MIME_TYPE_XML, 
....................    MIME_TYPE_GIF, 
....................    MIME_TYPE_JPG, 
....................    MIME_TYPE_PNG, 
....................    MIME_TYPE_ICO 
.................... } MIME_T; 
....................  
.................... //static int1 is_image[HTTP_NUM_SOCKETS]; 
.................... MIME_T g_HTTPMimeType[HTTP_NUM_SOCKETS]; 
.................... #if HTTP_LAST_MODIFIED_CHECK 
....................  int1 g_lastModifiedCheck[HTTP_NUM_SOCKETS]; 
.................... #endif 
.................... #define IsImage(t)   (g_HTTPMimeType[t]>=MIME_TYPE_GIF) 
....................  
.................... #define HTTP_NUM_MIME_TYPES   8 
....................  
.................... ROM char gc_MimeTypes[HTTP_NUM_MIME_TYPES][5] =  //filename extensions 
.................... { 
....................    "htm", 
....................    "html", 
....................    "txt", 
....................    "xml", 
....................    "gif", 
....................    "jpg", 
....................    "png", 
....................    "ico" 
.................... }; 
....................  
.................... ROM char gc_MimeTypesHeader[HTTP_NUM_MIME_TYPES][13] = 
.................... { 
....................    "text/html", 
....................    "text/html", 
....................    "text/plain", 
....................    "text/xml", 
....................    "image/gif", 
....................    "image/jpeg", 
....................    "image/png", 
....................    "image/x-icon" 
.................... }; 
....................  
.................... MIME_T HTTPFindMimeType(char *fname) 
.................... { 
....................    unsigned int8 i; 
....................    char str[5]; 
....................    char extension[5]; 
....................  
....................    if(strlen(strchr(fname,'.'))<6) 
*
08204:  MOVFF  3D5,3E2
08208:  MOVFF  3D4,3E1
0820C:  MOVLW  2E
0820E:  MOVLB  3
08210:  MOVWF  xE3
08212:  MOVLB  0
08214:  RCALL  8148
08216:  MOVFF  02,3E2
0821A:  MOVFF  01,3E1
0821E:  MOVFF  02,407
08222:  MOVFF  01,406
08226:  CALL   75AE
0822A:  MOVF   01,W
0822C:  SUBLW  05
0822E:  BNC   8272
....................    { 
....................       strncpy (extension, (strchr(fname,  '.'))+1,  4); 
08230:  MOVFF  3D5,3E2
08234:  MOVFF  3D4,3E1
08238:  MOVLW  2E
0823A:  MOVLB  3
0823C:  MOVWF  xE3
0823E:  MOVLB  0
08240:  RCALL  8148
08242:  MOVFF  02,3E2
08246:  MOVFF  01,3E1
0824A:  MOVLW  01
0824C:  MOVLB  3
0824E:  ADDWF  xE1,F
08250:  MOVLW  00
08252:  ADDWFC xE2,F
08254:  MOVLW  03
08256:  MOVLB  4
08258:  MOVWF  x02
0825A:  MOVLW  DC
0825C:  MOVWF  x01
0825E:  MOVFF  3E2,404
08262:  MOVFF  3E1,403
08266:  CLRF   x06
08268:  MOVLW  04
0826A:  MOVWF  x05
0826C:  MOVLB  0
0826E:  RCALL  7C54
....................    } 
08270:  BRA    8278
....................    else 
....................       extension[0] = 0; 
08272:  MOVLB  3
08274:  CLRF   xDC
08276:  MOVLB  0
....................  
....................  
....................    for (i=0; i<HTTP_NUM_MIME_TYPES; i++) 
08278:  MOVLB  3
0827A:  CLRF   xD6
0827C:  MOVF   xD6,W
0827E:  SUBLW  07
08280:  BNC   82EC
....................    { 
....................       //sprintf(str, "%s", gc_MimeTypes[i]); 
....................       strcpypgm2ram(str, &gc_MimeTypes[i][0]); 
08282:  MOVF   xD6,W
08284:  MULLW  05
08286:  MOVF   FF3,W
08288:  CLRF   xE2
0828A:  MOVWF  xE1
0828C:  MOVLW  BC
0828E:  ADDWF  xE1,W
08290:  MOVWF  xE3
08292:  MOVLW  66
08294:  ADDWFC xE2,W
08296:  MOVWF  xE4
08298:  MOVLW  01
0829A:  MOVWF  xE5
0829C:  BCF    FD8.2
0829E:  BTFSC  FD8.0
082A0:  INCF   xE5,F
082A2:  CLRF   xE6
082A4:  MOVLW  03
082A6:  MOVWF  xED
082A8:  MOVLW  D7
082AA:  MOVWF  xEC
082AC:  MOVFF  3E6,3F1
082B0:  MOVFF  3E5,3F0
082B4:  MOVFF  3E4,3EF
082B8:  MOVFF  3E3,3EE
082BC:  MOVLB  0
082BE:  RCALL  818C
....................       debug_html(debug_html_putc, "\r\nHTML Ext check %u '%s' '%s' vs '%s'(0x%LX) ", i, fname, extension, str, &gc_MimeTypes[i][0]); 
....................       if (stricmp(str, extension) == 0) 
082C0:  MOVLW  03
082C2:  MOVLB  3
082C4:  MOVWF  xE2
082C6:  MOVLW  D7
082C8:  MOVWF  xE1
082CA:  MOVLW  03
082CC:  MOVWF  xE4
082CE:  MOVLW  DC
082D0:  MOVWF  xE3
082D2:  MOVLB  0
082D4:  CALL   77B2
082D8:  MOVF   01,F
082DA:  BNZ   82E6
....................          return(i); 
082DC:  MOVLB  3
082DE:  MOVFF  3D6,01
082E2:  BRA    82F0
082E4:  MOVLB  0
082E6:  MOVLB  3
082E8:  INCF   xD6,F
082EA:  BRA    827C
....................    } 
....................     
....................    return(MIME_TYPE_TXT); 
082EC:  MOVLW  02
082EE:  MOVWF  01
082F0:  MOVLB  0
082F2:  GOTO   A3A6 (RETURN)
.................... } 
....................  
.................... typedef enum 
.................... { 
....................    TCP_PUT_CONST_EC_FINISH = 0, 
....................    TCP_PUT_CONST_EC_CONTINUE, 
....................    TCP_PUT_CONST_EC_ESCAPE 
.................... } TCP_PUT_CONST_EC; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileVarChunk(ptr) 
.................... // 
.................... // send a chunked response from ram 
.................... // 
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated 
.................... //          with the continue position before exit. 
.................... // 
.................... // Returns a status code: 
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed 
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr) 
.................... //because of a compiler error this had to be a double pointer an int16, when 
.................... //it should be a char. 
....................  
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(unsigned int16 **retPtr) 
.................... { 
....................    unsigned int16 txLeft, n; 
....................    char *ptr, ec; 
....................  
....................    ptr=*retPtr; 
*
08660:  MOVLB  3
08662:  MOVFF  3E4,FE9
08666:  MOVFF  3E5,FEA
0866A:  MOVFF  FEC,03
0866E:  MOVF   FED,F
08670:  MOVFF  FEF,3EA
08674:  MOVFF  03,3EB
....................  
....................    n=strlen(ptr); 
08678:  MOVFF  3EB,407
0867C:  MOVFF  3EA,406
08680:  MOVLB  0
08682:  CALL   75AE
08686:  MOVLB  3
08688:  CLRF   xE9
0868A:  MOVFF  01,3E8
....................     
....................    if (!n){ 
0868E:  MOVF   xE8,W
08690:  IORWF  xE9,W
08692:  BNZ   869A
....................       return(TCP_PUT_CONST_EC_FINISH); 
08694:  MOVLW  00
08696:  MOVWF  01
08698:  BRA    8712
....................    } 
....................  
....................    txLeft = tcp_http_tx_left(); 
0869A:  MOVFF  210,3FC
0869E:  MOVLB  0
086A0:  RCALL  82F6
086A2:  MOVFF  02,3E7
086A6:  MOVFF  01,3E6
....................    
....................    if (n > txLeft) 
086AA:  MOVLB  3
086AC:  MOVF   xE7,W
086AE:  SUBWF  xE9,W
086B0:  BNC   86C0
086B2:  BNZ   86BA
086B4:  MOVF   xE8,W
086B6:  SUBWF  xE6,W
086B8:  BC    86C0
....................       ec = TCP_PUT_CONST_EC_CONTINUE;    
086BA:  MOVLW  01
086BC:  MOVWF  xEC
086BE:  BRA    86CA
....................    else 
....................    { 
....................       txLeft = n; 
086C0:  MOVFF  3E9,3E7
086C4:  MOVFF  3E8,3E6
....................       ec = TCP_PUT_CONST_EC_FINISH; 
086C8:  CLRF   xEC
....................    } 
....................  
....................    //TCPPutFileChunkStart(txLeft); 
....................  
....................    while (txLeft--) 
086CA:  MOVFF  3E7,03
086CE:  MOVF   xE6,W
086D0:  BTFSC  FD8.2
086D2:  DECF   xE7,F
086D4:  DECF   xE6,F
086D6:  IORWF  03,W
086D8:  BZ    86FC
....................       tcp_http_putc(*(ptr++)); 
086DA:  MOVFF  3EB,03
086DE:  MOVF   xEA,W
086E0:  INCF   xEA,F
086E2:  BTFSC  FD8.2
086E4:  INCF   xEB,F
086E6:  MOVWF  FE9
086E8:  MOVFF  03,FEA
086EC:  MOVFF  FEF,3ED
086F0:  MOVFF  3ED,3F7
086F4:  MOVLB  0
086F6:  RCALL  8506
086F8:  MOVLB  3
086FA:  BRA    86CA
....................  
....................    //TCPPutFileChunkStop(); 
....................  
....................    *retPtr=ptr; 
086FC:  MOVFF  3E4,FE9
08700:  MOVFF  3E5,FEA
08704:  MOVFF  3EB,FEC
08708:  MOVF   FED,F
0870A:  MOVFF  3EA,FEF
....................  
....................    return(ec); 
0870E:  MOVFF  3EC,01
08712:  MOVLB  0
08714:  RETURN 0
.................... } 
....................  
....................  
.................... /* 
....................    Allows negative seek offset. 
.................... */ 
.................... void myMPFSSeek(MPFS *handle, signed int16 offset) 
.................... { 
....................     MPFSGetBegin(*handle); 
*
0895A:  MOVLB  3
0895C:  MOVFF  3F9,FE9
08960:  MOVFF  3FA,FEA
08964:  MOVFF  FEF,FD
08968:  MOVFF  FEC,FE
0896C:  MOVFF  FEC,FF
08970:  MOVFF  FEC,100
....................     if(offset < 0){ 
08974:  BTFSS  xFC.7
08976:  BRA    89BA
....................       while(offset++!=0){ 
08978:  MOVFF  3FC,03
0897C:  MOVF   xFB,W
0897E:  INCF   xFB,F
08980:  BTFSC  FD8.2
08982:  INCF   xFC,F
08984:  MOVWF  xFD
08986:  MOVFF  03,3FE
0898A:  MOVF   xFD,F
0898C:  BNZ   8992
0898E:  MOVF   xFE,F
08990:  BZ    89B8
....................           _currentHandle--; 
08992:  MOVLW  FF
08994:  MOVLB  0
08996:  ADDWF  xFD,F
08998:  BTFSS  FD8.0
0899A:  ADDWF  xFE,F
0899C:  BTFSS  FD8.0
0899E:  ADDWF  xFF,F
089A0:  BTFSC  FD8.0
089A2:  BRA    89AA
089A4:  MOVLB  1
089A6:  ADDWF  x00,F
089A8:  MOVLB  0
....................           _currentCount--; 
089AA:  MOVLB  2
089AC:  MOVF   x0C,W
089AE:  BTFSC  FD8.2
089B0:  DECF   x0D,F
089B2:  DECF   x0C,F
089B4:  MOVLB  3
089B6:  BRA    8978
....................        } 
....................     }else if(offset >0){ 
089B8:  BRA    8A06
089BA:  BTFSC  xFC.7
089BC:  BRA    8A06
089BE:  MOVF   xFC,F
089C0:  BNZ   89C8
089C2:  MOVF   xFB,W
089C4:  SUBLW  00
089C6:  BC    8A06
....................       while(offset--!=0){ 
089C8:  MOVFF  3FC,03
089CC:  MOVF   xFB,W
089CE:  BTFSC  FD8.2
089D0:  DECF   xFC,F
089D2:  DECF   xFB,F
089D4:  MOVWF  xFD
089D6:  MOVFF  03,3FE
089DA:  MOVF   xFD,F
089DC:  BNZ   89E2
089DE:  MOVF   xFE,F
089E0:  BZ    8A06
....................          _currentHandle++; 
089E2:  MOVLW  01
089E4:  MOVLB  0
089E6:  ADDWF  xFD,F
089E8:  BTFSC  FD8.0
089EA:  INCF   xFE,F
089EC:  BTFSC  FD8.2
089EE:  INCF   xFF,F
089F0:  BTFSS  FD8.2
089F2:  BRA    89FA
089F4:  MOVLB  1
089F6:  INCF   x00,F
089F8:  MOVLB  0
....................          _currentCount++; 
089FA:  MOVLB  2
089FC:  INCF   x0C,F
089FE:  BTFSC  FD8.2
08A00:  INCF   x0D,F
08A02:  MOVLB  3
08A04:  BRA    89C8
....................       } 
....................     } 
....................  
....................    *handle = MPFSGetEnd(); 
08A06:  MOVFF  3F9,FE9
08A0A:  MOVFF  3FA,FEA
08A0E:  MOVFF  FD,FEF
08A12:  MOVFF  FE,FEC
08A16:  MOVFF  FF,FEC
08A1A:  MOVFF  100,FEC
08A1E:  MOVLB  0
08A20:  GOTO   8BB8 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSFileTell(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          beginning of current file 
....................  * 
....................  * Side Effects:    None. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None. 
....................  ********************************************************************/ 
.................... #define MPFSFileTell()  (_currentFile) 
....................  
.................... //Now these are global--not initialized to 0 
.................... //save a couple hundred bytes of ROM this way 
.................... char HTTPbuffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
.................... MPFS http_page_req[HTTP_NUM_SOCKETS]; 
....................  
.................... #if HTTP_USE_AUTHENTICATION 
....................  char http_get_cache[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
....................  char http_auth_user[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
.................... #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileParseConst(fstream, n, doSend) 
.................... // 
.................... // Reads file from mmc.  Stops when it reaches an escape sequence, 
.................... // n chars or an end of file 
.................... // 
.................... // fstream - file sream to read (will be sent as an http/1.1 chunk).  The stream 
.................... //        will be updated for the next call. 
.................... // 
.................... // n - max number of chars to read from file.  will save the total number 
.................... //    of chars passed to this pointer. 
.................... // 
.................... // doSend - if TRUE, then send data to TCP socket 
.................... // 
.................... // returns the last char read 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... #if 0 //original slow 
.................... char TCPPutFileParseConst(MPFS *fstream, unsigned int16 *n, int8 doSend, int1 isPix) 
.................... { 
....................    char stopC, checkC; 
....................    unsigned int16 fileSize = 1, max; 
....................    int1 premature = TRUE; 
....................    max = *n; 
....................    MPFSGetBegin(*fstream); 
....................    while (TRUE) 
....................    { 
....................       if(MPFSIsEOF())//EOF 
....................       { 
....................          premature = FALSE; 
....................          break;    
....................       } 
....................       stopC= MPFSGet(); 
....................       if (stopC == '%'&&!isPix) 
....................       { 
....................          checkC= MPFSGet(); 
....................          if (checkC == '%') 
....................          { 
....................             if (fileSize < max) 
....................             { 
....................                if (doSend) 
....................                   tcp_http_putc('%'); 
....................                fileSize++; 
....................             } 
....................             else 
....................                break; 
....................          } 
....................          else 
....................             break;   //ESCAPE 
....................       } 
....................       else 
....................       { 
....................          if (MPFSIsEOF()) 
....................          { 
....................             premature = FALSE; 
....................             break; 
....................          } 
....................          if (((fileSize) < max)) 
....................          { 
....................             //if (doSend&&!fateof(fstream)) 
....................             if (doSend) 
....................             { 
....................                tcp_http_putc(stopC); 
....................             } 
....................             fileSize++; 
....................          } 
....................          else 
....................             break; 
....................       } 
....................       /* 
....................       if(fateof(fstream))//EOF 
....................       { 
....................          premature = FALSE; 
....................          break;    
....................       } 
....................       */ 
....................    } 
....................     
....................    *fstream = MPFSGetEnd(); 
....................    if (premature==TRUE){ 
....................       myMPFSSeek(fstream, -1);  //addy--; 
....................    } 
....................   
....................    *n = fileSize; 
....................    *fstream = MPFSGetEnd(); 
....................    return(stopC); 
.................... } 
.................... #endif 
.................... //new fast 
.................... char TCPPutFileParseConst(MPFS *fstream, unsigned int16 max, int1 isPix) 
08A24:  MOVLB  3
08A26:  BCF    xF6.0
.................... { 
....................    char c; 
....................    unsigned int8 *p; 
....................    unsigned int16 readCount; 
....................    int1 escape = FALSE; 
....................     
....................    debug_mpfs2(debug_putc, "\r\nTCPPutFileParseConst() c=%X max=%LX f=%LX p=%U ", g_HttpCurrConn, max, *fstream, isPix); 
....................     
....................    /*  
....................       this will cause httpTask() to only process 128 bytes at 
....................       a time and allow other processes to run while reading 
....................       page from EE. 
....................    */ 
....................    if (max > (unsigned int16)HTTP_SEND_BYTES_PER_CHUNK) 
08A28:  MOVF   xEF,F
08A2A:  BNZ   8A32
08A2C:  MOVF   xEE,W
08A2E:  SUBLW  80
08A30:  BC    8A38
....................       max = HTTP_SEND_BYTES_PER_CHUNK; 
08A32:  CLRF   xEF
08A34:  MOVLW  80
08A36:  MOVWF  xEE
....................     
....................    MPFSGetBegin(*fstream); 
08A38:  MOVFF  3EC,FE9
08A3C:  MOVFF  3ED,FEA
08A40:  MOVFF  FEF,FD
08A44:  MOVFF  FEC,FE
08A48:  MOVFF  FEC,FF
08A4C:  MOVFF  FEC,100
....................  
....................    while (max && !escape && !MPFSIsEOF()) 
08A50:  MOVF   xEE,W
08A52:  IORWF  xEF,W
08A54:  BTFSC  FD8.2
08A56:  BRA    8B58
08A58:  BTFSC  xF6.0
08A5A:  BRA    8B58
08A5C:  MOVLB  0
08A5E:  INCFSZ xFD,W
08A60:  BRA    8A7C
08A62:  INCFSZ xFE,W
08A64:  BRA    8A7C
08A66:  INCFSZ xFF,W
08A68:  BRA    8A7C
08A6A:  MOVLB  1
08A6C:  INCFSZ x00,W
08A6E:  BRA    8A72
08A70:  BRA    8A76
08A72:  MOVLB  0
08A74:  BRA    8A7C
08A76:  MOVLB  3
08A78:  BRA    8B58
08A7A:  MOVLB  0
....................    { 
....................       p = &HTTPbuffer[g_HttpCurrConn][0]; 
08A7C:  MOVLB  2
08A7E:  MOVF   x11,W
08A80:  MULLW  FE
08A82:  MOVF   FF3,W
08A84:  MOVLB  3
08A86:  CLRF   xF8
08A88:  MOVWF  xF7
08A8A:  MOVLW  19
08A8C:  ADDWF  xF7,W
08A8E:  MOVWF  01
08A90:  MOVLW  02
08A92:  ADDWFC xF8,W
08A94:  MOVFF  01,3F2
08A98:  MOVWF  xF3
....................     
....................       readCount = MIN(max, HTTP_GET_PARAM_MAX_SIZE); 
08A9A:  MOVF   xEF,F
08A9C:  BNZ   8AA4
08A9E:  MOVF   xEE,W
08AA0:  SUBLW  FE
08AA2:  BC    8AAA
08AA4:  CLRF   03
08AA6:  MOVLW  FE
08AA8:  BRA    8AB0
08AAA:  MOVFF  3EF,03
08AAE:  MOVF   xEE,W
08AB0:  MOVWF  xF4
08AB2:  MOVFF  03,3F5
....................     
....................       readCount = MPFSGetBytes(p, readCount); 
08AB6:  MOVFF  3F3,3F8
08ABA:  MOVFF  3F2,3F7
08ABE:  MOVFF  3F5,3FA
08AC2:  MOVFF  3F4,3F9
08AC6:  MOVLB  0
08AC8:  BRA    8716
08ACA:  MOVFF  02,3F5
08ACE:  MOVFF  01,3F4
....................        
....................       debug_mpfs2(debug_putc, "r=%LX ", readCount); 
....................           
....................       while (readCount && !escape) 
08AD2:  MOVLB  3
08AD4:  MOVF   xF4,W
08AD6:  IORWF  xF5,W
08AD8:  BZ    8B56
08ADA:  BTFSC  xF6.0
08ADC:  BRA    8B56
....................       { 
....................          readCount--; 
08ADE:  MOVF   xF4,W
08AE0:  BTFSC  FD8.2
08AE2:  DECF   xF5,F
08AE4:  DECF   xF4,F
....................          c = *p++; 
08AE6:  MOVFF  3F3,03
08AEA:  MOVF   xF2,W
08AEC:  INCF   xF2,F
08AEE:  BTFSC  FD8.2
08AF0:  INCF   xF3,F
08AF2:  MOVWF  FE9
08AF4:  MOVFF  03,FEA
08AF8:  MOVFF  FEF,3F1
....................          if ((c == '%') && !isPix) 
08AFC:  MOVF   xF1,W
08AFE:  SUBLW  25
08B00:  BNZ   8B3E
08B02:  MOVF   xF0,F
08B04:  BNZ   8B3E
....................          { 
....................             debug_mpfs2(debug_putc, "+%%="); 
....................             if (readCount) 
08B06:  MOVF   xF4,W
08B08:  IORWF  xF5,W
08B0A:  BZ    8B2C
....................             { 
....................                readCount--; 
08B0C:  MOVF   xF4,W
08B0E:  BTFSC  FD8.2
08B10:  DECF   xF5,F
08B12:  DECF   xF4,F
....................                c = *p++; 
08B14:  MOVFF  3F3,03
08B18:  MOVF   xF2,W
08B1A:  INCF   xF2,F
08B1C:  BTFSC  FD8.2
08B1E:  INCF   xF3,F
08B20:  MOVWF  FE9
08B22:  MOVFF  03,FEA
08B26:  MOVFF  FEF,3F1
....................             } 
08B2A:  BRA    8B36
....................             else 
....................             { 
....................                c = MPFSGet(); 
08B2C:  MOVLB  0
08B2E:  RCALL  88BA
08B30:  MOVFF  01,3F1
08B34:  MOVLB  3
....................             } 
....................             debug_mpfs2(debug_putc, "%X", c); 
....................             if (c != '%') 
08B36:  MOVF   xF1,W
08B38:  SUBLW  25
08B3A:  BZ    8B3E
....................             { 
....................                escape = TRUE; 
08B3C:  BSF    xF6.0
....................                debug_mpfs2(debug_putc, "e"); 
....................             } 
....................             debug_mpfs2(debug_putc, " "); 
....................          } 
....................          if (!escape) 
08B3E:  BTFSC  xF6.0
08B40:  BRA    8B54
....................          { 
....................             tcp_http_putc(c); 
08B42:  MOVFF  3F1,3F7
08B46:  MOVLB  0
08B48:  RCALL  8506
....................             max--; 
08B4A:  MOVLB  3
08B4C:  MOVF   xEE,W
08B4E:  BTFSC  FD8.2
08B50:  DECF   xEF,F
08B52:  DECF   xEE,F
....................          } 
08B54:  BRA    8AD4
....................       } 
....................       HTTP_INTERRUPT_TASKS(); 
08B56:  BRA    8A50
....................    } 
....................        
....................    *fstream = MPFSGetEnd(); 
08B58:  MOVFF  3EC,FE9
08B5C:  MOVFF  3ED,FEA
08B60:  MOVFF  FD,FEF
08B64:  MOVFF  FE,FEC
08B68:  MOVFF  FF,FEC
08B6C:  MOVFF  100,FEC
....................     
....................    if (escape) 
08B70:  BTFSS  xF6.0
08B72:  BRA    8BBC
....................    {   
....................       debug_mpfs2(debug_putc, "f1=%LX ", *fstream); 
....................       *fstream = _MpfsEofLoc; 
08B74:  MOVFF  3EC,FE9
08B78:  MOVFF  3ED,FEA
08B7C:  MOVFF  101,FEF
08B80:  MOVFF  102,FEC
08B84:  MOVFF  103,FEC
08B88:  MOVFF  104,FEC
....................       debug_mpfs2(debug_putc, "fe=%LX ", *fstream); 
....................       c = '%'; 
08B8C:  MOVLW  25
08B8E:  MOVWF  xF1
....................       readCount++; 
08B90:  INCF   xF4,F
08B92:  BTFSC  FD8.2
08B94:  INCF   xF5,F
....................       myMPFSSeek(fstream, -readCount);  //addy--; 
08B96:  COMF   xF4,W
08B98:  MOVWF  xF7
08B9A:  COMF   xF5,W
08B9C:  MOVWF  xF8
08B9E:  INCF   xF7,F
08BA0:  BTFSC  FD8.2
08BA2:  INCF   xF8,F
08BA4:  MOVFF  3ED,3FA
08BA8:  MOVFF  3EC,3F9
08BAC:  MOVFF  3F8,3FC
08BB0:  MOVFF  3F7,3FB
08BB4:  MOVLB  0
08BB6:  BRA    895A
....................       debug_mpfs2(debug_putc, "r=%LX fr=%LX ", readCount, *fstream); 
....................    } 
08BB8:  BRA    8BC0
08BBA:  MOVLB  3
....................    else 
....................    { 
....................       c = 0; 
08BBC:  CLRF   xF1
08BBE:  MOVLB  0
....................    } 
....................  
....................    debug_mpfs2(debug_putc, "c=%X e=%U ", c, escape); 
....................   
....................    return(c); 
08BC0:  MOVLB  3
08BC2:  MOVFF  3F1,01
08BC6:  MOVLB  0
08BC8:  GOTO   8C1E (RETURN)
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileConstChunk(*addy) 
.................... // 
.................... // send a chunked response from mmc 
.................... // 
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // returns a response: 
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue 
.................... //                            from this position on next call. 
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character 
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(MPFS *retAddy, int1 isPix) 
.................... { 
....................    char stopC; 
....................    unsigned int16 txLeft; 
....................    TCP_PUT_CONST_EC ec; 
....................    MPFSGetBegin(*retAddy); 
08BCC:  MOVLB  3
08BCE:  MOVFF  3E5,FE9
08BD2:  MOVFF  3E6,FEA
08BD6:  MOVFF  FEF,FD
08BDA:  MOVFF  FEC,FE
08BDE:  MOVFF  FEC,FF
08BE2:  MOVFF  FEC,100
....................    txLeft = tcp_http_tx_left(); 
08BE6:  MOVFF  210,3FC
08BEA:  MOVLB  0
08BEC:  CALL   82F6
08BF0:  MOVFF  02,3EA
08BF4:  MOVFF  01,3E9
....................  
....................    if (!txLeft) 
08BF8:  MOVLB  3
08BFA:  MOVF   xE9,W
08BFC:  IORWF  xEA,W
08BFE:  BNZ   8C06
....................    { 
....................       debug_mpfs2(debug_putc, "\r\nTCPPutFileConstChunk() txleft=0 "); 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
08C00:  MOVLW  01
08C02:  MOVWF  01
08C04:  BRA    8C76
....................    } 
....................     
....................    stopC=TCPPutFileParseConst(retAddy, txLeft, isPix); 
08C06:  MOVFF  3E6,3ED
08C0A:  MOVFF  3E5,3EC
08C0E:  MOVFF  3EA,3EF
08C12:  MOVFF  3E9,3EE
08C16:  MOVFF  3E7,3F0
08C1A:  MOVLB  0
08C1C:  BRA    8A24
08C1E:  MOVFF  01,3E8
....................     
....................    if (stopC == '%'&&!isPix) 
08C22:  MOVLB  3
08C24:  MOVF   xE8,W
08C26:  SUBLW  25
08C28:  BNZ   8C34
08C2A:  MOVF   xE7,F
08C2C:  BNZ   8C34
....................    { 
....................       ec = TCP_PUT_CONST_EC_ESCAPE; 
08C2E:  MOVLW  02
08C30:  MOVWF  xEB
....................    } 
08C32:  BRA    8C38
....................    else 
....................    { 
....................       ec = TCP_PUT_CONST_EC_CONTINUE; 
08C34:  MOVLW  01
08C36:  MOVWF  xEB
....................    } 
....................     
....................    if(MPFSIsEOF())//EOF 
08C38:  MOVLB  0
08C3A:  INCFSZ xFD,W
08C3C:  BRA    8C58
08C3E:  INCFSZ xFE,W
08C40:  BRA    8C58
08C42:  INCFSZ xFF,W
08C44:  BRA    8C58
08C46:  MOVLB  1
08C48:  INCFSZ x00,W
08C4A:  BRA    8C4E
08C4C:  BRA    8C52
08C4E:  MOVLB  0
08C50:  BRA    8C58
....................    { 
....................       ec = TCP_PUT_CONST_EC_FINISH; 
08C52:  MOVLB  3
08C54:  CLRF   xEB
08C56:  MOVLB  0
....................    } 
....................     
....................    debug_mpfs2(debug_putc, "\r\nTCPPutFileConstChunk() stop=%X isPix=%U ec=%X eof=%U ", stopC, isPix, ec, MPFSIsEOF()); 
....................     
....................    *retAddy = MPFSGetEnd(); 
08C58:  MOVLB  3
08C5A:  MOVFF  3E5,FE9
08C5E:  MOVFF  3E6,FEA
08C62:  MOVFF  FD,FEF
08C66:  MOVFF  FE,FEC
08C6A:  MOVFF  FF,FEC
08C6E:  MOVFF  100,FEC
....................     
....................    return(ec); 
08C72:  MOVFF  3EB,01
08C76:  MOVLB  0
08C78:  GOTO   972A (RETURN)
.................... } 
....................  
....................  
.................... #if HTTP_USE_TRIPLE_ESCAPE 
.................... unsigned int16 
.................... #else 
.................... unsigned int8 
.................... #endif 
.................... TCPPutFileConstGetEscape(MPFS* fstream) 
.................... { 
.................... #if HTTP_USE_TRIPLE_ESCAPE 
....................    char str[4]; 
....................    uint16_t ret; 
....................    MPFSGetBegin(*fstream); 
....................    str[0]=MPFSGet(); 
....................    str[1]=MPFSGet(); 
....................    str[2]=MPFSGet(); 
....................    str[3] = 0; 
....................    ret = strtol(str, 0, 16); 
.................... #elif HTTP_USE_DOUBLE_ESCAPE 
....................    char str[3]; 
....................    unsigned int ret; 
....................    MPFSGetBegin(*fstream); 
*
090AE:  MOVLB  3
090B0:  MOVFF  3E4,FE9
090B4:  MOVFF  3E5,FEA
090B8:  MOVFF  FEF,FD
090BC:  MOVFF  FEC,FE
090C0:  MOVFF  FEC,FF
090C4:  MOVFF  FEC,100
....................    str[0]=MPFSGet(); 
090C8:  MOVLB  0
090CA:  CALL   88BA
090CE:  MOVFF  01,3E6
....................    str[1]=MPFSGet(); 
090D2:  CALL   88BA
090D6:  MOVFF  01,3E7
....................    //myfatseek(fstream, -2); 
....................  
....................    str[2] = 0; 
090DA:  MOVLB  3
090DC:  CLRF   xE8
....................    ret = strtol(str, 0, 16); 
090DE:  MOVLW  03
090E0:  MOVWF  xEC
090E2:  MOVLW  E6
090E4:  MOVWF  xEB
090E6:  CLRF   xEE
090E8:  CLRF   xED
090EA:  CLRF   xF0
090EC:  MOVLW  10
090EE:  MOVWF  xEF
090F0:  MOVLB  0
090F2:  BRA    8C7C
090F4:  MOVFF  01,3EA
090F8:  MOVFF  00,3E9
.................... #else 
....................    char ret; 
....................    //printf(UserPutc, "\r\nTCPPutFileConstGetEscape() st=%LX ", *fstream); 
....................    MPFSGetBegin(*fstream); 
....................    ret=MPFSGet(); 
....................    //MPFSGetEnd(fstream); 
....................    //myfatseek(fstream, -1);//"replace" that char to the stream 
.................... #endif 
....................    *fstream = MPFSGetEnd(); 
090FC:  MOVLB  3
090FE:  MOVFF  3E4,FE9
09102:  MOVFF  3E5,FEA
09106:  MOVFF  FD,FEF
0910A:  MOVFF  FE,FEC
0910E:  MOVFF  FF,FEC
09112:  MOVFF  100,FEC
....................    //printf(UserPutc, "ret=%X end=%LX ", ret, *fstream); 
....................    return(ret); 
09116:  MOVFF  3E9,01
0911A:  MOVLB  0
0911C:  GOTO   975C (RETURN)
.................... } 
....................  
.................... int1 tcp_http_put_file(unsigned int16 errorCode, MPFS* MMCfile, char* fname) 
.................... { 
....................    static char str[HTTP_NUM_SOCKETS][HTTP_ESCAPED_STR_SIZE]; 
....................    char ec; 
....................   #if HTTP_USE_TRIPLE_ESCAPE 
....................    unsigned int16 escaped; 
....................   #else 
....................    unsigned int8 escaped; 
....................   #endif 
....................  
....................    MPFS position;    
....................  
....................    static enum 
....................    { 
....................       HTTP_PUT_FILE_INIT = 0, 
....................       HTTP_PUT_FILE_CONTINUE, 
....................       HTTP_PUT_FILE_CHUNK_END, 
....................       HTTP_PUT_FILE_DONE 
....................    } status[HTTP_NUM_SOCKETS]; 
....................     
....................    MPFSGetBegin(*MMCfile);  
*
09324:  MOVLB  3
09326:  MOVFF  3D8,FE9
0932A:  MOVFF  3D9,FEA
0932E:  MOVFF  FEF,FD
09332:  MOVFF  FEC,FE
09336:  MOVFF  FEC,FF
0933A:  MOVFF  FEC,100
....................       
....................    position = MPFSTell()-MPFSFileTell(); 
0933E:  MOVLB  2
09340:  MOVF   x08,W
09342:  MOVLB  0
09344:  SUBWF  xFD,W
09346:  MOVLB  3
09348:  MOVWF  xDE
0934A:  MOVLB  2
0934C:  MOVF   x09,W
0934E:  MOVLB  0
09350:  SUBWFB xFE,W
09352:  MOVLB  3
09354:  MOVWF  xDF
09356:  MOVLB  2
09358:  MOVF   x0A,W
0935A:  MOVLB  0
0935C:  SUBWFB xFF,W
0935E:  MOVLB  3
09360:  MOVWF  xE0
09362:  MOVLB  2
09364:  MOVF   x0B,W
09366:  MOVLB  1
09368:  SUBWFB x00,W
0936A:  MOVLB  3
0936C:  MOVWF  xE1
....................  
....................    debug_html(debug_html_putc, "\r\n** PUT FILE W%U/S%U '%s' EC=%LU MRK=%LX POS=%LX LASTVAR=%LX STATUS=%U ", g_HttpCurrConn, g_HttpCurrSocket, fname, errorCode, *MMCfile, position, lastHTTPPutVarPos[g_HttpCurrConn], status[g_HttpCurrConn]); 
....................    if(position == 0) 
0936E:  MOVF   xDE,F
09370:  BTFSS  FD8.2
09372:  BRA    9610
09374:  MOVF   xDF,F
09376:  BTFSS  FD8.2
09378:  BRA    9610
0937A:  MOVF   xE0,F
0937C:  BTFSS  FD8.2
0937E:  BRA    9610
09380:  MOVF   xE1,F
09382:  BTFSS  FD8.2
09384:  BRA    9610
....................    { 
....................       lastHTTPPutVarPos[g_HttpCurrConn] = 0; 
09386:  BCF    FD8.0
09388:  MOVLB  2
0938A:  RLCF   x11,W
0938C:  CLRF   03
0938E:  ADDLW  16
09390:  MOVWF  FE9
09392:  MOVLW  02
09394:  ADDWFC 03,W
09396:  MOVWF  FEA
09398:  CLRF   FEC
0939A:  MOVF   FED,F
0939C:  CLRF   FEF
....................       lastHTTPPutConstPos[g_HttpCurrConn] = *MMCfile; 
0939E:  MOVF   x11,W
093A0:  MULLW  04
093A2:  MOVF   FF3,W
093A4:  CLRF   03
093A6:  ADDLW  12
093A8:  MOVWF  01
093AA:  MOVLW  02
093AC:  ADDWFC 03,F
093AE:  MOVFF  01,3E2
093B2:  MOVLB  3
093B4:  MOVFF  03,3E3
093B8:  MOVFF  3D8,FE9
093BC:  MOVFF  3D9,FEA
093C0:  MOVFF  FEF,00
093C4:  MOVFF  FEC,01
093C8:  MOVFF  FEC,02
093CC:  MOVFF  FEC,03
093D0:  MOVFF  3E3,FEA
093D4:  MOVFF  3E2,FE9
093D8:  MOVFF  00,FEF
093DC:  MOVFF  01,FEC
093E0:  MOVFF  02,FEC
093E4:  MOVFF  03,FEC
....................       status[g_HttpCurrConn] = HTTP_PUT_FILE_CONTINUE; 
093E8:  CLRF   03
093EA:  MOVLB  2
093EC:  MOVF   x11,W
093EE:  ADDLW  43
093F0:  MOVWF  FE9
093F2:  MOVLW  03
093F4:  ADDWFC 03,W
093F6:  MOVWF  FEA
093F8:  MOVLW  01
093FA:  MOVWF  FEF
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
....................     #else 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
093FC:  MOVLW  CE
093FE:  MOVWF  FF6
09400:  MOVLW  00
09402:  MOVWF  FF7
09404:  MOVLW  00
09406:  MOVWF  FF8
09408:  MOVLW  09
0940A:  MOVLB  3
0940C:  MOVWF  xE2
0940E:  MOVLB  0
09410:  GOTO   8518
09414:  MOVLW  10
09416:  MOVWF  FE9
09418:  MOVFF  3D7,3E3
0941C:  MOVFF  3D6,3E2
09420:  GOTO   854A
09424:  MOVLW  20
09426:  MOVLB  3
09428:  MOVWF  xF7
0942A:  MOVLB  0
0942C:  CALL   8506
....................     #endif 
....................  
....................       switch(errorCode) 
09430:  MOVLB  3
09432:  MOVF   xD6,W
09434:  MOVWF  00
09436:  MOVF   xD7,W
09438:  MOVWF  03
0943A:  MOVF   03,W
0943C:  BNZ   9448
0943E:  MOVLW  C8
09440:  SUBWF  00,W
09442:  MOVLB  0
09444:  BZ    947A
09446:  MOVLB  3
09448:  MOVLW  01
0944A:  SUBWF  03,W
0944C:  BNZ   9458
0944E:  MOVLW  91
09450:  SUBWF  00,W
09452:  MOVLB  0
09454:  BZ    9494
09456:  MOVLB  3
09458:  MOVLW  01
0945A:  SUBWF  03,W
0945C:  BNZ   9468
0945E:  MOVLW  94
09460:  SUBWF  00,W
09462:  MOVLB  0
09464:  BZ    94A6
09466:  MOVLB  3
09468:  MOVLW  01
0946A:  SUBWF  03,W
0946C:  BNZ   9478
0946E:  MOVLW  F4
09470:  SUBWF  00,W
09472:  MOVLB  0
09474:  BZ    94B8
09476:  MOVLB  3
09478:  BRA    94CC
....................       { 
....................          case 200: 
....................             printf(tcp_http_putc,"OK"); 
0947A:  MOVLW  4F
0947C:  MOVLB  3
0947E:  MOVWF  xF7
09480:  MOVLB  0
09482:  CALL   8506
09486:  MOVLW  4B
09488:  MOVLB  3
0948A:  MOVWF  xF7
0948C:  MOVLB  0
0948E:  CALL   8506
....................             break; 
09492:  BRA    94CE
....................         #if HTTP_LAST_MODIFIED_CHECK 
....................          case 304: 
....................             printf(tcp_http_putc, "Not Modified"); 
....................             break; 
....................         #endif 
....................          case 401: 
....................             printf(tcp_http_putc,"Authorization Required"); 
09494:  MOVLW  DC
09496:  MOVWF  FF6
09498:  MOVLW  00
0949A:  MOVWF  FF7
0949C:  MOVLW  00
0949E:  MOVWF  FF8
094A0:  CALL   8612
....................             break; 
094A4:  BRA    94CE
....................          case 404: 
....................             printf(tcp_http_putc,"Not Found"); 
094A6:  MOVLW  F4
094A8:  MOVWF  FF6
094AA:  MOVLW  00
094AC:  MOVWF  FF7
094AE:  MOVLW  00
094B0:  MOVWF  FF8
094B2:  CALL   8612
....................             break; 
094B6:  BRA    94CE
....................          case 500: 
....................             printf(tcp_http_putc,"Server Error"); 
094B8:  MOVLW  FE
094BA:  MOVWF  FF6
094BC:  MOVLW  00
094BE:  MOVWF  FF7
094C0:  MOVLW  00
094C2:  MOVWF  FF8
094C4:  CALL   8612
....................             break; 
094C8:  BRA    94CE
094CA:  MOVLB  3
....................          default: 
....................             break; 
094CC:  MOVLB  0
....................       } 
....................       printf(tcp_http_putc, "\r\n"); 
094CE:  MOVLW  0D
094D0:  MOVLB  3
094D2:  MOVWF  xF7
094D4:  MOVLB  0
094D6:  CALL   8506
094DA:  MOVLW  0A
094DC:  MOVLB  3
094DE:  MOVWF  xF7
094E0:  MOVLB  0
094E2:  CALL   8506
....................        
....................      #if HTTP_USE_AUTHENTICATION 
....................       if (errorCode==401) 
....................          printf(tcp_http_putc, "WWW-Authenticate: Basic realm=\"Authorization Required\"\r\n"); 
....................      #endif 
....................  
....................       printf(tcp_http_putc, "Content-Type: "); 
094E6:  MOVLW  0C
094E8:  MOVWF  FF6
094EA:  MOVLW  01
094EC:  MOVWF  FF7
094EE:  MOVLW  00
094F0:  MOVWF  FF8
094F2:  CALL   8612
....................       strcpypgm2ram(&str[g_HttpCurrConn][0], &gc_MimeTypesHeader[g_HTTPMimeType[g_HttpCurrConn]][0]); 
094F6:  MOVLB  2
094F8:  MOVF   x11,W
094FA:  MULLW  28
094FC:  MOVF   FF3,W
094FE:  MOVLB  3
09500:  CLRF   xE3
09502:  MOVWF  xE2
09504:  MOVLW  1B
09506:  ADDWF  xE2,W
09508:  MOVWF  01
0950A:  MOVLW  03
0950C:  ADDWFC xE3,W
0950E:  MOVWF  03
09510:  MOVFF  01,3E4
09514:  MOVWF  xE5
09516:  CLRF   03
09518:  MOVLB  2
0951A:  MOVF   x11,W
0951C:  ADDLW  18
0951E:  MOVWF  FE9
09520:  MOVLW  02
09522:  ADDWFC 03,W
09524:  MOVWF  FEA
09526:  MOVF   FEF,W
09528:  MULLW  0D
0952A:  MOVF   FF3,W
0952C:  MOVLB  3
0952E:  CLRF   xE7
09530:  MOVWF  xE6
09532:  MOVLW  54
09534:  ADDWF  xE6,W
09536:  MOVWF  xE8
09538:  MOVLW  66
0953A:  ADDWFC xE7,W
0953C:  MOVWF  xE9
0953E:  MOVLW  01
09540:  MOVWF  xEA
09542:  BCF    FD8.2
09544:  BTFSC  FD8.0
09546:  INCF   xEA,F
09548:  CLRF   xEB
0954A:  MOVFF  3E5,3ED
0954E:  MOVFF  01,3EC
09552:  MOVFF  3EB,3F1
09556:  MOVFF  3EA,3F0
0955A:  MOVFF  3E9,3EF
0955E:  MOVFF  3E8,3EE
09562:  MOVLB  0
09564:  CALL   818C
....................       printf(tcp_http_putc, "%s\r\n", str[g_HttpCurrConn]); 
09568:  MOVLB  2
0956A:  MOVF   x11,W
0956C:  MULLW  28
0956E:  MOVF   FF3,W
09570:  CLRF   03
09572:  ADDLW  1B
09574:  MOVWF  01
09576:  MOVLW  03
09578:  ADDWFC 03,F
0957A:  MOVFF  01,3E2
0957E:  MOVFF  03,3E3
09582:  MOVFF  03,FEA
09586:  MOVFF  01,FE9
0958A:  MOVLB  0
0958C:  GOTO   863A
09590:  MOVLW  0D
09592:  MOVLB  3
09594:  MOVWF  xF7
09596:  MOVLB  0
09598:  CALL   8506
0959C:  MOVLW  0A
0959E:  MOVLB  3
095A0:  MOVWF  xF7
095A2:  MOVLB  0
095A4:  CALL   8506
....................        
....................       debug_html(debug_html_putc, " content='%s'(%u) ", str[g_HttpCurrConn], g_HTTPMimeType[g_HttpCurrConn]); 
....................        
....................       if (IsImage(g_HttpCurrConn)) 
095A8:  CLRF   03
095AA:  MOVLB  2
095AC:  MOVF   x11,W
095AE:  ADDLW  18
095B0:  MOVWF  FE9
095B2:  MOVLW  02
095B4:  ADDWFC 03,W
095B6:  MOVWF  FEA
095B8:  MOVF   FEF,W
095BA:  SUBLW  03
095BC:  BC    95D4
....................       { 
....................          printf(tcp_http_putc, "Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\r\n"); 
095BE:  MOVLW  1C
095C0:  MOVWF  FF6
095C2:  MOVLW  01
095C4:  MOVWF  FF7
095C6:  MOVLW  00
095C8:  MOVWF  FF8
095CA:  MOVLB  0
095CC:  CALL   8612
....................       } 
095D0:  BRA    95E6
095D2:  MOVLB  2
....................       else 
....................       { 
....................          printf(tcp_http_putc, "Cache-Control: no-cache\r\n"); 
095D4:  MOVLW  4C
095D6:  MOVWF  FF6
095D8:  MOVLW  01
095DA:  MOVWF  FF7
095DC:  MOVLW  00
095DE:  MOVWF  FF8
095E0:  MOVLB  0
095E2:  CALL   8612
....................       } 
....................  
....................      #if !HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc, "Connection: close\r\n"); 
095E6:  MOVLW  66
095E8:  MOVWF  FF6
095EA:  MOVLW  01
095EC:  MOVWF  FF7
095EE:  MOVLW  00
095F0:  MOVWF  FF8
095F2:  CALL   8612
....................      #endif 
....................  
....................       printf(tcp_http_putc, "\r\n"); 
095F6:  MOVLW  0D
095F8:  MOVLB  3
095FA:  MOVWF  xF7
095FC:  MOVLB  0
095FE:  CALL   8506
09602:  MOVLW  0A
09604:  MOVLB  3
09606:  MOVWF  xF7
09608:  MOVLB  0
0960A:  CALL   8506
0960E:  MOVLB  3
....................    } 
....................     
....................   #if HTTP_LAST_MODIFIED_CHECK 
....................    if (errorCode == 304) 
....................    { 
....................       TCPFlush(socket); 
....................       return(TRUE); 
....................    } 
....................   #endif 
....................     
....................    if (errorCode==500) 
09610:  MOVF   xD6,W
09612:  SUBLW  F4
09614:  BNZ   9666
09616:  DECFSZ xD7,W
09618:  BRA    9666
....................    { 
....................       sprintf(fname, "%s", HTTP_500_ERROR_FNAME); 
0961A:  MOVFF  3DB,345
0961E:  MOVFF  3DA,344
09622:  MOVLW  7A
09624:  MOVWF  FF6
09626:  MOVLW  01
09628:  MOVWF  FF7
0962A:  MOVLW  00
0962C:  MOVWF  FF8
0962E:  MOVLB  0
09630:  CALL   7906
....................       if(!FileExists(fname)) 
09634:  MOVFF  3DB,3E3
09638:  MOVFF  3DA,3E2
0963C:  CALL   7C06
09640:  MOVF   01,W
09642:  IORWF  02,W
09644:  BNZ   9664
....................       { 
....................          printf(tcp_http_putc, "%s", HTML_500_FILE_CONTENTS); 
09646:  MOVLW  88
09648:  MOVWF  FF6
0964A:  MOVLW  01
0964C:  MOVWF  FF7
0964E:  MOVLW  00
09650:  MOVWF  FF8
09652:  CALL   8612
....................          TCPFlush(g_HttpCurrSocket); 
09656:  MOVFF  210,3FC
0965A:  CALL   83A4
....................          return(TRUE); 
0965E:  MOVLW  01
09660:  MOVWF  01
09662:  BRA    98B2
09664:  MOVLB  3
....................       } 
....................    } 
....................  
....................    debug_mpfs2(debug_putc, "\r\nVAR START ST=%X ", status[g_HttpCurrConn]); 
....................  
....................    if (lastHTTPPutVarPos[g_HttpCurrConn]!=0) 
09666:  BCF    FD8.0
09668:  MOVLB  2
0966A:  RLCF   x11,W
0966C:  CLRF   03
0966E:  ADDLW  16
09670:  MOVWF  FE9
09672:  MOVLW  02
09674:  ADDWFC 03,W
09676:  MOVWF  FEA
09678:  MOVFF  FEC,3E3
0967C:  MOVF   FED,F
0967E:  MOVFF  FEF,3E2
09682:  MOVLB  3
09684:  MOVF   xE2,F
09686:  BNZ   968C
09688:  MOVF   xE3,F
0968A:  BZ    96CC
....................    { 
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[g_HttpCurrConn]); 
0968C:  BCF    FD8.0
0968E:  MOVLB  2
09690:  RLCF   x11,W
09692:  CLRF   03
09694:  ADDLW  16
09696:  MOVWF  01
09698:  MOVLW  02
0969A:  ADDWFC 03,F
0969C:  MOVFF  01,3E2
096A0:  MOVFF  03,3E3
096A4:  MOVFF  03,3E5
096A8:  MOVFF  01,3E4
096AC:  MOVLB  0
096AE:  CALL   8660
....................       lastHTTPPutVarPos[g_HttpCurrConn] = 0; 
096B2:  BCF    FD8.0
096B4:  MOVLB  2
096B6:  RLCF   x11,W
096B8:  CLRF   03
096BA:  ADDLW  16
096BC:  MOVWF  FE9
096BE:  MOVLW  02
096C0:  ADDWFC 03,W
096C2:  MOVWF  FEA
096C4:  CLRF   FEC
096C6:  MOVF   FED,F
096C8:  CLRF   FEF
096CA:  MOVLB  3
....................    } 
....................  
....................    debug_mpfs2(debug_putc, "\r\nPUT START ST=%X ", status[g_HttpCurrConn]); 
....................  
....................    if (status[g_HttpCurrConn] == HTTP_PUT_FILE_CONTINUE) 
096CC:  CLRF   03
096CE:  MOVLB  2
096D0:  MOVF   x11,W
096D2:  ADDLW  43
096D4:  MOVWF  FE9
096D6:  MOVLW  03
096D8:  ADDWFC 03,W
096DA:  MOVWF  FEA
096DC:  DECFSZ FEF,W
096DE:  BRA    983E
....................    { 
....................       for(;;) 
....................       { 
....................          //printf(UserPutc, "\r\nHTTP Put Const st=%LX ", lastHTTPPutConstPos[g_HttpCurrConn]); 
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[g_HttpCurrConn], IsImage(g_HttpCurrConn)); 
096E0:  MOVF   x11,W
096E2:  MULLW  04
096E4:  MOVF   FF3,W
096E6:  CLRF   03
096E8:  ADDLW  12
096EA:  MOVWF  01
096EC:  MOVLW  02
096EE:  ADDWFC 03,F
096F0:  MOVFF  01,3E2
096F4:  MOVLB  3
096F6:  MOVFF  03,3E3
096FA:  CLRF   03
096FC:  MOVLB  2
096FE:  MOVF   x11,W
09700:  ADDLW  18
09702:  MOVWF  FE9
09704:  MOVLW  02
09706:  ADDWFC 03,W
09708:  MOVWF  FEA
0970A:  MOVF   FEF,W
0970C:  SUBLW  03
0970E:  BNC   9714
09710:  MOVLW  00
09712:  BRA    9716
09714:  MOVLW  01
09716:  MOVLB  3
09718:  MOVWF  xE4
0971A:  MOVFF  3E3,3E6
0971E:  MOVFF  3E2,3E5
09722:  MOVWF  xE7
09724:  MOVLB  0
09726:  GOTO   8BCC
0972A:  MOVFF  01,3DC
....................          //printf(UserPutc, "end=%LX\r\n", lastHTTPPutConstPos[g_HttpCurrConn]); 
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE)//&is_image 
0972E:  MOVLB  3
09730:  MOVF   xDC,W
09732:  SUBLW  02
09734:  BNZ   9818
....................          { 
....................             HTTP_INTERRUPT_TASKS(); 
....................             escaped = TCPPutFileConstGetEscape(&lastHTTPPutConstPos[g_HttpCurrConn]);//// 
09736:  MOVLB  2
09738:  MOVF   x11,W
0973A:  MULLW  04
0973C:  MOVF   FF3,W
0973E:  CLRF   03
09740:  ADDLW  12
09742:  MOVWF  01
09744:  MOVLW  02
09746:  ADDWFC 03,F
09748:  MOVFF  01,3E2
0974C:  MOVFF  03,3E3
09750:  MOVFF  03,3E5
09754:  MOVFF  01,3E4
09758:  MOVLB  0
0975A:  BRA    90AE
0975C:  MOVFF  01,3DD
....................             http_format_char(fname, escaped, &str[g_HttpCurrConn][0], (sizeof(str)/HTTP_NUM_SOCKETS)-1); 
09760:  MOVLB  2
09762:  MOVF   x11,W
09764:  MULLW  28
09766:  MOVF   FF3,W
09768:  MOVLB  3
0976A:  CLRF   xE3
0976C:  MOVWF  xE2
0976E:  MOVLW  1B
09770:  ADDWF  xE2,W
09772:  MOVWF  01
09774:  MOVLW  03
09776:  ADDWFC xE3,W
09778:  MOVWF  03
0977A:  MOVFF  01,3E4
0977E:  MOVWF  xE5
09780:  MOVFF  3DB,3E7
09784:  MOVFF  3DA,3E6
09788:  MOVFF  3DD,3E8
0978C:  MOVWF  xEA
0978E:  MOVFF  01,3E9
09792:  MOVLW  27
09794:  MOVWF  xEB
09796:  MOVLB  0
09798:  BRA    91CE
....................             lastHTTPPutVarPos[g_HttpCurrConn] = &str[g_HttpCurrConn][0]; 
0979A:  BCF    FD8.0
0979C:  MOVLB  2
0979E:  RLCF   x11,W
097A0:  CLRF   03
097A2:  ADDLW  16
097A4:  MOVWF  FE9
097A6:  MOVLW  02
097A8:  ADDWFC 03,W
097AA:  MOVWF  FEA
097AC:  MOVF   x11,W
097AE:  MULLW  28
097B0:  MOVF   FF3,W
097B2:  MOVLB  3
097B4:  CLRF   xE5
097B6:  MOVWF  xE4
097B8:  MOVLW  1B
097BA:  ADDWF  xE4,W
097BC:  MOVWF  FEF
097BE:  MOVLW  03
097C0:  ADDWFC xE5,W
097C2:  MOVWF  FEC
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[g_HttpCurrConn]); 
097C4:  BCF    FD8.0
097C6:  MOVLB  2
097C8:  RLCF   x11,W
097CA:  CLRF   03
097CC:  ADDLW  16
097CE:  MOVWF  01
097D0:  MOVLW  02
097D2:  ADDWFC 03,F
097D4:  MOVFF  01,3E2
097D8:  MOVFF  03,3E3
097DC:  MOVFF  03,3E5
097E0:  MOVFF  01,3E4
097E4:  MOVLB  0
097E6:  CALL   8660
097EA:  MOVFF  01,3DC
....................             //printf(UserPutc, "\r\n** HTTP PUT VAR ec=%U escape=0x%LX str='%s' start=0x%LX end=0x%LX status=%U", 
....................             debug_html(debug_html_putc, "\r\n** HTTP PUT VAR ec=%U escape=0x%LX str='%s' start=0x%LX end=0x%LX status=%U", 
....................                   ec, 
....................                   escaped, 
....................                   str[g_HttpCurrConn], 
....................                   &str[g_HttpCurrConn][0], 
....................                   lastHTTPPutVarPos[g_HttpCurrConn], 
....................                   status[g_HttpCurrConn] 
....................                ); 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
097EE:  MOVLB  3
097F0:  MOVF   xDC,F
097F2:  BNZ   9810
....................                lastHTTPPutVarPos[g_HttpCurrConn] = 0; 
097F4:  BCF    FD8.0
097F6:  MOVLB  2
097F8:  RLCF   x11,W
097FA:  CLRF   03
097FC:  ADDLW  16
097FE:  MOVWF  FE9
09800:  MOVLW  02
09802:  ADDWFC 03,W
09804:  MOVWF  FEA
09806:  CLRF   FEC
09808:  MOVF   FED,F
0980A:  CLRF   FEF
0980C:  BRA    9814
0980E:  MOVLB  3
....................             else 
....................                break; 
09810:  BRA    9840
09812:  MOVLB  2
....................          } 
09814:  BRA    9836
09816:  MOVLB  3
....................          else 
....................          { 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
09818:  MOVF   xDC,F
0981A:  BNZ   9832
....................                status[g_HttpCurrConn] = HTTP_PUT_FILE_CHUNK_END; 
0981C:  CLRF   03
0981E:  MOVLB  2
09820:  MOVF   x11,W
09822:  ADDLW  43
09824:  MOVWF  FE9
09826:  MOVLW  03
09828:  ADDWFC 03,W
0982A:  MOVWF  FEA
0982C:  MOVLW  02
0982E:  MOVWF  FEF
09830:  MOVLB  3
....................             break; 
09832:  BRA    9840
09834:  MOVLB  2
....................          } 
....................          //debug_printf(debug_putc, "\r\nHTTP INTR "); 
....................          HTTP_INTERRUPT_TASKS(); 
....................          //debug_printf(debug_putc "DONE "); 
....................          break; 
09836:  MOVLB  3
09838:  BRA    9840
0983A:  MOVLB  2
0983C:  BRA    96E0
0983E:  MOVLB  3
....................       } 
....................    } 
....................     
....................    debug_mpfs2(debug_putc, "\r\nPUT END ST=%X ", status[g_HttpCurrConn]); 
....................  
....................    if (status[g_HttpCurrConn] == HTTP_PUT_FILE_CHUNK_END) 
09840:  CLRF   03
09842:  MOVLB  2
09844:  MOVF   x11,W
09846:  ADDLW  43
09848:  MOVWF  FE9
0984A:  MOVLW  03
0984C:  ADDWFC 03,W
0984E:  MOVWF  FEA
09850:  MOVF   FEF,W
09852:  SUBLW  02
09854:  BNZ   9868
....................    { 
....................      #if HTTP_USE_CHUNKS 
....................       if (tcp_http_tx_left() > 8) 
....................       { 
....................          TCPPutFileChunkStart(0); 
....................          TCPPutFileChunkStop(); 
....................          status[which] = HTTP_PUT_FILE_DONE; 
....................       } 
....................      #else 
....................       status[g_HttpCurrConn] = HTTP_PUT_FILE_DONE; 
09856:  CLRF   03
09858:  MOVF   x11,W
0985A:  ADDLW  43
0985C:  MOVWF  FE9
0985E:  MOVLW  03
09860:  ADDWFC 03,W
09862:  MOVWF  FEA
09864:  MOVLW  03
09866:  MOVWF  FEF
....................      #endif 
....................    } 
....................  
....................    *MMCfile = MPFSGetEnd(); 
09868:  MOVLB  3
0986A:  MOVFF  3D8,FE9
0986E:  MOVFF  3D9,FEA
09872:  MOVFF  FD,FEF
09876:  MOVFF  FE,FEC
0987A:  MOVFF  FF,FEC
0987E:  MOVFF  100,FEC
....................    //printf("\r\nFLUSH W%u/S%u/T%u", which,socket,_httpPutcSocket); 
....................    //printf(" RETURN=%U\r\n", ec); 
....................    debug_html(debug_html_putc, "\r\nHTML Flush status=%U ", status[g_HttpCurrConn]); 
....................     
....................    if (status[g_HttpCurrConn] == HTTP_PUT_FILE_DONE) 
09882:  CLRF   03
09884:  MOVLB  2
09886:  MOVF   x11,W
09888:  ADDLW  43
0988A:  MOVWF  FE9
0988C:  MOVLW  03
0988E:  ADDWFC 03,W
09890:  MOVWF  FEA
09892:  MOVF   FEF,W
09894:  SUBLW  03
09896:  BNZ   98AC
....................    { 
....................       TCPFlush(g_HttpCurrSocket); 
09898:  MOVFF  210,3FC
0989C:  MOVLB  0
0989E:  CALL   83A4
....................       return(TRUE); 
098A2:  MOVLW  01
098A4:  MOVWF  01
098A6:  BRA    98B2
....................    } 
098A8:  BRA    98B2
098AA:  MOVLB  2
....................    else 
....................    { 
....................       return(FALSE); 
098AC:  MOVLW  00
098AE:  MOVWF  01
098B0:  MOVLB  0
....................    } 
098B2:  GOTO   A566 (RETURN)
.................... } 
....................  
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack 
.................... void HTTPInit(void) { 
....................    int8 i; 
....................    //fprintf(USER,"\r\nHTTP OPENING"); 
....................    if (HTTP_PORT != 0) 
....................    { 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
*
0146C:  MOVLB  3
0146E:  CLRF   xC0
01470:  BTFSC  xC0.7
01472:  BRA    147A
01474:  MOVF   xC0,W
01476:  SUBLW  00
01478:  BNC   14EE
....................       { 
....................          http_state[i]=HTTP_DISABLED; 
0147A:  CLRF   03
0147C:  MOVF   xC0,W
0147E:  ADDLW  0F
01480:  MOVWF  FE9
01482:  MOVLW  02
01484:  ADDWFC 03,W
01486:  MOVWF  FEA
01488:  SETF   FEF
....................           
....................          http_socket[i]=TCPOpen(0, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER); 
0148A:  CLRF   03
0148C:  MOVF   xC0,W
0148E:  ADDLW  0E
01490:  MOVWF  01
01492:  MOVLW  02
01494:  ADDWFC 03,F
01496:  MOVFF  01,3C1
0149A:  MOVFF  03,3C2
0149E:  CLRF   xC6
014A0:  CLRF   xC5
014A2:  CLRF   xC4
014A4:  CLRF   xC3
014A6:  CLRF   xC7
014A8:  CLRF   xC9
014AA:  MOVLW  50
014AC:  MOVWF  xC8
014AE:  MOVLW  08
014B0:  MOVWF  xCA
014B2:  MOVLB  0
014B4:  BRA    13F4
014B6:  MOVFF  3C2,FEA
014BA:  MOVFF  3C1,FE9
014BE:  MOVFF  01,FEF
....................          //fprintf(USER,"\r\nHTTP SOCKET=%X", http_socket[i]); 
....................          if (http_socket[i]!=INVALID_SOCKET) 
014C2:  CLRF   03
014C4:  MOVLB  3
014C6:  MOVF   xC0,W
014C8:  ADDLW  0E
014CA:  MOVWF  FE9
014CC:  MOVLW  02
014CE:  ADDWFC 03,W
014D0:  MOVWF  FEA
014D2:  MOVF   FEF,W
014D4:  SUBLW  FE
014D6:  BZ    14EA
....................          { 
....................             http_state[i]=HTTP_LISTEN_WAIT; 
014D8:  CLRF   03
014DA:  MOVF   xC0,W
014DC:  ADDLW  0F
014DE:  MOVWF  FE9
014E0:  MOVLW  02
014E2:  ADDWFC 03,W
014E4:  MOVWF  FEA
014E6:  MOVLW  01
014E8:  MOVWF  FEF
....................          } 
014EA:  INCF   xC0,F
014EC:  BRA    1470
....................       } 
....................    } 
....................    else 
....................    { 
....................       //fprintf(USER,"\r\nHTTP DISABLED"); 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
....................       { 
....................             http_state[i]=HTTP_DISABLED; 
....................       } 
....................    } 
014EE:  MOVLB  0
014F0:  GOTO   154E (RETURN)
.................... } 
....................  
.................... #DEFINE HTTP_INDEX_PAGE_EC 0x01 
.................... #DEFINE HTTP_FILE_PAGE_EC    0x02 
.................... #DEFINE HTTP_404_PAGE_EC    0x00 
.................... #DEFINE HTTP_401_PAGE_EC    0xFE 
.................... #DEFINE HTTP_500_PAGE_EC    0xFF 
....................  
.................... void HTTPServer(void) { 
*
0991A:  MOVLB  3
0991C:  CLRF   xC0
0991E:  CLRF   xC1
....................    static char tokens_header[]=" "; 
....................    static char tokens_get[]="?"; 
....................    static char http_get_str[]="GET"; 
....................    static char http_post_str[]="POST"; 
....................    static char http_len_str[]="Content-Length:"; 
....................    unsigned int8 j =0, l=0; 
....................     
....................    char index[]="/"; 
09920:  MOVLW  2F
09922:  MOVWF  xC2
09924:  CLRF   xC3
....................    static char page[HTTP_NUM_SOCKETS][20]; 
....................    MPFS fstream; 
....................    
....................   #if defined(__DO_DEBUG_HTML) 
....................    static unsigned int8 debug; 
....................   #endif 
....................  
....................    //static char http_keepalive_str[]="keep-alive"; 
....................    //static char http_connection_str[]="Connection"; 
....................  
....................  
....................  
....................    static unsigned int8 i[HTTP_NUM_SOCKETS]; 
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]; 
....................     
....................    static unsigned int16 http_error_code[HTTP_NUM_SOCKETS]; 
....................    static unsigned int16 http_post_len[HTTP_NUM_SOCKETS]; 
....................    static TICK http_timer[HTTP_NUM_SOCKETS]; 
....................   
....................  #if HTTP_USE_AUTHENTICATION 
....................    static char http_auth_str[]="Authorization:"; 
....................  #endif 
....................  
....................    int1 doneSend, postContinue; 
....................  
....................    char c, *pKey, *pValue; 
....................    //unsigned int8 hs, currSocket; 
....................  
....................    for (g_HttpCurrConn=0; g_HttpCurrConn<HTTP_NUM_SOCKETS; g_HttpCurrConn++) 
09926:  MOVLB  2
09928:  CLRF   x11
0992A:  MOVF   x11,F
0992C:  BTFSS  FD8.2
0992E:  GOTO   A748
....................    {      
....................       if (http_state[g_HttpCurrConn]==HTTP_DISABLED) 
09932:  CLRF   03
09934:  MOVF   x11,W
09936:  ADDLW  0F
09938:  MOVWF  FE9
0993A:  MOVLW  02
0993C:  ADDWFC 03,W
0993E:  MOVWF  FEA
09940:  INCFSZ FEF,W
09942:  BRA    9948
....................          return; 
09944:  GOTO   A748
....................  
....................       g_HttpCurrSocket = http_socket[g_HttpCurrConn]; 
09948:  CLRF   03
0994A:  MOVF   x11,W
0994C:  ADDLW  0E
0994E:  MOVWF  FE9
09950:  MOVLW  02
09952:  ADDWFC 03,W
09954:  MOVWF  FEA
09956:  MOVFF  FEF,210
....................  
....................       if (!TCPIsConnected(g_HttpCurrSocket)) 
0995A:  MOVFF  210,3CE
0995E:  MOVLB  0
09960:  CALL   6DB2
09964:  MOVF   01,F
09966:  BNZ   997E
....................          http_state[g_HttpCurrConn]=HTTP_LISTEN_WAIT; 
09968:  CLRF   03
0996A:  MOVLB  2
0996C:  MOVF   x11,W
0996E:  ADDLW  0F
09970:  MOVWF  FE9
09972:  MOVLW  02
09974:  ADDWFC 03,W
09976:  MOVWF  FEA
09978:  MOVLW  01
0997A:  MOVWF  FEF
0997C:  MOVLB  0
....................  
....................       switch(http_state[g_HttpCurrConn]) 
0997E:  CLRF   03
09980:  MOVLB  2
09982:  MOVF   x11,W
09984:  ADDLW  0F
09986:  MOVWF  FE9
09988:  MOVLW  02
0998A:  ADDWFC 03,W
0998C:  MOVWF  FEA
0998E:  MOVF   FEF,W
09990:  XORLW  01
09992:  MOVLB  0
09994:  BZ    99D8
09996:  XORLW  03
09998:  BZ    99E8
0999A:  XORLW  01
0999C:  BTFSC  FD8.2
0999E:  BRA    9A9C
099A0:  XORLW  06
099A2:  BTFSC  FD8.2
099A4:  BRA    A048
099A6:  XORLW  03
099A8:  BTFSC  FD8.2
099AA:  BRA    A0A6
099AC:  XORLW  01
099AE:  BTFSC  FD8.2
099B0:  GOTO   A35A
099B4:  XORLW  0F
099B6:  BTFSC  FD8.2
099B8:  GOTO   A4A8
099BC:  XORLW  01
099BE:  BTFSC  FD8.2
099C0:  GOTO   A620
099C4:  XORLW  03
099C6:  BTFSC  FD8.2
099C8:  GOTO   A66A
099CC:  XORLW  01
099CE:  BTFSC  FD8.2
099D0:  GOTO   A740
099D4:  GOTO   A740
....................       { 
....................          case HTTP_LISTEN_WAIT: 
....................             if (!TCPIsConnected(g_HttpCurrSocket)) 
099D8:  MOVFF  210,3CE
099DC:  CALL   6DB2
099E0:  MOVF   01,F
099E2:  BNZ   99E8
....................                break; 
099E4:  GOTO   A740
.................... //            fprintf(USER,"HTTP %U CONNECTED\r\n", hs); 
....................  
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header 
....................          case HTTP_CONNECTED: 
.................... //            fprintf(USER,"HTTP %U LISTENING\r\n", hs); 
....................             /* 
....................             printf("\r\nHTTP OPEN %U/%U ", hs, currSocket); 
....................                ui_disp_ip_user(&TCB[currSocket].remote.IPAddr) 
....................                printf(" MAC="); 
....................                ui_disp_mac_user(&TCB[currSocket].remote.MACAddr);; 
....................                printf("\r\n"); 
....................                */ 
....................                 
....................             HTTPbuffer[g_HttpCurrConn][0]=0; 
099E8:  MOVLB  2
099EA:  MOVF   x11,W
099EC:  MULLW  FE
099EE:  MOVF   FF3,W
099F0:  MOVLB  3
099F2:  CLRF   xCF
099F4:  MOVWF  xCE
099F6:  MOVLW  19
099F8:  ADDWF  xCE,W
099FA:  MOVWF  FE9
099FC:  MOVLW  02
099FE:  ADDWFC xCF,W
09A00:  MOVWF  FEA
09A02:  CLRF   FEF
....................             i[g_HttpCurrConn]=0; 
09A04:  CLRF   03
09A06:  MOVLB  2
09A08:  MOVF   x11,W
09A0A:  ADDLW  77
09A0C:  MOVWF  FE9
09A0E:  MOVLW  03
09A10:  ADDWFC 03,W
09A12:  MOVWF  FEA
09A14:  CLRF   FEF
....................             http_state[g_HttpCurrConn]=HTTP_GET_HEADERS; 
09A16:  CLRF   03
09A18:  MOVF   x11,W
09A1A:  ADDLW  0F
09A1C:  MOVWF  FE9
09A1E:  MOVLW  02
09A20:  ADDWFC 03,W
09A22:  MOVWF  FEA
09A24:  MOVLW  03
09A26:  MOVWF  FEF
....................             http_timer[g_HttpCurrConn]=TickGet(); 
09A28:  MOVF   x11,W
09A2A:  MULLW  04
09A2C:  MOVF   FF3,W
09A2E:  CLRF   03
09A30:  ADDLW  7D
09A32:  MOVWF  01
09A34:  MOVLW  03
09A36:  ADDWFC 03,F
09A38:  MOVFF  01,3CE
09A3C:  MOVFF  03,3CF
09A40:  MOVLB  0
09A42:  CALL   2424
09A46:  MOVFF  3CF,FEA
09A4A:  MOVFF  3CE,FE9
09A4E:  MOVFF  00,FEF
09A52:  MOVFF  01,FEC
09A56:  MOVFF  02,FEC
09A5A:  MOVFF  03,FEC
....................             http_page_req[g_HttpCurrConn]=0; 
09A5E:  MOVLB  2
09A60:  MOVF   x11,W
09A62:  MULLW  04
09A64:  MOVF   FF3,W
09A66:  CLRF   03
09A68:  ADDLW  17
09A6A:  MOVWF  FE9
09A6C:  MOVLW  03
09A6E:  ADDWFC 03,W
09A70:  MOVWF  FEA
09A72:  MOVF   FEE,F
09A74:  MOVF   FEE,F
09A76:  CLRF   FEC
09A78:  MOVF   FED,F
09A7A:  CLRF   FEF
09A7C:  MOVF   FED,F
09A7E:  CLRF   FEF
09A80:  MOVF   FED,F
09A82:  CLRF   FEF
....................             http_post_len[g_HttpCurrConn]=0; 
09A84:  BCF    FD8.0
09A86:  RLCF   x11,W
09A88:  CLRF   03
09A8A:  ADDLW  7B
09A8C:  MOVWF  FE9
09A8E:  MOVLW  03
09A90:  ADDWFC 03,W
09A92:  MOVWF  FEA
09A94:  CLRF   FEC
09A96:  MOVF   FED,F
09A98:  CLRF   FEF
09A9A:  MOVLB  0
....................            #if HTTP_USE_AUTHENTICATION 
....................             http_auth_user[g_HttpCurrConn][0]=0; 
....................            #endif 
....................            #if HTTP_LAST_MODIFIED_CHECK 
....................             g_lastModifiedCheck[g_HttpCurrConn] = FALSE; 
....................            #endif 
....................            debug_html(debug_html_putc, "\r\nHTML Connected %u ", g_HttpCurrConn); 
....................             //http_got_headers[hs]=FALSE; 
....................             //http_isKeepAlive[hs]=FALSE; 
....................  
....................          case HTTP_GET_HEADERS: 
....................             if(mpfsFlags.bits.bNotAvailable) 
09A9C:  MOVLB  2
09A9E:  BTFSS  x07.0
09AA0:  BRA    9AAA
....................                break; 
09AA2:  MOVLB  0
09AA4:  GOTO   A740
09AA8:  MOVLB  2
....................             postContinue=FALSE; 
09AAA:  MOVLB  3
09AAC:  BCF    xC8.1
....................             while (TCPIsGetReady(g_HttpCurrSocket) && TCPGet(g_HttpCurrSocket, &c)) 
09AAE:  MOVFF  210,3D3
09AB2:  MOVLB  0
09AB4:  CALL   6DE0
09AB8:  MOVF   01,W
09ABA:  IORWF  02,W
09ABC:  BTFSC  FD8.2
09ABE:  BRA    9F6E
09AC0:  MOVFF  210,3CE
09AC4:  MOVLW  03
09AC6:  MOVLB  3
09AC8:  MOVWF  xD0
09ACA:  MOVLW  C9
09ACC:  MOVWF  xCF
09ACE:  MOVLB  0
09AD0:  CALL   6E60
09AD4:  MOVF   01,F
09AD6:  BTFSC  FD8.2
09AD8:  BRA    9F6E
....................             { 
....................                //http_got_headers[hs]=TRUE; 
....................                if ( (c >= 0x20) && (i[g_HttpCurrConn] < HTTP_GET_PARAM_MAX_SIZE - 2) ) 
09ADA:  MOVLB  3
09ADC:  BTFSC  xC9.7
09ADE:  BRA    9B3E
09AE0:  MOVF   xC9,W
09AE2:  SUBLW  1F
09AE4:  BC    9B3E
09AE6:  CLRF   03
09AE8:  MOVLB  2
09AEA:  MOVF   x11,W
09AEC:  ADDLW  77
09AEE:  MOVWF  FE9
09AF0:  MOVLW  03
09AF2:  ADDWFC 03,W
09AF4:  MOVWF  FEA
09AF6:  MOVF   FEF,W
09AF8:  SUBLW  FB
09AFA:  BTFSC  FD8.0
09AFC:  BRA    9B02
09AFE:  MOVLB  3
09B00:  BRA    9B3E
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]++]=c; 
09B02:  MOVF   x11,W
09B04:  MULLW  FE
09B06:  MOVF   FF3,W
09B08:  MOVLB  3
09B0A:  CLRF   xCF
09B0C:  MOVWF  xCE
09B0E:  CLRF   03
09B10:  MOVLB  2
09B12:  MOVF   x11,W
09B14:  ADDLW  77
09B16:  MOVWF  FE9
09B18:  MOVLW  03
09B1A:  ADDWFC 03,W
09B1C:  MOVWF  FEA
09B1E:  MOVF   FEF,W
09B20:  INCF   FEF,F
09B22:  CLRF   03
09B24:  MOVLB  3
09B26:  ADDWF  xCE,W
09B28:  MOVWF  01
09B2A:  MOVF   xCF,W
09B2C:  ADDWFC 03,F
09B2E:  MOVF   01,W
09B30:  ADDLW  19
09B32:  MOVWF  FE9
09B34:  MOVLW  02
09B36:  ADDWFC 03,W
09B38:  MOVWF  FEA
09B3A:  MOVFF  3C9,FEF
....................                } 
....................                if (c=='\n') 
09B3E:  MOVF   xC9,W
09B40:  SUBLW  0A
09B42:  BTFSS  FD8.2
09B44:  BRA    9F6A
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]]=0; 
09B46:  MOVLB  2
09B48:  MOVF   x11,W
09B4A:  MULLW  FE
09B4C:  MOVF   FF3,W
09B4E:  MOVLB  3
09B50:  CLRF   xCF
09B52:  MOVWF  xCE
09B54:  CLRF   03
09B56:  MOVLB  2
09B58:  MOVF   x11,W
09B5A:  ADDLW  77
09B5C:  MOVWF  FE9
09B5E:  MOVLW  03
09B60:  ADDWFC 03,W
09B62:  MOVWF  FEA
09B64:  CLRF   03
09B66:  MOVF   FEF,W
09B68:  MOVLB  3
09B6A:  ADDWF  xCE,W
09B6C:  MOVWF  01
09B6E:  MOVF   xCF,W
09B70:  ADDWFC 03,F
09B72:  MOVF   01,W
09B74:  ADDLW  19
09B76:  MOVWF  FE9
09B78:  MOVLW  02
09B7A:  ADDWFC 03,W
09B7C:  MOVWF  FEA
09B7E:  CLRF   FEF
....................                   if ( 
....................                        ( ( pKey = strtok(&HTTPbuffer[g_HttpCurrConn][0], tokens_header) ) !=0 ) && 
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 ) 
09B80:  MOVLB  2
09B82:  MOVF   x11,W
09B84:  MULLW  FE
09B86:  MOVF   FF3,W
09B88:  MOVLB  3
09B8A:  CLRF   xCF
09B8C:  MOVWF  xCE
09B8E:  MOVLW  19
09B90:  ADDWF  xCE,W
09B92:  MOVWF  01
09B94:  MOVLW  02
09B96:  ADDWFC xCF,W
09B98:  MOVWF  03
09B9A:  MOVFF  01,3D0
09B9E:  MOVWF  xD1
09BA0:  MOVWF  xD3
09BA2:  MOVFF  01,3D2
09BA6:  MOVLW  03
09BA8:  MOVWF  xD5
09BAA:  MOVLW  46
09BAC:  MOVWF  xD4
09BAE:  MOVLB  0
09BB0:  CALL   701A
09BB4:  MOVFF  02,3CB
09BB8:  MOVFF  01,3CA
09BBC:  MOVLB  3
09BBE:  MOVF   xCA,F
09BC0:  BNZ   9BC8
09BC2:  MOVF   xCB,F
09BC4:  BTFSC  FD8.2
09BC6:  BRA    9EF0
09BC8:  CLRF   xD3
09BCA:  CLRF   xD2
09BCC:  MOVLW  03
09BCE:  MOVWF  xD5
09BD0:  MOVLW  46
09BD2:  MOVWF  xD4
09BD4:  MOVLB  0
09BD6:  CALL   701A
09BDA:  MOVFF  02,3CD
09BDE:  MOVFF  01,3CC
09BE2:  MOVLB  3
09BE4:  MOVF   xCC,F
09BE6:  BNZ   9BEE
09BE8:  MOVF   xCD,F
09BEA:  BTFSC  FD8.2
09BEC:  BRA    9EF0
....................                      ) 
....................                   { 
....................                      debug_html(debug_html_putc, "\r\nHTML Key/Pair '%s'/'%s' ", pKey, pValue); 
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) ) 
09BEE:  MOVFF  3CB,3CF
09BF2:  MOVFF  3CA,3CE
09BF6:  MOVLW  03
09BF8:  MOVWF  xD1
09BFA:  MOVLW  4A
09BFC:  MOVWF  xD0
09BFE:  MOVLB  0
09C00:  CALL   70CA
09C04:  MOVF   01,F
09C06:  BZ    9C26
09C08:  MOVFF  3CB,3CF
09C0C:  MOVFF  3CA,3CE
09C10:  MOVLW  03
09C12:  MOVLB  3
09C14:  MOVWF  xD1
09C16:  MOVLW  4E
09C18:  MOVWF  xD0
09C1A:  MOVLB  0
09C1C:  CALL   70CA
09C20:  MOVF   01,F
09C22:  BTFSS  FD8.2
09C24:  BRA    9E84
....................                      { 
....................                         if (strcmp(pKey, http_get_str)==0){ 
09C26:  MOVFF  3CB,3CF
09C2A:  MOVFF  3CA,3CE
09C2E:  MOVLW  03
09C30:  MOVLB  3
09C32:  MOVWF  xD1
09C34:  MOVLW  4A
09C36:  MOVWF  xD0
09C38:  MOVLB  0
09C3A:  CALL   70CA
09C3E:  MOVF   01,F
09C40:  BNZ   9C5A
....................                            http_cmd[g_HttpCurrConn]=HTTP_REQ_GET; 
09C42:  CLRF   03
09C44:  MOVLB  2
09C46:  MOVF   x11,W
09C48:  ADDLW  78
09C4A:  MOVWF  FE9
09C4C:  MOVLW  03
09C4E:  ADDWFC 03,W
09C50:  MOVWF  FEA
09C52:  MOVLW  01
09C54:  MOVWF  FEF
....................                         } 
09C56:  BRA    9C6E
09C58:  MOVLB  0
....................                         else{ 
....................                            http_cmd[g_HttpCurrConn]=HTTP_REQ_POST; 
09C5A:  CLRF   03
09C5C:  MOVLB  2
09C5E:  MOVF   x11,W
09C60:  ADDLW  78
09C62:  MOVWF  FE9
09C64:  MOVLW  03
09C66:  ADDWFC 03,W
09C68:  MOVWF  FEA
09C6A:  MOVLW  02
09C6C:  MOVWF  FEF
....................                         } 
....................                                            
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ? 
09C6E:  MOVFF  3CD,3D3
09C72:  MOVFF  3CC,3D2
09C76:  MOVLW  03
09C78:  MOVLB  3
09C7A:  MOVWF  xD5
09C7C:  MOVLW  48
09C7E:  MOVWF  xD4
09C80:  MOVLB  0
09C82:  CALL   701A
09C86:  MOVFF  02,3CD
09C8A:  MOVFF  01,3CC
....................                         http_escape_chars(pValue); 
09C8E:  MOVFF  3CD,3E0
09C92:  MOVFF  3CC,3DF
09C96:  CALL   76D0
....................  
....................                         if (stricmp(pValue,index)==0) 
09C9A:  MOVFF  3CD,3E2
09C9E:  MOVFF  3CC,3E1
09CA2:  MOVLW  03
09CA4:  MOVLB  3
09CA6:  MOVWF  xE4
09CA8:  MOVLW  C2
09CAA:  MOVWF  xE3
09CAC:  MOVLB  0
09CAE:  CALL   77B2
09CB2:  MOVF   01,F
09CB4:  BNZ   9CD0
....................                         { 
....................                            sprintf(pValue, "%s", HTML_INDEX_FNAME); 
09CB6:  MOVFF  3CD,345
09CBA:  MOVFF  3CC,344
09CBE:  MOVLW  D6
09CC0:  MOVWF  FF6
09CC2:  MOVLW  01
09CC4:  MOVWF  FF7
09CC6:  MOVLW  00
09CC8:  MOVWF  FF8
09CCA:  CALL   7906
....................                            debug_html(debug_html_putc, "index='%s' ", pValue);                            
....................                         } 
09CCE:  BRA    9D2C
....................                         else 
....................                         { 
....................                            if (pValue[0] == '/') 
09CD0:  MOVLB  3
09CD2:  MOVFF  3CC,FE9
09CD6:  MOVFF  3CD,FEA
09CDA:  MOVF   FEF,W
09CDC:  SUBLW  2F
09CDE:  BNZ   9CE6
....................                                                          pValue++;   //skip leading / 
09CE0:  INCF   xCC,F
09CE2:  BTFSC  FD8.2
09CE4:  INCF   xCD,F
....................                            j=strlen(pValue); 
09CE6:  MOVFF  3CD,407
09CEA:  MOVFF  3CC,406
09CEE:  MOVLB  0
09CF0:  CALL   75AE
09CF4:  MOVFF  01,3C0
....................                            l=j; 
09CF8:  MOVFF  3C0,3C1
....................                            while(pValue[--j] == 47&& j!=0){//strip out trailing '/' chars 
09CFC:  MOVLB  3
09CFE:  DECF   xC0,F
09D00:  CLRF   03
09D02:  MOVF   xC0,W
09D04:  ADDWF  xCC,W
09D06:  MOVWF  FE9
09D08:  MOVF   xCD,W
09D0A:  ADDWFC 03,W
09D0C:  MOVWF  FEA
09D0E:  MOVF   FEF,W
09D10:  SUBLW  2F
09D12:  BNZ   9D2A
09D14:  MOVF   xC0,F
09D16:  BZ    9D2A
....................                               pValue[j] = 0;   //this may have to be changed if 
09D18:  CLRF   03
09D1A:  MOVF   xC0,W
09D1C:  ADDWF  xCC,W
09D1E:  MOVWF  FE9
09D20:  MOVF   xCD,W
09D22:  ADDWFC 03,W
09D24:  MOVWF  FEA
09D26:  CLRF   FEF
09D28:  BRA    9CFE
09D2A:  MOVLB  0
....................                            }               //we want to process directories 
....................                         } 
....................                          
....................                         debug_html(debug_html_putc, "page='%s' ", pValue); 
....................                          
....................                         //TODO: do i need the following 2 lines? 
....................                         fstream = MPFSGetEnd(); 
09D2C:  MOVFF  100,3C7
09D30:  MOVFF  FF,3C6
09D34:  MOVFF  FE,3C5
09D38:  MOVFF  FD,3C4
....................  
....................                         MPFSClose(); 
09D3C:  CALL   792E
....................  
....................                         if (FileExists(pValue)) 
09D40:  MOVFF  3CD,3E3
09D44:  MOVFF  3CC,3E2
09D48:  CALL   7C06
09D4C:  MOVF   01,W
09D4E:  IORWF  02,W
09D50:  BZ    9DAA
....................                         { 
....................                            _strncpy(&page[g_HttpCurrConn][0], pValue, sizeof(page)/HTTP_NUM_SOCKETS); 
09D52:  MOVLB  2
09D54:  MOVF   x11,W
09D56:  MULLW  14
09D58:  MOVF   FF3,W
09D5A:  MOVLB  3
09D5C:  CLRF   xCF
09D5E:  MOVWF  xCE
09D60:  MOVLW  63
09D62:  ADDWF  xCE,W
09D64:  MOVWF  01
09D66:  MOVLW  03
09D68:  ADDWFC xCF,W
09D6A:  MOVWF  03
09D6C:  MOVFF  01,3D0
09D70:  MOVWF  xD1
09D72:  MOVWF  xD3
09D74:  MOVFF  01,3D2
09D78:  MOVFF  3CD,3D5
09D7C:  MOVFF  3CC,3D4
09D80:  CLRF   xD7
09D82:  MOVLW  14
09D84:  MOVWF  xD6
09D86:  MOVLB  0
09D88:  GOTO   7CE6
....................                            http_error_code[g_HttpCurrConn]=200; 
09D8C:  BCF    FD8.0
09D8E:  MOVLB  2
09D90:  RLCF   x11,W
09D92:  CLRF   03
09D94:  ADDLW  79
09D96:  MOVWF  FE9
09D98:  MOVLW  03
09D9A:  ADDWFC 03,W
09D9C:  MOVWF  FEA
09D9E:  CLRF   FEC
09DA0:  MOVF   FED,F
09DA2:  MOVLW  C8
09DA4:  MOVWF  FEF
....................                            debug_html(debug_html_putc, "FOUND "); 
....................                         } 
09DA6:  BRA    9DFE
09DA8:  MOVLB  0
....................                         else 
....................                         { 
....................                            sprintf(&page[g_HttpCurrConn][0], "%s", HTTP_404_ERROR_FNAME); 
09DAA:  MOVLB  2
09DAC:  MOVF   x11,W
09DAE:  MULLW  14
09DB0:  MOVF   FF3,W
09DB2:  MOVLB  3
09DB4:  CLRF   xCF
09DB6:  MOVWF  xCE
09DB8:  MOVLW  63
09DBA:  ADDWF  xCE,W
09DBC:  MOVWF  01
09DBE:  MOVLW  03
09DC0:  ADDWFC xCF,W
09DC2:  MOVWF  03
09DC4:  MOVFF  01,3D0
09DC8:  MOVWF  xD1
09DCA:  MOVWF  x45
09DCC:  MOVFF  01,344
09DD0:  MOVLW  E0
09DD2:  MOVWF  FF6
09DD4:  MOVLW  01
09DD6:  MOVWF  FF7
09DD8:  MOVLW  00
09DDA:  MOVWF  FF8
09DDC:  MOVLB  0
09DDE:  CALL   7906
....................                            http_error_code[g_HttpCurrConn]=404; 
09DE2:  BCF    FD8.0
09DE4:  MOVLB  2
09DE6:  RLCF   x11,W
09DE8:  CLRF   03
09DEA:  ADDLW  79
09DEC:  MOVWF  FE9
09DEE:  MOVLW  03
09DF0:  ADDWFC 03,W
09DF2:  MOVWF  FEA
09DF4:  MOVLW  01
09DF6:  MOVWF  FEC
09DF8:  MOVF   FED,F
09DFA:  MOVLW  94
09DFC:  MOVWF  FEF
....................                            debug_html(debug_html_putc, "MISSING "); 
....................                         } 
....................  
.................... //                      fprintf(USER,"HTTP %U PVALUE: %s FILE OPENED: %s, handle:%LX\r\n", hs, pValue, page, fstream); 
....................                         pValue=strtok(0, tokens_get); 
09DFE:  MOVLB  3
09E00:  CLRF   xD3
09E02:  CLRF   xD2
09E04:  MOVLW  03
09E06:  MOVWF  xD5
09E08:  MOVLW  48
09E0A:  MOVWF  xD4
09E0C:  MOVLB  0
09E0E:  CALL   701A
09E12:  MOVFF  02,3CD
09E16:  MOVFF  01,3CC
....................                        #if HTTP_USE_AUTHENTICATION 
....................                        //we cant execute this until we authorize 
....................                         _strncpy(&http_get_cache[g_HttpCurrConn][0],pValue,(sizeof(http_get_cache)/HTTP_NUM_SOCKETS)); 
....................                        #else 
....................                         if (pValue && (http_error_code[g_HttpCurrConn]==200)) 
09E1A:  MOVLB  3
09E1C:  MOVF   xCC,W
09E1E:  IORWF  xCD,W
09E20:  BZ    9E80
09E22:  BCF    FD8.0
09E24:  MOVLB  2
09E26:  RLCF   x11,W
09E28:  CLRF   03
09E2A:  ADDLW  79
09E2C:  MOVWF  FE9
09E2E:  MOVLW  03
09E30:  ADDWFC 03,W
09E32:  MOVWF  FEA
09E34:  MOVFF  FEC,3CF
09E38:  MOVF   FED,F
09E3A:  MOVFF  FEF,3CE
09E3E:  MOVLB  3
09E40:  MOVF   xCE,W
09E42:  SUBLW  C8
09E44:  BNZ   9E80
09E46:  MOVF   xCF,F
09E48:  BNZ   9E80
....................                         { 
....................                            http_parse_cgi_string(&page[g_HttpCurrConn][0], pValue); 
09E4A:  MOVLB  2
09E4C:  MOVF   x11,W
09E4E:  MULLW  14
09E50:  MOVF   FF3,W
09E52:  MOVLB  3
09E54:  CLRF   xCF
09E56:  MOVWF  xCE
09E58:  MOVLW  63
09E5A:  ADDWF  xCE,W
09E5C:  MOVWF  01
09E5E:  MOVLW  03
09E60:  ADDWFC xCF,W
09E62:  MOVWF  03
09E64:  MOVFF  01,3D0
09E68:  MOVWF  xD1
09E6A:  MOVWF  xD7
09E6C:  MOVFF  01,3D6
09E70:  MOVFF  3CD,3D9
09E74:  MOVFF  3CC,3D8
09E78:  MOVLB  0
09E7A:  CALL   7D32
09E7E:  MOVLB  3
....................                         } 
....................                        #endif 
....................                      } 
09E80:  BRA    9EEE
09E82:  MOVLB  0
....................                      else if (http_cmd[g_HttpCurrConn] != HTTP_REQ_UNKOWN)   //we processed a GET or POST 
09E84:  CLRF   03
09E86:  MOVLB  2
09E88:  MOVF   x11,W
09E8A:  ADDLW  78
09E8C:  MOVWF  FE9
09E8E:  MOVLW  03
09E90:  ADDWFC 03,W
09E92:  MOVWF  FEA
09E94:  MOVF   FEF,F
09E96:  BZ    9EEC
....................                      { 
....................                         //if you want to parse HTTP headers, do it here. 
....................                         //pKey and pVal hold the individual headers. 
....................  
....................                         //parse the Content-Length header. 
....................                         if (strcmp(pKey, http_len_str)==0) 
09E98:  MOVFF  3CB,3CF
09E9C:  MOVFF  3CA,3CE
09EA0:  MOVLW  03
09EA2:  MOVLB  3
09EA4:  MOVWF  xD1
09EA6:  MOVLW  53
09EA8:  MOVWF  xD0
09EAA:  MOVLB  0
09EAC:  CALL   70CA
09EB0:  MOVF   01,F
09EB2:  BNZ   9EEC
....................                            http_post_len[g_HttpCurrConn]=atol(pValue); 
09EB4:  BCF    FD8.0
09EB6:  MOVLB  2
09EB8:  RLCF   x11,W
09EBA:  CLRF   03
09EBC:  ADDLW  7B
09EBE:  MOVWF  01
09EC0:  MOVLW  03
09EC2:  ADDWFC 03,F
09EC4:  MOVFF  01,3CE
09EC8:  MOVFF  03,3CF
09ECC:  MOVFF  3CD,3D1
09ED0:  MOVFF  3CC,3D0
09ED4:  MOVLB  0
09ED6:  GOTO   7DCC
09EDA:  MOVFF  3CF,FEA
09EDE:  MOVFF  3CE,FE9
09EE2:  MOVFF  01,FEC
09EE6:  MOVF   FED,F
09EE8:  MOVFF  00,FEF
09EEC:  MOVLB  3
....................                       #if HTTP_LAST_MODIFIED_CHECK 
....................                         if (strstr(pKey, "If-Modified-Since") != 0) 
....................                            g_lastModifiedCheck[g_HttpCurrConn] = TRUE; 
....................                       #endif 
....................                       #if HTTP_USE_AUTHENTICATION                         
....................                         //parse the Authorization header. 
....................                         if (strcmp(pKey, http_auth_str)==0) 
....................                         { 
....................                            _strncpy(http_auth_user, pValue+6,(sizeof(http_auth_user)/HTTP_NUM_SOCKETS)); 
....................                            //printf("\r\nAuth Attempt '%s'->'%s'\r\n", pValue, &http_auth_user[hs][0]); 
....................                         } 
....................                       #endif 
....................                      } 
....................                   } 
09EEE:  BRA    9F56
....................                   else if (i[g_HttpCurrConn] == 0) 
09EF0:  CLRF   03
09EF2:  MOVLB  2
09EF4:  MOVF   x11,W
09EF6:  ADDLW  77
09EF8:  MOVWF  FE9
09EFA:  MOVLW  03
09EFC:  ADDWFC 03,W
09EFE:  MOVWF  FEA
09F00:  MOVF   FEF,F
09F02:  BNZ   9F54
....................                   { 
....................                      //got a double \r\n 
....................                      //fprintf(USER,"HTTP %U GET HEADER DONE\r\n", hs); 
....................                      if (http_cmd[g_HttpCurrConn] == HTTP_REQ_POST) 
09F04:  CLRF   03
09F06:  MOVF   x11,W
09F08:  ADDLW  78
09F0A:  MOVWF  FE9
09F0C:  MOVLW  03
09F0E:  ADDWFC 03,W
09F10:  MOVWF  FEA
09F12:  MOVF   FEF,W
09F14:  SUBLW  02
09F16:  BNZ   9F32
....................                      { 
....................                       #if HTTP_USE_AUTHENTICATION 
....................                         http_state[g_HttpCurrConn]=HTTP_CHECK_AUTHENTICATION; 
....................                       #else 
....................                         http_state[g_HttpCurrConn]=HTTP_GET_POST; 
09F18:  CLRF   03
09F1A:  MOVF   x11,W
09F1C:  ADDLW  0F
09F1E:  MOVWF  FE9
09F20:  MOVLW  02
09F22:  ADDWFC 03,W
09F24:  MOVWF  FEA
09F26:  MOVLW  05
09F28:  MOVWF  FEF
....................                       #endif 
....................                         postContinue=TRUE; 
09F2A:  MOVLB  3
09F2C:  BSF    xC8.1
....................                      } 
09F2E:  BRA    9F50
09F30:  MOVLB  2
....................                      else 
....................                      { 
....................                       #if HTTP_USE_AUTHENTICATION 
....................                         http_state[g_HttpCurrConn]=HTTP_CHECK_AUTHENTICATION; 
....................                       #else 
....................                         http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
09F32:  CLRF   03
09F34:  MOVF   x11,W
09F36:  ADDLW  0F
09F38:  MOVWF  FE9
09F3A:  MOVLW  02
09F3C:  ADDWFC 03,W
09F3E:  MOVWF  FEA
09F40:  MOVLW  07
09F42:  MOVWF  FEF
....................                       #endif 
....................                         TCPDiscard(g_HttpCurrSocket); 
09F44:  MOVFF  210,3CE
09F48:  MOVLB  0
09F4A:  CALL   8118
09F4E:  MOVLB  3
....................                      } 
....................                      break;   //break out of read from ethernet loop 
09F50:  MOVLB  0
09F52:  BRA    9F6E
09F54:  MOVLB  3
....................                   } 
....................                   i[g_HttpCurrConn]=0; 
09F56:  CLRF   03
09F58:  MOVLB  2
09F5A:  MOVF   x11,W
09F5C:  ADDLW  77
09F5E:  MOVWF  FE9
09F60:  MOVLW  03
09F62:  ADDWFC 03,W
09F64:  MOVWF  FEA
09F66:  CLRF   FEF
09F68:  MOVLB  3
....................                } 
09F6A:  BRA    9AAE
09F6C:  MOVLB  0
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[g_HttpCurrConn]) > TICKS_PER_SECOND*20) 
09F6E:  CALL   2424
09F72:  MOVFF  03,3D1
09F76:  MOVFF  02,3D0
09F7A:  MOVFF  01,3CF
09F7E:  MOVFF  00,3CE
09F82:  MOVLB  2
09F84:  MOVF   x11,W
09F86:  MULLW  04
09F88:  MOVF   FF3,W
09F8A:  CLRF   03
09F8C:  ADDLW  7D
09F8E:  MOVWF  FE9
09F90:  MOVLW  03
09F92:  ADDWFC 03,W
09F94:  MOVWF  FEA
09F96:  MOVFF  FEF,00
09F9A:  MOVFF  FEC,01
09F9E:  MOVFF  FEC,02
09FA2:  MOVFF  FEC,03
09FA6:  MOVF   00,W
09FA8:  MOVLB  3
09FAA:  SUBWF  xCE,F
09FAC:  MOVF   01,W
09FAE:  SUBWFB xCF,F
09FB0:  MOVF   02,W
09FB2:  SUBWFB xD0,F
09FB4:  MOVF   03,W
09FB6:  SUBWFB xD1,F
09FB8:  BNZ   9FD4
09FBA:  MOVF   xD0,W
09FBC:  SUBLW  04
09FBE:  BC    A03C
09FC0:  XORLW  FF
09FC2:  BNZ   9FD4
09FC4:  MOVF   xCF,W
09FC6:  SUBLW  F4
09FC8:  BC    A03C
09FCA:  XORLW  FF
09FCC:  BNZ   9FD4
09FCE:  MOVF   xCE,W
09FD0:  SUBLW  DC
09FD2:  BC    A03C
....................             { 
....................                   debug_html(debug_html_putc, "\r\nHTTP %U GET HEADER TIMEOUT ", g_HttpCurrConn); 
....................                   sprintf(&page[g_HttpCurrConn][0], "%s", HTTP_500_ERROR_FNAME); 
09FD4:  MOVLB  2
09FD6:  MOVF   x11,W
09FD8:  MULLW  14
09FDA:  MOVF   FF3,W
09FDC:  MOVLB  3
09FDE:  CLRF   xCF
09FE0:  MOVWF  xCE
09FE2:  MOVLW  63
09FE4:  ADDWF  xCE,W
09FE6:  MOVWF  01
09FE8:  MOVLW  03
09FEA:  ADDWFC xCF,W
09FEC:  MOVWF  03
09FEE:  MOVFF  01,3D0
09FF2:  MOVWF  xD1
09FF4:  MOVWF  x45
09FF6:  MOVFF  01,344
09FFA:  MOVLW  EE
09FFC:  MOVWF  FF6
09FFE:  MOVLW  01
0A000:  MOVWF  FF7
0A002:  MOVLW  00
0A004:  MOVWF  FF8
0A006:  MOVLB  0
0A008:  CALL   7906
....................                   http_error_code[g_HttpCurrConn]=500; 
0A00C:  BCF    FD8.0
0A00E:  MOVLB  2
0A010:  RLCF   x11,W
0A012:  CLRF   03
0A014:  ADDLW  79
0A016:  MOVWF  FE9
0A018:  MOVLW  03
0A01A:  ADDWFC 03,W
0A01C:  MOVWF  FEA
0A01E:  MOVLW  01
0A020:  MOVWF  FEC
0A022:  MOVF   FED,F
0A024:  MOVLW  F4
0A026:  MOVWF  FEF
....................                   http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
0A028:  CLRF   03
0A02A:  MOVF   x11,W
0A02C:  ADDLW  0F
0A02E:  MOVWF  FE9
0A030:  MOVLW  02
0A032:  ADDWFC 03,W
0A034:  MOVWF  FEA
0A036:  MOVLW  07
0A038:  MOVWF  FEF
0A03A:  MOVLB  3
....................             } 
....................             if (!postContinue) 
0A03C:  BTFSC  xC8.1
0A03E:  BRA    A046
....................                break; 
0A040:  MOVLB  0
0A042:  BRA    A740
0A044:  MOVLB  3
0A046:  MOVLB  0
....................  
....................       #if HTTP_USE_AUTHENTICATION 
....................          case HTTP_CHECK_AUTHENTICATION: 
....................             http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
....................             postContinue=FALSE; 
....................             if (HTTPRequiresAuthentication(&page[g_HttpCurrConn][0], &http_auth_user[g_HttpCurrConn][0])) 
....................             { 
....................                //printf("\r\nAUTH REQUIRED\r\n"); 
....................                _strncpy(&page[g_HttpCurrConn][0], http_401_error, sizeof(page)/HTTP_NUM_SOCKETS); 
....................                http_error_code[g_HttpCurrConn]=401; 
....................             } 
....................             else if (http_cmd[g_HttpCurrConn] == HTTP_REQ_POST) 
....................             { 
....................                http_state[g_HttpCurrConn]=HTTP_GET_POST; 
....................                postContinue=TRUE; 
....................             } 
....................             else 
....................             { 
....................                debug_html(debug_html_putc, "\r\n!! AUTH OK !!\r\n"); 
....................                http_parse_cgi_string(&page[g_HttpCurrConn][0], &http_get_cache[g_HttpCurrConn][0]); 
....................             } 
....................             if (!postContinue) 
....................                break; 
....................       #endif 
....................  
....................          case HTTP_GET_POST: 
.................... //            fprintf(USER,"HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]); 
....................             http_state[g_HttpCurrConn]=HTTP_GET_POST_CONTINUE; 
0A048:  CLRF   03
0A04A:  MOVLB  2
0A04C:  MOVF   x11,W
0A04E:  ADDLW  0F
0A050:  MOVWF  FE9
0A052:  MOVLW  02
0A054:  ADDWFC 03,W
0A056:  MOVWF  FEA
0A058:  MOVLW  06
0A05A:  MOVWF  FEF
....................             http_timer[g_HttpCurrConn]=TickGet(); 
0A05C:  MOVF   x11,W
0A05E:  MULLW  04
0A060:  MOVF   FF3,W
0A062:  CLRF   03
0A064:  ADDLW  7D
0A066:  MOVWF  01
0A068:  MOVLW  03
0A06A:  ADDWFC 03,F
0A06C:  MOVFF  01,3CE
0A070:  MOVFF  03,3CF
0A074:  MOVLB  0
0A076:  CALL   2424
0A07A:  MOVFF  3CF,FEA
0A07E:  MOVFF  3CE,FE9
0A082:  MOVFF  00,FEF
0A086:  MOVFF  01,FEC
0A08A:  MOVFF  02,FEC
0A08E:  MOVFF  03,FEC
....................             i[g_HttpCurrConn]=0; 
0A092:  CLRF   03
0A094:  MOVLB  2
0A096:  MOVF   x11,W
0A098:  ADDLW  77
0A09A:  MOVWF  FE9
0A09C:  MOVLW  03
0A09E:  ADDWFC 03,W
0A0A0:  MOVWF  FEA
0A0A2:  CLRF   FEF
0A0A4:  MOVLB  0
....................  
....................          case HTTP_GET_POST_CONTINUE: 
....................             while ( 
....................                      TCPIsGetReady(g_HttpCurrSocket) && 
....................                      TCPGet(g_HttpCurrSocket, &c) && 
....................                      (http_post_len[g_HttpCurrConn] != 0) 
....................                   ) 
0A0A6:  MOVFF  210,3D3
0A0AA:  CALL   6DE0
0A0AE:  MOVF   01,W
0A0B0:  IORWF  02,W
0A0B2:  BTFSC  FD8.2
0A0B4:  BRA    A288
0A0B6:  MOVFF  210,3CE
0A0BA:  MOVLW  03
0A0BC:  MOVLB  3
0A0BE:  MOVWF  xD0
0A0C0:  MOVLW  C9
0A0C2:  MOVWF  xCF
0A0C4:  MOVLB  0
0A0C6:  CALL   6E60
0A0CA:  MOVF   01,F
0A0CC:  BTFSC  FD8.2
0A0CE:  BRA    A288
0A0D0:  BCF    FD8.0
0A0D2:  MOVLB  2
0A0D4:  RLCF   x11,W
0A0D6:  CLRF   03
0A0D8:  ADDLW  7B
0A0DA:  MOVWF  FE9
0A0DC:  MOVLW  03
0A0DE:  ADDWFC 03,W
0A0E0:  MOVWF  FEA
0A0E2:  MOVFF  FEC,3CF
0A0E6:  MOVF   FED,F
0A0E8:  MOVFF  FEF,3CE
0A0EC:  MOVLB  3
0A0EE:  MOVF   xCE,F
0A0F0:  BNZ   A0FC
0A0F2:  MOVF   xCF,F
0A0F4:  BTFSS  FD8.2
0A0F6:  BRA    A0FC
0A0F8:  MOVLB  0
0A0FA:  BRA    A288
....................             { 
....................                http_post_len[g_HttpCurrConn] -= 1; 
0A0FC:  BCF    FD8.0
0A0FE:  MOVLB  2
0A100:  RLCF   x11,W
0A102:  CLRF   03
0A104:  ADDLW  7B
0A106:  MOVWF  FE9
0A108:  MOVLW  03
0A10A:  ADDWFC 03,W
0A10C:  MOVWF  FEA
0A10E:  MOVLW  01
0A110:  SUBWF  FEF,W
0A112:  MOVWF  00
0A114:  MOVLW  00
0A116:  SUBWFB FEC,W
0A118:  MOVWF  03
0A11A:  MOVF   00,W
0A11C:  MOVF   FED,F
0A11E:  MOVWF  FEF
0A120:  MOVFF  03,FEC
....................  
....................                if (c!='&') 
0A124:  MOVLB  3
0A126:  MOVF   xC9,W
0A128:  SUBLW  26
0A12A:  BZ    A16A
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]++]=c; 
0A12C:  MOVLB  2
0A12E:  MOVF   x11,W
0A130:  MULLW  FE
0A132:  MOVF   FF3,W
0A134:  MOVLB  3
0A136:  CLRF   xCF
0A138:  MOVWF  xCE
0A13A:  CLRF   03
0A13C:  MOVLB  2
0A13E:  MOVF   x11,W
0A140:  ADDLW  77
0A142:  MOVWF  FE9
0A144:  MOVLW  03
0A146:  ADDWFC 03,W
0A148:  MOVWF  FEA
0A14A:  MOVF   FEF,W
0A14C:  INCF   FEF,F
0A14E:  CLRF   03
0A150:  MOVLB  3
0A152:  ADDWF  xCE,W
0A154:  MOVWF  01
0A156:  MOVF   xCF,W
0A158:  ADDWFC 03,F
0A15A:  MOVF   01,W
0A15C:  ADDLW  19
0A15E:  MOVWF  FE9
0A160:  MOVLW  02
0A162:  ADDWFC 03,W
0A164:  MOVWF  FEA
0A166:  MOVFF  3C9,FEF
....................                } 
....................  
....................                if ( (c=='&') || (http_post_len[g_HttpCurrConn] == 0) ) 
0A16A:  MOVF   xC9,W
0A16C:  SUBLW  26
0A16E:  BZ    A198
0A170:  BCF    FD8.0
0A172:  MOVLB  2
0A174:  RLCF   x11,W
0A176:  CLRF   03
0A178:  ADDLW  7B
0A17A:  MOVWF  FE9
0A17C:  MOVLW  03
0A17E:  ADDWFC 03,W
0A180:  MOVWF  FEA
0A182:  MOVFF  FEC,3CF
0A186:  MOVF   FED,F
0A188:  MOVFF  FEF,3CE
0A18C:  MOVLB  3
0A18E:  MOVF   xCE,F
0A190:  BTFSS  FD8.2
0A192:  BRA    A284
0A194:  MOVF   xCF,F
0A196:  BNZ   A284
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]]=0; 
0A198:  MOVLB  2
0A19A:  MOVF   x11,W
0A19C:  MULLW  FE
0A19E:  MOVF   FF3,W
0A1A0:  MOVLB  3
0A1A2:  CLRF   xCF
0A1A4:  MOVWF  xCE
0A1A6:  CLRF   03
0A1A8:  MOVLB  2
0A1AA:  MOVF   x11,W
0A1AC:  ADDLW  77
0A1AE:  MOVWF  FE9
0A1B0:  MOVLW  03
0A1B2:  ADDWFC 03,W
0A1B4:  MOVWF  FEA
0A1B6:  CLRF   03
0A1B8:  MOVF   FEF,W
0A1BA:  MOVLB  3
0A1BC:  ADDWF  xCE,W
0A1BE:  MOVWF  01
0A1C0:  MOVF   xCF,W
0A1C2:  ADDWFC 03,F
0A1C4:  MOVF   01,W
0A1C6:  ADDLW  19
0A1C8:  MOVWF  FE9
0A1CA:  MOVLW  02
0A1CC:  ADDWFC 03,W
0A1CE:  MOVWF  FEA
0A1D0:  CLRF   FEF
....................  
....................                   //fprintf(USER,"%lu - %s\r\n", http_post_len[hs], &HTTPbuffer[hs][0]); 
....................  
....................                   http_parse_cgi_string(&page[g_HttpCurrConn][0], &HTTPbuffer[g_HttpCurrConn][0]); 
0A1D2:  MOVLB  2
0A1D4:  MOVF   x11,W
0A1D6:  MULLW  14
0A1D8:  MOVF   FF3,W
0A1DA:  MOVLB  3
0A1DC:  CLRF   xCF
0A1DE:  MOVWF  xCE
0A1E0:  MOVLW  63
0A1E2:  ADDWF  xCE,W
0A1E4:  MOVWF  01
0A1E6:  MOVLW  03
0A1E8:  ADDWFC xCF,W
0A1EA:  MOVWF  03
0A1EC:  MOVFF  01,3D0
0A1F0:  MOVWF  xD1
0A1F2:  MOVLB  2
0A1F4:  MOVF   x11,W
0A1F6:  MULLW  FE
0A1F8:  MOVF   FF3,W
0A1FA:  MOVLB  3
0A1FC:  CLRF   xD3
0A1FE:  MOVWF  xD2
0A200:  MOVLW  19
0A202:  ADDWF  xD2,W
0A204:  MOVWF  01
0A206:  MOVLW  02
0A208:  ADDWFC xD3,W
0A20A:  MOVWF  03
0A20C:  MOVFF  01,3D4
0A210:  MOVWF  xD5
0A212:  MOVFF  3D1,3D7
0A216:  MOVFF  3D0,3D6
0A21A:  MOVWF  xD9
0A21C:  MOVFF  01,3D8
0A220:  MOVLB  0
0A222:  CALL   7D32
....................                   if (http_post_len[g_HttpCurrConn] == 0) 
0A226:  BCF    FD8.0
0A228:  MOVLB  2
0A22A:  RLCF   x11,W
0A22C:  CLRF   03
0A22E:  ADDLW  7B
0A230:  MOVWF  FE9
0A232:  MOVLW  03
0A234:  ADDWFC 03,W
0A236:  MOVWF  FEA
0A238:  MOVFF  FEC,3CF
0A23C:  MOVF   FED,F
0A23E:  MOVFF  FEF,3CE
0A242:  MOVLB  3
0A244:  MOVF   xCE,F
0A246:  BNZ   A270
0A248:  MOVF   xCF,F
0A24A:  BNZ   A270
....................                   { 
....................                      http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
0A24C:  CLRF   03
0A24E:  MOVLB  2
0A250:  MOVF   x11,W
0A252:  ADDLW  0F
0A254:  MOVWF  FE9
0A256:  MOVLW  02
0A258:  ADDWFC 03,W
0A25A:  MOVWF  FEA
0A25C:  MOVLW  07
0A25E:  MOVWF  FEF
....................                      TCPDiscard(g_HttpCurrSocket); 
0A260:  MOVFF  210,3CE
0A264:  MOVLB  0
0A266:  CALL   8118
....................                      break; 
0A26A:  BRA    A288
....................                   } 
0A26C:  BRA    A284
0A26E:  MOVLB  3
....................                   else 
....................                      i[g_HttpCurrConn]=0; 
0A270:  CLRF   03
0A272:  MOVLB  2
0A274:  MOVF   x11,W
0A276:  ADDLW  77
0A278:  MOVWF  FE9
0A27A:  MOVLW  03
0A27C:  ADDWFC 03,W
0A27E:  MOVWF  FEA
0A280:  CLRF   FEF
0A282:  MOVLB  0
....................                } 
0A284:  MOVLB  0
0A286:  BRA    A0A6
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[g_HttpCurrConn]) > TICKS_PER_SECOND*20) 
0A288:  CALL   2424
0A28C:  MOVFF  03,3D1
0A290:  MOVFF  02,3D0
0A294:  MOVFF  01,3CF
0A298:  MOVFF  00,3CE
0A29C:  MOVLB  2
0A29E:  MOVF   x11,W
0A2A0:  MULLW  04
0A2A2:  MOVF   FF3,W
0A2A4:  CLRF   03
0A2A6:  ADDLW  7D
0A2A8:  MOVWF  FE9
0A2AA:  MOVLW  03
0A2AC:  ADDWFC 03,W
0A2AE:  MOVWF  FEA
0A2B0:  MOVFF  FEF,00
0A2B4:  MOVFF  FEC,01
0A2B8:  MOVFF  FEC,02
0A2BC:  MOVFF  FEC,03
0A2C0:  MOVF   00,W
0A2C2:  MOVLB  3
0A2C4:  SUBWF  xCE,F
0A2C6:  MOVF   01,W
0A2C8:  SUBWFB xCF,F
0A2CA:  MOVF   02,W
0A2CC:  SUBWFB xD0,F
0A2CE:  MOVF   03,W
0A2D0:  SUBWFB xD1,F
0A2D2:  BNZ   A2EE
0A2D4:  MOVF   xD0,W
0A2D6:  SUBLW  04
0A2D8:  BC    A356
0A2DA:  XORLW  FF
0A2DC:  BNZ   A2EE
0A2DE:  MOVF   xCF,W
0A2E0:  SUBLW  F4
0A2E2:  BC    A356
0A2E4:  XORLW  FF
0A2E6:  BNZ   A2EE
0A2E8:  MOVF   xCE,W
0A2EA:  SUBLW  DC
0A2EC:  BC    A356
....................             { 
....................                debug_html(debug_html_putc, "\r\nHTTP %U GET POST TIMEOUT ", g_HttpCurrConn); 
....................                sprintf(&page[g_HttpCurrConn][0], HTTP_500_ERROR_FNAME); 
0A2EE:  MOVLB  2
0A2F0:  MOVF   x11,W
0A2F2:  MULLW  14
0A2F4:  MOVF   FF3,W
0A2F6:  MOVLB  3
0A2F8:  CLRF   xCF
0A2FA:  MOVWF  xCE
0A2FC:  MOVLW  63
0A2FE:  ADDWF  xCE,W
0A300:  MOVWF  01
0A302:  MOVLW  03
0A304:  ADDWFC xCF,W
0A306:  MOVWF  03
0A308:  MOVFF  01,3D0
0A30C:  MOVWF  xD1
0A30E:  MOVWF  x45
0A310:  MOVFF  01,344
0A314:  MOVLW  FC
0A316:  MOVWF  FF6
0A318:  MOVLW  01
0A31A:  MOVWF  FF7
0A31C:  MOVLW  00
0A31E:  MOVWF  FF8
0A320:  MOVLB  0
0A322:  CALL   7906
....................                http_error_code[g_HttpCurrConn]=500; 
0A326:  BCF    FD8.0
0A328:  MOVLB  2
0A32A:  RLCF   x11,W
0A32C:  CLRF   03
0A32E:  ADDLW  79
0A330:  MOVWF  FE9
0A332:  MOVLW  03
0A334:  ADDWFC 03,W
0A336:  MOVWF  FEA
0A338:  MOVLW  01
0A33A:  MOVWF  FEC
0A33C:  MOVF   FED,F
0A33E:  MOVLW  F4
0A340:  MOVWF  FEF
....................                http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
0A342:  CLRF   03
0A344:  MOVF   x11,W
0A346:  ADDLW  0F
0A348:  MOVWF  FE9
0A34A:  MOVLW  02
0A34C:  ADDWFC 03,W
0A34E:  MOVWF  FEA
0A350:  MOVLW  07
0A352:  MOVWF  FEF
0A354:  MOVLB  3
....................             } 
....................             break; 
0A356:  MOVLB  0
0A358:  BRA    A740
....................  
....................          case HTTP_SEND_RESPONSE: 
....................             //putc('.'); 
....................             if(mpfsFlags.bits.bNotAvailable) 
0A35A:  MOVLB  2
0A35C:  BTFSS  x07.0
0A35E:  BRA    A366
....................                break; 
0A360:  MOVLB  0
0A362:  BRA    A740
0A364:  MOVLB  2
.................... //            fprintf(USER,"HTTP %U SEND RESPONSE\r\n", hs); 
....................             //putc('*'); 
....................             g_HTTPMimeType[g_HttpCurrConn] = HTTPFindMimeType(&page[g_HttpCurrConn][0]); 
0A366:  CLRF   03
0A368:  MOVF   x11,W
0A36A:  ADDLW  18
0A36C:  MOVWF  01
0A36E:  MOVLW  02
0A370:  ADDWFC 03,F
0A372:  MOVFF  01,3CE
0A376:  MOVFF  03,3CF
0A37A:  MOVLB  2
0A37C:  MOVF   x11,W
0A37E:  MULLW  14
0A380:  MOVF   FF3,W
0A382:  MOVLB  3
0A384:  CLRF   xD1
0A386:  MOVWF  xD0
0A388:  MOVLW  63
0A38A:  ADDWF  xD0,W
0A38C:  MOVWF  01
0A38E:  MOVLW  03
0A390:  ADDWFC xD1,W
0A392:  MOVWF  03
0A394:  MOVFF  01,3D2
0A398:  MOVWF  xD3
0A39A:  MOVWF  xD5
0A39C:  MOVFF  01,3D4
0A3A0:  MOVLB  0
0A3A2:  GOTO   8204
0A3A6:  MOVFF  3CF,FEA
0A3AA:  MOVFF  3CE,FE9
0A3AE:  MOVFF  01,FEF
....................            #if HTTP_LAST_MODIFIED_CHECK 
....................             if (IsImage(g_HttpCurrConn) && g_lastModifiedCheck[g_HttpCurrConn]) 
....................             { 
....................                http_error_code[g_HttpCurrConn] = 304; 
....................             } 
....................            #endif 
....................             fstream = MPFSOpen(page); 
0A3B2:  MOVLW  03
0A3B4:  MOVLB  3
0A3B6:  MOVWF  xEB
0A3B8:  MOVLW  63
0A3BA:  MOVWF  xEA
0A3BC:  MOVLB  0
0A3BE:  CALL   7A88
0A3C2:  MOVFF  03,3C7
0A3C6:  MOVFF  02,3C6
0A3CA:  MOVFF  01,3C5
0A3CE:  MOVFF  00,3C4
....................             if (fstream == MPFS_INVALID) 
0A3D2:  MOVLB  3
0A3D4:  INCFSZ xC4,W
0A3D6:  BRA    A43C
0A3D8:  INCFSZ xC5,W
0A3DA:  BRA    A43C
0A3DC:  INCFSZ xC6,W
0A3DE:  BRA    A43C
0A3E0:  INCFSZ xC7,W
0A3E2:  BRA    A43C
....................             { 
....................                sprintf(page, HTTP_500_ERROR_FNAME); 
0A3E4:  MOVLW  03
0A3E6:  MOVWF  x45
0A3E8:  MOVLW  63
0A3EA:  MOVWF  x44
0A3EC:  MOVLW  0A
0A3EE:  MOVWF  FF6
0A3F0:  MOVLW  02
0A3F2:  MOVWF  FF7
0A3F4:  MOVLW  00
0A3F6:  MOVWF  FF8
0A3F8:  MOVLB  0
0A3FA:  CALL   7906
....................                http_error_code[g_HttpCurrConn]=500; 
0A3FE:  BCF    FD8.0
0A400:  MOVLB  2
0A402:  RLCF   x11,W
0A404:  CLRF   03
0A406:  ADDLW  79
0A408:  MOVWF  FE9
0A40A:  MOVLW  03
0A40C:  ADDWFC 03,W
0A40E:  MOVWF  FEA
0A410:  MOVLW  01
0A412:  MOVWF  FEC
0A414:  MOVF   FED,F
0A416:  MOVLW  F4
0A418:  MOVWF  FEF
....................                fstream = MPFSOpen(page); 
0A41A:  MOVLW  03
0A41C:  MOVLB  3
0A41E:  MOVWF  xEB
0A420:  MOVLW  63
0A422:  MOVWF  xEA
0A424:  MOVLB  0
0A426:  CALL   7A88
0A42A:  MOVFF  03,3C7
0A42E:  MOVFF  02,3C6
0A432:  MOVFF  01,3C5
0A436:  MOVFF  00,3C4
0A43A:  MOVLB  3
....................             } 
....................             MPFSGetBegin(fstream); 
0A43C:  MOVFF  3C7,100
0A440:  MOVFF  3C6,FF
0A444:  MOVFF  3C5,FE
0A448:  MOVFF  3C4,FD
....................             http_page_req[g_HttpCurrConn]=fstream; 
0A44C:  MOVLB  2
0A44E:  MOVF   x11,W
0A450:  MULLW  04
0A452:  MOVF   FF3,W
0A454:  CLRF   03
0A456:  ADDLW  17
0A458:  MOVWF  FE9
0A45A:  MOVLW  03
0A45C:  ADDWFC 03,W
0A45E:  MOVWF  FEA
0A460:  MOVFF  3C4,FEF
0A464:  MOVFF  3C5,FEC
0A468:  MOVFF  3C6,FEC
0A46C:  MOVFF  3C7,FEC
....................             lastHTTPPutConstPos[g_HttpCurrConn]=0; 
0A470:  MOVF   x11,W
0A472:  MULLW  04
0A474:  MOVF   FF3,W
0A476:  CLRF   03
0A478:  ADDLW  12
0A47A:  MOVWF  FE9
0A47C:  MOVLW  02
0A47E:  ADDWFC 03,W
0A480:  MOVWF  FEA
0A482:  MOVF   FEE,F
0A484:  MOVF   FEE,F
0A486:  CLRF   FEC
0A488:  MOVF   FED,F
0A48A:  CLRF   FEF
0A48C:  MOVF   FED,F
0A48E:  CLRF   FEF
0A490:  MOVF   FED,F
0A492:  CLRF   FEF
....................             http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE_CONTINUE; 
0A494:  CLRF   03
0A496:  MOVF   x11,W
0A498:  ADDLW  0F
0A49A:  MOVWF  FE9
0A49C:  MOVLW  02
0A49E:  ADDWFC 03,W
0A4A0:  MOVWF  FEA
0A4A2:  MOVLW  08
0A4A4:  MOVWF  FEF
0A4A6:  MOVLB  0
....................  
....................          case HTTP_SEND_RESPONSE_CONTINUE: 
....................             TCPDiscard(g_HttpCurrSocket); 
0A4A8:  MOVFF  210,3CE
0A4AC:  CALL   8118
....................             //putc('@'); 
....................              if (TCPIsPutReady(g_HttpCurrSocket)) 
0A4B0:  MOVFF  210,3FC
0A4B4:  CALL   82F6
0A4B8:  MOVF   01,W
0A4BA:  IORWF  02,W
0A4BC:  BZ    A59C
....................             { 
....................                //printf("\r\nPut Page Segment %U/%U EC=%LU '%s' %LX ", hs, currSocket, http_error_code[hs], page, http_page_req[hs]); 
....................                /* 
....................                ui_disp_mac_user(&TCB[currSocket].remote.MACAddr); 
....................                printf(" MAC="); 
....................                ui_disp_ip_user(&TCB[currSocket].remote.IPAddr); 
....................                printf("\r\n"); 
....................                */ 
....................                http_timer[g_HttpCurrConn]=TickGet(); 
0A4BE:  MOVLB  2
0A4C0:  MOVF   x11,W
0A4C2:  MULLW  04
0A4C4:  MOVF   FF3,W
0A4C6:  CLRF   03
0A4C8:  ADDLW  7D
0A4CA:  MOVWF  01
0A4CC:  MOVLW  03
0A4CE:  ADDWFC 03,F
0A4D0:  MOVFF  01,3CE
0A4D4:  MOVFF  03,3CF
0A4D8:  MOVLB  0
0A4DA:  CALL   2424
0A4DE:  MOVFF  3CF,FEA
0A4E2:  MOVFF  3CE,FE9
0A4E6:  MOVFF  00,FEF
0A4EA:  MOVFF  01,FEC
0A4EE:  MOVFF  02,FEC
0A4F2:  MOVFF  03,FEC
....................                 
.................... //               fprintf(USER,"\r\nPUTTING HTTP SEG\r\n"); 
....................                doneSend=tcp_http_put_file(http_error_code[g_HttpCurrConn], &http_page_req[g_HttpCurrConn], &page[g_HttpCurrConn][0]); 
0A4F6:  BCF    FD8.0
0A4F8:  MOVLB  2
0A4FA:  RLCF   x11,W
0A4FC:  CLRF   03
0A4FE:  ADDLW  79
0A500:  MOVWF  FE9
0A502:  MOVLW  03
0A504:  ADDWFC 03,W
0A506:  MOVWF  FEA
0A508:  MOVFF  FEC,3CF
0A50C:  MOVF   FED,F
0A50E:  MOVFF  FEF,3CE
0A512:  MOVF   x11,W
0A514:  MULLW  04
0A516:  MOVF   FF3,W
0A518:  CLRF   03
0A51A:  ADDLW  17
0A51C:  MOVWF  01
0A51E:  MOVLW  03
0A520:  ADDWFC 03,F
0A522:  MOVFF  01,3D0
0A526:  MOVFF  03,3D1
0A52A:  MOVLB  2
0A52C:  MOVF   x11,W
0A52E:  MULLW  14
0A530:  MOVF   FF3,W
0A532:  MOVLB  3
0A534:  CLRF   xD3
0A536:  MOVWF  xD2
0A538:  MOVLW  63
0A53A:  ADDWF  xD2,W
0A53C:  MOVWF  01
0A53E:  MOVLW  03
0A540:  ADDWFC xD3,W
0A542:  MOVWF  03
0A544:  MOVFF  01,3D4
0A548:  MOVWF  xD5
0A54A:  MOVFF  3CF,3D7
0A54E:  MOVFF  3CE,3D6
0A552:  MOVFF  3D1,3D9
0A556:  MOVFF  3D0,3D8
0A55A:  MOVWF  xDB
0A55C:  MOVFF  01,3DA
0A560:  MOVLB  0
0A562:  GOTO   9324
0A566:  MOVLB  3
0A568:  BCF    xC8.0
0A56A:  BTFSC  01.0
0A56C:  BSF    xC8.0
....................                if (doneSend!=0) 
0A56E:  BTFSS  xC8.0
0A570:  BRA    A59E
....................                { 
....................                   debug_html(debug_html_putc, "\r\nHTML Done sending page "); 
....................                   //if (http_isKeepAlive[hs]) 
....................                   //   http_state[hs]=HTTP_CONNECTED; 
....................                   //else 
....................                   //   http_state[hs]=HTTP_CLOSE; 
....................                   http_state[g_HttpCurrConn] = HTTP_CLOSE; 
0A572:  CLRF   03
0A574:  MOVLB  2
0A576:  MOVF   x11,W
0A578:  ADDLW  0F
0A57A:  MOVWF  FE9
0A57C:  MOVLW  02
0A57E:  ADDWFC 03,W
0A580:  MOVWF  FEA
0A582:  MOVLW  09
0A584:  MOVWF  FEF
....................                    
....................                   fstream = MPFSGetEnd();  
0A586:  MOVFF  100,3C7
0A58A:  MOVFF  FF,3C6
0A58E:  MOVFF  FE,3C5
0A592:  MOVFF  FD,3C4
....................                   MPFSClose(); 
0A596:  MOVLB  0
0A598:  CALL   792E
0A59C:  MOVLB  3
.................... //                  fprintf(USER,"HTTP %U RESPONSE SENT\r\n", hs); 
....................                } 
....................             } 
....................             if ((TickGet() - http_timer[g_HttpCurrConn]) >= (TICK)15*TICKS_PER_SECOND) 
0A59E:  MOVLB  0
0A5A0:  CALL   2424
0A5A4:  MOVFF  03,3D1
0A5A8:  MOVFF  02,3D0
0A5AC:  MOVFF  01,3CF
0A5B0:  MOVFF  00,3CE
0A5B4:  MOVLB  2
0A5B6:  MOVF   x11,W
0A5B8:  MULLW  04
0A5BA:  MOVF   FF3,W
0A5BC:  CLRF   03
0A5BE:  ADDLW  7D
0A5C0:  MOVWF  FE9
0A5C2:  MOVLW  03
0A5C4:  ADDWFC 03,W
0A5C6:  MOVWF  FEA
0A5C8:  MOVFF  FEF,00
0A5CC:  MOVFF  FEC,01
0A5D0:  MOVFF  FEC,02
0A5D4:  MOVFF  FEC,03
0A5D8:  MOVF   00,W
0A5DA:  MOVLB  3
0A5DC:  SUBWF  xCE,F
0A5DE:  MOVF   01,W
0A5E0:  SUBWFB xCF,F
0A5E2:  MOVF   02,W
0A5E4:  SUBWFB xD0,F
0A5E6:  MOVF   03,W
0A5E8:  SUBWFB xD1,F
0A5EA:  BNZ   A606
0A5EC:  MOVF   xD0,W
0A5EE:  SUBLW  03
0A5F0:  BC    A61C
0A5F2:  XORLW  FF
0A5F4:  BNZ   A606
0A5F6:  MOVF   xCF,W
0A5F8:  SUBLW  77
0A5FA:  BC    A61C
0A5FC:  XORLW  FF
0A5FE:  BNZ   A606
0A600:  MOVF   xCE,W
0A602:  SUBLW  64
0A604:  BC    A61C
....................             { 
....................                http_state[g_HttpCurrConn] = HTTP_CLOSE; 
0A606:  CLRF   03
0A608:  MOVLB  2
0A60A:  MOVF   x11,W
0A60C:  ADDLW  0F
0A60E:  MOVWF  FE9
0A610:  MOVLW  02
0A612:  ADDWFC 03,W
0A614:  MOVWF  FEA
0A616:  MOVLW  09
0A618:  MOVWF  FEF
0A61A:  MOVLB  3
....................             } 
....................             break; 
0A61C:  MOVLB  0
0A61E:  BRA    A740
....................  
....................          case HTTP_CLOSE: 
....................             //since we set connection: close in the header, the client 
....................             //should automatically close.  but after so many seconds we 
....................             //shall kill the connection 
....................             /* 
....................             printf("\r\nClosing HTTP %U/%U.... ", hs, currSocket); 
....................                ui_disp_mac_user(&TCB[currSocket].remote.MACAddr); 
....................                printf(" MAC="); 
....................                ui_disp_ip_user(&TCB[currSocket].remote.IPAddr); 
....................                printf("\r\n"); 
....................                */ 
....................              
....................             http_state[g_HttpCurrConn]=HTTP_CLOSE_WAITING; 
0A620:  CLRF   03
0A622:  MOVLB  2
0A624:  MOVF   x11,W
0A626:  ADDLW  0F
0A628:  MOVWF  FE9
0A62A:  MOVLW  02
0A62C:  ADDWFC 03,W
0A62E:  MOVWF  FEA
0A630:  MOVLW  0A
0A632:  MOVWF  FEF
....................             http_timer[g_HttpCurrConn]=TickGet(); 
0A634:  MOVF   x11,W
0A636:  MULLW  04
0A638:  MOVF   FF3,W
0A63A:  CLRF   03
0A63C:  ADDLW  7D
0A63E:  MOVWF  01
0A640:  MOVLW  03
0A642:  ADDWFC 03,F
0A644:  MOVFF  01,3CE
0A648:  MOVFF  03,3CF
0A64C:  MOVLB  0
0A64E:  CALL   2424
0A652:  MOVFF  3CF,FEA
0A656:  MOVFF  3CE,FE9
0A65A:  MOVFF  00,FEF
0A65E:  MOVFF  01,FEC
0A662:  MOVFF  02,FEC
0A666:  MOVFF  03,FEC
....................              
....................          case HTTP_CLOSE_WAITING: 
....................             TCPDiscard(g_HttpCurrSocket); 
0A66A:  MOVFF  210,3CE
0A66E:  CALL   8118
....................             if (   
....................                   (TCPGetTxFIFOFull(g_HttpCurrSocket) == 0) || 
....................                   (TickGetDiff(TickGet(),http_timer[g_HttpCurrConn]) > (TICKS_PER_SECOND*8)) 
0A672:  MOVFF  210,3CE
0A676:  CALL   98B6
0A67A:  MOVFF  02,3CF
0A67E:  MOVFF  01,3CE
0A682:  MOVLB  3
0A684:  MOVF   xCE,F
0A686:  BNZ   A68C
0A688:  MOVF   xCF,F
0A68A:  BZ    A6F4
0A68C:  MOVLB  0
0A68E:  CALL   2424
0A692:  MOVFF  03,3D1
0A696:  MOVFF  02,3D0
0A69A:  MOVFF  01,3CF
0A69E:  MOVFF  00,3CE
0A6A2:  MOVLB  2
0A6A4:  MOVF   x11,W
0A6A6:  MULLW  04
0A6A8:  MOVF   FF3,W
0A6AA:  CLRF   03
0A6AC:  ADDLW  7D
0A6AE:  MOVWF  FE9
0A6B0:  MOVLW  03
0A6B2:  ADDWFC 03,W
0A6B4:  MOVWF  FEA
0A6B6:  MOVFF  FEF,00
0A6BA:  MOVFF  FEC,01
0A6BE:  MOVFF  FEC,02
0A6C2:  MOVFF  FEC,03
0A6C6:  MOVF   00,W
0A6C8:  MOVLB  3
0A6CA:  SUBWF  xCE,F
0A6CC:  MOVF   01,W
0A6CE:  SUBWFB xCF,F
0A6D0:  MOVF   02,W
0A6D2:  SUBWFB xD0,F
0A6D4:  MOVF   03,W
0A6D6:  SUBWFB xD1,F
0A6D8:  BNZ   A6F4
0A6DA:  MOVF   xD0,W
0A6DC:  SUBLW  01
0A6DE:  BC    A73C
0A6E0:  XORLW  FF
0A6E2:  BNZ   A6F4
0A6E4:  MOVF   xCF,W
0A6E6:  SUBLW  61
0A6E8:  BC    A73C
0A6EA:  XORLW  FF
0A6EC:  BNZ   A6F4
0A6EE:  MOVF   xCE,W
0A6F0:  SUBLW  58
0A6F2:  BC    A73C
....................                ) 
....................             { 
....................                if (TCPGetTxFIFOFull(g_HttpCurrSocket) != 0) 
0A6F4:  MOVFF  210,3CE
0A6F8:  MOVLB  0
0A6FA:  CALL   98B6
0A6FE:  MOVFF  02,3CF
0A702:  MOVFF  01,3CE
0A706:  MOVLB  3
0A708:  MOVF   xCE,F
0A70A:  BNZ   A710
0A70C:  MOVF   xCF,F
0A70E:  BZ    A71C
....................                { 
....................                   //socket is messed up.  just kill it by calling TCPDisconnect() twice. 
....................                   TCPDisconnect(g_HttpCurrSocket); 
0A710:  MOVFF  210,3CE
0A714:  MOVLB  0
0A716:  CALL   3C3E
0A71A:  MOVLB  3
....................                } 
....................                TCPDisconnect(g_HttpCurrSocket); 
0A71C:  MOVFF  210,3CE
0A720:  MOVLB  0
0A722:  CALL   3C3E
....................                http_state[g_HttpCurrConn]=HTTP_CLOSED; 
0A726:  CLRF   03
0A728:  MOVLB  2
0A72A:  MOVF   x11,W
0A72C:  ADDLW  0F
0A72E:  MOVWF  FE9
0A730:  MOVLW  02
0A732:  ADDWFC 03,W
0A734:  MOVWF  FEA
0A736:  MOVLW  0B
0A738:  MOVWF  FEF
0A73A:  MOVLB  3
....................             } 
....................             break; 
0A73C:  MOVLB  0
0A73E:  BRA    A740
....................  
....................          case HTTP_CLOSED: //do nothing until socket actually closes 
....................          default: 
....................             break; 
....................       } 
....................        
....................      #if defined(__DO_DEBUG_HTML) 
0A740:  MOVLB  2
0A742:  INCF   x11,F
0A744:  GOTO   992A
....................       //HTTP_NUM_SOCKETS 
....................       if (debug != http_state[g_HttpCurrConn]) 
....................       { 
....................          debug_html(debug_html_putc, "\r\nHTML %U %X->%X ", g_HttpCurrConn, debug, http_state[g_HttpCurrConn]); 
....................          debug = http_state[g_HttpCurrConn]; 
....................       } 
....................      #endif 
....................    } 
0A748:  MOVLB  0
0A74A:  GOTO   A752 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP) && !defined(__SMTP_C) 
....................    #include "smtp.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TWITTER) 
....................    #include "ccs_twitter.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) && !defined(__ANNOUNCE_C) 
....................    #include "Announce.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.c" 
.................... #endif 
....................  
.................... #if defined(__18CXX) 
....................    #include "p18cxxx.c" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_C__ 
.................... #define __P18CXXXX_C__ 
....................  
.................... #include "p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................  #include "PIC18F4620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1) 
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(rom char *s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... /* STRING.H already has this exact function 
.................... signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n) 
.................... { 
....................   #if 1 
....................    char *su1; 
....................    rom char *su2; 
....................     
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................          return ((*su1<*su2)?-1:+1); 
....................    } 
....................    return 0; 
....................   #else 
....................    #error///warning memcmppgm2ram disabled 
....................   #endif 
.................... }*/ 
....................  
.................... #if 0 //this is in string.h and helpers.c 
.................... char* strupr(char *s) 
.................... { 
....................    char *p; 
....................     
....................    p=s; 
....................     
....................    while(*p) 
....................    { 
....................       *p = toupper(*p++); 
....................    } 
....................    return(s); 
.................... } 
.................... #endif 
....................  
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n) 
.................... { 
....................    //printf("ROM_0x%LX-to-0x%LX ", d, s); 
....................   #if (getenv("PROGRAM_MEMORY") > 0x10000) 
....................    #warning temporary ccs bug fix 
....................    s |= 0x10000; 
*
079D2:  MOVLB  4
079D4:  BSF    x0A.0
....................   #endif 
....................    read_program_memory(s, d, n); 
079D6:  MOVFF  40A,FF8
079DA:  MOVFF  409,FF7
079DE:  MOVFF  408,FF6
079E2:  MOVFF  407,FEA
079E6:  MOVFF  406,FE9
079EA:  MOVFF  40D,40F
079EE:  MOVFF  40C,40E
079F2:  MOVLB  0
079F4:  BRA    79B2
079F6:  RETURN 0
.................... } 
....................  
.................... void strcpypgm2ram(char *d, __ADDRESS__ s) 
.................... { 
....................    char c; 
....................    do 
....................    { 
....................       memcpypgm2ram(&c, s++, 1); 
*
0818C:  MOVLB  3
0818E:  MOVFF  3F1,03
08192:  MOVFF  3F0,02
08196:  MOVFF  3EF,01
0819A:  MOVFF  3EE,00
0819E:  MOVLW  01
081A0:  ADDWF  xEE,F
081A2:  BTFSC  FD8.0
081A4:  INCF   xEF,F
081A6:  BTFSC  FD8.2
081A8:  INCF   xF0,F
081AA:  BTFSC  FD8.2
081AC:  INCF   xF1,F
081AE:  MOVFF  03,3F6
081B2:  MOVFF  02,3F5
081B6:  MOVFF  01,3F4
081BA:  MOVFF  00,3F3
081BE:  MOVLW  03
081C0:  MOVLB  4
081C2:  MOVWF  x07
081C4:  MOVLW  F2
081C6:  MOVWF  x06
081C8:  MOVFF  03,40B
081CC:  MOVFF  02,40A
081D0:  MOVFF  01,409
081D4:  MOVFF  00,408
081D8:  CLRF   x0D
081DA:  MOVLW  01
081DC:  MOVWF  x0C
081DE:  MOVLB  0
081E0:  CALL   79D2
....................       *d++ = c; 
081E4:  MOVLB  3
081E6:  MOVFF  3ED,03
081EA:  MOVF   xEC,W
081EC:  INCF   xEC,F
081EE:  BTFSC  FD8.2
081F0:  INCF   xED,F
081F2:  MOVWF  FE9
081F4:  MOVFF  03,FEA
081F8:  MOVFF  3F2,FEF
....................    } while(c); 
081FC:  MOVF   xF2,F
081FE:  BNZ   818E
08200:  MOVLB  0
08202:  RETURN 0
.................... } 
....................  
.................... #if 0 
.................... signed int8 strcmppgm2ram(char *s1, rom char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... #endif 
....................  
.................... char *strchrpgm(rom char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
....................  
.................... char *strstrrampgm(char *s1,__ADDRESS__ s2) 
.................... { 
....................    char *s; 
....................    rom char *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... unsigned int8 strlenpgm( __ADDRESS__ s) 
.................... { 
....................    char c; 
....................    char counter = 0; 
....................    do{ 
....................       memcpypgm2ram(&c,s++,1); 
....................       counter++; 
....................    }while(c != 0); 
....................    return(counter - 1); 
.................... } 
.................... //#endif   //if 0 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void) 
.................... { 
....................   #if defined(STACK_USE_DHCP_CLIENT) 
....................    return(!DHCPIsEnabled(0) || DHCPIsBound(0)); 
....................   #else 
....................    return(TRUE); 
....................   #endif 
.................... } 
....................  
.................... int1 IsLinked(void) 
.................... { 
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       return(MACIsLinked() && g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................     
....................    return(MACIsLinked() && DHCPBoundOrDisabled()); 
.................... } 
....................  
.................... #if defined(STACK_USE_MPFS) 
.................... MPFS _MpfsEofLoc; 
....................  
.................... unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n) 
*
08716:  MOVLB  3
08718:  CLRF   xFC
0871A:  CLRF   xFB
0871C:  MOVLB  4
0871E:  BCF    x01.0
.................... { 
....................    unsigned int16 ret = 0; 
....................    unsigned int16 i; 
....................    unsigned int8 *p; 
....................    int1 escaped = FALSE; 
....................     
....................    p = pDest; 
08720:  MOVFF  3F8,400
08724:  MOVFF  3F7,3FF
....................     
....................    debug_mpfs2(debug_putc, "\r\nMPFSGetBytes() START %LX ", _currentHandle); 
....................     
....................    while(n) 
08728:  MOVLB  3
0872A:  MOVF   xF9,W
0872C:  IORWF  xFA,W
0872E:  BTFSC  FD8.2
08730:  BRA    88AC
....................    { 
....................       HTTP_INTERRUPT_TASKS(); 
....................        
....................       debug_mpfs2(debug_putc, "n=%LX ", n); 
....................        
....................       _MpfsEofLoc = _currentHandle; 
08732:  MOVFF  100,104
08736:  MOVFF  FF,103
0873A:  MOVFF  FE,102
0873E:  MOVFF  FD,101
....................      #if defined(MPFS_USE_SPI_FLASH) 
....................       SPIFlashReadArray(_currentHandle, pDest, n); 
....................      #else 
....................       memcpypgm2ram(pDest, _currentHandle, n); //__ccs__ change because MPFS isn't rom pointer 
08742:  MOVFF  3F8,407
08746:  MOVFF  3F7,406
0874A:  MOVFF  100,40B
0874E:  MOVFF  FF,40A
08752:  MOVFF  FE,409
08756:  MOVFF  FD,408
0875A:  MOVFF  3FA,40D
0875E:  MOVFF  3F9,40C
08762:  MOVLB  0
08764:  CALL   79D2
....................      #endif 
....................  
....................       _currentHandle += n; 
08768:  MOVLB  3
0876A:  MOVF   xF9,W
0876C:  MOVLB  0
0876E:  ADDWF  xFD,F
08770:  MOVLB  3
08772:  MOVF   xFA,W
08774:  MOVLB  0
08776:  ADDWFC xFE,F
08778:  MOVLW  00
0877A:  ADDWFC xFF,F
0877C:  MOVLB  1
0877E:  ADDWFC x00,F
....................  
....................       //debug_array("START", pDest, n); 
....................  
....................       i = n; 
08780:  MOVFF  3FA,3FE
08784:  MOVFF  3F9,3FD
....................       n = 0; 
08788:  MOVLB  3
0878A:  CLRF   xFA
0878C:  CLRF   xF9
....................        
....................       while(i--) 
0878E:  MOVFF  3FE,03
08792:  MOVF   xFD,W
08794:  BTFSC  FD8.2
08796:  DECF   xFE,F
08798:  DECF   xFD,F
0879A:  IORWF  03,W
0879C:  BTFSC  FD8.2
0879E:  BRA    88AA
....................       { 
....................          _MpfsEofLoc++; 
087A0:  MOVLW  01
087A2:  MOVLB  1
087A4:  ADDWF  x01,F
087A6:  BTFSC  FD8.0
087A8:  INCF   x02,F
087AA:  BTFSC  FD8.2
087AC:  INCF   x03,F
087AE:  BTFSC  FD8.2
087B0:  INCF   x04,F
....................          if (escaped || (*pDest == MPFS_DLE)) 
087B2:  MOVLB  4
087B4:  BTFSC  x01.0
087B6:  BRA    87CE
087B8:  MOVFF  3F8,03
087BC:  MOVLB  3
087BE:  MOVFF  3F7,FE9
087C2:  MOVFF  3F8,FEA
087C6:  MOVF   FEF,W
087C8:  SUBLW  03
087CA:  BNZ   8860
087CC:  MOVLB  4
....................          { 
....................             if (!escaped) 
087CE:  BTFSC  x01.0
087D0:  BRA    87DC
....................             { 
....................                n++; 
087D2:  MOVLB  3
087D4:  INCF   xF9,F
087D6:  BTFSC  FD8.2
087D8:  INCF   xFA,F
087DA:  MOVLB  4
....................             } 
....................              
....................             if (escaped || i) 
087DC:  BTFSC  x01.0
087DE:  BRA    87EA
087E0:  MOVLB  3
087E2:  MOVF   xFD,W
087E4:  IORWF  xFE,W
087E6:  BZ    884C
087E8:  MOVLB  4
....................             { 
....................                if (!escaped) 
087EA:  BTFSC  x01.0
087EC:  BRA    883C
....................                { 
....................                   debug_mpfs2(debug_putc, "! "); 
....................                   memmove(pDest, pDest+1, i); 
087EE:  MOVLW  01
087F0:  MOVLB  3
087F2:  ADDWF  xF7,W
087F4:  MOVLB  4
087F6:  MOVWF  x02
087F8:  MOVLW  00
087FA:  MOVLB  3
087FC:  ADDWFC xF8,W
087FE:  MOVLB  4
08800:  MOVWF  x03
08802:  MOVFF  3F8,405
08806:  MOVFF  3F7,404
0880A:  MOVWF  x07
0880C:  MOVFF  402,406
08810:  MOVFF  3FE,409
08814:  MOVFF  3FD,408
08818:  MOVLB  0
0881A:  CALL   75E8
....................                   _MpfsEofLoc++; 
0881E:  MOVLW  01
08820:  MOVLB  1
08822:  ADDWF  x01,F
08824:  BTFSC  FD8.0
08826:  INCF   x02,F
08828:  BTFSC  FD8.2
0882A:  INCF   x03,F
0882C:  BTFSC  FD8.2
0882E:  INCF   x04,F
....................                   i--; 
08830:  MOVLB  3
08832:  MOVF   xFD,W
08834:  BTFSC  FD8.2
08836:  DECF   xFE,F
08838:  DECF   xFD,F
0883A:  MOVLB  4
....................                } 
....................                ret++; 
0883C:  MOVLB  3
0883E:  INCF   xFB,F
08840:  BTFSC  FD8.2
08842:  INCF   xFC,F
....................                escaped = FALSE; 
08844:  MOVLB  4
08846:  BCF    x01.0
....................             } 
08848:  BRA    885C
0884A:  MOVLB  3
....................             else 
....................             { 
....................                escaped = TRUE; 
0884C:  MOVLB  4
0884E:  BSF    x01.0
....................                pDest--; //counter pDest++ below, since we need to start saving new bytes here 
08850:  MOVLB  3
08852:  MOVF   xF7,W
08854:  BTFSC  FD8.2
08856:  DECF   xF8,F
08858:  DECF   xF7,F
0885A:  MOVLB  4
....................             } 
....................          } 
0885C:  BRA    88A0
0885E:  MOVLB  3
....................          else if(*pDest == MPFS_ETX) 
08860:  MOVFF  3F8,03
08864:  MOVFF  3F7,FE9
08868:  MOVFF  3F8,FEA
0886C:  MOVF   FEF,W
0886E:  SUBLW  04
08870:  BNZ   8898
....................          { 
....................             _MpfsEofLoc--; 
08872:  MOVLW  FF
08874:  MOVLB  1
08876:  ADDWF  x01,F
08878:  BTFSS  FD8.0
0887A:  ADDWF  x02,F
0887C:  BTFSS  FD8.0
0887E:  ADDWF  x03,F
08880:  BTFSS  FD8.0
08882:  ADDWF  x04,F
....................             debug_mpfs2(debug_putc, "EOF %LX ", _MpfsEofLoc); 
....................             _currentHandle = MPFS_INVALID; 
08884:  SETF   x00
08886:  MOVLB  0
08888:  SETF   xFF
0888A:  SETF   xFE
0888C:  SETF   xFD
....................             n = 0; 
0888E:  MOVLB  3
08890:  CLRF   xFA
08892:  CLRF   xF9
....................             break; 
08894:  BRA    88AA
....................          } 
08896:  BRA    889E
....................          else 
....................          { 
....................             ret++; 
08898:  INCF   xFB,F
0889A:  BTFSC  FD8.2
0889C:  INCF   xFC,F
0889E:  MOVLB  4
....................          } 
....................          pDest++; 
088A0:  MOVLB  3
088A2:  INCF   xF7,F
088A4:  BTFSC  FD8.2
088A6:  INCF   xF8,F
088A8:  BRA    878E
....................       } 
088AA:  BRA    872A
....................    } 
....................    //debug_array("STOP", p, ret);    
....................  
....................    return(ret); 
088AC:  MOVFF  3FB,01
088B0:  MOVFF  3FC,02
088B4:  MOVLB  0
088B6:  GOTO   8ACA (RETURN)
.................... } 
.................... #ENDIF 
....................  
.................... #if STACK_USE_WIFI 
....................  
.................... //extern int1 g_WifiTempDisFlag; 
.................... //extern TICK g_WifiTempDisTick; 
.................... //extern int1 g_wifiConnected; 
.................... extern int1 g_WifiConnectFail; 
....................  
.................... // see StackTsk2.h for documentation 
.................... #if 0 
.................... int1 MyWFisConnected(void) 
.................... { 
....................    int1 ret = FALSE; 
....................  
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................       return(g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................  
....................    if (g_wifiConnected) 
....................    { 
....................       ret = TRUE; 
....................    } 
....................    else if (!g_WifiConnectFail) 
....................    { 
....................       if (g_WifiTempDisFlag) 
....................       { 
....................          if ((TickGet() - g_WifiTempDisTick) < ((TICK)5*TICKS_PER_SECOND)) 
....................          { 
....................             ret = TRUE; 
....................          } 
....................          else 
....................          { 
....................             g_WifiTempDisFlag = FALSE; 
....................          } 
....................       } 
....................    } 
....................  
....................    return(ret); 
.................... } 
.................... #endif 
....................  
.................... unsigned int8 g_connectionProfileID = 0xFF;  //used to communicate with the connection profile on the WiFi module 
....................  
.................... unsigned int8 WIFI_channelList[16]; 
.................... unsigned int8 WIFI_numChannelsInList; 
.................... unsigned int8 WIFI_region; 
....................  
.................... // this option will force the connection profile to be closed and reopened 
.................... // if we do not get a connection within this time.  might fix an errata that 
.................... // says WPA/WPA2 will lockup instead of sending an event. 
.................... #define WIFI_FORCE_RECONNECT_TICK   (TICK)(TICKS_PER_SECOND * 120)  //might be too short for WPA/WPA2 phrase 
....................  
.................... #if defined(WIFI_GET_VERSION_INFO) 
.................... tWFDeviceInfo WIFI_GET_VERSION_INFO; 
.................... #endif 
....................  
.................... void WIFIConnectInitStates(void) 
.................... { 
....................    //wf_debug_printf(wf_debug_putc, "\r\nWIFIConnectInitStates"); 
....................     
....................    g_connectionProfileID = 0xFF; 
....................     
....................    g_WifiConnectFail = FALSE;    
....................     
....................   #if defined(STACK_USE_CCS_SCAN_TASK) 
....................    WIFIScanInit(); 
....................   #endif 
....................  
....................         #if defined(WIFI_GET_VERSION_INFO) 
....................          WF_GetDeviceInfo(&WIFI_GET_VERSION_INFO); 
....................         #endif  
....................  
....................          WF_CASetScanType(MY_DEFAULT_SCAN_TYPE);   // was WF_ACTIVE_SCAN 
....................  
....................          WF_CASetChannelList(WIFI_channelList, WIFI_numChannelsInList); //was AppConfig.channelList, AppConfig.numChannelsInList 
....................  
....................          WF_SetRegionalDomain(WIFI_region);  //was AppConfig.region 
....................           
....................          WF_CASetListRetryCount(MY_DEFAULT_LIST_RETRY_COUNT);  // was WF_RETRY_FOREVER 
....................           
....................          WF_CASetEventNotificationAction(MY_DEFAULT_EVENT_NOTIFICATION_LIST); // was WF_NOTIFY_ALL_EVENTS 
....................           
....................          WF_CASetBeaconTimeout(MY_DEFAULT_BEACON_TIMEOUT); 
....................  
....................          WF_CASetBeaconTimeoutAction(WF_ATTEMPT_TO_RECONNECT); 
....................           
....................          WF_CASetDeauthAction(WF_ATTEMPT_TO_RECONNECT); 
....................  
....................        #if defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................            if (AppConfig.SecurityMode == WF_SECURITY_WPA_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA2_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) { 
....................                WF_ConvPassphrase2Key(AppConfig.SecurityKeyLength, AppConfig.SecurityKey, 
....................                    AppConfig.SsidLength, AppConfig.MySSID); 
....................                AppConfig.SecurityMode--; 
....................                AppConfig.SecurityKeyLength = 32; 
....................            } 
....................        #if defined (MRF24WG) 
....................            else if (AppConfig.SecurityMode == WF_SECURITY_WPS_PUSH_BUTTON 
....................                        || AppConfig.SecurityMode == WF_SECURITY_WPS_PIN) { 
....................                WF_YieldPassphrase2Host();     
....................            } 
....................        #endif    // defined (MRF24WG) 
....................        #endif    // defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................  
....................        #ifndef WF_FORCE_NO_PS_POLL 
....................        #if MY_DEFAULT_PS_POLL == WF_ENABLED 
....................            WF_PsPollEnable(TRUE); 
....................        #if !defined(MRF24WG)  
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableDeferredPowerSave(); 
....................        #endif    // !defined(MRF24WG) 
....................        #else     // MY_DEFAULT_PS_POLL != WF_ENABLED 
....................            WF_PsPollDisable(); 
....................        #endif    // MY_DEFAULT_PS_POLL == WF_ENABLED 
....................     
....................        #ifdef WF_AGGRESSIVE_PS 
....................        #if !defined(MRF24WG) 
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableAggressivePowerSave(); 
....................        #endif 
....................        #endif 
....................        #endif  
.................... } 
....................  
.................... int1 g_WIFIConnectStart = TRUE; 
....................  
.................... void WIFIConnectStop(void) 
.................... { 
....................    if (!MACIsLinked() || (g_connectionProfileID == 0xFF)) 
....................    { 
....................       //wf_debug_printf(wf_debug_putc, "\r\n\n*** Reset of MAC because WIFIConnectStop()\r\n"); 
....................       MACInit(); 
....................    } 
....................   #if defined(WF_DEBUG) 
....................    else 
....................    { 
....................       //wf_debug_printf(wf_debug_putc, "\r\nWIFIConnectStop"); 
....................    } 
....................   #endif 
....................     
....................    g_WIFIConnectStart = FALSE; 
.................... } 
....................  
.................... void WIFIConnectStart(void) 
.................... { 
....................    //wf_debug_printf(wf_debug_putc, "\r\nWIFIConnectStart"); 
....................     
....................    g_WIFIConnectStart = TRUE; 
.................... } 
....................  
.................... // this was based off of WF_Connect() in Microchip's demo application. 
.................... void WIFIConnectTask(void) 
.................... { 
....................    #if !defined(APP_GENERIC_SCRATCH) 
....................       char WIFIConnectTask_Scratch[6]; 
....................    #else 
....................       #define WIFIConnectTask_Scratch  APP_GENERIC_SCRATCH 
....................    #endif 
....................     
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    static TICK fTick; 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) || defined(LED_ACTIVITY_ON) 
....................    static TICK l; 
....................    // if you have both LED_CONNECTION_ON and LED_ACTIVITY_ON (2 WIFI LEDs),  
....................    //    then one LED is used for flickering on traffic and another is used to  
....................    //    show connection state. 
....................    // if you only have LED_CONNECTION_ON (only 1 WIFI LED), then WIFI  
....................    //    connection status and wifi traffic flickering is shared on the same 
....................    //    LED. 
....................    // this routine below handles the traffic led flickering.  the LED was 
....................    //    turned off in the TCP/IP stack, this routine turns it back on every 
....................    //    200ms. 
....................    if ((TickGet() - l) >= TICKS_PER_SECOND/5) 
....................    { 
....................       l = TickGet(); 
....................        
....................      #if defined(LED_ACTIVITY_ON) 
....................       LED_ACTIVITY_OFF(); 
....................      #else 
....................       if (IsLinked()) 
....................       { 
....................          LED_CONNECTION_ON(); 
....................       } 
....................       else 
....................       { 
....................          LED_CONNECTION_OFF(); 
....................       } 
....................      #endif 
....................    } 
....................   #endif 
....................  
....................   #if defined(STACK_USE_CCS_SCAN_TASK) 
....................    WIFIScanTask(); 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) && defined(LED_ACTIVITY_ON) 
....................    // handle the connection status LED if you have 2 WIFI LEDs. 
....................    if (IsLinked()) 
....................    { 
....................       LED_CONNECTION_ON(); 
....................    } 
....................    else 
....................    { 
....................       LED_CONNECTION_OFF(); 
....................    } 
....................   #endif 
....................  
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................    } 
....................   #endif 
....................  
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    if ( 
....................          (AppConfig.networkType != WF_ADHOC) && 
....................          (g_connectionProfileID != 0xFF) 
....................       ) 
....................    { 
....................       if (IsLinked()) 
....................       { 
....................          fTick = TickGet(); 
....................       } 
....................       else if ((TickGet() - fTick) > WIFI_FORCE_RECONNECT_TICK) 
....................       { 
....................         #if defined(STACK_IS_CCS_EXAMPLE) 
....................          fprintf(STREAM_UI, "\r\nLong WIFI connection timeout, reseting module"); 
....................         #endif 
....................          MACInit(); 
....................         #if defined(WIFI_EXTRA_LINK_STATUS) 
....................          g_LastWifiEvent = 20; 
....................         #endif 
....................       } 
....................    } 
....................   #endif 
....................  
....................    if ((g_connectionProfileID == 0xFF) && g_WIFIConnectStart) 
....................    { 
....................       g_WifiConnectFail = FALSE; 
....................        
....................       WF_CPCreate(&g_connectionProfileID); 
....................        
....................       #if defined(WF_DEBUG) 
....................       wf_debug_printf(wf_debug_putc, "\r\nCreating connect profile... "); 
....................       #endif 
....................        
....................       if (g_connectionProfileID != 0xFF) 
....................       { 
....................          /* 
....................         #if defined(WIFI_GET_VERSION_INFO) 
....................          WF_GetDeviceInfo(&WIFI_GET_VERSION_INFO); 
....................         #endif 
....................         */ 
....................          #if defined(WF_DEBUG) 
....................          wf_debug_printf(wf_debug_putc, "%U ", g_connectionProfileID); 
....................          #endif 
....................  
....................          g_WifiConnectFail = TRUE; 
....................  
....................          WF_CPSetSsid(g_connectionProfileID,  
....................                     AppConfig.MySSID,  
....................                     AppConfig.SsidLength); 
....................           
....................          memset(WIFIConnectTask_Scratch, 0xFF, 6); 
....................          WF_CPSetBssid(g_connectionProfileID, WIFIConnectTask_Scratch); 
....................  
....................          WF_CPSetNetworkType(g_connectionProfileID, AppConfig.networkType); 
....................           
....................          if(AppConfig.networkType == WF_ADHOC) 
....................          { 
....................             WF_CPSetAdHocBehavior(g_connectionProfileID, AppConfig.adhocBehavior); 
....................          } 
....................  
....................          /* 
....................          WF_CASetScanType(MY_DEFAULT_SCAN_TYPE);   // was WF_ACTIVE_SCAN 
....................  
....................          WF_CASetChannelList(WIFI_channelList, WIFI_numChannelsInList); //was AppConfig.channelList, AppConfig.numChannelsInList 
....................  
....................          WF_SetRegionalDomain(WIFI_region);  //was AppConfig.region 
....................           
....................          WF_CASetListRetryCount(MY_DEFAULT_LIST_RETRY_COUNT);  // was WF_RETRY_FOREVER 
....................           
....................          WF_CASetEventNotificationAction(MY_DEFAULT_EVENT_NOTIFICATION_LIST); // was WF_NOTIFY_ALL_EVENTS 
....................           
....................          WF_CASetBeaconTimeout(MY_DEFAULT_BEACON_TIMEOUT); 
....................  
....................          WF_CASetBeaconTimeoutAction(WF_ATTEMPT_TO_RECONNECT); 
....................           
....................          WF_CASetDeauthAction(WF_ATTEMPT_TO_RECONNECT); 
....................  
....................        #if defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................            if (AppConfig.SecurityMode == WF_SECURITY_WPA_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA2_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) { 
....................                WF_ConvPassphrase2Key(AppConfig.SecurityKeyLength, AppConfig.SecurityKey, 
....................                    AppConfig.SsidLength, AppConfig.MySSID); 
....................                AppConfig.SecurityMode--; 
....................                AppConfig.SecurityKeyLength = 32; 
....................            } 
....................        #if defined (MRF24WG) 
....................            else if (AppConfig.SecurityMode == WF_SECURITY_WPS_PUSH_BUTTON 
....................                        || AppConfig.SecurityMode == WF_SECURITY_WPS_PIN) { 
....................                WF_YieldPassphrase2Host();     
....................            } 
....................        #endif    // defined (MRF24WG) 
....................        #endif    // defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................        */ 
....................  
....................          WF_CPSetSecurity(g_connectionProfileID, 
....................                         AppConfig.SecurityMode, 
....................                         0, //AppConfig.WepKeyIndex, //AppConfig.WepKeyIndex,   /* only used if WEP enabled */ 
....................                         AppConfig.SecurityKey, 
....................                         AppConfig.SecurityKeyLength);       
....................   
....................       #if (MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE!=WF_SECURITY_WEP_SHAREDKEY) 
....................         #if !defined(MRF24WG) 
....................          if (gRFModuleVer1209orLater) 
....................         #endif 
....................          { 
....................             // If WEP security is used, set WEP Key Type.  The default WEP Key Type is Shared Key. 
....................             if ((AppConfig.SecurityMode == WF_SECURITY_WEP_40) || (AppConfig.SecurityMode == WF_SECURITY_WEP_104)) 
....................             { 
....................                 WF_CPSetWepKeyType(g_connectionProfileID, MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE); 
....................             } 
....................          } 
....................      #endif 
....................  
....................          /* 
....................        #ifndef WF_FORCE_NO_PS_POLL 
....................        #if MY_DEFAULT_PS_POLL == WF_ENABLED 
....................            WF_PsPollEnable(TRUE); 
....................        #if !defined(MRF24WG)  
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableDeferredPowerSave(); 
....................        #endif    // !defined(MRF24WG) 
....................        #else     // MY_DEFAULT_PS_POLL != WF_ENABLED 
....................            WF_PsPollDisable(); 
....................        #endif    // MY_DEFAULT_PS_POLL == WF_ENABLED 
....................     
....................        #ifdef WF_AGGRESSIVE_PS 
....................        #if !defined(MRF24WG) 
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableAggressivePowerSave(); 
....................        #endif 
....................        #endif 
....................        #endif 
....................          */ 
....................       } 
....................    } 
....................  
....................    if(g_WifiConnectFail && g_WIFIConnectStart) 
....................    { 
....................       #if defined(WF_DEBUG) 
....................       wf_debug_printf(wf_debug_putc, "\r\nStart WiFi Connect PROF=%u ", g_connectionProfileID); 
....................       #endif 
....................       
....................      #if defined(STACK_IS_CCS_EXAMPLE) 
....................       fprintf(STREAM_UI, "\r\nStart WiFi Connect"); 
....................      #endif 
....................       
....................      #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................       fTick = TickGet(); 
....................      #endif 
....................  
....................      #if defined(WF_FORCE_NO_PS_POLL) 
....................       WF_CCS_PsPollDisable(); 
....................      #endif 
....................     
....................       WF_CMConnect(g_connectionProfileID); 
....................    } 
....................     
....................    g_WifiConnectFail = 0; 
.................... } 
....................  
.................... void LinkTraffic(int1 isTx) 
.................... { 
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (!isTx && (AppConfig.networkType == WF_ADHOC)) 
....................    { 
....................       g_WifiAdhocIsConn = TRUE; 
....................       g_WifiAdhocTickConn = TickGet(); 
....................    } 
....................   #endif 
....................  
....................    // these LEDs are desribed in WIFIConnectTask() 
....................   #if defined(LED_ACTIVITY_ON) 
....................    LED_ACTIVITY_ON(); 
....................   #elif defined(LED_CONNECTION_ON) 
....................    LED_CONNECTION_OFF(); 
....................   #endif 
.................... } 
....................  
....................  
.................... #if defined(WF_FORCE_NO_PS_POLL) 
.................... #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................    #error dont use both at the same time 
.................... #endif 
.................... typedef struct pwrModeRequestStruct 
.................... { 
....................     UINT8 mode; 
....................     UINT8 wake; 
....................     UINT8 rcvDtims; 
....................     UINT8 reserved;            /* pad byte */ 
.................... } tWFPwrModeReq; 
....................  
.................... static void SendPowerModeMsg(tWFPwrModeReq *p_powerMode) 
.................... { 
....................     UINT8 hdr[2]; 
....................      
....................     hdr[0] = WF_MGMT_REQUEST_TYPE; 
....................     hdr[1] = WF_SET_POWER_MODE_SUBTYPE; 
....................  
....................     SendMgmtMsg(hdr, 
....................                 sizeof(hdr), 
....................                (UINT8 *)p_powerMode, 
....................                sizeof(tWFPwrModeReq)); 
....................  
....................     /* wait for mgmt response, free buffer after it comes in (no data to read) */ 
....................    WaitForMgmtResponse(WF_SET_POWER_MODE_SUBTYPE, FREE_MGMT_BUFFER); 
....................      
.................... }  
....................  
.................... void WF_CCS_PsPollDisable(void) 
.................... { 
....................    tWFPwrModeReq   pwrModeReq; 
....................      
....................     pwrModeReq.mode     = 1;  //PS_POLL_DISABLED; 
....................     pwrModeReq.wake     = 1; 
....................     pwrModeReq.rcvDtims = 1; 
....................     SendPowerModeMsg(&pwrModeReq); 
....................  
....................     //SetPowerSaveState(WF_PS_OFF); //not really needed, sets a global for their statemachine 
....................  
....................     WFConfigureLowPowerMode(WF_LOW_POWER_MODE_OFF);  
.................... } 
.................... #endif   //WF_FORCE_NO_PS_POLL 
....................  
.................... #endif //STACK_USE_WIFI 
....................  
.................... #if defined(__DO_DEBUG_MPFS2) 
.................... void debug_array(char *str, char *p, unsigned int16 n) 
.................... { 
....................    char c; 
....................    debug_mpfs2(debug_putc, "\r\n%s %LX ", str, n); 
....................    while(n--) 
....................    { 
....................       c = *p++; 
....................       if ((c >= ' ') && (c <= '}')) 
....................       { 
....................          debug_mpfs2(debug_putc, "%c", c); 
....................       } 
....................       else 
....................       { 
....................          debug_mpfs2(debug_putc, "+%X", c); 
....................       } 
....................    } 
....................    debug_mpfs2(debug_putc, " "); 
.................... } 
.................... #else 
.................... #define debug_array(str, p, n) 
.................... #endif 
....................  
.................... // if you call TickGet() from an ISR, this may be a lock-up condition. 
.................... // this is a morph of GetTickCopy() and TickUpdate() that works from an ISR. 
.................... // only works on PIC18. 
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void) 
.................... { 
....................    BYTE myTickReading[6]; 
....................    do 
....................    { 
....................       if(INTCONbits.TMR0IF) 
....................       { 
....................          dwInternalTicks++; 
....................          INTCONbits.TMR0IF = 0; 
....................       } 
....................       myTickReading[0] = TMR0L; 
....................       myTickReading[1] = TMR0H; 
....................       *((DWORD*)&myTickReading[2]) = dwInternalTicks; 
....................    } while(INTCONbits.TMR0IF); 
....................     
....................    return *((DWORD*)&myTickReading[0]); 
.................... } 
.................... #endif 
....................  
.................... // this used to be called GenerateRandomBYTE() in an older CCS port of Helpers.c 
.................... BYTE GenerateRandomByteFromTimers(void) 
.................... { 
....................    BYTE rand; 
....................     
....................   #if getenv("TIMER0") && !defined(__PCD__) 
....................    rand+=get_timer0(); 
....................   #endif 
....................    
....................   #if getenv("TIMER1") 
....................    rand+=get_timer1(); 
....................   #endif 
....................    
....................   #if getenv("TIMER2") 
....................    rand+=get_timer2(); 
....................   #endif 
....................    
....................   #if getenv("TIMER3") 
....................    rand+=get_timer3(); 
....................   #endif 
....................    
....................   #if getenv("TIMER4") 
....................    rand+=get_timer4(); 
....................   #endif 
....................    
....................   #if getenv("TIMER5") 
....................    rand+=get_timer5(); 
....................   #endif 
....................    
....................    return(rand); 
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #use standard_io(b) 
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits=8, parity=N,BRGH1OK,ERRORS) 
*
00218:  BTFSS  F9E.5
0021A:  BRA    0218
0021C:  MOVFF  FAB,381
00220:  MOVLB  3
00222:  MOVFF  FAE,01
00226:  BTFSS  x81.1
00228:  BRA    022E
0022A:  BCF    FAB.4
0022C:  BSF    FAB.4
0022E:  MOVLB  0
00230:  GOTO   0236 (RETURN)
....................  
.................... #define RX_BUFFER_SIZE  27 
.................... char Rx_Buffer[RX_BUFFER_SIZE+1]; 
.................... char Rx_Buffer2[RX_BUFFER_SIZE+1]; 
.................... int8 RX_Wr_Index=0; 
.................... int8 Dato2=0,Inicio=0,Dato_Exitoso=0,i=0,z=0; 
....................  
.................... #int_rda 
.................... void serial_rx_isr(){ 
....................  
....................    Dato2=fgetc(); 
00234:  BRA    0218
00236:  MOVFF  01,3BB
0023A:  MOVLB  3
....................    if(Dato2==0x65){//Inicio Comunicacion 
0023C:  MOVF   xBB,W
0023E:  SUBLW  65
00240:  BNZ   0248
....................       Inicio=1; 
00242:  MOVLW  01
00244:  MOVWF  xBC
....................       RX_Wr_Index =0; 
00246:  CLRF   xBA
....................    } 
....................    //Inicio=1; 
....................    if(Inicio==1){ 
00248:  DECFSZ xBC,W
0024A:  BRA    0260
....................       Rx_Buffer2[RX_Wr_Index] = Dato2; 
0024C:  CLRF   03
0024E:  MOVF   xBA,W
00250:  ADDLW  9E
00252:  MOVWF  FE9
00254:  MOVLW  03
00256:  ADDWFC 03,W
00258:  MOVWF  FEA
0025A:  MOVFF  3BB,FEF
....................       RX_Wr_Index++; 
0025E:  INCF   xBA,F
....................    } 
....................    if(RX_Wr_Index >= RX_BUFFER_SIZE){ 
00260:  BTFSC  xBA.7
00262:  BRA    026E
00264:  MOVF   xBA,W
00266:  SUBLW  1A
00268:  BC    026E
....................       RX_Wr_Index =0; 
0026A:  CLRF   xBA
....................       Inicio=0; 
0026C:  CLRF   xBC
....................    } 
....................  
....................    if(RX_Wr_Index==0){ 
0026E:  MOVF   xBA,F
00270:  BNZ   028E
....................       if(Rx_Buffer2[0]==0x65 && Rx_Buffer2[1]==0xff && Rx_Buffer2[9]==0x00 && Rx_Buffer2[10]==0xff ){ 
00272:  MOVF   x9E,W
00274:  SUBLW  65
00276:  BNZ   028A
00278:  INCFSZ x9F,W
0027A:  BRA    028A
0027C:  MOVF   xA7,F
0027E:  BNZ   028A
00280:  INCFSZ xA8,W
00282:  BRA    028A
....................          Dato_Exitoso=5; 
00284:  MOVLW  05
00286:  MOVWF  xBD
....................       }else{ 
00288:  BRA    028E
....................          Dato_Exitoso=10; 
0028A:  MOVLW  0A
0028C:  MOVWF  xBD
....................       } 
....................    } 
....................    //output_toggle(PIN_C0); 
0028E:  BCF    F9E.5
00290:  MOVLB  0
00292:  GOTO   0064
.................... } 
....................  
.................... void LeeDisplay(void){     
....................     if(Dato_Exitoso==5){ 
*
0A756:  MOVLB  3
0A758:  MOVF   xBD,W
0A75A:  SUBLW  05
0A75C:  BNZ   A7A2
....................       for(i=0;i<27;i++){ 
0A75E:  CLRF   xBE
0A760:  BTFSC  xBE.7
0A762:  BRA    A76A
0A764:  MOVF   xBE,W
0A766:  SUBLW  1A
0A768:  BNC   A79C
....................          Rx_Buffer[i]=Rx_Buffer2[i]; 
0A76A:  CLRF   03
0A76C:  MOVF   xBE,W
0A76E:  ADDLW  82
0A770:  MOVWF  01
0A772:  MOVLW  03
0A774:  ADDWFC 03,F
0A776:  MOVFF  03,3C1
0A77A:  CLRF   03
0A77C:  MOVF   xBE,W
0A77E:  ADDLW  9E
0A780:  MOVWF  FE9
0A782:  MOVLW  03
0A784:  ADDWFC 03,W
0A786:  MOVWF  FEA
0A788:  MOVFF  FEF,3C2
0A78C:  MOVFF  3C1,FEA
0A790:  MOVFF  01,FE9
0A794:  MOVFF  3C2,FEF
0A798:  INCF   xBE,F
0A79A:  BRA    A760
....................       } 
....................           
....................       if(Rx_Buffer[3]==0x01){// Pregunta por la pagina en la que esta el display,01 es Contrasea de Acceso 
0A79C:  DECFSZ x85,W
0A79E:  BRA    A7A0
....................       } 
....................    }else{ 
0A7A0:  BRA    A7B2
....................       for(z=0;z<RX_BUFFER_SIZE;z++){ 
0A7A2:  CLRF   xBF
0A7A4:  BTFSC  xBF.7
0A7A6:  BRA    A7AE
0A7A8:  MOVF   xBF,W
0A7AA:  SUBLW  1A
0A7AC:  BNC   A7B2
0A7AE:  INCF   xBF,F
0A7B0:  BRA    A7A4
....................             //Rx_Buffer[z]=0; 
....................             //Rx_Buffer2[z]=0; 
....................          } 
....................    } 
0A7B2:  MOVLB  0
0A7B4:  GOTO   A8CC (RETURN)
.................... } 
....................  
.................... /* TODO: Web server enabled. Server files are added to the /pages 
.................... directory. You can modify the contents of the dynamic display fields 
.................... at the end of the index.htm file. By default, headings are in the left 
.................... column and the dynamic display elements are in the right. The text on 
.................... the input buttons can be set by changing the 'value' strings in the 
.................... form section. Dynamic display elements can be added or removed from 
.................... index.htm and index.xml */ 
.................... /* TODO: Server files must be built into an MPFS image prior to  
.................... compiling and runing the web server. Running makempfsimg.bat in the 
.................... /mpfs directory will create an MPFS image of the files in /pages. 
.................... A new MPFS image has to be compiled and re-loaded if a file in 
.................... /pages needs to be changed. */ 
....................  
.................... unsigned int8 http_format_char(char* file, char id, char *str, unsigned int8 max_ret) 
*
091CE:  MOVLB  4
091D0:  CLRF   x00
.................... { 
....................    /* TODO: This is a callback function to the HTTP stack. 
....................    'id' is the char for the dynamic element to be updated. 
....................    For each dynamic element you create, you need to parse 
....................    and save a result to 'str'. *str is where the callback 
....................    function must save the formatting result, and it should 
....................    not store more than max_ret characters to this pointer 
....................    (buffer-overrun protection). 
....................    Example: 
....................    switch(id) { 
....................       case 0x00: 
....................          set_adc_channel(0); 
....................          delay_us(100); 
....................          i=read_adc(); 
....................          sprintf(new_str,"0x%X", i); 
....................    ..... 
....................    strncpy(str, new_str, max_ret); 
....................    */ 
....................    char new_str[20]; 
....................    int8 len=0; 
....................     
....................    if (id == 0){ 
091D2:  MOVLB  3
091D4:  MOVF   xE8,F
091D6:  BNZ   923C
....................          sprintf(new_str,"%02u.%01u",Rx_Buffer[3],Rx_Buffer[4]); 
091D8:  MOVLW  03
091DA:  MOVWF  x45
091DC:  MOVLW  EC
091DE:  MOVWF  x44
091E0:  MOVFF  385,401
091E4:  MOVLW  01
091E6:  MOVLB  4
091E8:  MOVWF  x02
091EA:  MOVLB  0
091EC:  RCALL  914C
091EE:  MOVLW  2E
091F0:  MOVLB  4
091F2:  MOVWF  x03
091F4:  MOVLB  0
091F6:  CALL   78E4
091FA:  MOVFF  386,401
091FE:  MOVLW  08
09200:  MOVLB  4
09202:  MOVWF  x02
09204:  MOVLB  0
09206:  RCALL  914C
....................          len=strlen(new_str); 
09208:  MOVLW  03
0920A:  MOVLB  4
0920C:  MOVWF  x07
0920E:  MOVLW  EC
09210:  MOVWF  x06
09212:  MOVLB  0
09214:  CALL   75AE
09218:  MOVFF  01,400
....................          strncpy(str, new_str, max_ret); 
0921C:  MOVFF  3EA,402
09220:  MOVFF  3E9,401
09224:  MOVLW  03
09226:  MOVLB  4
09228:  MOVWF  x04
0922A:  MOVLW  EC
0922C:  MOVWF  x03
0922E:  CLRF   x06
09230:  MOVFF  3EB,405
09234:  MOVLB  0
09236:  CALL   7C54
0923A:  MOVLB  3
....................    } 
....................    if (id == 1){ 
0923C:  DECFSZ xE8,W
0923E:  BRA    92A4
....................          sprintf(new_str,"%02u.%01u",Rx_Buffer[5],Rx_Buffer[6]); 
09240:  MOVLW  03
09242:  MOVWF  x45
09244:  MOVLW  EC
09246:  MOVWF  x44
09248:  MOVFF  387,401
0924C:  MOVLW  01
0924E:  MOVLB  4
09250:  MOVWF  x02
09252:  MOVLB  0
09254:  RCALL  914C
09256:  MOVLW  2E
09258:  MOVLB  4
0925A:  MOVWF  x03
0925C:  MOVLB  0
0925E:  CALL   78E4
09262:  MOVFF  388,401
09266:  MOVLW  08
09268:  MOVLB  4
0926A:  MOVWF  x02
0926C:  MOVLB  0
0926E:  RCALL  914C
....................          len=strlen(new_str); 
09270:  MOVLW  03
09272:  MOVLB  4
09274:  MOVWF  x07
09276:  MOVLW  EC
09278:  MOVWF  x06
0927A:  MOVLB  0
0927C:  CALL   75AE
09280:  MOVFF  01,400
....................          strncpy(str, new_str, max_ret); 
09284:  MOVFF  3EA,402
09288:  MOVFF  3E9,401
0928C:  MOVLW  03
0928E:  MOVLB  4
09290:  MOVWF  x04
09292:  MOVLW  EC
09294:  MOVWF  x03
09296:  CLRF   x06
09298:  MOVFF  3EB,405
0929C:  MOVLB  0
0929E:  CALL   7C54
092A2:  MOVLB  3
....................    } 
....................    if (id == 2){ 
092A4:  MOVF   xE8,W
092A6:  SUBLW  02
092A8:  BNZ   931A
....................          sprintf(new_str,"%02u.%01u%%",Rx_Buffer[7],Rx_Buffer[8]); 
092AA:  MOVLW  03
092AC:  MOVWF  x45
092AE:  MOVLW  EC
092B0:  MOVWF  x44
092B2:  MOVFF  389,401
092B6:  MOVLW  01
092B8:  MOVLB  4
092BA:  MOVWF  x02
092BC:  MOVLB  0
092BE:  RCALL  914C
092C0:  MOVLW  2E
092C2:  MOVLB  4
092C4:  MOVWF  x03
092C6:  MOVLB  0
092C8:  CALL   78E4
092CC:  MOVFF  38A,401
092D0:  MOVLW  08
092D2:  MOVLB  4
092D4:  MOVWF  x02
092D6:  MOVLB  0
092D8:  RCALL  914C
092DA:  MOVLW  25
092DC:  MOVLB  4
092DE:  MOVWF  x03
092E0:  MOVLB  0
092E2:  CALL   78E4
....................          len=strlen(new_str); 
092E6:  MOVLW  03
092E8:  MOVLB  4
092EA:  MOVWF  x07
092EC:  MOVLW  EC
092EE:  MOVWF  x06
092F0:  MOVLB  0
092F2:  CALL   75AE
092F6:  MOVFF  01,400
....................          strncpy(str, new_str, max_ret); 
092FA:  MOVFF  3EA,402
092FE:  MOVFF  3E9,401
09302:  MOVLW  03
09304:  MOVLB  4
09306:  MOVWF  x04
09308:  MOVLW  EC
0930A:  MOVWF  x03
0930C:  CLRF   x06
0930E:  MOVFF  3EB,405
09312:  MOVLB  0
09314:  CALL   7C54
09318:  MOVLB  3
....................    } 
....................    return(str); 
0931A:  MOVFF  3E9,01
0931E:  MOVLB  0
09320:  GOTO   979A (RETURN)
.................... } 
....................  
.................... void http_exec_cgi(char* file, char *key, char *val) 
.................... { 
*
00004:  GOTO   7D8E (RETURN)
....................    /* TODO: This is a callback function to the HTTP stack. 
....................    This function is called with each key/value pair read in 
....................    the GET/POST request before any web data is sent to the 
....................    web browser. 'key' matches the name of the field and 
....................    'val' is the value it was changed to. 
....................    Example: 
....................    int8 v = atoi(val); 
....................    if (stricmp(key,led1_key)==0) 
....................       LedSet(0, v); 
....................    */ 
....................  /* 
....................    if (strcmp(key, "button00") == 0) 
....................    { 
....................          //TODO: Handle button00 
....................          output_toggle(PIN_C7); 
....................          delay_ms(100); 
....................    } 
.................... */ 
.................... } 
....................  
.................... void IPAddressInit(void) 
.................... { 
....................    //MAC address of this unit 
....................    MY_MAC_BYTE1=MY_DEFAULT_MAC_BYTE1; 
*
002BE:  CLRF   50
....................    MY_MAC_BYTE2=MY_DEFAULT_MAC_BYTE2; 
002C0:  MOVLW  20
002C2:  MOVWF  51
....................    MY_MAC_BYTE3=MY_DEFAULT_MAC_BYTE3; 
002C4:  MOVLW  30
002C6:  MOVWF  52
....................    MY_MAC_BYTE4=MY_DEFAULT_MAC_BYTE4; 
002C8:  MOVLW  40
002CA:  MOVWF  53
....................    MY_MAC_BYTE5=MY_DEFAULT_MAC_BYTE5; 
002CC:  MOVLW  50
002CE:  MOVWF  54
....................    MY_MAC_BYTE6=MY_DEFAULT_MAC_BYTE6; 
002D0:  MOVLW  60
002D2:  MOVWF  55
....................  
....................    //IP address of this unit 
....................    MY_IP_BYTE1=192; 
002D4:  MOVLW  C0
002D6:  MOVWF  23
....................    MY_IP_BYTE2=168; 
002D8:  MOVLW  A8
002DA:  MOVWF  24
....................    MY_IP_BYTE3=0; 
002DC:  CLRF   25
....................    MY_IP_BYTE4=118; 
002DE:  MOVLW  76
002E0:  MOVWF  26
....................  
....................    //network gateway 
....................    MY_GATE_BYTE1=192; 
002E2:  MOVLW  C0
002E4:  MOVWF  2B
....................    MY_GATE_BYTE2=168; 
002E6:  MOVLW  A8
002E8:  MOVWF  2C
....................    MY_GATE_BYTE3=0; 
002EA:  CLRF   2D
....................    MY_GATE_BYTE4=1; 
002EC:  MOVLW  01
002EE:  MOVWF  2E
....................  
....................    //subnet mask 
....................    MY_MASK_BYTE1=MY_DEFAULT_MASK_BYTE1; 
002F0:  SETF   27
....................    MY_MASK_BYTE2=MY_DEFAULT_MASK_BYTE2; 
002F2:  SETF   28
....................    MY_MASK_BYTE3=MY_DEFAULT_MASK_BYTE3; 
002F4:  SETF   29
....................    MY_MASK_BYTE4=MY_DEFAULT_MASK_BYTE4; 
002F6:  CLRF   2A
002F8:  GOTO   A8BA (RETURN)
.................... } 
....................  
.................... void main() 
*
0A7B8:  CLRF   FF8
0A7BA:  BCF    FD0.7
0A7BC:  BSF    07.7
0A7BE:  MOVLW  FE
0A7C0:  MOVWF  00
0A7C2:  MOVLW  0D
0A7C4:  MOVWF  01
0A7C6:  MOVLW  02
0A7C8:  MOVWF  FE9
0A7CA:  MOVLW  00
0A7CC:  MOVWF  FEA
0A7CE:  CLRF   FEE
0A7D0:  DECFSZ 00,F
0A7D2:  BRA    A7CE
0A7D4:  DECFSZ 01,F
0A7D6:  BRA    A7CE
0A7D8:  MOVLB  1
0A7DA:  BCF    x10.0
0A7DC:  BCF    x10.1
0A7DE:  MOVLW  41
0A7E0:  MOVWF  x14
0A7E2:  MOVLW  FE
0A7E4:  MOVWF  x13
0A7E6:  MOVLW  9F
0A7E8:  MOVWF  x12
0A7EA:  MOVLW  9E
0A7EC:  MOVWF  x11
0A7EE:  CLRF   x1C
0A7F0:  CLRF   x1B
0A7F2:  CLRF   x1A
0A7F4:  CLRF   x19
0A7F6:  CLRF   x29
0A7F8:  CLRF   x28
0A7FA:  BCF    x10.3
0A7FC:  SETF   x35
0A7FE:  SETF   x3B
0A800:  BCF    x10.4
0A802:  MOVLW  FE
0A804:  MOVWF  xA1
0A806:  MOVWF  xFA
0A808:  MOVLB  3
0A80A:  CLRF   x45
0A80C:  CLRF   x44
0A80E:  CLRF   x81
0A810:  BSF    FB8.3
0A812:  MOVLW  08
0A814:  MOVWF  FAF
0A816:  MOVLW  02
0A818:  MOVWF  FB0
0A81A:  MOVLW  A6
0A81C:  MOVWF  FAC
0A81E:  MOVLW  90
0A820:  MOVWF  FAB
0A822:  CLRF   xBA
0A824:  CLRF   xBB
0A826:  CLRF   xBC
0A828:  CLRF   xBD
0A82A:  CLRF   xBE
0A82C:  CLRF   xBF
0A82E:  MOVF   FC1,W
0A830:  ANDLW  C0
0A832:  IORLW  0F
0A834:  MOVWF  FC1
0A836:  MOVLW  07
0A838:  MOVWF  FB4
0A83A:  BRA    A866
0A83C:  DATA 06,00
0A83E:  DATA 1D,08
0A840:  DATA 00,DC
0A842:  DATA 05,F4
0A844:  DATA 01,1D
0A846:  DATA 03,46
0A848:  DATA 20,00
0A84A:  DATA 3F,00
0A84C:  DATA 47,45
0A84E:  DATA 54,00
0A850:  DATA 50,4F
0A852:  DATA 53,54
0A854:  DATA 00,43
0A856:  DATA 6F,6E
0A858:  DATA 74,65
0A85A:  DATA 6E,74
0A85C:  DATA 2D,4C
0A85E:  DATA 65,6E
0A860:  DATA 67,74
0A862:  DATA 68,3A
0A864:  DATA 00,00
0A866:  MOVLW  00
0A868:  MOVWF  FF8
0A86A:  MOVLW  A8
0A86C:  MOVWF  FF7
0A86E:  MOVLW  3C
0A870:  MOVWF  FF6
0A872:  TBLRD*+
0A874:  MOVF   FF5,W
0A876:  MOVWF  00
0A878:  XORLW  00
0A87A:  BZ    A8A2
0A87C:  TBLRD*+
0A87E:  MOVF   FF5,W
0A880:  MOVWF  01
0A882:  BTFSC  FE8.7
0A884:  BRA    A890
0A886:  ANDLW  0F
0A888:  MOVWF  FEA
0A88A:  TBLRD*+
0A88C:  MOVFF  FF5,FE9
0A890:  BTFSC  01.6
0A892:  TBLRD*+
0A894:  BTFSS  01.6
0A896:  TBLRD*+
0A898:  MOVFF  FF5,FEE
0A89C:  DCFSNZ 00,F
0A89E:  BRA    A872
0A8A0:  BRA    A894
0A8A2:  CLRF   FF8
.................... { 
....................    setup_wdt(WDT_ON); 
0A8A4:  BSF    FD1.0
....................    enable_interrupts(INT_RDA); 
0A8A6:  BSF    F9D.5
....................    enable_interrupts(GLOBAL); 
0A8A8:  MOVLW  C0
0A8AA:  IORWF  FF2,F
....................    delay_ms(100); 
0A8AC:  MOVLW  64
0A8AE:  MOVWF  xC2
0A8B0:  MOVLB  0
0A8B2:  CALL   0296
....................    IPAddressInit(); 
0A8B6:  GOTO   02BE
....................    TickInit(); 
0A8BA:  GOTO   02FC
....................    StackInit(); 
0A8BE:  GOTO   14F4
....................  
....................  
....................    while(TRUE) 
....................    { 
....................       restart_wdt(); 
0A8C2:  CLRWDT
....................       StackTask(); 
0A8C4:  GOTO   6BC6
....................       StackApplications(); 
0A8C8:  BRA    A74E
....................        
....................       LeeDisplay(); 
0A8CA:  BRA    A756
....................  
....................       MY_IP_BYTE1=Rx_Buffer[11]; 
0A8CC:  MOVFF  38D,23
....................       MY_IP_BYTE2=Rx_Buffer[12]; 
0A8D0:  MOVFF  38E,24
....................       MY_IP_BYTE3=Rx_Buffer[13]; 
0A8D4:  MOVFF  38F,25
....................       MY_IP_BYTE4=Rx_Buffer[14]; 
0A8D8:  MOVFF  390,26
....................  
....................       //Eleccin de la direccin de puerta de enlace.  
....................       MY_GATE_BYTE1=Rx_Buffer[11]; 
0A8DC:  MOVFF  38D,2B
....................       MY_GATE_BYTE2=Rx_Buffer[12]; 
0A8E0:  MOVFF  38E,2C
....................       MY_GATE_BYTE3=Rx_Buffer[13]; 
0A8E4:  MOVFF  38F,2D
....................       MY_GATE_BYTE4=Rx_Buffer[19]; 
0A8E8:  MOVFF  395,2E
....................     
....................       //Eleccin de la mscara de red.Si no se indica nada se tomar 255.255.255.0 
....................       MY_MASK_BYTE1=Rx_Buffer[15]; 
0A8EC:  MOVFF  391,27
....................       MY_MASK_BYTE2=Rx_Buffer[16]; 
0A8F0:  MOVFF  392,28
....................       MY_MASK_BYTE3=Rx_Buffer[17]; 
0A8F4:  MOVFF  393,29
....................       MY_MASK_BYTE4=Rx_Buffer[18]; 
0A8F8:  MOVFF  394,2A
0A8FC:  BRA    A8C2
....................    } 
....................  
.................... } 
0A8FE:  SLEEP 

Configuration Fuses:
   Word  1: 0200   HS NOFCMEN NOIESO
   Word  2: 1908   PUT NOBROWNOUT BORV43 WDT WDT4096
   Word  3: 0000   NOPBADEN NOLPT1OSC NOMCLR
   Word  4: 00B0   NOSTVREN NOLVP NOXINST NODEBUG
   Word  5: C03F   NOPROTECT NOCPB NOCPD
   Word  6: E03F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 403F   NOEBTR NOEBTRB

ROM data:
016654: 74 65 78 74 2F 68 74 6D 6C 00 00 00 00 74 65 78 
016664: 74 2F 68 74 6D 6C 00 00 00 00 74 65 78 74 2F 70 
016674: 6C 61 69 6E 00 00 00 74 65 78 74 2F 78 6D 6C 00 
016684: 00 00 00 00 69 6D 61 67 65 2F 67 69 66 00 00 00 
016694: 00 69 6D 61 67 65 2F 6A 70 65 67 00 00 00 69 6D 
0166A4: 61 67 65 2F 70 6E 67 00 00 00 00 69 6D 61 67 65 
0166B4: 2F 78 2D 69 63 6F 6E 00 

0166BC: 68 74 6D 00 00 68 74 6D 6C 00 74 78 74 00 00 78 
0166CC: 6D 6C 00 00 67 69 66 00 00 6A 70 67 00 00 70 6E 
0166DC: 67 00 00 69 63 6F 00 00 

0166E4: 00 33 00 00 00 49 4E 44 45 58 2E 48 54 4D 20 20 
0166F4: 20 00 22 18 00 00 49 4E 44 45 58 2E 58 4D 4C 20 
016704: 20 20 04 FF FF FF FF 45 4E 44 20 4F 46 20 46 41 
016714: 54 20 20 09 3C 68 74 6D 6C 3E 0D 0A 3C 68 65 61 
016724: 64 3E 0D 0A 0D 0A 3C 74 69 74 6C 65 3E 4A 50 49 
016734: 6E 67 6C 6F 62 61 6C 20 44 61 74 6F 73 20 45 74 
016744: 68 65 72 6E 65 74 3C 2F 74 69 74 6C 65 3E 0D 0A 
016754: 3C 2F 68 65 61 64 3E 0D 0A 0D 0A 3C 62 6F 64 79 
016764: 20 6F 6E 6C 6F 61 64 3D 22 73 65 74 53 74 61 72 
016774: 74 54 69 6D 65 28 27 27 29 3B 22 20 73 74 79 6C 
016784: 65 3D 22 62 61 63 6B 67 72 6F 75 6E 64 3A 23 66 
016794: 66 66 66 66 66 22 3E 20 0D 0A 0D 0A 3C 64 69 76 
0167A4: 20 73 74 79 6C 65 3D 22 62 61 63 6B 67 72 6F 75 
0167B4: 6E 64 3A 23 34 33 38 33 64 33 22 20 61 6C 69 67 
0167C4: 6E 3D 22 63 65 6E 74 65 72 22 3E 0D 0A 0D 0A 20 
0167D4: 20 20 3C 69 6D 67 20 73 72 63 3D 22 68 74 74 70 
0167E4: 73 3A 2F 2F 6A 70 69 6E 67 6C 6F 62 61 6C 2E 63 
0167F4: 6F 6D 2F 69 6D 61 67 65 73 2F 61 6E 64 6F 5F 73 
016804: 69 73 74 65 6D 61 2F 4C 6F 67 6F 2D 4A 50 5F 32 
016814: 30 31 39 2D 30 35 2E 70 6E 67 22 20 61 6C 74 3D 
016824: 22 4C 6F 67 6F 20 4A 50 49 6E 67 6C 6F 62 61 6C 
016834: 22 20 61 6C 69 67 6E 3D 22 63 65 6E 74 65 72 22 
016844: 20 77 69 64 74 68 3D 22 35 36 37 22 20 68 65 69 
016854: 67 68 74 3D 22 31 38 39 22 3E 0D 0A 3C 2F 64 69 
016864: 76 3E 0D 0A 0D 0A 3C 68 72 20 73 69 7A 65 3D 22 
016874: 38 70 78 22 20 63 6F 6C 6F 72 3D 22 23 34 33 38 
016884: 33 64 33 22 3E 0D 0A 0D 0A 3C 64 69 76 20 73 74 
016894: 79 6C 65 3D 22 62 61 63 6B 67 72 6F 75 6E 64 3A 
0168A4: 23 45 31 46 36 46 46 22 20 61 6C 69 67 6E 3D 22 
0168B4: 63 65 6E 74 65 72 22 3E 0D 0A 0D 0A 20 20 20 3C 
0168C4: 68 32 20 61 6C 69 67 6E 3D 22 63 65 6E 74 65 72 
0168D4: 22 3E 20 56 69 73 75 61 6C 69 7A 61 63 69 F3 6E 
0168E4: 20 64 65 20 64 61 74 6F 73 3C 2F 68 32 3E 0D 0A 
0168F4: 0D 0A 20 20 20 3C 54 41 42 4C 45 20 42 4F 52 44 
016904: 45 52 3D 30 3E 0D 0A 20 20 20 20 20 20 3C 54 52 
016914: 3E 0D 0A 09 20 3C 54 44 3E 20 3C 69 6D 67 20 73 
016924: 72 63 3D 22 68 74 74 70 73 3A 2F 2F 77 37 2E 70 
016934: 6E 67 77 69 6E 67 2E 63 6F 6D 2F 70 6E 67 73 2F 
016944: 32 2F 32 33 37 2F 70 6E 67 2D 74 72 61 6E 73 70 
016954: 61 72 65 6E 74 2D 63 6F 6D 70 75 74 65 72 2D 69 
016964: 63 6F 6E 73 2D 74 68 65 72 6D 6F 6D 65 74 65 72 
016974: 2D 74 65 6D 70 65 72 61 74 75 72 65 2D 62 75 73 
016984: 69 6E 65 73 73 2D 63 65 6C 73 69 75 73 2D 74 68 
016994: 65 6D 6F 6D 65 74 65 72 2D 6D 65 61 73 75 72 65 
0169A4: 6D 65 6E 74 2D 62 75 73 69 6E 65 73 73 2D 74 65 
0169B4: 6D 70 65 72 61 74 75 72 65 2D 6D 65 61 73 75 72 
0169C4: 65 6D 65 6E 74 2E 70 6E 67 22 20 61 6C 74 3D 22 
0169D4: 54 65 6D 70 65 72 61 74 75 72 61 22 20 61 6C 69 
0169E4: 67 6E 3D 22 63 65 6E 74 65 72 22 20 77 69 64 74 
0169F4: 68 3D 22 39 32 22 20 68 65 69 67 68 74 3D 22 35 
016A04: 31 22 3E 20 3C 2F 54 44 3E 0D 0A 20 20 20 20 20 
016A14: 20 20 20 20 3C 54 48 3E 54 65 6D 70 65 72 61 74 
016A24: 75 72 61 28 BA 43 29 3A 3C 2F 54 48 3E 0D 0A 20 
016A34: 20 20 20 20 20 20 20 20 3C 54 44 20 69 64 3D 22 
016A44: 64 79 6E 30 22 3E 3C 2F 54 44 3E 0D 0A 20 20 20 
016A54: 20 20 20 3C 2F 54 52 3E 0D 0A 20 20 20 20 20 20 
016A64: 3C 54 52 3E 20 0D 0A 09 20 20 3C 54 52 3E 0D 0A 
016A74: 09 20 3C 54 44 3E 20 3C 69 6D 67 20 73 72 63 3D 
016A84: 22 68 74 74 70 73 3A 2F 2F 77 37 2E 70 6E 67 77 
016A94: 69 6E 67 2E 63 6F 6D 2F 70 6E 67 73 2F 32 2F 32 
016AA4: 33 37 2F 70 6E 67 2D 74 72 61 6E 73 70 61 72 65 
016AB4: 6E 74 2D 63 6F 6D 70 75 74 65 72 2D 69 63 6F 6E 
016AC4: 73 2D 74 68 65 72 6D 6F 6D 65 74 65 72 2D 74 65 
016AD4: 6D 70 65 72 61 74 75 72 65 2D 62 75 73 69 6E 65 
016AE4: 73 73 2D 63 65 6C 73 69 75 73 2D 74 68 65 6D 6F 
016AF4: 6D 65 74 65 72 2D 6D 65 61 73 75 72 65 6D 65 6E 
016B04: 74 2D 62 75 73 69 6E 65 73 73 2D 74 65 6D 70 65 
016B14: 72 61 74 75 72 65 2D 6D 65 61 73 75 72 65 6D 65 
016B24: 6E 74 2E 70 6E 67 22 20 61 6C 74 3D 22 54 65 6D 
016B34: 70 65 72 61 74 75 72 61 22 20 61 6C 69 67 6E 3D 
016B44: 22 63 65 6E 74 65 72 22 20 77 69 64 74 68 3D 22 
016B54: 39 32 22 20 68 65 69 67 68 74 3D 22 35 31 22 3E 
016B64: 20 3C 2F 54 44 3E 0D 0A 20 20 20 20 20 20 20 20 
016B74: 20 3C 54 48 3E 54 65 6D 70 65 72 61 74 75 72 61 
016B84: 20 32 28 BA 43 29 3A 3C 2F 54 48 3E 0D 0A 20 20 
016B94: 20 20 20 20 20 20 20 3C 54 44 20 69 64 3D 22 64 
016BA4: 79 6E 31 22 3E 3C 2F 54 44 3E 0D 0A 20 20 20 20 
016BB4: 20 20 3C 2F 54 52 3E 0D 0A 09 20 3C 54 44 3E 20 
016BC4: 3C 69 6D 67 20 73 72 63 3D 22 68 74 74 70 73 3A 
016BD4: 2F 2F 77 37 2E 70 6E 67 77 69 6E 67 2E 63 6F 6D 
016BE4: 2F 70 6E 67 73 2F 37 36 32 2F 33 35 31 2F 70 6E 
016BF4: 67 2D 74 72 61 6E 73 70 61 72 65 6E 74 2D 68 75 
016C04: 6D 69 64 69 74 79 2D 63 6F 6D 70 75 74 65 72 2D 
016C14: 69 63 6F 6E 73 2D 63 6C 69 6D 61 74 65 2D 6D 6F 
016C24: 69 73 74 75 72 65 2D 68 75 6D 69 64 2D 61 6E 67 
016C34: 6C 65 2D 63 6C 6F 75 64 2D 6D 65 74 65 6F 72 6F 
016C44: 6C 6F 67 79 2E 70 6E 67 22 20 61 6C 74 3D 22 48 
016C54: 75 6D 65 64 61 64 22 20 61 6C 69 67 6E 3D 22 63 
016C64: 65 6E 74 65 72 22 20 77 69 64 74 68 3D 22 39 32 
016C74: 22 20 68 65 69 67 68 74 3D 22 35 31 22 3E 3C 2F 
016C84: 54 44 3E 0D 0A 20 20 20 20 20 20 20 20 20 3C 54 
016C94: 48 3E 48 75 6D 65 64 61 64 3A 3C 2F 54 48 3E 0D 
016CA4: 0A 20 20 20 20 20 20 20 20 20 3C 54 44 20 69 64 
016CB4: 3D 22 64 79 6E 32 22 3E 3C 2F 54 44 3E 0D 0A 20 
016CC4: 20 20 20 20 20 3C 2F 54 52 3E 0D 0A 20 20 20 20 
016CD4: 20 20 3C 54 52 3E 0D 0A 09 20 3C 54 44 3E 20 3C 
016CE4: 69 6D 67 20 73 72 63 3D 22 68 74 74 70 73 3A 2F 
016CF4: 2F 77 37 2E 70 6E 67 77 69 6E 67 2E 63 6F 6D 2F 
016D04: 70 6E 67 73 2F 34 39 33 2F 39 35 38 2F 70 6E 67 
016D14: 2D 74 72 61 6E 73 70 61 72 65 6E 74 2D 73 79 6D 
016D24: 62 6F 6C 2D 6C 6F 67 6F 2D 63 6F 6D 70 75 74 65 
016D34: 72 2D 69 63 6F 6E 73 2D 74 69 6D 65 2D 73 79 6D 
016D44: 62 6F 6C 2D 6D 69 73 63 65 6C 6C 61 6E 65 6F 75 
016D54: 73 2D 61 6E 67 6C 65 2D 6C 6F 67 6F 2E 70 6E 67 
016D64: 22 20 61 6C 74 3D 22 54 69 65 6D 70 6F 22 20 61 
016D74: 6C 69 67 6E 3D 22 63 65 6E 74 65 72 22 20 77 69 
016D84: 64 74 68 3D 22 39 32 22 20 68 65 69 67 68 74 3D 
016D94: 22 35 31 22 3E 20 3C 2F 54 44 3E 0D 0A 09 20 3C 
016DA4: 54 48 3E 20 46 65 63 68 61 3A 20 3C 2F 54 48 3E 
016DB4: 0D 0A 09 20 3C 54 44 20 69 64 3D 22 48 6F 72 61 
016DC4: 41 63 74 75 61 6C 22 3E 20 3C 2F 54 44 3E 0D 0A 
016DD4: 20 20 20 20 20 20 3C 2F 54 52 3E 0D 0A 20 20 20 
016DE4: 3C 2F 54 41 42 4C 45 3E 0D 0A 20 20 20 3C 42 52 
016DF4: 2F 3E 0D 0A 3C 2F 64 69 76 3E 0D 0A 0D 0A 0D 0A 
016E04: 3C 2F 62 6F 64 79 3E 0D 0A 0D 0A 3C 73 63 72 69 
016E14: 70 74 20 74 79 70 65 3D 22 74 65 78 74 2F 6A 61 
016E24: 76 61 73 63 72 69 70 74 22 3E 0D 0A 2F 2F 2F 2F 
016E34: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
016E44: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
016E54: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
016E64: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
016E74: 2F 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 20 20 20 20 
016E84: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
016E94: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
016EA4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
016EB4: 20 20 20 20 20 20 20 20 20 20 20 20 2F 2F 2F 2F 
016EC4: 0D 0A 2F 2F 2F 2F 20 20 41 4A 41 58 20 72 6F 75 
016ED4: 74 69 6E 65 73 20 66 6F 72 20 72 78 2F 74 78 20 
016EE4: 6F 66 20 64 61 74 61 20 77 69 74 68 6F 75 74 20 
016EF4: 68 61 76 69 6E 67 20 74 6F 20 72 65 6C 6F 61 64 
016F04: 20 70 61 67 65 2E 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 
016F14: 2F 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
016F24: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
016F34: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
016F44: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
016F54: 20 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 20 57 72 
016F64: 69 74 74 65 6E 20 62 79 20 43 43 53 2C 20 49 6E 
016F74: 63 2E 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
016F84: 20 20 20 20 20 20 68 74 74 70 3A 2F 2F 77 77 77 
016F94: 2E 63 63 73 69 6E 66 6F 2E 63 6F 6D 20 2F 2F 2F 
016FA4: 2F 0D 0A 2F 2F 2F 2F 20 20 20 20 20 20 20 20 20 
016FB4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
016FC4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
016FD4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
016FE4: 20 20 20 20 20 20 20 20 2F 2F 2F 2F 0D 0A 2F 2F 
016FF4: 2F 2F 20 20 20 20 20 20 20 20 28 43 29 20 43 6F 
017004: 70 79 72 69 67 68 74 20 31 39 39 36 2C 32 30 31 
017014: 33 20 43 75 73 74 6F 6D 20 43 6F 6D 70 75 74 65 
017024: 72 20 53 65 72 76 69 63 65 73 20 20 20 20 20 20 
017034: 20 20 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 54 68 
017044: 69 73 20 73 6F 75 72 63 65 20 63 6F 64 65 20 6D 
017054: 61 79 20 6F 6E 6C 79 20 62 65 20 75 73 65 64 20 
017064: 62 79 20 6C 69 63 65 6E 73 65 64 20 75 73 65 72 
017074: 73 20 6F 66 20 74 68 65 20 43 43 53 20 20 2F 2F 
017084: 2F 2F 0D 0A 2F 2F 2F 2F 20 43 20 63 6F 6D 70 69 
017094: 6C 65 72 2E 20 20 54 68 69 73 20 73 6F 75 72 63 
0170A4: 65 20 63 6F 64 65 20 6D 61 79 20 6F 6E 6C 79 20 
0170B4: 62 65 20 64 69 73 74 72 69 62 75 74 65 64 20 74 
0170C4: 6F 20 6F 74 68 65 72 20 20 2F 2F 2F 2F 0D 0A 2F 
0170D4: 2F 2F 2F 20 6C 69 63 65 6E 73 65 64 20 75 73 65 
0170E4: 72 73 20 6F 66 20 74 68 65 20 43 43 53 20 43 20 
0170F4: 63 6F 6D 70 69 6C 65 72 2E 20 20 4E 6F 20 6F 74 
017104: 68 65 72 20 75 73 65 2C 20 20 20 20 20 20 20 20 
017114: 20 20 20 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 72 
017124: 65 70 72 6F 64 75 63 74 69 6F 6E 20 6F 72 20 64 
017134: 69 73 74 72 69 62 75 74 69 6F 6E 20 69 73 20 70 
017144: 65 72 6D 69 74 74 65 64 20 77 69 74 68 6F 75 74 
017154: 20 77 72 69 74 74 65 6E 20 20 20 20 20 20 20 2F 
017164: 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 70 65 72 6D 69 73 
017174: 73 69 6F 6E 2E 20 20 20 20 20 20 20 20 20 20 20 
017184: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
017194: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
0171A4: 20 20 20 20 20 20 20 20 20 20 2F 2F 2F 2F 0D 0A 
0171B4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
0171C4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
0171D4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
0171E4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
0171F4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 0D 0A 76 61 72 20 61 
017204: 6A 61 78 47 65 74 3B 0D 0A 76 61 72 20 74 3B 0D 
017214: 0A 76 61 72 20 77 61 69 74 69 6E 67 20 3D 20 30 
017224: 3B 0D 0A 76 61 72 20 74 56 61 6C 69 64 20 3D 20 
017234: 30 3B 0D 0A 76 61 72 20 6E 65 78 74 43 67 69 20 
017244: 3D 20 22 22 3B 0D 0A 76 61 72 20 6C 61 73 74 43 
017254: 67 69 20 3D 20 22 22 3B 0D 0A 76 61 72 20 69 6F 
017264: 73 36 77 6F 72 6B 61 72 6F 75 6E 64 20 3D 20 30 
017274: 3B 0D 0A 0D 0A 66 75 6E 63 74 69 6F 6E 20 73 65 
017284: 74 53 74 61 72 74 54 69 6D 65 28 29 0D 0A 7B 0D 
017294: 0A 20 20 20 74 56 61 6C 69 64 20 3D 20 31 3B 0D 
0172A4: 0A 20 20 20 74 20 3D 20 73 65 74 54 69 6D 65 6F 
0172B4: 75 74 28 27 61 6A 61 78 28 29 27 2C 20 35 30 30 
0172C4: 29 3B 0D 0A 7D 0D 0A 0D 0A 66 75 6E 63 74 69 6F 
0172D4: 6E 20 61 6A 61 78 28 29 0D 0A 7B 0D 0A 20 20 20 
0172E4: 69 66 20 28 77 61 69 74 69 6E 67 29 0D 0A 20 20 
0172F4: 20 7B 0D 0A 20 20 20 20 20 20 77 61 69 74 69 6E 
017304: 67 2D 2D 3B 0D 0A 20 20 20 20 20 20 69 66 20 28 
017314: 77 61 69 74 69 6E 67 20 3D 3D 20 30 29 0D 0A 20 
017324: 20 20 20 20 20 7B 0D 0A 20 20 20 20 20 20 20 20 
017334: 20 69 66 20 28 6C 61 73 74 43 67 69 20 21 3D 20 
017344: 22 22 29 0D 0A 20 20 20 20 20 20 20 20 20 7B 0D 
017354: 0A 20 20 20 20 20 20 20 20 20 20 20 20 69 66 20 
017364: 28 6E 65 78 74 43 67 69 20 3D 3D 20 22 22 29 0D 
017374: 0A 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
017384: 6E 65 78 74 43 67 69 20 3D 20 6C 61 73 74 43 67 
017394: 69 3B 0D 0A 20 20 20 20 20 20 20 20 20 20 20 20 
0173A4: 65 6C 73 65 0D 0A 20 20 20 20 20 20 20 20 20 20 
0173B4: 20 20 20 20 20 6E 65 78 74 43 67 69 20 3D 20 6C 
0173C4: 61 73 74 43 67 69 20 2B 20 22 26 22 20 2B 20 6E 
0173D4: 65 78 74 43 67 69 3B 0D 0A 20 20 20 20 20 20 20 
0173E4: 20 20 7D 0D 0A 20 20 20 20 20 20 7D 0D 0A 20 20 
0173F4: 20 7D 0D 0A 0D 0A 20 20 20 69 66 20 28 21 77 61 
017404: 69 74 69 6E 67 29 0D 0A 20 20 20 7B 0D 0A 20 20 
017414: 20 20 20 20 61 6A 61 78 47 65 74 3D 47 65 74 58 
017424: 6D 6C 48 74 74 70 4F 62 6A 65 63 74 28 29 3B 0D 
017434: 0A 0D 0A 20 20 20 20 20 20 69 66 20 28 61 6A 61 
017444: 78 47 65 74 3D 3D 6E 75 6C 6C 29 0D 0A 20 20 20 
017454: 20 20 20 7B 0D 0A 20 20 20 20 20 20 20 20 20 61 
017464: 6C 65 72 74 20 28 22 59 6F 75 72 20 62 72 6F 77 
017474: 73 65 72 20 64 6F 65 73 20 6E 6F 74 20 73 75 70 
017484: 70 6F 72 74 20 41 4A 41 58 21 22 29 3B 0D 0A 20 
017494: 20 20 20 20 20 20 20 20 72 65 74 75 72 6E 3B 0D 
0174A4: 0A 20 20 20 20 20 20 7D 0D 0A 0D 0A 20 20 20 20 
0174B4: 20 20 77 61 69 74 69 6E 67 20 3D 20 35 3B 20 20 
0174C4: 2F 2F 77 61 69 74 20 32 2E 35 20 73 65 63 6F 6E 
0174D4: 64 73 20 66 6F 72 20 61 20 72 65 73 70 6F 6E 73 
0174E4: 65 0D 0A 0D 0A 20 20 20 20 20 20 61 6A 61 78 47 
0174F4: 65 74 2E 6F 70 65 6E 28 22 50 4F 53 54 22 2C 20 
017504: 22 69 6E 64 65 78 2E 78 6D 6C 22 2C 20 74 72 75 
017514: 65 29 3B 0D 0A 0D 0A 20 20 20 20 20 20 61 6A 61 
017524: 78 47 65 74 2E 6F 6E 72 65 61 64 79 73 74 61 74 
017534: 65 63 68 61 6E 67 65 20 3D 20 73 74 61 74 65 43 
017544: 68 61 6E 67 65 64 3B 0D 0A 0D 0A 20 20 20 20 20 
017554: 20 69 66 20 28 6E 65 78 74 43 67 69 20 21 3D 20 
017564: 22 22 29 0D 0A 20 20 20 20 20 20 7B 0D 0A 20 20 
017574: 20 20 20 20 20 20 20 61 6A 61 78 47 65 74 2E 73 
017584: 65 6E 64 28 6E 65 78 74 43 67 69 29 3B 0D 0A 20 
017594: 20 20 20 20 20 20 20 20 6C 61 73 74 43 67 69 20 
0175A4: 3D 20 6E 65 78 74 43 67 69 3B 0D 0A 20 20 20 20 
0175B4: 20 20 20 20 20 6E 65 78 74 43 67 69 20 3D 20 22 
0175C4: 22 3B 0D 0A 20 20 20 20 20 20 7D 0D 0A 20 20 20 
0175D4: 20 20 20 65 6C 73 65 0D 0A 20 20 20 20 20 20 7B 
0175E4: 0D 0A 20 20 20 20 20 20 20 20 20 61 6A 61 78 47 
0175F4: 65 74 2E 73 65 6E 64 28 22 49 47 4E 4F 52 45 44 
017604: 54 41 47 3D 22 2B 69 6F 73 36 77 6F 72 6B 61 72 
017614: 6F 75 6E 64 29 3B 0D 0A 0D 0A 20 20 20 20 20 20 
017624: 20 20 20 69 66 20 28 2B 2B 69 6F 73 36 77 6F 72 
017634: 6B 61 72 6F 75 6E 64 20 3E 20 32 35 35 29 0D 0A 
017644: 20 20 20 20 20 20 20 20 20 20 20 20 69 6F 73 36 
017654: 77 6F 72 6B 61 72 6F 75 6E 64 20 3D 20 30 3B 0D 
017664: 0A 20 20 20 20 20 20 7D 0D 0A 20 20 20 7D 0D 0A 
017674: 0D 0A 20 20 20 73 65 74 53 74 61 72 74 54 69 6D 
017684: 65 28 29 3B 0D 0A 7D 0D 0A 0D 0A 66 75 6E 63 74 
017694: 69 6F 6E 20 73 65 6E 64 43 67 69 28 63 6D 64 2C 
0176A4: 20 76 61 6C 75 65 29 0D 0A 7B 0D 0A 20 20 20 69 
0176B4: 66 20 28 6E 65 78 74 43 67 69 20 21 3D 20 22 22 
0176C4: 29 0D 0A 20 20 20 20 20 20 6E 65 78 74 43 67 69 
0176D4: 20 2B 3D 20 22 26 22 3B 0D 0A 0D 0A 20 20 20 6E 

0176E4: 65 78 74 43 67 69 20 2B 3D 20 63 6D 64 20 2B 20 
0176F4: 22 3D 22 20 2B 20 76 61 6C 75 65 3B 0D 0A 7D 0D 
017704: 0A 0D 0A 66 75 6E 63 74 69 6F 6E 20 47 65 74 45 
017714: 6C 65 6D 65 6E 74 4E 6F 64 65 56 61 6C 75 65 28 
017724: 78 6D 6C 44 6F 63 2C 20 69 64 29 0D 0A 7B 0D 0A 
017734: 20 20 20 72 65 74 75 72 6E 20 78 6D 6C 44 6F 63 
017744: 2E 67 65 74 45 6C 65 6D 65 6E 74 73 42 79 54 61 
017754: 67 4E 61 6D 65 28 69 64 29 5B 30 5D 2E 63 68 69 
017764: 6C 64 4E 6F 64 65 73 5B 30 5D 2E 6E 6F 64 65 56 
017774: 61 6C 75 65 3B 0D 0A 7D 0D 0A 0D 0A 66 75 6E 63 
017784: 74 69 6F 6E 20 47 65 74 45 6C 65 6D 65 6E 74 41 
017794: 74 74 72 69 62 75 74 65 56 61 6C 75 65 28 78 6D 
0177A4: 6C 44 6F 63 2C 20 65 6C 65 6D 65 6E 74 2C 20 61 
0177B4: 74 74 72 69 62 75 74 65 29 0D 0A 7B 0D 0A 20 20 
0177C4: 20 76 61 72 20 6E 3B 0D 0A 20 20 20 76 61 72 20 
0177D4: 69 3B 0D 0A 0D 0A 20 20 20 6E 20 3D 20 78 6D 6C 
0177E4: 44 6F 63 2E 67 65 74 45 6C 65 6D 65 6E 74 73 42 
0177F4: 79 54 61 67 4E 61 6D 65 28 65 6C 65 6D 65 6E 74 
017804: 29 5B 30 5D 2E 61 74 74 72 69 62 75 74 65 73 2E 
017814: 6C 65 6E 67 74 68 3B 0D 0A 0D 0A 20 20 20 66 6F 
017824: 72 20 28 69 3D 30 3B 20 69 3C 6E 3B 20 69 2B 2B 
017834: 29 0D 0A 20 20 20 7B 0D 0A 20 20 20 20 20 20 69 
017844: 66 20 28 78 6D 6C 44 6F 63 2E 67 65 74 45 6C 65 
017854: 6D 65 6E 74 73 42 79 54 61 67 4E 61 6D 65 28 65 
017864: 6C 65 6D 65 6E 74 29 5B 30 5D 2E 61 74 74 72 69 
017874: 62 75 74 65 73 5B 69 5D 2E 6E 61 6D 65 20 3D 3D 
017884: 20 61 74 74 72 69 62 75 74 65 29 0D 0A 20 20 20 
017894: 20 20 20 7B 0D 0A 20 20 20 20 20 20 20 20 20 72 
0178A4: 65 74 75 72 6E 20 78 6D 6C 44 6F 63 2E 67 65 74 
0178B4: 45 6C 65 6D 65 6E 74 73 42 79 54 61 67 4E 61 6D 
0178C4: 65 28 65 6C 65 6D 65 6E 74 29 5B 30 5D 2E 61 74 
0178D4: 74 72 69 62 75 74 65 73 5B 69 5D 2E 76 61 6C 75 
0178E4: 65 3B 0D 0A 20 20 20 20 20 20 7D 0D 0A 20 20 20 
0178F4: 7D 0D 0A 0D 0A 20 20 20 72 65 74 75 72 6E 20 22 
017904: 22 3B 0D 0A 7D 0D 0A 0D 0A 66 75 6E 63 74 69 6F 
017914: 6E 20 55 70 64 61 74 65 45 78 69 73 74 69 6E 67 
017924: 54 61 62 6C 65 28 78 6D 6C 44 6F 63 29 0D 0A 7B 
017934: 0D 0A 20 20 20 76 61 72 20 69 20 3D 20 30 3B 0D 
017944: 0A 0D 0A 20 20 20 66 6F 72 28 3B 3B 29 0D 0A 20 
017954: 20 20 7B 0D 0A 20 20 20 20 20 20 76 61 72 20 69 
017964: 64 20 3D 20 22 64 79 6E 22 2B 69 3B 0D 0A 20 20 
017974: 20 20 20 20 69 2B 2B 3B 0D 0A 20 20 20 20 20 20 
017984: 69 66 20 28 64 6F 63 75 6D 65 6E 74 2E 67 65 74 
017994: 45 6C 65 6D 65 6E 74 42 79 49 64 28 69 64 29 29 
0179A4: 0D 0A 20 20 20 20 20 20 7B 0D 0A 20 20 20 20 20 
0179B4: 20 20 20 20 64 6F 63 75 6D 65 6E 74 2E 67 65 74 
0179C4: 45 6C 65 6D 65 6E 74 42 79 49 64 28 69 64 29 2E 
0179D4: 69 6E 6E 65 72 48 54 4D 4C 20 3D 20 47 65 74 45 
0179E4: 6C 65 6D 65 6E 74 4E 6F 64 65 56 61 6C 75 65 28 
0179F4: 78 6D 6C 44 6F 63 2C 20 69 64 29 3B 0D 0A 20 20 
017A04: 20 20 20 20 7D 0D 0A 20 20 20 20 20 20 65 6C 73 
017A14: 65 0D 0A 20 20 20 20 20 20 20 20 20 62 72 65 61 
017A24: 6B 3B 0D 0A 20 20 20 7D 0D 0A 7D 0D 0A 0D 0A 66 
017A34: 75 6E 63 74 69 6F 6E 20 73 74 61 74 65 43 68 61 
017A44: 6E 67 65 64 28 29 0D 0A 7B 0D 0A 20 20 20 69 66 
017A54: 20 28 61 6A 61 78 47 65 74 2E 72 65 61 64 79 53 
017A64: 74 61 74 65 3D 3D 34 29 0D 0A 20 20 20 7B 0D 0A 
017A74: 20 20 20 20 20 20 55 70 64 61 74 65 45 78 69 73 
017A84: 74 69 6E 67 54 61 62 6C 65 28 61 6A 61 78 47 65 
017A94: 74 2E 72 65 73 70 6F 6E 73 65 58 4D 4C 2E 64 6F 
017AA4: 63 75 6D 65 6E 74 45 6C 65 6D 65 6E 74 29 3B 0D 
017AB4: 0A 0D 0A 20 20 20 20 20 20 77 61 69 74 69 6E 67 
017AC4: 20 3D 20 30 3B 0D 0A 20 20 7D 0D 0A 7D 0D 0A 0D 
017AD4: 0A 66 75 6E 63 74 69 6F 6E 20 47 65 74 58 6D 6C 
017AE4: 48 74 74 70 4F 62 6A 65 63 74 28 29 0D 0A 7B 0D 
017AF4: 0A 20 20 20 69 66 20 28 77 69 6E 64 6F 77 2E 58 
017B04: 4D 4C 48 74 74 70 52 65 71 75 65 73 74 29 0D 0A 
017B14: 20 20 20 7B 0D 0A 20 20 20 20 20 20 2F 2F 20 63 
017B24: 6F 64 65 20 66 6F 72 20 49 45 37 2B 2C 20 46 69 
017B34: 72 65 66 6F 78 2C 20 43 68 72 6F 6D 65 2C 20 4F 
017B44: 70 65 72 61 2C 20 53 61 66 61 72 69 0D 0A 20 20 
017B54: 20 20 20 20 72 65 74 75 72 6E 20 6E 65 77 20 58 
017B64: 4D 4C 48 74 74 70 52 65 71 75 65 73 74 28 29 3B 
017B74: 0D 0A 20 20 20 7D 0D 0A 20 20 20 69 66 20 28 77 
017B84: 69 6E 64 6F 77 2E 41 63 74 69 76 65 58 4F 62 6A 
017B94: 65 63 74 29 0D 0A 20 20 20 7B 0D 0A 20 20 20 20 
017BA4: 20 20 2F 2F 20 63 6F 64 65 20 66 6F 72 20 49 45 
017BB4: 36 2C 20 49 45 35 0D 0A 20 20 20 20 20 20 72 65 
017BC4: 74 75 72 6E 20 6E 65 77 20 41 63 74 69 76 65 58 
017BD4: 4F 62 6A 65 63 74 28 22 4D 69 63 72 6F 73 6F 66 
017BE4: 74 2E 58 4D 4C 48 54 54 50 22 29 3B 0D 0A 20 20 
017BF4: 20 7D 0D 0A 20 20 20 72 65 74 75 72 6E 20 6E 75 
017C04: 6C 6C 3B 0D 0A 7D 0D 0A 0D 0A 73 68 6F 77 54 69 
017C14: 6D 65 28 29 3B 0D 0A 0D 0A 66 75 6E 63 74 69 6F 
017C24: 6E 20 73 68 6F 77 54 69 6D 65 28 29 7B 0D 0A 20 
017C34: 20 20 6D 79 44 61 74 65 20 3D 20 6E 65 77 20 44 
017C44: 61 74 65 28 29 3B 0D 0A 20 20 20 6D 79 44 61 74 
017C54: 65 2E 74 6F 4C 6F 63 61 6C 65 53 74 72 69 6E 67 
017C64: 28 27 65 73 2D 43 4F 27 29 3B 0D 0A 20 20 20 2F 
017C74: 2F 64 6F 63 75 6D 65 6E 74 2E 77 72 69 74 65 28 
017C84: 6D 79 44 61 74 65 29 3B 0D 0A 20 20 20 2F 2F 6D 
017C94: 79 44 61 74 65 2E 74 6F 55 54 43 53 74 72 69 6E 
017CA4: 67 28 29 3B 0D 0A 20 20 20 2F 2F 64 6F 63 75 6D 
017CB4: 65 6E 74 2E 67 65 74 45 6C 65 6D 65 6E 74 42 79 
017CC4: 49 64 28 22 48 6F 72 61 41 63 74 75 61 6C 22 29 
017CD4: 2E 69 6E 6E 65 72 48 54 4D 4C 20 3D 20 6D 79 44 
017CE4: 61 74 65 2E 74 6F 55 54 43 53 74 72 69 6E 67 28 
017CF4: 29 3B 0D 0A 20 20 20 68 6F 75 72 73 20 3D 20 6D 
017D04: 79 44 61 74 65 2E 67 65 74 48 6F 75 72 73 28 29 
017D14: 3B 0D 0A 20 20 20 6D 69 6E 75 74 65 73 20 3D 20 
017D24: 6D 79 44 61 74 65 2E 67 65 74 4D 69 6E 75 74 65 
017D34: 73 28 29 3B 0D 0A 20 20 20 73 65 63 6F 6E 64 73 
017D44: 20 3D 20 6D 79 44 61 74 65 2E 67 65 74 53 65 63 
017D54: 6F 6E 64 73 28 29 3B 0D 0A 20 20 20 69 66 20 28 
017D64: 68 6F 75 72 73 20 3C 20 31 30 29 20 68 6F 75 72 
017D74: 73 20 3D 20 30 20 2B 20 68 6F 75 72 73 3B 0D 0A 
017D84: 20 20 20 69 66 20 28 6D 69 6E 75 74 65 73 20 3C 
017D94: 20 31 30 29 20 6D 69 6E 75 74 65 73 20 3D 20 22 
017DA4: 30 22 20 2B 20 6D 69 6E 75 74 65 73 3B 0D 0A 20 
017DB4: 20 20 69 66 20 28 73 65 63 6F 6E 64 73 20 3C 20 
017DC4: 31 30 29 20 73 65 63 6F 6E 64 73 20 3D 20 22 30 
017DD4: 22 20 2B 20 73 65 63 6F 6E 64 73 3B 0D 0A 20 20 
017DE4: 20 2F 2F 24 28 22 23 48 6F 72 61 41 63 74 75 61 
017DF4: 6C 22 29 2E 74 65 78 74 28 68 6F 75 72 73 2B 20 
017E04: 22 3A 22 20 2B 6D 69 6E 75 74 65 73 2B 20 22 3A 
017E14: 22 20 2B 73 65 63 6F 6E 64 73 29 3B 0D 0A 20 20 
017E24: 20 2F 2F 64 6F 63 75 6D 65 6E 74 2E 67 65 74 45 
017E34: 6C 65 6D 65 6E 74 42 79 49 64 28 22 48 6F 72 61 
017E44: 41 63 74 75 61 6C 22 29 2E 69 6E 6E 65 72 48 54 
017E54: 4D 4C 3D 6D 79 44 61 74 65 2E 74 6F 55 54 43 53 
017E64: 74 72 69 6E 67 28 29 3B 0D 0A 20 20 20 64 6F 63 
017E74: 75 6D 65 6E 74 2E 67 65 74 45 6C 65 6D 65 6E 74 
017E84: 42 79 49 64 28 22 48 6F 72 61 41 63 74 75 61 6C 
017E94: 22 29 2E 69 6E 6E 65 72 48 54 4D 4C 3D 6D 79 44 
017EA4: 61 74 65 2E 74 6F 4C 6F 63 61 6C 65 53 74 72 69 
017EB4: 6E 67 28 27 65 73 2D 43 4F 27 29 3B 0D 0A 20 20 
017EC4: 20 73 65 74 54 69 6D 65 6F 75 74 28 22 73 68 6F 
017ED4: 77 54 69 6D 65 28 29 22 2C 20 31 30 30 30 29 3B 
017EE4: 0D 0A 0D 0A 7D 0D 0A 0D 0A 3C 2F 73 63 72 69 70 
017EF4: 74 3E 0D 0A 0D 0A 3C 2F 68 74 6D 6C 3E 0D 0A 04 
017F04: FF FF 3C 50 49 43 54 43 50 49 50 3E 0D 0A 20 20 
017F14: 20 3C 64 79 6E 30 3E 25 30 30 3C 2F 64 79 6E 30 
017F24: 3E 0D 0A 20 20 20 3C 64 79 6E 31 3E 25 30 31 3C 
017F34: 2F 64 79 6E 31 3E 0D 0A 20 20 20 3C 64 79 6E 32 
017F44: 3E 25 30 32 3C 2F 64 79 6E 32 3E 0D 0A 3C 2F 50 
017F54: 49 43 54 43 50 49 50 3E 0D 0A 04 FF FF 2F 2A 2A 
017F64: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
017F74: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
017F84: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
017F94: 0D 0A 20 2A 20 45 6E 64 20 6F 66 20 4D 50 46 53 
017FA4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
017FB4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
017FC4: 20 20 20 20 0D 0A 20 2A 2A 2A 2A 2A 2A 2A 2A 2A 
017FD4: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
017FE4: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
017FF4: 2A 2A 2A 2A 2A 2A 2A 2A 2F 0D 0A 00 
