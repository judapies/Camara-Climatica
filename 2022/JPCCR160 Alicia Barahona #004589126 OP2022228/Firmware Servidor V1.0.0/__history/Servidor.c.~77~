//Falta crear menu de ajuste de variables y de norma CFR21

#include <18F4685.h>
#device adc=10
#device HIGH_INTS=TRUE //Activamos niveles de prioridad
#fuses HS,WDT4096,NOPROTECT,NOLVP,NODEBUG,NOSTVREN,PUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOLPT1OSC,NOMCLR,NOBROWNOUT,BORV43
#use delay(clock=20000000)
#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits=8, parity=N,BRGH1OK,ERRORS)
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

/** Configuración para el uso del stack tcip **/
#define STACK_USE_ICMP        1  //Módulo de respuesta ICMP (ping)
#define STACK_USE_ARP         1  //Para solucionar direccionamiento MAC de las IP
#define STACK_USE_TCP         1  //Para enviar paquetes TCP 
#define STACK_USE_HTTP        1  //Uso de las funciones http del stack.
#define STACK_USE_CCS_PICENS  1  //CCS PICENS (Embedded Ethernet) 18F4620 + ENC28J60
#define STACK_USE_MCPENC      1  //Uso del enc28j60 por el stack (stacktsk.c)
#define STACK_USE_MAC         1  //Uso de la tarjeta de red

#define HTTP_SOCKET 80         //Nº de puerto asociado al socket.
int8 AD0;
/********** Definición del patillaje de conexión al enc28j60 ******************/
/* Existen varias posibilidades:

Opción 1. No definir nada, en cuyo caso se implementará una comunicación SPI por 
software y se tomarán la definición de patillas establecida en enc28j60.c

SO  PIN_D7 ---- ENC >>>> PIC
SI  PIN_D6 ---- PIC >>>> ENC
CLK PIN_D5
CS  PIN_D4
RST PIN_D3
INT PIN_D2
WOL PIN_D1

Opción 2. Definir todas las patillas de la comunicación SPI, en cuyo caso se 
implementará una comunicación SPI por software con la definición de patillas 
elegida. Por ejemplo...

#define PIN_ENC_MAC_SO  PIN_C4   //Entrada serie de datos
#define PIN_ENC_MAC_SI  PIN_C5   //Salida serie de datos
#define PIN_ENC_MAC_CLK PIN_B4   //Señal de reloj
#define PIN_ENC_MAC_CS  PIN_B5   //Chip select
#define PIN_ENC_MAC_RST PIN_B6   //Reset
#define PIN_ENC_MAC_INT PIN_B7   //Interrupción

Opción 3. El que aquí se ha utilizado, que consiste en habilitar el uso de SPI 
por hardware del PIC y definir las patillas ajenas al hardware del módulo SPI 
(CS, INT y RST). En este caso es imprescindible definir también la patilla SO 
para que el stack (dentro de enc28j60.c) no habilite SPI por software. Da igual 
que patilla SO se defina, la que se deberá cablear será la SO real del PIC    */

#define ENC_MAC_USE_SPI 1           //Uso del SPI por hardware

#define PIN_ENC_MAC_SO  PIN_C5      //Entrada serie de datos
#define PIN_ENC_MAC_SI  PIN_C4    //Salida serie de datos (no necesario definir)
#define PIN_ENC_MAC_CLK PIN_C3    //Señal de reloj  (no necesario definir)
#define PIN_ENC_MAC_CS  PIN_C1      //Chip select
#define PIN_ENC_MAC_RST PIN_C0      //Reset
#define PIN_ENC_MAC_INT PIN_C2      //Interrupción

/******************************************************************************/

#include "tcpip/stacktsk.c"      //Carga el stack TCP/IP de Microchip 
#if defined(__PCH__)
   #define GetSystemClock()       getenv("CLOCK")
   #define GetInstructionClock()  (GetSystemClock()/4)
   #define GetPeripheralClock()   (unsigned int32)GetInstructionClock()
#else
   #define GetSystemClock()       getenv("CLOCK")
   #define GetInstructionClock()  (GetSystemClock()/2)
   #define GetPeripheralClock()   (GetSystemClock()/2)
#endif

#define MIN(a,b)  ((a > b) ? b : a)

#define RX_BUFFER_SIZE  11
char Rx_Buffer[RX_BUFFER_SIZE+1];
char Rx_Buffer2[RX_BUFFER_SIZE+1];
int8 RX_Wr_Index=0;
int8 Dato2=0,Inicio=0,Dato_Exitoso=0,i=0,z=0,cont=0;

#include "pages.h"

#int_rda
void serial_rx_isr(){

   Dato2=fgetc();
   if(Dato2==0x65){//Inicio Comunicacion
      Inicio=1;
      RX_Wr_Index =0;
   }
   //Inicio=1;
   if(Inicio==1){
      Rx_Buffer2[RX_Wr_Index] = Dato2;
      RX_Wr_Index++;
   }
   if(RX_Wr_Index >= RX_BUFFER_SIZE){
      RX_Wr_Index =0;
      Inicio=0;
   }

   if(RX_Wr_Index==0){
      if(Rx_Buffer2[0]==0x65 && Rx_Buffer2[1]==0xff && Rx_Buffer2[9]==0x00 && Rx_Buffer2[10]==0xff ){
         Dato_Exitoso=5;
      }else{
         Dato_Exitoso=10;
      }
   }
   //output_toggle(PIN_C0);
}

void LeeDisplay(void){    
    if(Dato_Exitoso==5){
      for(i=0;i<11;i++){
         Rx_Buffer[i]=Rx_Buffer2[i];
      }
         
      if(Rx_Buffer[3]==0x01){// Pregunta por la pagina en la que esta el display,01 es Contraseña de Acceso
      }
   }else{
      for(z=0;z<RX_BUFFER_SIZE;z++){
            //Rx_Buffer[z]=0;
            //Rx_Buffer2[z]=0;
         }
   }
}

/* Elección de MAC. No puede haber 2 dispositivos con misma MAC en una misma red
   Microchip Vendor ID  MAC: 00.04.A3.xx.xx.xx.  */
void MACAddrInit(void) {
   MY_MAC_BYTE1=0;
   MY_MAC_BYTE2=0x04;
   MY_MAC_BYTE3=0xA3;
   MY_MAC_BYTE4=0x06;
   MY_MAC_BYTE5=0x07;
   MY_MAC_BYTE6=0x08;
}

void IPAddrInit(void) {
   //Elección de la dirección IP. 
   MY_IP_BYTE1=192;
   MY_IP_BYTE2=168;
   MY_IP_BYTE3=0;
   MY_IP_BYTE4=118;

   //Elección de la dirección de puerta de enlace. 
   MY_GATE_BYTE1=192;
   MY_GATE_BYTE2=168;
   MY_GATE_BYTE3=0;
   MY_GATE_BYTE4=1;

   //Elección de la máscara de red.Si no se indica nada se tomará 255.255.255.0
   MY_MASK_BYTE1=255;
   MY_MASK_BYTE2=255;
   MY_MASK_BYTE3=255;
   MY_MASK_BYTE4=0;
}


/***************************  FUNCIÓN GET PAGE   ******************************/
/* Esta función devuelve la posición de memoria donde se encuentra la página web 
a mostrar. En este caso se trata de una web con 2 páginas. Una principal index(/) 
y una secundaria(/lecturas)                                                   */

int32 http_get_page(char *file_str) {
   int32 file_loc=0;
   static char index[]="/";
   static char lecturas[]="/lecturas";

   /* Busca la posición de memoria donde se encuentra la página solicitada */
   if (stricmp(file_str,index)==0)                 //Si es la principal...
      file_loc=label_address(HTML_INDEX_PAGE);     //...toma su posición en la memoria
   //else if (stricmp(file_str,lecturas)==0)            //O si es la secundaria...
     // file_loc=label_address(HTML_LECTURAS_PAGE);    //...toma su posición en la memoria

   
   /* Devuelve la posición en la memoria donde se encuentra la página a mostrar */
   return(file_loc);                           
}

/**************************  FUNCIÓN FORMAT CHAR  *****************************/
/* Con  la función http_format_char  interconectamos las variables virtuales de 
la página web con las variables del programa del PIC. Se encarga de enviar los 
cambios producidos en la aplicación del PIC y reflejarlos en la aplicación web. 
Muestra,por tanto, las lectura obtenidas por el PIC y las representa en la 
aplicación de la página web      

%0 es la variable virtual para representar el valor de la lectura del canal 
analógico
%1 es la variable virtual para representar el valor de la lectura del bit 0 del 
puerto E.
*/
int8 http_format_char(char* file, char id, char *str, int8 max_ret) {
   char new_str[20];
   int8 len=0;
   
   int8 RE0;

   *str=0;

   switch(id) {
      case '0':
         sprintf(new_str,"%02u.%01u°C",Rx_Buffer[3],Rx_Buffer[4]);
         len=strlen(new_str);
         strncpy(str, new_str, max_ret);
      break;
      case '1':
         sprintf(new_str,"%02u.%01u°C",Rx_Buffer[5],Rx_Buffer[6]);
         len=strlen(new_str);
         strncpy(str, new_str, max_ret);
      break;  
      case '2':
         sprintf(new_str,"%02u.%01u%%",Rx_Buffer[7],Rx_Buffer[8]);
         len=strlen(new_str);
         strncpy(str, new_str, max_ret);
      break;  
      case '3':
         sprintf(new_str,"%03u.%03u.%03u.%03u %03u.%03u.%03u.%03u %X.%X.%X.%X.%X.%X",MY_IP_BYTE1,MY_IP_BYTE2,MY_IP_BYTE3,MY_IP_BYTE4,MY_MASK_BYTE1,MY_MASK_BYTE2,MY_MASK_BYTE3,MY_MASK_BYTE4,MY_MAC_BYTE1,MY_MAC_BYTE2,MY_MAC_BYTE3,MY_MAC_BYTE4,MY_MAC_BYTE5,MY_MAC_BYTE6);
         len=strlen(new_str);
         strncpy(str, new_str, max_ret);
      break;  
      default:
      len=0;
   }

   if (len)strncpy(str, new_str, max_ret);
   else  *str=0;
   
   return(len);
}

/***************************  FUNCIÓN EXEC CGI   ******************************/
/* Con la función http_exec_cgi interconectamos las variables virtuales de la 
página web con las variables del programa del PIC. Se encarga de recibir 
los cambios producidos en la aplicación web y reflejarlos en el hardware del PIC. 
Ejecuta, por tanto, la acción elegida según el valor de la variable virtual recibida 
de la página web

key es la variable virtual que viene de la pagina web
val es el valor de una variable virtual de la página web
file es la dirección de la página web devuelta por http_get_page ()

*/

void http_exec_cgi(int32 file, char *key, char *val) {
   
}

/************************** FUNCIÓN PRINCIPAL *********************************/
void main(void) {
   setup_wdt(WDT_ON);
   enable_interrupts(INT_RDA);
   enable_interrupts(GLOBAL);
   delay_ms(500);
   /* Inicialización del Stack */
   MACAddrInit(); //Se asigna la dirección MAC elegida 
   IPAddrInit();  //Se asigna IP, mascara de red y puerta de enlace elegidos
   StackInit();   //Inicializa el stack   
   delay_ms(10);

   while(TRUE) {
      restart_wdt();
      StackTask();
      LeeDisplay();
      if(Rx_Buffer[2]==10){
         MY_IP_BYTE1=Rx_Buffer[3];
         MY_IP_BYTE2=Rx_Buffer[4];
         MY_IP_BYTE3=Rx_Buffer[5];
         MY_IP_BYTE4=Rx_Buffer[6];
      }else if(Rx_Buffer[2]==20){
         MY_MASK_BYTE1=Rx_Buffer[3];
         MY_MASK_BYTE2=Rx_Buffer[4];
         MY_MASK_BYTE3=Rx_Buffer[5];
         MY_MASK_BYTE4=Rx_Buffer[6];
         MY_GATE_BYTE1=MY_IP_BYTE1;
         MY_GATE_BYTE2=MY_IP_BYTE2;
         MY_GATE_BYTE3=MY_IP_BYTE3;
         MY_GATE_BYTE4=Rx_Buffer[7];
      }else if(Rx_Buffer[2]==30){
         MY_MAC_BYTE1=Rx_Buffer[3];
         MY_MAC_BYTE2=Rx_Buffer[4];
         MY_MAC_BYTE3=Rx_Buffer[5];
         MY_MAC_BYTE4=Rx_Buffer[6];
         MY_MAC_BYTE5=Rx_Buffer[7];
         MY_MAC_BYTE6=Rx_Buffer[8];
         StackInit();   //Inicializa el stack   
         delay_ms(100);
      }
    }
}

